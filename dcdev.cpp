/*
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

#include "dcdev.h"

#include <QDebug>

DcDev::DcDev(QObject *parent) :
    Device(parent)
{
}

#define CMD_GENERAL_INCR_SYNCPT_OFFSET 0x0
#define CMD_GENERAL_INCR_SYNCPT_UNDEFMASK 0xFFFF0000
union cmd_general_incr_syncpt_u {
    struct {
        unsigned int general_indx:8;        /* syncpt index value */
        unsigned int general_cond:8;        /* Condition mapped from raise/wait 0 = IMMEDIATE 1 = OP_DONE 2 = RD_DONE 3 = REG_WR_SAFE 4 = HSPI 5 = FRAME_DONE 6 = VPULSE3 7 = FRAME_START 8 = COND_8 9 = COND_9 10 = COND_10 11 = COND_11 12 = COND_12 13 = COND_13 14 = COND_14 15 = COND_15 */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_general_incr_syncpt_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_general_incr_syncpt_u old_value_t = { .reg32 = value };
    const cmd_general_incr_syncpt_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: general_indx:8",
              "syncpt index value",
              8, old_value_t.general_indx, new_value_t.general_indx };
    m_bit_details_model.bits.append(entry);
    entry = { "08: general_cond:8",
              "Condition mapped from raise/wait\n0 = IMMEDIATE\n1 = OP_DONE\n2 = RD_DONE\n3 = REG_WR_SAFE\n4 = HSPI\n5 = FRAME_DONE\n6 = VPULSE3\n7 = FRAME_START\n8 = COND_8\n9 = COND_9\n10 = COND_10\n11 = COND_11\n12 = COND_12\n13 = COND_13\n14 = COND_14\n15 = COND_15",
              8, old_value_t.general_cond, new_value_t.general_cond };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define CMD_GENERAL_INCR_SYNCPT_CNTRL_OFFSET 0x1
#define CMD_GENERAL_INCR_SYNCPT_CNTRL_UNDEFMASK 0xFFFFFEFE
union cmd_general_incr_syncpt_cntrl_u {
    struct {
        unsigned int general_incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs */
        unsigned int undefined_bits_1_7:7;
        unsigned int general_incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_general_incr_syncpt_cntrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_general_incr_syncpt_cntrl_u old_value_t = { .reg32 = value };
    const cmd_general_incr_syncpt_cntrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: general_incr_syncpt_soft_reset:1",
              "If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs",
              1, old_value_t.general_incr_syncpt_soft_reset, new_value_t.general_incr_syncpt_soft_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: general_incr_syncpt_no_stall:1",
              "If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled",
              1, old_value_t.general_incr_syncpt_no_stall, new_value_t.general_incr_syncpt_no_stall };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define CMD_GENERAL_INCR_SYNCPT_ERROR_OFFSET 0x2
#define CMD_GENERAL_INCR_SYNCPT_ERROR_UNDEFMASK 0x00000000
union cmd_general_incr_syncpt_error_u {
    struct {
        unsigned int general_cond_status:32;/* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_general_incr_syncpt_error_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_general_incr_syncpt_error_u old_value_t = { .reg32 = value };
    const cmd_general_incr_syncpt_error_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: general_cond_status:32",
              "COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero",
              32, old_value_t.general_cond_status, new_value_t.general_cond_status };
    m_bit_details_model.bits.append(entry);
}

#define CMD_WIN_A_INCR_SYNCPT_OFFSET 0x8
#define CMD_WIN_A_INCR_SYNCPT_UNDEFMASK 0xFFFF0000
union cmd_win_a_incr_syncpt_u {
    struct {
        unsigned int win_a_indx:8;          /* syncpt index value */
        unsigned int win_a_cond:8;          /* Condition mapped from raise/wait 0 = IMMEDIATE 1 = OP_DONE 2 = RD_DONE 3 = REG_WR_SAFE 4 = COND_4 5 = COND_5 6 = COND_6 7 = COND_7 8 = COND_8 9 = COND_9 10 = COND_10 11 = COND_11 12 = COND_12 13 = COND_13 14 = COND_14 15 = COND_15 */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_win_a_incr_syncpt_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_win_a_incr_syncpt_u old_value_t = { .reg32 = value };
    const cmd_win_a_incr_syncpt_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: win_a_indx:8",
              "syncpt index value",
              8, old_value_t.win_a_indx, new_value_t.win_a_indx };
    m_bit_details_model.bits.append(entry);
    entry = { "08: win_a_cond:8",
              "Condition mapped from raise/wait\n0 = IMMEDIATE\n1 = OP_DONE\n2 = RD_DONE\n3 = REG_WR_SAFE\n4 = COND_4\n5 = COND_5\n6 = COND_6\n7 = COND_7\n8 = COND_8\n9 = COND_9\n10 = COND_10\n11 = COND_11\n12 = COND_12\n13 = COND_13\n14 = COND_14\n15 = COND_15",
              8, old_value_t.win_a_cond, new_value_t.win_a_cond };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define CMD_WIN_A_INCR_SYNCPT_CNTRL_OFFSET 0x9
#define CMD_WIN_A_INCR_SYNCPT_CNTRL_UNDEFMASK 0xFFFFFEFE
union cmd_win_a_incr_syncpt_cntrl_u {
    struct {
        unsigned int win_a_incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs */
        unsigned int undefined_bits_1_7:7;
        unsigned int win_a_incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_win_a_incr_syncpt_cntrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_win_a_incr_syncpt_cntrl_u old_value_t = { .reg32 = value };
    const cmd_win_a_incr_syncpt_cntrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: win_a_incr_syncpt_soft_reset:1",
              "If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs",
              1, old_value_t.win_a_incr_syncpt_soft_reset, new_value_t.win_a_incr_syncpt_soft_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: win_a_incr_syncpt_no_stall:1",
              "If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled",
              1, old_value_t.win_a_incr_syncpt_no_stall, new_value_t.win_a_incr_syncpt_no_stall };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define CMD_WIN_A_INCR_SYNCPT_ERROR_OFFSET 0xA
#define CMD_WIN_A_INCR_SYNCPT_ERROR_UNDEFMASK 0x00000000
union cmd_win_a_incr_syncpt_error_u {
    struct {
        unsigned int win_a_cond_status:32;  /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_win_a_incr_syncpt_error_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_win_a_incr_syncpt_error_u old_value_t = { .reg32 = value };
    const cmd_win_a_incr_syncpt_error_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: win_a_cond_status:32",
              "COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero",
              32, old_value_t.win_a_cond_status, new_value_t.win_a_cond_status };
    m_bit_details_model.bits.append(entry);
}

#define CMD_WIN_B_INCR_SYNCPT_OFFSET 0x10
#define CMD_WIN_B_INCR_SYNCPT_UNDEFMASK 0xFFFF0000
union cmd_win_b_incr_syncpt_u {
    struct {
        unsigned int win_b_indx:8;          /* syncpt index value */
        unsigned int win_b_cond:8;          /* Condition mapped from raise/wait 0 = IMMEDIATE 1 = OP_DONE 2 = RD_DONE 3 = REG_WR_SAFE 4 = COND_4 5 = COND_5 6 = COND_6 7 = COND_7 8 = COND_8 9 = COND_9 10 = COND_10 11 = COND_11 12 = COND_12 13 = COND_13 14 = COND_14 15 = COND_15 */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_win_b_incr_syncpt_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_win_b_incr_syncpt_u old_value_t = { .reg32 = value };
    const cmd_win_b_incr_syncpt_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: win_b_indx:8",
              "syncpt index value",
              8, old_value_t.win_b_indx, new_value_t.win_b_indx };
    m_bit_details_model.bits.append(entry);
    entry = { "08: win_b_cond:8",
              "Condition mapped from raise/wait\n0 = IMMEDIATE\n1 = OP_DONE\n2 = RD_DONE\n3 = REG_WR_SAFE\n4 = COND_4\n5 = COND_5\n6 = COND_6\n7 = COND_7\n8 = COND_8\n9 = COND_9\n10 = COND_10\n11 = COND_11\n12 = COND_12\n13 = COND_13\n14 = COND_14\n15 = COND_15",
              8, old_value_t.win_b_cond, new_value_t.win_b_cond };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define CMD_WIN_B_INCR_SYNCPT_CNTRL_OFFSET 0x11
#define CMD_WIN_B_INCR_SYNCPT_CNTRL_UNDEFMASK 0xFFFFFEFE
union cmd_win_b_incr_syncpt_cntrl_u {
    struct {
        unsigned int win_b_incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs */
        unsigned int undefined_bits_1_7:7;
        unsigned int win_b_incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_win_b_incr_syncpt_cntrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_win_b_incr_syncpt_cntrl_u old_value_t = { .reg32 = value };
    const cmd_win_b_incr_syncpt_cntrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: win_b_incr_syncpt_soft_reset:1",
              "If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs",
              1, old_value_t.win_b_incr_syncpt_soft_reset, new_value_t.win_b_incr_syncpt_soft_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: win_b_incr_syncpt_no_stall:1",
              "If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled",
              1, old_value_t.win_b_incr_syncpt_no_stall, new_value_t.win_b_incr_syncpt_no_stall };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define CMD_WIN_B_INCR_SYNCPT_ERROR_OFFSET 0x12
#define CMD_WIN_B_INCR_SYNCPT_ERROR_UNDEFMASK 0x00000000
union cmd_win_b_incr_syncpt_error_u {
    struct {
        unsigned int win_b_cond_status:32;  /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_win_b_incr_syncpt_error_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_win_b_incr_syncpt_error_u old_value_t = { .reg32 = value };
    const cmd_win_b_incr_syncpt_error_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: win_b_cond_status:32",
              "COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero",
              32, old_value_t.win_b_cond_status, new_value_t.win_b_cond_status };
    m_bit_details_model.bits.append(entry);
}

#define CMD_WIN_C_INCR_SYNCPT_OFFSET 0x18
#define CMD_WIN_C_INCR_SYNCPT_UNDEFMASK 0xFFFF0000
union cmd_win_c_incr_syncpt_u {
    struct {
        unsigned int win_c_indx:8;          /* syncpt index value */
        unsigned int win_c_cond:8;          /* Condition mapped from raise/wait 0 = IMMEDIATE 1 = OP_DONE 2 = RD_DONE 3 = REG_WR_SAFE 4 = COND_4 5 = COND_5 6 = COND_6 7 = COND_7 8 = COND_8 9 = COND_9 10 = COND_10 11 = COND_11 12 = COND_12 13 = COND_13 14 = COND_14 15 = COND_15 */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_win_c_incr_syncpt_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_win_c_incr_syncpt_u old_value_t = { .reg32 = value };
    const cmd_win_c_incr_syncpt_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: win_c_indx:8",
              "syncpt index value",
              8, old_value_t.win_c_indx, new_value_t.win_c_indx };
    m_bit_details_model.bits.append(entry);
    entry = { "08: win_c_cond:8",
              "Condition mapped from raise/wait\n0 = IMMEDIATE\n1 = OP_DONE\n2 = RD_DONE\n3 = REG_WR_SAFE\n4 = COND_4\n5 = COND_5\n6 = COND_6\n7 = COND_7\n8 = COND_8\n9 = COND_9\n10 = COND_10\n11 = COND_11\n12 = COND_12\n13 = COND_13\n14 = COND_14\n15 = COND_15",
              8, old_value_t.win_c_cond, new_value_t.win_c_cond };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define CMD_WIN_C_INCR_SYNCPT_CNTRL_OFFSET 0x19
#define CMD_WIN_C_INCR_SYNCPT_CNTRL_UNDEFMASK 0xFFFFFEFE
union cmd_win_c_incr_syncpt_cntrl_u {
    struct {
        unsigned int win_c_incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs */
        unsigned int undefined_bits_1_7:7;
        unsigned int win_c_incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_win_c_incr_syncpt_cntrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_win_c_incr_syncpt_cntrl_u old_value_t = { .reg32 = value };
    const cmd_win_c_incr_syncpt_cntrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: win_c_incr_syncpt_soft_reset:1",
              "If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs",
              1, old_value_t.win_c_incr_syncpt_soft_reset, new_value_t.win_c_incr_syncpt_soft_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: win_c_incr_syncpt_no_stall:1",
              "If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled",
              1, old_value_t.win_c_incr_syncpt_no_stall, new_value_t.win_c_incr_syncpt_no_stall };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define CMD_WIN_C_INCR_SYNCPT_ERROR_OFFSET 0x1A
#define CMD_WIN_C_INCR_SYNCPT_ERROR_UNDEFMASK 0x00000000
union cmd_win_c_incr_syncpt_error_u {
    struct {
        unsigned int win_c_cond_status:32;  /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_win_c_incr_syncpt_error_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_win_c_incr_syncpt_error_u old_value_t = { .reg32 = value };
    const cmd_win_c_incr_syncpt_error_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: win_c_cond_status:32",
              "COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero",
              32, old_value_t.win_c_cond_status, new_value_t.win_c_cond_status };
    m_bit_details_model.bits.append(entry);
}

#define CMD_CONT_SYNCPT_VSYNC_OFFSET 0x28
#define CMD_CONT_SYNCPT_VSYNC_UNDEFMASK 0xFFFFFE00
union cmd_cont_syncpt_vsync_u {
    struct {
        unsigned int vsync_indx:8;          /* return INDX (set HOST_CLRD packet TYPE field to SYNCPT) */
        unsigned int vsync_en:1;            /* on host read bus every time VSYNC (V-blank leading edge) happens and VSYNC_EN is set 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_cont_syncpt_vsync_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_cont_syncpt_vsync_u old_value_t = { .reg32 = value };
    const cmd_cont_syncpt_vsync_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vsync_indx:8",
              "return INDX (set HOST_CLRD packet TYPE field to SYNCPT)",
              8, old_value_t.vsync_indx, new_value_t.vsync_indx };
    m_bit_details_model.bits.append(entry);
    entry = { "08: vsync_en:1",
              "on host read bus every time VSYNC (V-blank leading edge) happens and VSYNC_EN is set\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.vsync_en, new_value_t.vsync_en };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define CMD_CTXSW_OFFSET 0x30
#define CMD_CTXSW_UNDEFMASK 0x0C000400
union cmd_ctxsw_u {
    struct {
        unsigned int curr_class:10;         /* Current working class */
        unsigned int undefined_bit_10:1;
        unsigned int auto_ack:1;            /* Automatically acknowledge any incoming context switch requests 0 = MANUAL 1 = AUTOACK */
        unsigned int curr_channel:4;        /* Current working channel, reset to 'invalid' */
        unsigned int next_class:10;         /* Next requested class */
        unsigned int undefined_bits_26_27:2;
        unsigned int next_channel:4;        /* Next requested channel */
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_ctxsw_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_ctxsw_u old_value_t = { .reg32 = value };
    const cmd_ctxsw_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: curr_class:10",
              "Current working class",
              10, old_value_t.curr_class, new_value_t.curr_class };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bit_10:1", "", 1, old_value_t.undefined_bit_10, new_value_t.undefined_bit_10 };
    m_bit_details_model.bits.append(entry);
    entry = { "11: auto_ack:1",
              "Automatically acknowledge any incoming context switch requests\n0 = MANUAL\n1 = AUTOACK",
              1, old_value_t.auto_ack, new_value_t.auto_ack };
    m_bit_details_model.bits.append(entry);
    entry = { "12: curr_channel:4",
              "Current working channel, reset to 'invalid'",
              4, old_value_t.curr_channel, new_value_t.curr_channel };
    m_bit_details_model.bits.append(entry);
    entry = { "16: next_class:10",
              "Next requested class",
              10, old_value_t.next_class, new_value_t.next_class };
    m_bit_details_model.bits.append(entry);
    entry = { "26: undefined_bits_26_27:2", "", 2, old_value_t.undefined_bits_26_27, new_value_t.undefined_bits_26_27 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: next_channel:4",
              "Next requested channel",
              4, old_value_t.next_channel, new_value_t.next_channel };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Context switch registers for class and channel\nShould be common to all modules. Includes the current channel/class (which is writable by SW) and the next channel/class (which the hardware sets when it receives a context switch).\nContext switch works like this:\nAny context switch request triggers an interrupt to the host and causes the new channel/class to be stored in NEXT_CHANNEL/NEXT_CLASS (see vmod/chexample). SW sees that there is a context switch interrupt and does the necessary operations to make the module ready to receive traffic from the new context. It clears the context switch interrupt and writes CURR_CHANNEL/CLASS to the same value as NEXT_CHANNEL/CLASS, which causes a context switch acknowledge packet to be sent to the host. This completes the context switch and allows the host to continue sending data to the module.\nContext switches can also be pre-loaded. If CURR_CLASS/CHANNEL are written and updated to the next CLASS/CHANNEL before the context switch request occurs, an acknowledge will be generated by the module and no interrupt will be triggered. This is one way for software to avoid dealing with context switch interrupts.\nAnother way to avoid context switch interrupts is to set the AUTO_ACK bit.\nThis bit tells the module to automatically acknowledge any incoming context switch requests without triggering an interrupt. CURR_* and NEXT_* will be updated by the module so they will always be current.";
}

#define CMD_DISPLAY_COMMAND_OPTION0_OFFSET 0x31
#define CMD_DISPLAY_COMMAND_OPTION0_UNDEFMASK 0xFFF8FF00
union cmd_display_command_option0_u {
    struct {
        unsigned int msf_polarity:1;        /* Main-Display Stop Frame (MSF) Polarity; 0= Active high; 1= Active low */
        unsigned int msf_enable:1;          /* Main-Display Stop Frame (MSF) input This is effective only in Non-Continuous Display mode 0= Disabled 1= Enabled When enabled, MSF signal can be input through LSPI pin. When MSF is enabled a trigger to send a frame in Non-Continuous Display mode will be delayed until MSF is active. 0 = DISABLE 1 = ENABLE */
        unsigned int msf_source:2;          /* Source pin for the MSF input Controls which pin will be used as the source for the trigger input when MSF mode is enabled. Note that although the same pins are available for both MSF and SSF, the order in the enum and hence the values differ between the pins. This is to maintain backwards compatibility with previous chips, which had a fixed mapping. The init value and the first value in the enum reflects this historical mapping. 0= LCD_SPI pin (legacy default) 1= LCD_DC pin 2= LCD_SDI pin 3= RESERVED for future use. 0 = MSF_LSPI 1 = MSF_LDC 2 = MSF_LSDI */
        unsigned int ssf_polarity:1;        /* Sub-Display Stop Frame (SSF) Polarity; 0= Active high; 1= Active low */
        unsigned int ssf_enable:1;          /* Sub-Display Stop Frame (SSF) input This is effective only in Non-Continuous Display mode 0= Disabled 1= Enabled When enabled, SSF signal can be input through LDC pin. When SSF is enabled a trigger to send a frame in Non-Continuous Display mode will be delayed until SSF is active. 0 = DISABLE 1 = ENABLE */
        unsigned int ssf_source:2;          /* Source pin for the SSF input Controls which pin will be used as the source for the trigger input when MSF mode is enabled. Note that although the same pins are available for both MSF and SSF, the order in the enum and hence the values differ between the pins. This is to maintain backwards compatibility with previous chips, which had a fixed mapping. The init value and the first value in the enum reflects this historical mapping. 0= LCD_DC pin (legacy default) 1= LCD_SPI pin 2= LCD_SDI pin 3= RESERVED for future use. 0 = SSF_LDC 1 = SSF_LSPI 2 = SSF_LSDI */
        unsigned int undefined_bits_8_15:8;
        unsigned int window_a_nc_display:1; /* Window A Non-Continuous Display This is effective only in Non-Continuous Display mode when window A buffer switching is not controlled by host. If this bit is enabled, a frame is sent whenever Window A buffer is switched.  0 = DISABLE 1 = ENABLE */
        unsigned int window_b_nc_display:1; /* Window B Non-Continuous Display This is effective only in Non-Continuous Display mode when window B buffer switching is not controlled by host. If this bit is enabled, a frame is sent whenever Window B buffer is switched.  0 = DISABLE 1 = ENABLE */
        unsigned int window_c_nc_display:1; /* Window C Non-Continuous Display This is effective only in Non-Continuous Display mode when window B buffer switching is not controlled by host. If this bit is enabled, a frame is sent whenever Window B buffer is switched; 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_31:13;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_display_command_option0_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_display_command_option0_u old_value_t = { .reg32 = value };
    const cmd_display_command_option0_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: msf_polarity:1",
              "Main-Display Stop Frame (MSF) Polarity;\n0= Active high;\n1= Active low",
              1, old_value_t.msf_polarity, new_value_t.msf_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "01: msf_enable:1",
              "Main-Display Stop Frame (MSF) input This is effective only in Non-Continuous Display mode\n0= Disabled\n1= Enabled When enabled, MSF signal can be input through LSPI pin. When MSF is enabled a trigger to send a frame in Non-Continuous Display mode will be delayed until MSF is active.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.msf_enable, new_value_t.msf_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "02: msf_source:2",
              "Source pin for the MSF input Controls which pin will be used as the source for the trigger input when MSF mode is enabled. Note that although the same pins are available for both MSF and SSF, the order in the enum and hence the values differ between the pins. This is to maintain backwards compatibility with previous chips, which had a fixed mapping. The init value and the first value in the enum reflects this historical mapping.\n0= LCD_SPI pin (legacy default)\n1= LCD_DC pin\n2= LCD_SDI pin\n3= RESERVED for future use.\n0 = MSF_LSPI\n1 = MSF_LDC\n2 = MSF_LSDI",
              2, old_value_t.msf_source, new_value_t.msf_source };
    m_bit_details_model.bits.append(entry);
    entry = { "04: ssf_polarity:1",
              "Sub-Display Stop Frame (SSF) Polarity;\n0= Active high;\n1= Active low",
              1, old_value_t.ssf_polarity, new_value_t.ssf_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "05: ssf_enable:1",
              "Sub-Display Stop Frame (SSF) input This is effective only in Non-Continuous Display mode\n0= Disabled\n1= Enabled When enabled, SSF signal can be input through LDC pin. When SSF is enabled a trigger to send a frame in Non-Continuous Display mode will be delayed until SSF is active.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ssf_enable, new_value_t.ssf_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "06: ssf_source:2",
              "Source pin for the SSF input Controls which pin will be used as the source for the trigger input when MSF mode is enabled. Note that although the same pins are available for both MSF and SSF, the order in the enum and hence the values differ between the pins. This is to maintain backwards compatibility with previous chips, which had a fixed mapping. The init value and the first value in the enum reflects this historical mapping.\n0= LCD_DC pin (legacy default)\n1= LCD_SPI pin\n2= LCD_SDI pin\n3= RESERVED for future use.\n0 = SSF_LDC\n1 = SSF_LSPI\n2 = SSF_LSDI",
              2, old_value_t.ssf_source, new_value_t.ssf_source };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: window_a_nc_display:1",
              "Window A Non-Continuous Display This is effective only in Non-Continuous Display mode when window A buffer switching is not controlled by host. If this bit is enabled, a frame is sent whenever Window A buffer is switched.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.window_a_nc_display, new_value_t.window_a_nc_display };
    m_bit_details_model.bits.append(entry);
    entry = { "17: window_b_nc_display:1",
              "Window B Non-Continuous Display This is effective only in Non-Continuous Display mode when window B buffer switching is not controlled by host. If this bit is enabled, a frame is sent whenever Window B buffer is switched.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.window_b_nc_display, new_value_t.window_b_nc_display };
    m_bit_details_model.bits.append(entry);
    entry = { "18: window_c_nc_display:1",
              "Window C Non-Continuous Display This is effective only in Non-Continuous Display mode when window B buffer switching is not controlled by host. If this bit is enabled, a frame is sent whenever Window B buffer is switched;\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.window_c_nc_display, new_value_t.window_c_nc_display };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bits_19_31:13", "", 13, old_value_t.undefined_bits_19_31, new_value_t.undefined_bits_19_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Display Controller Option 0. This register is not effective until DISPLAY_COMMAND is written.\nClass: Display Command";
}

#define CMD_DISPLAY_COMMAND_OFFSET 0x32
#define CMD_DISPLAY_COMMAND_UNDEFMASK 0x803FFF9E
union cmd_display_command_u {
    struct {
        unsigned int disp_command_raise:1;  /* Display Command Raise. Raise vector will be returned at the end of command completion 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_1_4:4;
        unsigned int display_ctrl_mode:2;   /* Display Controller Mode 0= Stop Display, this can be used to stop sending frame at the next frame boundary. This is automatically generated in Non-Continuous Display after sending one frame. If this is issued when display controller is already stopped then there is no frame sent. Raise vector (if raise is enabled) is also returned immediately. This command can also be used in non-continuous display mode to stop accepting non-host trigger conditions from other clients; 1= Continuous Display, the display controller will continuously send frame. Continuous display mode can be stopped by switching to Non-Continuous Display or by issuing Stop Display.; 2= Non-Continuous Display, the display controller is forced to send one frame of each active display and then wait for the next time this command is issued or for other (non-host) trigger conditions to send frame. The sending of frames may be delayed by MSF or SSF input signals from the display device. If a Stop Display is issued while in non-continuous display mode then non-host trigger conditions will no longer be accepted until the next time Non-Continuous Display is issued 0 = STOP 1 = C_DISPLAY 2 = NC_DISPLAY */
        unsigned int undefined_bits_7_21:15;
        unsigned int disp_command_raise_vector:5;/* Display Command Raise Vector This raise vector is at the next line or frame boundary, depending on GENERAL_ACT_CNTR_SEL */
        unsigned int disp_command_raise_channel_id:4;/* Display Command Channel ID */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_display_command_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_display_command_u old_value_t = { .reg32 = value };
    const cmd_display_command_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: disp_command_raise:1",
              "Display Command Raise. Raise vector will be returned at the end of command completion\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.disp_command_raise, new_value_t.disp_command_raise };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_4:4", "", 4, old_value_t.undefined_bits_1_4, new_value_t.undefined_bits_1_4 };
    m_bit_details_model.bits.append(entry);
    entry = { "05: display_ctrl_mode:2",
              "Display Controller Mode\n0= Stop Display, this can be used to stop sending frame at the next frame boundary. This is automatically generated in Non-Continuous Display after sending one frame. If this is issued when display controller is already stopped then there is no frame sent. Raise vector (if raise is enabled) is also returned immediately. This command can also be used in non-continuous display mode to stop accepting non-host trigger conditions from other clients;\n1= Continuous Display, the display controller will continuously send frame. Continuous display mode can be stopped by switching to Non-Continuous Display or by issuing Stop Display.;\n2= Non-Continuous Display, the display controller is forced to send one frame of each active display and then wait for the next time this command is issued or for other (non-host) trigger conditions to send frame. The sending of frames may be delayed by MSF or SSF input signals from the display device. If a Stop Display is issued while in non-continuous display mode then non-host trigger conditions will no longer be accepted until the next time Non-Continuous Display is issued\n0 = STOP\n1 = C_DISPLAY\n2 = NC_DISPLAY",
              2, old_value_t.display_ctrl_mode, new_value_t.display_ctrl_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bits_7_21:15", "", 15, old_value_t.undefined_bits_7_21, new_value_t.undefined_bits_7_21 };
    m_bit_details_model.bits.append(entry);
    entry = { "22: disp_command_raise_vector:5",
              "Display Command Raise Vector This raise vector is at the next line or frame boundary, depending on GENERAL_ACT_CNTR_SEL",
              5, old_value_t.disp_command_raise_vector, new_value_t.disp_command_raise_vector };
    m_bit_details_model.bits.append(entry);
    entry = { "27: disp_command_raise_channel_id:4",
              "Display Command Channel ID",
              4, old_value_t.disp_command_raise_channel_id, new_value_t.disp_command_raise_channel_id };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Display Command";
}

#define CMD_SIGNAL_RAISE_OFFSET 0x33
#define CMD_SIGNAL_RAISE_UNDEFMASK 0xFFF0E8E0
union cmd_signal_raise_u {
    struct {
        unsigned int signal_raise_vector:5; /* bit number to raise */
        unsigned int undefined_bits_5_7:3;
        unsigned int signal_raise_select:3; /* which signal to raise on 0= none, no raise sent back 1= Frame End signal 2= V Blank signal 3= V Pulse 3 signal 4= Rising edge of V Blank signal 5= Falling edge of V Blank signal 6= Rising edge of V Pulse 3 signal 7= Falling edge of V Pulse 3 signal 0 = NONE 1 = FRAME_END 2 = VBLANK 3 = VPULSE3 4 = VBLANK_START 5 = VBLANK_END 6 = VPULSE3_START 7 = VPULSE3_END */
        unsigned int undefined_bit_11:1;
        unsigned int signal_raise_type:1;   /* 0= Oneshot, single raise returned 1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE_SELECT=NONE or SIGNAL_RAISE_TYPE=ONESHOT 0 = ONESHOT 1 = CONT */
        unsigned int undefined_bits_13_15:3;
        unsigned int signal_raise_channel_id:4;/* Signal Raise Channel ID */
        unsigned int undefined_bits_20_31:12;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_signal_raise_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_signal_raise_u old_value_t = { .reg32 = value };
    const cmd_signal_raise_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: signal_raise_vector:5",
              "bit number to raise",
              5, old_value_t.signal_raise_vector, new_value_t.signal_raise_vector };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: signal_raise_select:3",
              "which signal to raise on\n0= none, no raise sent back\n1= Frame End signal\n2= V Blank signal\n3= V Pulse 3 signal\n4= Rising edge of V Blank signal\n5= Falling edge of V Blank signal\n6= Rising edge of V Pulse 3 signal\n7= Falling edge of V Pulse 3 signal\n0 = NONE\n1 = FRAME_END\n2 = VBLANK\n3 = VPULSE3\n4 = VBLANK_START\n5 = VBLANK_END\n6 = VPULSE3_START\n7 = VPULSE3_END",
              3, old_value_t.signal_raise_select, new_value_t.signal_raise_select };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: signal_raise_type:1",
              "0= Oneshot, single raise returned\n1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE_SELECT=NONE or SIGNAL_RAISE_TYPE=ONESHOT\n0 = ONESHOT\n1 = CONT",
              1, old_value_t.signal_raise_type, new_value_t.signal_raise_type };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: signal_raise_channel_id:4",
              "Signal Raise Channel ID",
              4, old_value_t.signal_raise_channel_id, new_value_t.signal_raise_channel_id };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_31:12", "", 12, old_value_t.undefined_bits_20_31, new_value_t.undefined_bits_20_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "When written, next occurrence of the selected SIGNAL will cause a RAISE to be sent to the host. Software must not write this register if a previous request (from previous write) is still outstanding. Added SIGNAL_RAISE_TYPE option so that multiple raises can be returned without software intervention. SIGNAL_RAISE1, SIGNAL_RAISE2, or SIGNAL_RAISE3 can be used if more than one source signal is needed.";
}

#define CMD_DISPLAY_POWER_CONTROL_OFFSET 0x36
#define CMD_DISPLAY_POWER_CONTROL_UNDEFMASK 0xFCFAFEAA
union cmd_display_power_control_u {
    struct {
        unsigned int pw0_enable:1;          /* PW0 signal Enable. This signal controls the display H and V counters. It must be enabled first and disabled last during display power sequencing. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int pw1_enable:1;          /* PW1 signal Enable. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_3:1;
        unsigned int pw2_enable:1;          /* PW2 signal Enable. This signal controls pixel data processing. It should be enabled during V blank time. This signal also controls the time when pin polarity takes effect at the pad. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_5:1;
        unsigned int pw3_enable:1;          /* PW3 signal Enable. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_7:1;
        unsigned int pw4_enable:1;          /* PW4 signal Enable. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_9_15:7;
        unsigned int pm0_enable:1;          /* PM0 signal Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int pm1_enable:1;          /* PM1 signal Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_23:5;
        unsigned int spi_enable:1;          /* SPI interface Enable. This enables clock to SPI interface logic for Host SPI, IS SPI, and LCD SPI. 0 = DISABLE 1 = ENABLE */
        unsigned int hspi_enable:1;         /* Host SPI write cycle Enable. SPI_ENABLE must be enabled also for this bit to be effective. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_26_31:6;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_display_power_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_display_power_control_u old_value_t = { .reg32 = value };
    const cmd_display_power_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pw0_enable:1",
              "PW0 signal Enable. This signal controls the display H and V counters. It must be enabled first and disabled last during display power sequencing. This signal can be output at the pad for display power sequencing.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.pw0_enable, new_value_t.pw0_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: pw1_enable:1",
              "PW1 signal Enable. This signal can be output at the pad for display power sequencing.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.pw1_enable, new_value_t.pw1_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: pw2_enable:1",
              "PW2 signal Enable. This signal controls pixel data processing. It should be enabled during V blank time. This signal also controls the time when pin polarity takes effect at the pad. This signal can be output at the pad for display power sequencing.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.pw2_enable, new_value_t.pw2_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: pw3_enable:1",
              "PW3 signal Enable. This signal can be output at the pad for display power sequencing.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.pw3_enable, new_value_t.pw3_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: pw4_enable:1",
              "PW4 signal Enable. This signal can be output at the pad for display power sequencing.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.pw4_enable, new_value_t.pw4_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: pm0_enable:1",
              "PM0 signal Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.pm0_enable, new_value_t.pm0_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: pm1_enable:1",
              "PM1 signal Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.pm1_enable, new_value_t.pm1_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bits_19_23:5", "", 5, old_value_t.undefined_bits_19_23, new_value_t.undefined_bits_19_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: spi_enable:1",
              "SPI interface Enable. This enables clock to SPI interface logic for Host SPI, IS SPI, and LCD SPI.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.spi_enable, new_value_t.spi_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "25: hspi_enable:1",
              "Host SPI write cycle Enable. SPI_ENABLE must be enabled also for this bit to be effective.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.hspi_enable, new_value_t.hspi_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "26: undefined_bits_26_31:6", "", 6, old_value_t.undefined_bits_26_31, new_value_t.undefined_bits_26_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Display Power Control";
}

#define CMD_INT_STATUS_OFFSET 0x37
#define CMD_INT_STATUS_UNDEFMASK 0xFFE20060
union cmd_int_status_u {
    struct {
        unsigned int ctxsw_int:1;           /* Context Switch Interrupt Status (this is cleared on write); 0= interrupt not pending; 1= interrupt pending */
        unsigned int frame_end_int:1;       /* Frame End Interrupt; 0= interrupt not pending; 1= interrupt pending */
        unsigned int v_blank_int:1;         /* Vertical Blank Interrupt; 0= interrupt not pending; 1= interrupt pending */
        unsigned int h_blank_int:1;         /* Horizontal Blank Interrupt; 0= interrupt not pending; 1= interrupt pending */
        unsigned int v_pulse3_int:1;        /* Vertical Pulse 3 Interrupt; 0= interrupt not pending; 1= interrupt pending */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int:1;        /* SPI Busy Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_a_uf_int:1;        /* Window A Underflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_b_uf_int:1;        /* Window B Underflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_c_uf_int:1;        /* Window C Underflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int epp_of_int:1;          /* Display2epp Overflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int msf_int:1;             /* Main-Display Stop Frame Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int ssf_int:1;             /* Sub-Display Stop Frame Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_a_of_int:1;        /* Window A Overflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_b_of_int:1;        /* Window B Overflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_c_of_int:1;        /* Window C Overflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int:1;          /* GPIO 0 Interrupt Status, connected to LCD_PWR0; 0= interrupt not pending; 1= interrupt pending */
        unsigned int gpio_1_int:1;          /* GPIO 1 Interrupt Status, connected to LCD_PWR1; 0= interrupt not pending; 1= interrupt pending */
        unsigned int gpio_2_int:1;          /* GPIO 2 Interrupt Status, connected to LCD_PWR2; 0= interrupt not pending; 1= interrupt pending */
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_int_status_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_int_status_u old_value_t = { .reg32 = value };
    const cmd_int_status_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ctxsw_int:1",
              "Context Switch Interrupt Status (this is cleared on write);\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.ctxsw_int, new_value_t.ctxsw_int };
    m_bit_details_model.bits.append(entry);
    entry = { "01: frame_end_int:1",
              "Frame End Interrupt;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.frame_end_int, new_value_t.frame_end_int };
    m_bit_details_model.bits.append(entry);
    entry = { "02: v_blank_int:1",
              "Vertical Blank Interrupt;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.v_blank_int, new_value_t.v_blank_int };
    m_bit_details_model.bits.append(entry);
    entry = { "03: h_blank_int:1",
              "Horizontal Blank Interrupt;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.h_blank_int, new_value_t.h_blank_int };
    m_bit_details_model.bits.append(entry);
    entry = { "04: v_pulse3_int:1",
              "Vertical Pulse 3 Interrupt;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.v_pulse3_int, new_value_t.v_pulse3_int };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_6:2", "", 2, old_value_t.undefined_bits_5_6, new_value_t.undefined_bits_5_6 };
    m_bit_details_model.bits.append(entry);
    entry = { "07: spi_busy_int:1",
              "SPI Busy Interrupt Status;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.spi_busy_int, new_value_t.spi_busy_int };
    m_bit_details_model.bits.append(entry);
    entry = { "08: win_a_uf_int:1",
              "Window A Underflow Interrupt Status;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.win_a_uf_int, new_value_t.win_a_uf_int };
    m_bit_details_model.bits.append(entry);
    entry = { "09: win_b_uf_int:1",
              "Window B Underflow Interrupt Status;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.win_b_uf_int, new_value_t.win_b_uf_int };
    m_bit_details_model.bits.append(entry);
    entry = { "10: win_c_uf_int:1",
              "Window C Underflow Interrupt Status;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.win_c_uf_int, new_value_t.win_c_uf_int };
    m_bit_details_model.bits.append(entry);
    entry = { "11: epp_of_int:1",
              "Display2epp Overflow Interrupt Status;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.epp_of_int, new_value_t.epp_of_int };
    m_bit_details_model.bits.append(entry);
    entry = { "12: msf_int:1",
              "Main-Display Stop Frame Interrupt Status;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.msf_int, new_value_t.msf_int };
    m_bit_details_model.bits.append(entry);
    entry = { "13: ssf_int:1",
              "Sub-Display Stop Frame Interrupt Status;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.ssf_int, new_value_t.ssf_int };
    m_bit_details_model.bits.append(entry);
    entry = { "14: win_a_of_int:1",
              "Window A Overflow Interrupt Status;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.win_a_of_int, new_value_t.win_a_of_int };
    m_bit_details_model.bits.append(entry);
    entry = { "15: win_b_of_int:1",
              "Window B Overflow Interrupt Status;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.win_b_of_int, new_value_t.win_b_of_int };
    m_bit_details_model.bits.append(entry);
    entry = { "16: win_c_of_int:1",
              "Window C Overflow Interrupt Status;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.win_c_of_int, new_value_t.win_c_of_int };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: gpio_0_int:1",
              "GPIO 0 Interrupt Status, connected to LCD_PWR0;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.gpio_0_int, new_value_t.gpio_0_int };
    m_bit_details_model.bits.append(entry);
    entry = { "19: gpio_1_int:1",
              "GPIO 1 Interrupt Status, connected to LCD_PWR1;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.gpio_1_int, new_value_t.gpio_1_int };
    m_bit_details_model.bits.append(entry);
    entry = { "20: gpio_2_int:1",
              "GPIO 2 Interrupt Status, connected to LCD_PWR2;\n0= interrupt not pending;\n1= interrupt pending",
              1, old_value_t.gpio_2_int, new_value_t.gpio_2_int };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Interrupt Status. This reflects status of all pending interrupts which is valid as long as the interrupt is not cleared even if the interrupt is masked. A pending interrupt can be cleared by writing a '1' to this the corresponding interrupt status bit in this register.\n Display Interrupt and Status";
}

#define CMD_INT_MASK_OFFSET 0x38
#define CMD_INT_MASK_UNDEFMASK 0xFFE20860
union cmd_int_mask_u {
    struct {
        unsigned int ctxsw_int_mask:1;      /* Context Switch Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int frame_end_int_mask:1;  /* Frame End Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int v_blank_int_mask:1;    /* Vertical Blank Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int h_blank_int_mask:1;    /* Horizontal Blank Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int v_pulse3_int_mask:1;   /* Vertical Pulse 3 Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int_mask:1;   /* SPI Busy Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_a_uf_int_mask:1;   /* Window A Underflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_b_uf_int_mask:1;   /* Window B Underflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_c_uf_int_mask:1;   /* Window C Underflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bit_11:1;
        unsigned int msf_int_mask:1;        /* Main-Display Stop Frame Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ssf_int_mask:1;        /* Sub-Display Stop Frame Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_a_of_int_mask:1;   /* Window A Overflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_b_of_int_mask:1;   /* Window B Overflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_c_of_int_mask:1;   /* Window C Overflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int_mask:1;     /* GPIO 0 Interrupt Mask, connected to LCD_PWR0 0= interrupt masked 1= interrupt not masked 0 = MASKED 1 = NOTMASKED */
        unsigned int gpio_1_int_mask:1;     /* GPIO 1 Interrupt Mask, connected to LCD_PWR1  0 = MASKED 1 = NOTMASKED */
        unsigned int gpio_2_int_mask:1;     /* GPIO 2 Interrupt Mask, connected to LCD_PWR2  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_int_mask_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_int_mask_u old_value_t = { .reg32 = value };
    const cmd_int_mask_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ctxsw_int_mask:1",
              "Context Switch Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ctxsw_int_mask, new_value_t.ctxsw_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "01: frame_end_int_mask:1",
              "Frame End Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.frame_end_int_mask, new_value_t.frame_end_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "02: v_blank_int_mask:1",
              "Vertical Blank Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.v_blank_int_mask, new_value_t.v_blank_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "03: h_blank_int_mask:1",
              "Horizontal Blank Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.h_blank_int_mask, new_value_t.h_blank_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "04: v_pulse3_int_mask:1",
              "Vertical Pulse 3 Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.v_pulse3_int_mask, new_value_t.v_pulse3_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_6:2", "", 2, old_value_t.undefined_bits_5_6, new_value_t.undefined_bits_5_6 };
    m_bit_details_model.bits.append(entry);
    entry = { "07: spi_busy_int_mask:1",
              "SPI Busy Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.spi_busy_int_mask, new_value_t.spi_busy_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "08: win_a_uf_int_mask:1",
              "Window A Underflow Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.win_a_uf_int_mask, new_value_t.win_a_uf_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "09: win_b_uf_int_mask:1",
              "Window B Underflow Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.win_b_uf_int_mask, new_value_t.win_b_uf_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "10: win_c_uf_int_mask:1",
              "Window C Underflow Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.win_c_uf_int_mask, new_value_t.win_c_uf_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: msf_int_mask:1",
              "Main-Display Stop Frame Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.msf_int_mask, new_value_t.msf_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "13: ssf_int_mask:1",
              "Sub-Display Stop Frame Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ssf_int_mask, new_value_t.ssf_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "14: win_a_of_int_mask:1",
              "Window A Overflow Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.win_a_of_int_mask, new_value_t.win_a_of_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "15: win_b_of_int_mask:1",
              "Window B Overflow Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.win_b_of_int_mask, new_value_t.win_b_of_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "16: win_c_of_int_mask:1",
              "Window C Overflow Interrupt Mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.win_c_of_int_mask, new_value_t.win_c_of_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: gpio_0_int_mask:1",
              "GPIO 0 Interrupt Mask, connected to LCD_PWR0\n0= interrupt masked\n1= interrupt not masked\n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.gpio_0_int_mask, new_value_t.gpio_0_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "19: gpio_1_int_mask:1",
              "GPIO 1 Interrupt Mask, connected to LCD_PWR1 \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.gpio_1_int_mask, new_value_t.gpio_1_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "20: gpio_2_int_mask:1",
              "GPIO 2 Interrupt Mask, connected to LCD_PWR2 \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.gpio_2_int_mask, new_value_t.gpio_2_int_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Interrupt Mask Setting bits in this register masked the corresponding interrupt but does not clear a pending interrupt and does not prevent a pending interrupt to be generated. Masking an interrupt also does not clear a pending interrupt status and does not prevent a pending interrupt status to be generated.";
}

#define CMD_INT_ENABLE_OFFSET 0x39
#define CMD_INT_ENABLE_UNDEFMASK 0xFFE20860
union cmd_int_enable_u {
    struct {
        unsigned int ctxsw_int_enable:1;    /* Context Switch Interrupt Enable 0= interrupt disabled 1= interrupt enabled 0 = DISABLE 1 = ENABLE */
        unsigned int frame_end_int_enable:1;/* Frame End Interrupt Enable 0= interrupt masked 1= interrupt not masked 0 = DISABLE 1 = ENABLE */
        unsigned int v_blank_int_enable:1;  /* Vertical Blank Interrupt Enable 0= interrupt masked 1= interrupt not masked 0 = DISABLE 1 = ENABLE */
        unsigned int h_blank_int_enable:1;  /* Horizontal Blank Interrupt Enable 0= interrupt masked 1= interrupt not masked 0 = DISABLE 1 = ENABLE */
        unsigned int v_pulse3_int_enable:1; /* Vertical Pulse 3 Interrupt Enable 0= interrupt masked 1= interrupt not masked 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int_enable:1; /* SPI Busy Interrupt Enable; 0 = DISABLE 1 = ENABLE */
        unsigned int win_a_uf_int_enable:1; /* Window A Underflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int win_b_uf_int_enable:1; /* Window B Underflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int win_c_uf_int_enable:1; /* Window C Underflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_11:1;
        unsigned int msf_int_enable:1;      /* Main-Display Stop Frame Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int ssf_int_enable:1;      /* Sub-Display Stop Frame Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int win_a_of_int_enable:1; /* Window A Overflow Interrupt Enable; 0 = DISABLE 1 = ENABLE */
        unsigned int win_b_of_int_enable:1; /* Window B Overflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int win_c_of_int_enable:1; /* Window C Overflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int_enable:1;   /* Display GPIO_0 Interrupt Enable, connected to LCD_PWR0; 0 = DISABLE 1 = ENABLE */
        unsigned int gpio_1_int_enable:1;   /* Display GPIO_1 Interrupt Enable, connected to LCD_PWR1  0 = DISABLE 1 = ENABLE */
        unsigned int gpio_2_int_enable:1;   /* Display GPIO_2 Interrupt Enable, connected to LCD_PWR2  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_int_enable_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_int_enable_u old_value_t = { .reg32 = value };
    const cmd_int_enable_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ctxsw_int_enable:1",
              "Context Switch Interrupt Enable\n0= interrupt disabled\n1= interrupt enabled\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ctxsw_int_enable, new_value_t.ctxsw_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: frame_end_int_enable:1",
              "Frame End Interrupt Enable\n0= interrupt masked\n1= interrupt not masked\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.frame_end_int_enable, new_value_t.frame_end_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "02: v_blank_int_enable:1",
              "Vertical Blank Interrupt Enable\n0= interrupt masked\n1= interrupt not masked\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.v_blank_int_enable, new_value_t.v_blank_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "03: h_blank_int_enable:1",
              "Horizontal Blank Interrupt Enable\n0= interrupt masked\n1= interrupt not masked\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.h_blank_int_enable, new_value_t.h_blank_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "04: v_pulse3_int_enable:1",
              "Vertical Pulse 3 Interrupt Enable\n0= interrupt masked\n1= interrupt not masked\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.v_pulse3_int_enable, new_value_t.v_pulse3_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_6:2", "", 2, old_value_t.undefined_bits_5_6, new_value_t.undefined_bits_5_6 };
    m_bit_details_model.bits.append(entry);
    entry = { "07: spi_busy_int_enable:1",
              "SPI Busy Interrupt Enable;\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.spi_busy_int_enable, new_value_t.spi_busy_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "08: win_a_uf_int_enable:1",
              "Window A Underflow Interrupt Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.win_a_uf_int_enable, new_value_t.win_a_uf_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "09: win_b_uf_int_enable:1",
              "Window B Underflow Interrupt Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.win_b_uf_int_enable, new_value_t.win_b_uf_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "10: win_c_uf_int_enable:1",
              "Window C Underflow Interrupt Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.win_c_uf_int_enable, new_value_t.win_c_uf_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: msf_int_enable:1",
              "Main-Display Stop Frame Interrupt Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.msf_int_enable, new_value_t.msf_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "13: ssf_int_enable:1",
              "Sub-Display Stop Frame Interrupt Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ssf_int_enable, new_value_t.ssf_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "14: win_a_of_int_enable:1",
              "Window A Overflow Interrupt Enable;\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.win_a_of_int_enable, new_value_t.win_a_of_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "15: win_b_of_int_enable:1",
              "Window B Overflow Interrupt Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.win_b_of_int_enable, new_value_t.win_b_of_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "16: win_c_of_int_enable:1",
              "Window C Overflow Interrupt Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.win_c_of_int_enable, new_value_t.win_c_of_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: gpio_0_int_enable:1",
              "Display GPIO_0 Interrupt Enable, connected to LCD_PWR0;\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.gpio_0_int_enable, new_value_t.gpio_0_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "19: gpio_1_int_enable:1",
              "Display GPIO_1 Interrupt Enable, connected to LCD_PWR1 \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.gpio_1_int_enable, new_value_t.gpio_1_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "20: gpio_2_int_enable:1",
              "Display GPIO_2 Interrupt Enable, connected to LCD_PWR2 \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.gpio_2_int_enable, new_value_t.gpio_2_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Interrupt Enable Setting bits in this register enable the corresponding interrupt event to generate a pending interrupt. Interrupt output signal will be activated only if the corresponding interrupt is not masked.\nDisabling an interrupt will not clear a corresponding pending interrupt - it only prevents a new interrupt event to generate a pending interrupt.";
}

#define CMD_INT_TYPE_OFFSET 0x3A
#define CMD_INT_TYPE_UNDEFMASK 0xFFE20861
union cmd_int_type_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int frame_end_int_type:1;  /* Frame End Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int v_blank_int_type:1;    /* Vertical Blank Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int h_blank_int_type:1;    /* Horizontal Blank Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int v_pulse3_int_type:1;   /* Vertical Pulse 3 Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int_type:1;   /* SPI Busy Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_a_uf_int_type:1;   /* Window A Underflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_b_uf_int_type:1;   /* Window B Underflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_c_uf_int_type:1;   /* Window C Underflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int undefined_bit_11:1;
        unsigned int msf_int_type:1;        /* Main-Display Stop Frame Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int ssf_int_type:1;        /* Sub-Display Stop Frame Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_a_of_int_type:1;   /* Window A Overflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_b_of_int_type:1;   /* Window B Overflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_c_of_int_type:1;   /* Window C Overflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int_type:1;     /* Display GPIO_0 Interrupt Type, connected to LCD_PWR0  0 = EDGE 1 = LEVEL */
        unsigned int gpio_1_int_type:1;     /* Display GPIO_1 Interrupt Type, connected to LCD_PWR1  0 = EDGE 1 = LEVEL */
        unsigned int gpio_2_int_type:1;     /* Display GPIO_2 Interrupt Type, connected to LCD_PWR2  0 = EDGE 1 = LEVEL */
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_int_type_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_int_type_u old_value_t = { .reg32 = value };
    const cmd_int_type_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bit_0:1", "", 1, old_value_t.undefined_bit_0, new_value_t.undefined_bit_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "01: frame_end_int_type:1",
              "Frame End Interrupt Type \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.frame_end_int_type, new_value_t.frame_end_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "02: v_blank_int_type:1",
              "Vertical Blank Interrupt Type \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.v_blank_int_type, new_value_t.v_blank_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "03: h_blank_int_type:1",
              "Horizontal Blank Interrupt Type \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.h_blank_int_type, new_value_t.h_blank_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "04: v_pulse3_int_type:1",
              "Vertical Pulse 3 Interrupt Type \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.v_pulse3_int_type, new_value_t.v_pulse3_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_6:2", "", 2, old_value_t.undefined_bits_5_6, new_value_t.undefined_bits_5_6 };
    m_bit_details_model.bits.append(entry);
    entry = { "07: spi_busy_int_type:1",
              "SPI Busy Interrupt Type \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.spi_busy_int_type, new_value_t.spi_busy_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "08: win_a_uf_int_type:1",
              "Window A Underflow Interrupt Type \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.win_a_uf_int_type, new_value_t.win_a_uf_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "09: win_b_uf_int_type:1",
              "Window B Underflow Interrupt Type \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.win_b_uf_int_type, new_value_t.win_b_uf_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "10: win_c_uf_int_type:1",
              "Window C Underflow Interrupt Type \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.win_c_uf_int_type, new_value_t.win_c_uf_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: msf_int_type:1",
              "Main-Display Stop Frame Interrupt Type \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.msf_int_type, new_value_t.msf_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "13: ssf_int_type:1",
              "Sub-Display Stop Frame Interrupt Type \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.ssf_int_type, new_value_t.ssf_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "14: win_a_of_int_type:1",
              "Window A Overflow Interrupt Type \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.win_a_of_int_type, new_value_t.win_a_of_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "15: win_b_of_int_type:1",
              "Window B Overflow Interrupt Type \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.win_b_of_int_type, new_value_t.win_b_of_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "16: win_c_of_int_type:1",
              "Window C Overflow Interrupt Type \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.win_c_of_int_type, new_value_t.win_c_of_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: gpio_0_int_type:1",
              "Display GPIO_0 Interrupt Type, connected to LCD_PWR0 \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.gpio_0_int_type, new_value_t.gpio_0_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "19: gpio_1_int_type:1",
              "Display GPIO_1 Interrupt Type, connected to LCD_PWR1 \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.gpio_1_int_type, new_value_t.gpio_1_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "20: gpio_2_int_type:1",
              "Display GPIO_2 Interrupt Type, connected to LCD_PWR2 \n0 = EDGE\n1 = LEVEL",
              1, old_value_t.gpio_2_int_type, new_value_t.gpio_2_int_type };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Interrupt Type Two interrupt types are available: a. Edge interrupt - transition on input signal/event generates pending interrupt b. Level interrupt - active level on input signal/event generates pending interrupt";
}

#define CMD_INT_POLARITY_OFFSET 0x3B
#define CMD_INT_POLARITY_UNDEFMASK 0xFFE20861
union cmd_int_polarity_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int frame_end_int_polarity:1;/* Frame End. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int v_blank_int_polarity:1;/* V Blank. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int h_blank_int_polarity:1;/* H Blank. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int v_pulse3_int_polarity:1;/* V Pulse 3. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int_polarity:1;/* SPI Busy. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_a_uf_int_polarity:1;/* Window A Underflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_b_uf_int_polarity:1;/* Window B Underflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_c_uf_int_polarity:1;/* Window C Underflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int undefined_bit_11:1;
        unsigned int msf_int_polarity:1;    /* Main-Display Stop Frame. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int ssf_int_polarity:1;    /* Sub-Display Stop Frame. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_a_of_int_polarity:1;/* Window A Overflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_b_of_int_polarity:1;/* Window B Overflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_c_of_int_polarity:1;/* Window C Overflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int_polarity:1; /* Display GPIO_0 Interrupt. Interrupt Polarity, connected to LCD_PWR0 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int gpio_1_int_polarity:1; /* Display GPIO_1 Interrupt. Interrupt Polarity, connected to LCD_PWR1 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int gpio_2_int_polarity:1; /* Display GPIO_2 Interrupt. Interrupt Polarity, connected to LCD_PWR2 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_int_polarity_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_int_polarity_u old_value_t = { .reg32 = value };
    const cmd_int_polarity_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bit_0:1", "", 1, old_value_t.undefined_bit_0, new_value_t.undefined_bit_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "01: frame_end_int_polarity:1",
              "Frame End. Interrupt Polarity\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.frame_end_int_polarity, new_value_t.frame_end_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "02: v_blank_int_polarity:1",
              "V Blank. Interrupt Polarity\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.v_blank_int_polarity, new_value_t.v_blank_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "03: h_blank_int_polarity:1",
              "H Blank. Interrupt Polarity\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.h_blank_int_polarity, new_value_t.h_blank_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "04: v_pulse3_int_polarity:1",
              "V Pulse 3. Interrupt Polarity\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.v_pulse3_int_polarity, new_value_t.v_pulse3_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_6:2", "", 2, old_value_t.undefined_bits_5_6, new_value_t.undefined_bits_5_6 };
    m_bit_details_model.bits.append(entry);
    entry = { "07: spi_busy_int_polarity:1",
              "SPI Busy. Interrupt Polarity\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.spi_busy_int_polarity, new_value_t.spi_busy_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "08: win_a_uf_int_polarity:1",
              "Window A Underflow. Interrupt Polarity\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.win_a_uf_int_polarity, new_value_t.win_a_uf_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "09: win_b_uf_int_polarity:1",
              "Window B Underflow. Interrupt Polarity\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.win_b_uf_int_polarity, new_value_t.win_b_uf_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "10: win_c_uf_int_polarity:1",
              "Window C Underflow. Interrupt Polarity\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.win_c_uf_int_polarity, new_value_t.win_c_uf_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: msf_int_polarity:1",
              "Main-Display Stop Frame. Interrupt Polarity\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.msf_int_polarity, new_value_t.msf_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "13: ssf_int_polarity:1",
              "Sub-Display Stop Frame. Interrupt Polarity\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.ssf_int_polarity, new_value_t.ssf_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "14: win_a_of_int_polarity:1",
              "Window A Overflow. Interrupt Polarity\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.win_a_of_int_polarity, new_value_t.win_a_of_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "15: win_b_of_int_polarity:1",
              "Window B Overflow. Interrupt Polarity\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.win_b_of_int_polarity, new_value_t.win_b_of_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "16: win_c_of_int_polarity:1",
              "Window C Overflow. Interrupt Polarity\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.win_c_of_int_polarity, new_value_t.win_c_of_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: gpio_0_int_polarity:1",
              "Display GPIO_0 Interrupt. Interrupt Polarity, connected to LCD_PWR0\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.gpio_0_int_polarity, new_value_t.gpio_0_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "19: gpio_1_int_polarity:1",
              "Display GPIO_1 Interrupt. Interrupt Polarity, connected to LCD_PWR1\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.gpio_1_int_polarity, new_value_t.gpio_1_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "20: gpio_2_int_polarity:1",
              "Display GPIO_2 Interrupt. Interrupt Polarity, connected to LCD_PWR2\n0= falling edge or low level interrupt\n1= rising edge or high level interrupt\n0 = LOW\n1 = HIGH",
              1, old_value_t.gpio_2_int_polarity, new_value_t.gpio_2_int_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Interrupt Polarity For edge interrupt, these bits specify whether a pending interrupt is generated on falling edge or on rising edge of the corresponding input signal/event. For level interrupt, these bits specify whether a pending interrupt is generated on low level or on high level of the corresponding input signal/event. 0 rw CTXSW_INT_POLARITY init=0 // Context Switch Interrupt Polarity enum (LOW, HIGH ) // 0= falling edge or low level interrupt // 1= rising edge or high level interrupt.";
}

#define CMD_SIGNAL_RAISE1_OFFSET 0x3C
#define CMD_SIGNAL_RAISE1_UNDEFMASK 0xFFF0E8E0
union cmd_signal_raise1_u {
    struct {
        unsigned int signal_raise1_vector:5;/* bit number to raise */
        unsigned int undefined_bits_5_7:3;
        unsigned int signal_raise1_select:3;/* which signal to raise on 0= none, no raise sent back 1= Frame End signal 2= V Blank signal 3= V Pulse 3 signal 4= Rising edge of V Blank signal 5= Falling edge of V Blank signal 6= Rising edge of V Pulse 3 signal 7= Falling edge of V Pulse 3 signal 0 = NONE 1 = FRAME_END 2 = VBLANK 3 = VPULSE3 4 = VBLANK_START 5 = VBLANK_END 6 = VPULSE3_START 7 = VPULSE3_END */
        unsigned int undefined_bit_11:1;
        unsigned int signal_raise1_type:1;  /* 0= Oneshot, single raise returned 1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE1_SELECT=NONE or SIGNAL_RAISE1_TYPE=ONESHOT 0 = ONESHOT 1 = CONT */
        unsigned int undefined_bits_13_15:3;
        unsigned int signal_raise1_channel_id:4;/* Signal Raise Channel ID */
        unsigned int undefined_bits_20_31:12;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_signal_raise1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_signal_raise1_u old_value_t = { .reg32 = value };
    const cmd_signal_raise1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: signal_raise1_vector:5",
              "bit number to raise",
              5, old_value_t.signal_raise1_vector, new_value_t.signal_raise1_vector };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: signal_raise1_select:3",
              "which signal to raise on\n0= none, no raise sent back\n1= Frame End signal\n2= V Blank signal\n3= V Pulse 3 signal\n4= Rising edge of V Blank signal\n5= Falling edge of V Blank signal\n6= Rising edge of V Pulse 3 signal\n7= Falling edge of V Pulse 3 signal\n0 = NONE\n1 = FRAME_END\n2 = VBLANK\n3 = VPULSE3\n4 = VBLANK_START\n5 = VBLANK_END\n6 = VPULSE3_START\n7 = VPULSE3_END",
              3, old_value_t.signal_raise1_select, new_value_t.signal_raise1_select };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: signal_raise1_type:1",
              "0= Oneshot, single raise returned\n1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE1_SELECT=NONE or SIGNAL_RAISE1_TYPE=ONESHOT\n0 = ONESHOT\n1 = CONT",
              1, old_value_t.signal_raise1_type, new_value_t.signal_raise1_type };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: signal_raise1_channel_id:4",
              "Signal Raise Channel ID",
              4, old_value_t.signal_raise1_channel_id, new_value_t.signal_raise1_channel_id };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_31:12", "", 12, old_value_t.undefined_bits_20_31, new_value_t.undefined_bits_20_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "When written, next occurrence of the selected SIGNAL will cause a RAISE to be sent to the host. Software must not write this register if a previous request (from previous write) is still outstanding. Added SIGNAL_RAISE1_TYPE option so that multiple raises can be returned without software intervention.";
}

#define CMD_SIGNAL_RAISE2_OFFSET 0x3D
#define CMD_SIGNAL_RAISE2_UNDEFMASK 0xFFF0E8E0
union cmd_signal_raise2_u {
    struct {
        unsigned int signal_raise2_vector:5;/* bit number to raise */
        unsigned int undefined_bits_5_7:3;
        unsigned int signal_raise2_select:3;/* which signal to raise on 0= none, no raise sent back 1= Frame End signal 2= V Blank signal 3= V Pulse 3 signal 4= Rising edge of V Blank signal 5= Falling edge of V Blank signal 6= Rising edge of V Pulse 3 signal 7= Falling edge of V Pulse 3 signal 0 = NONE 1 = FRAME_END 2 = VBLANK 3 = VPULSE3 4 = VBLANK_START 5 = VBLANK_END 6 = VPULSE3_START 7 = VPULSE3_END */
        unsigned int undefined_bit_11:1;
        unsigned int signal_raise2_type:1;  /* 0= Oneshot, single raise returned 1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE2_SELECT=NONE or SIGNAL_RAISE2_TYPE=ONESHOT 0 = ONESHOT 1 = CONT */
        unsigned int undefined_bits_13_15:3;
        unsigned int signal_raise2_channel_id:4;/* Signal Raise Channel ID */
        unsigned int undefined_bits_20_31:12;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_signal_raise2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_signal_raise2_u old_value_t = { .reg32 = value };
    const cmd_signal_raise2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: signal_raise2_vector:5",
              "bit number to raise",
              5, old_value_t.signal_raise2_vector, new_value_t.signal_raise2_vector };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: signal_raise2_select:3",
              "which signal to raise on\n0= none, no raise sent back\n1= Frame End signal\n2= V Blank signal\n3= V Pulse 3 signal\n4= Rising edge of V Blank signal\n5= Falling edge of V Blank signal\n6= Rising edge of V Pulse 3 signal\n7= Falling edge of V Pulse 3 signal\n0 = NONE\n1 = FRAME_END\n2 = VBLANK\n3 = VPULSE3\n4 = VBLANK_START\n5 = VBLANK_END\n6 = VPULSE3_START\n7 = VPULSE3_END",
              3, old_value_t.signal_raise2_select, new_value_t.signal_raise2_select };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: signal_raise2_type:1",
              "0= Oneshot, single raise returned\n1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE2_SELECT=NONE or SIGNAL_RAISE2_TYPE=ONESHOT\n0 = ONESHOT\n1 = CONT",
              1, old_value_t.signal_raise2_type, new_value_t.signal_raise2_type };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: signal_raise2_channel_id:4",
              "Signal Raise Channel ID",
              4, old_value_t.signal_raise2_channel_id, new_value_t.signal_raise2_channel_id };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_31:12", "", 12, old_value_t.undefined_bits_20_31, new_value_t.undefined_bits_20_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "When written, next occurrence of the selected SIGNAL will cause a RAISE to be sent to the host. Software must not write this register if a previous request (from previous write) is still outstanding. Added SIGNAL_RAISE2_TYPE option so that multiple raises can be returned without software intervention.";
}

#define CMD_SIGNAL_RAISE3_OFFSET 0x3E
#define CMD_SIGNAL_RAISE3_UNDEFMASK 0xFFF0E8E0
union cmd_signal_raise3_u {
    struct {
        unsigned int signal_raise3_vector:5;/* bit number to raise */
        unsigned int undefined_bits_5_7:3;
        unsigned int signal_raise3_select:3;/* which signal to raise on 0= none, no raise sent back 1= Frame End signal 2= V Blank signal 3= V Pulse 3 signal 4= Rising edge of V Blank signal 5= Falling edge of V Blank signal 6= Rising edge of V Pulse 3 signal 7= Falling edge of V Pulse 3 signal 0 = NONE 1 = FRAME_END 2 = VBLANK 3 = VPULSE3 4 = VBLANK_START 5 = VBLANK_END 6 = VPULSE3_START 7 = VPULSE3_END */
        unsigned int undefined_bit_11:1;
        unsigned int signal_raise3_type:1;  /* 0= Oneshot, single raise returned 1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE3_SELECT=NONE or SIGNAL_RAISE3_TYPE=ONESHOT 0 = ONESHOT 1 = CONT */
        unsigned int undefined_bits_13_15:3;
        unsigned int signal_raise3_channel_id:4;/* Signal Raise Channel ID */
        unsigned int undefined_bits_20_31:12;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_signal_raise3_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_signal_raise3_u old_value_t = { .reg32 = value };
    const cmd_signal_raise3_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: signal_raise3_vector:5",
              "bit number to raise",
              5, old_value_t.signal_raise3_vector, new_value_t.signal_raise3_vector };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: signal_raise3_select:3",
              "which signal to raise on\n0= none, no raise sent back\n1= Frame End signal\n2= V Blank signal\n3= V Pulse 3 signal\n4= Rising edge of V Blank signal\n5= Falling edge of V Blank signal\n6= Rising edge of V Pulse 3 signal\n7= Falling edge of V Pulse 3 signal\n0 = NONE\n1 = FRAME_END\n2 = VBLANK\n3 = VPULSE3\n4 = VBLANK_START\n5 = VBLANK_END\n6 = VPULSE3_START\n7 = VPULSE3_END",
              3, old_value_t.signal_raise3_select, new_value_t.signal_raise3_select };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: signal_raise3_type:1",
              "0= Oneshot, single raise returned\n1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE3_SELECT=NONE or SIGNAL_RAISE3_TYPE=ONESHOT\n0 = ONESHOT\n1 = CONT",
              1, old_value_t.signal_raise3_type, new_value_t.signal_raise3_type };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: signal_raise3_channel_id:4",
              "Signal Raise Channel ID",
              4, old_value_t.signal_raise3_channel_id, new_value_t.signal_raise3_channel_id };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_31:12", "", 12, old_value_t.undefined_bits_20_31, new_value_t.undefined_bits_20_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "When written, next occurrence of the selected SIGNAL will cause a RAISE to be sent to the host.\nSoftware must not write this register if a previous request (from previous write) is still outstanding.\nAdded SIGNAL_RAISE3_TYPE option so that multiple raises can be returned without software intervention.";
}

#define CMD_STATE_ACCESS_OFFSET 0x40
#define CMD_STATE_ACCESS_UNDEFMASK 0xFFFFFFFA
union cmd_state_access_u {
    struct {
        unsigned int read_mux:1;            /* Read access control 0= read assembly state 1= read active state Arm state register read is not controlled by this mux, but by reading the registers with "_NS" suffix 0 = ASSEMBLY 1 = ACTIVE */
        unsigned int undefined_bit_1:1;
        unsigned int write_mux:1;           /* Write access control 0= write assembly state 1= write active state When set to ACTIVE, register writes also propagate to assembly set for double buffered registers, to both assembly and arm set for triple buffered registers. 0 = ASSEMBLY 1 = ACTIVE */
        unsigned int undefined_bits_3_31:29;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_state_access_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_state_access_u old_value_t = { .reg32 = value };
    const cmd_state_access_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: read_mux:1",
              "Read access control\n0= read assembly state\n1= read active state Arm state register read is not controlled by this mux, but by reading the registers with \"_NS\" suffix\n0 = ASSEMBLY\n1 = ACTIVE",
              1, old_value_t.read_mux, new_value_t.read_mux };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: write_mux:1",
              "Write access control\n0= write assembly state\n1= write active state When set to ACTIVE, register writes also propagate to assembly set for double buffered registers, to both assembly and arm set for triple buffered registers.\n0 = ASSEMBLY\n1 = ACTIVE",
              1, old_value_t.write_mux, new_value_t.write_mux };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_31:29", "", 29, old_value_t.undefined_bits_3_31, new_value_t.undefined_bits_3_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Double/triple buffers read and write access control";
}

#define CMD_STATE_CONTROL_OFFSET 0x41
#define CMD_STATE_CONTROL_UNDEFMASK 0xFEFFF0F0
union cmd_state_control_u {
    struct {
        unsigned int general_act_req:1;     /* Non-window-specific 0= no req pending/req completed 1= activation requested/pending 0 = DISABLE 1 = ENABLE */
        unsigned int win_a_act_req:1;       /* Window A activation request 0= no req pending/req completed 1= activation requested/pending 0 = DISABLE 1 = ENABLE */
        unsigned int win_b_act_req:1;       /* Window B activation request 0= no req pending/req completed 1= activation requested/pending 0 = DISABLE 1 = ENABLE */
        unsigned int win_c_act_req:1;       /* Window C activation request 0= no req pending/req completed 1= activation requested/pending 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_4_7:4;
        unsigned int general_update:1;      /* Trigger for arming state (from assembly to armed state) for a subset of the triple buffered registers. This register is also known as "Update Register"  0 = DISABLE 1 = ENABLE */
        unsigned int win_a_update:1;        /* Trigger for arming state (from assembly to armed state) for the win A subset of the triple buffered registers. This register is also known as "Update Register"  0 = DISABLE 1 = ENABLE */
        unsigned int win_b_update:1;        /* Trigger for arming state (from assembly to armed state) for the win B subset of the triple buffered registers. This register is also known as "Update Register"  0 = DISABLE 1 = ENABLE */
        unsigned int win_c_update:1;        /* Trigger for arming state (from assembly to armed state) for the win C subset of the triple buffered registers. This register is also known as "Update Register"  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_12_23:12;
        unsigned int nc_host_trig_enable:1; /* Host trigger enable. Effective only in Non-continuous mode. The exception is that when TVO is enabled, this trigger is ignored so as not to corrupt TV output. Note that when this field is enabled, GENERAL_ACT_REQ must be enabled at the same time. 0= disable: no frame is triggered  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_25_31:7;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_state_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_state_control_u old_value_t = { .reg32 = value };
    const cmd_state_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: general_act_req:1",
              "Non-window-specific\n0= no req pending/req completed\n1= activation requested/pending\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.general_act_req, new_value_t.general_act_req };
    m_bit_details_model.bits.append(entry);
    entry = { "01: win_a_act_req:1",
              "Window A activation request\n0= no req pending/req completed\n1= activation requested/pending\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.win_a_act_req, new_value_t.win_a_act_req };
    m_bit_details_model.bits.append(entry);
    entry = { "02: win_b_act_req:1",
              "Window B activation request\n0= no req pending/req completed\n1= activation requested/pending\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.win_b_act_req, new_value_t.win_b_act_req };
    m_bit_details_model.bits.append(entry);
    entry = { "03: win_c_act_req:1",
              "Window C activation request\n0= no req pending/req completed\n1= activation requested/pending\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.win_c_act_req, new_value_t.win_c_act_req };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_7:4", "", 4, old_value_t.undefined_bits_4_7, new_value_t.undefined_bits_4_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: general_update:1",
              "Trigger for arming state (from assembly to armed state) for a subset of the triple buffered registers. This register is also known as \"Update Register\" \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.general_update, new_value_t.general_update };
    m_bit_details_model.bits.append(entry);
    entry = { "09: win_a_update:1",
              "Trigger for arming state (from assembly to armed state) for the win A subset of the triple buffered registers. This register is also known as \"Update Register\" \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.win_a_update, new_value_t.win_a_update };
    m_bit_details_model.bits.append(entry);
    entry = { "10: win_b_update:1",
              "Trigger for arming state (from assembly to armed state) for the win B subset of the triple buffered registers. This register is also known as \"Update Register\" \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.win_b_update, new_value_t.win_b_update };
    m_bit_details_model.bits.append(entry);
    entry = { "11: win_c_update:1",
              "Trigger for arming state (from assembly to armed state) for the win C subset of the triple buffered registers. This register is also known as \"Update Register\" \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.win_c_update, new_value_t.win_c_update };
    m_bit_details_model.bits.append(entry);
    entry = { "12: undefined_bits_12_23:12", "", 12, old_value_t.undefined_bits_12_23, new_value_t.undefined_bits_12_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: nc_host_trig_enable:1",
              "Host trigger enable. Effective only in Non-continuous mode. The exception is that when TVO is enabled, this trigger is ignored so as not to corrupt TV output. Note that when this field is enabled, GENERAL_ACT_REQ must be enabled at the same time.\n0= disable: no frame is triggered \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.nc_host_trig_enable, new_value_t.nc_host_trig_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bits_25_31:7", "", 7, old_value_t.undefined_bits_25_31, new_value_t.undefined_bits_25_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "State Control for activating/arming new register state\nRestrictions: ACT_REQ cannot be programmed at the same time the corresponding \"UPDATE\" is programmed.\nIf so desired, it should be split into two consecutive writes to this register.";
}

#define CMD_DISPLAY_WINDOW_HEADER_OFFSET 0x42
#define CMD_DISPLAY_WINDOW_HEADER_UNDEFMASK 0xFFFFFF8F
union cmd_display_window_header_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int window_a_select:1;     /* Window A Select 0= disable window A programming 1= enable window A programming 0 = DISABLE 1 = ENABLE */
        unsigned int window_b_select:1;     /* Window B Select 0= disable window B programming 1= enable window B programming 0 = DISABLE 1 = ENABLE */
        unsigned int window_c_select:1;     /* Window C Select 0= disable window C programming 1= enable window C programming 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_7_31:25;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_display_window_header_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_display_window_header_u old_value_t = { .reg32 = value };
    const cmd_display_window_header_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_3:4", "", 4, old_value_t.undefined_bits_0_3, new_value_t.undefined_bits_0_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: window_a_select:1",
              "Window A Select\n0= disable window A programming\n1= enable window A programming\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.window_a_select, new_value_t.window_a_select };
    m_bit_details_model.bits.append(entry);
    entry = { "05: window_b_select:1",
              "Window B Select\n0= disable window B programming\n1= enable window B programming\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.window_b_select, new_value_t.window_b_select };
    m_bit_details_model.bits.append(entry);
    entry = { "06: window_c_select:1",
              "Window C Select\n0= disable window C programming\n1= enable window C programming\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.window_c_select, new_value_t.window_c_select };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bits_7_31:25", "", 25, old_value_t.undefined_bits_7_31, new_value_t.undefined_bits_7_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Display Window Header for programming display windows and their corresponding buffer start addresses.\nClass: Display Window Programming Header";
}

#define CMD_REG_ACT_CONTROL_OFFSET 0x43
#define CMD_REG_ACT_CONTROL_UNDEFMASK 0xFFFFFFAA
union cmd_reg_act_control_u {
    struct {
        unsigned int general_act_cntr_sel:1;/* Select which counter to use for general activation  0 = VCOUNTER 1 = HCOUNTER */
        unsigned int undefined_bit_1:1;
        unsigned int win_a_act_cntr_sel:1;  /* Select which counter to use for window A activation  0 = VCOUNTER 1 = HCOUNTER */
        unsigned int undefined_bit_3:1;
        unsigned int win_b_act_cntr_sel:1;  /* Select which counter to use for window B activation  0 = VCOUNTER 1 = HCOUNTER */
        unsigned int undefined_bit_5:1;
        unsigned int win_c_act_cntr_sel:1;  /* Select which counter to use for window C activation  0 = VCOUNTER 1 = HCOUNTER */
        unsigned int undefined_bits_7_31:25;
    };

    u_int32_t reg32;
};

void DcDev::fill_cmd_reg_act_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const cmd_reg_act_control_u old_value_t = { .reg32 = value };
    const cmd_reg_act_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: general_act_cntr_sel:1",
              "Select which counter to use for general activation \n0 = VCOUNTER\n1 = HCOUNTER",
              1, old_value_t.general_act_cntr_sel, new_value_t.general_act_cntr_sel };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: win_a_act_cntr_sel:1",
              "Select which counter to use for window A activation \n0 = VCOUNTER\n1 = HCOUNTER",
              1, old_value_t.win_a_act_cntr_sel, new_value_t.win_a_act_cntr_sel };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: win_b_act_cntr_sel:1",
              "Select which counter to use for window B activation \n0 = VCOUNTER\n1 = HCOUNTER",
              1, old_value_t.win_b_act_cntr_sel, new_value_t.win_b_act_cntr_sel };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: win_c_act_cntr_sel:1",
              "Select which counter to use for window C activation \n0 = VCOUNTER\n1 = HCOUNTER",
              1, old_value_t.win_c_act_cntr_sel, new_value_t.win_c_act_cntr_sel };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bits_7_31:25", "", 25, old_value_t.undefined_bits_7_31, new_value_t.undefined_bits_7_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Register activation options";
}

#define COM_CRC_CONTROL_OFFSET 0x300
#define COM_CRC_CONTROL_UNDEFMASK 0xFFFFFFF0
union com_crc_control_u {
    struct {
        unsigned int crc_enable:1;          /* CRC Enable  0 = DISABLE 1 = ENABLE */
        unsigned int crc_wait:1;            /* CRC Wait 0= 1 Vsync 1= 2 Vsync */
        unsigned int crc_input_data:1;      /* CRC input data 0= Full frame (RGB data and control) 1= Active display (Only RGB data)  0 = FULL_FRAME 1 = ACTIVE_DATA */
        unsigned int crc_always:1;          /* CRC always: calculate CRC for every following frames Must use with CRC_INPUT_DATA = ACTIVE_DATA if enabled, CRC_WAIT field is ignored.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_crc_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_crc_control_u old_value_t = { .reg32 = value };
    const com_crc_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: crc_enable:1",
              "CRC Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.crc_enable, new_value_t.crc_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: crc_wait:1",
              "CRC Wait\n0= 1 Vsync\n1= 2 Vsync",
              1, old_value_t.crc_wait, new_value_t.crc_wait };
    m_bit_details_model.bits.append(entry);
    entry = { "02: crc_input_data:1",
              "CRC input data\n0= Full frame (RGB data and control)\n1= Active display (Only RGB data) \n0 = FULL_FRAME\n1 = ACTIVE_DATA",
              1, old_value_t.crc_input_data, new_value_t.crc_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "03: crc_always:1",
              "CRC always: calculate CRC for every following frames Must use with CRC_INPUT_DATA = ACTIVE_DATA if enabled, CRC_WAIT field is ignored.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.crc_always, new_value_t.crc_always };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "CRC Control\nCRC is provided for at speed testing and diagnostic. When CRC is enabled, the CRC logic waits for the next VSync pulse or the one after that (depending on CRC_WAIT) and then it captures one frame of data at the end of display pipeline and computes the CRC value.\nAfter one frame of data is captured, the CRC logic will stop capturing data.\nWhen CRC_INTPU_DATA = FULLL_FRAME, DISPLAY_COMMAND.DISPLAY_CTRL_MODE should be programmed to C_DISPLAY so that CRC works properly.\nWhen CRC_INTPU_DATA = ACTIVE_DATA, it can work on both NC_DISPLAY and C_DISPLAY modes, and can work for multiple frames if CRC is checked, disabled, and re-enabled after the end of frame v-active area and before next vsync.\nCRC logic takes 8-bit of control signals and 24-bit RGB pixel after dither and after display color (R and B) swap option.\nInput [31:0] into CRC depends on CRC_INPUT_DATA. If programmed as FULL_FRAME, input data is {LCD_D20, LPV0, LCD_D19, LCD_D18, LCD_D21, VSYNC, HSYNC, ACTIVE, R[7:0], G[7:0], B[7:0]} and CRC runs over the entire frame (including blank). If programmed as ACTIVE_DATA, input data is {R[7:0], G[7:0], B[7:0]} and CRC runs only during active display area.";
}

#define COM_CRC_CHECKSUM_OFFSET 0x301
#define COM_CRC_CHECKSUM_UNDEFMASK 0x00000000
union com_crc_checksum_u {
    struct {
        unsigned int crc_checksum:32;       /* CRC Checksum */
    };

    u_int32_t reg32;
};

void DcDev::fill_com_crc_checksum_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_crc_checksum_u old_value_t = { .reg32 = value };
    const com_crc_checksum_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: crc_checksum:32",
              "CRC Checksum",
              32, old_value_t.crc_checksum, new_value_t.crc_checksum };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "CRC Checksum\nThis register can be read by host after CRC logic stops capturing data.";
}

#define COM_PIN_OUTPUT_ENABLE0_OFFSET 0x302
#define COM_PIN_OUTPUT_ENABLE0_UNDEFMASK 0xAAAAAAAA
union com_pin_output_enable0_u {
    struct {
        unsigned int ld0_output_enable:1;   /* LD0 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_1:1;
        unsigned int ld1_output_enable:1;   /* LD1 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_3:1;
        unsigned int ld2_output_enable:1;   /* LD2 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_5:1;
        unsigned int ld3_output_enable:1;   /* LD3 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_7:1;
        unsigned int ld4_output_enable:1;   /* LD4 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_9:1;
        unsigned int ld5_output_enable:1;   /* LD5 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_11:1;
        unsigned int ld6_output_enable:1;   /* LD6 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_13:1;
        unsigned int ld7_output_enable:1;   /* LD7 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_15:1;
        unsigned int ld8_output_enable:1;   /* LD8 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_17:1;
        unsigned int ld9_output_enable:1;   /* LD9 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_19:1;
        unsigned int ld10_output_enable:1;  /* LD10 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_21:1;
        unsigned int ld11_output_enable:1;  /* LD11 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_23:1;
        unsigned int ld12_output_enable:1;  /* LD12 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_25:1;
        unsigned int ld13_output_enable:1;  /* LD13 pin output enable; 0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_27:1;
        unsigned int ld14_output_enable:1;  /* LD14 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_29:1;
        unsigned int ld15_output_enable:1;  /* LD15 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_enable0_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_enable0_u old_value_t = { .reg32 = value };
    const com_pin_output_enable0_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ld0_output_enable:1",
              "LD0 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld0_output_enable, new_value_t.ld0_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: ld1_output_enable:1",
              "LD1 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld1_output_enable, new_value_t.ld1_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: ld2_output_enable:1",
              "LD2 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld2_output_enable, new_value_t.ld2_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: ld3_output_enable:1",
              "LD3 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld3_output_enable, new_value_t.ld3_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ld4_output_enable:1",
              "LD4 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld4_output_enable, new_value_t.ld4_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bit_9:1", "", 1, old_value_t.undefined_bit_9, new_value_t.undefined_bit_9 };
    m_bit_details_model.bits.append(entry);
    entry = { "10: ld5_output_enable:1",
              "LD5 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld5_output_enable, new_value_t.ld5_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: ld6_output_enable:1",
              "LD6 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld6_output_enable, new_value_t.ld6_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: ld7_output_enable:1",
              "LD7 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld7_output_enable, new_value_t.ld7_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ld8_output_enable:1",
              "LD8 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld8_output_enable, new_value_t.ld8_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: ld9_output_enable:1",
              "LD9 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld9_output_enable, new_value_t.ld9_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ld10_output_enable:1",
              "LD10 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld10_output_enable, new_value_t.ld10_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bit_21:1", "", 1, old_value_t.undefined_bit_21, new_value_t.undefined_bit_21 };
    m_bit_details_model.bits.append(entry);
    entry = { "22: ld11_output_enable:1",
              "LD11 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld11_output_enable, new_value_t.ld11_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: ld12_output_enable:1",
              "LD12 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld12_output_enable, new_value_t.ld12_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bit_25:1", "", 1, old_value_t.undefined_bit_25, new_value_t.undefined_bit_25 };
    m_bit_details_model.bits.append(entry);
    entry = { "26: ld13_output_enable:1",
              "LD13 pin output enable;\n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld13_output_enable, new_value_t.ld13_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "27: undefined_bit_27:1", "", 1, old_value_t.undefined_bit_27, new_value_t.undefined_bit_27 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: ld14_output_enable:1",
              "LD14 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld14_output_enable, new_value_t.ld14_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: ld15_output_enable:1",
              "LD15 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld15_output_enable, new_value_t.ld15_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Pin Output Enable 0\nPin Output Enable registers";
}

#define COM_PIN_OUTPUT_ENABLE1_OFFSET 0x303
#define COM_PIN_OUTPUT_ENABLE1_UNDEFMASK 0xAAEAFFFA
union com_pin_output_enable1_u {
    struct {
        unsigned int ld16_output_enable:1;  /* LD16 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_1:1;
        unsigned int ld17_output_enable:1;  /* LD17 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_3_15:13;
        unsigned int lpw0_output_enable:1;  /* LCD_PWR0 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_17:1;
        unsigned int lpw1_output_enable:1;  /* LCD_PWR1 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_19:1;
        unsigned int lpw2_output_enable:1;  /* LCD_PWR2 pin output enable; 0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_21_23:3;
        unsigned int lsc0_output_enable:1;  /* LCD_PCLK pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_25:1;
        unsigned int lsc1_output_enable:1;  /* LCD_WR_N pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_27:1;
        unsigned int lvs_output_enable:1;   /* LVS pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_29:1;
        unsigned int lhs_output_enable:1;   /* LCD_HSYNC pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_enable1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_enable1_u old_value_t = { .reg32 = value };
    const com_pin_output_enable1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ld16_output_enable:1",
              "LD16 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld16_output_enable, new_value_t.ld16_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: ld17_output_enable:1",
              "LD17 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.ld17_output_enable, new_value_t.ld17_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_15:13", "", 13, old_value_t.undefined_bits_3_15, new_value_t.undefined_bits_3_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lpw0_output_enable:1",
              "LCD_PWR0 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lpw0_output_enable, new_value_t.lpw0_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: lpw1_output_enable:1",
              "LCD_PWR1 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lpw1_output_enable, new_value_t.lpw1_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: lpw2_output_enable:1",
              "LCD_PWR2 pin output enable;\n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lpw2_output_enable, new_value_t.lpw2_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_23:3", "", 3, old_value_t.undefined_bits_21_23, new_value_t.undefined_bits_21_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: lsc0_output_enable:1",
              "LCD_PCLK pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lsc0_output_enable, new_value_t.lsc0_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bit_25:1", "", 1, old_value_t.undefined_bit_25, new_value_t.undefined_bit_25 };
    m_bit_details_model.bits.append(entry);
    entry = { "26: lsc1_output_enable:1",
              "LCD_WR_N pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lsc1_output_enable, new_value_t.lsc1_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "27: undefined_bit_27:1", "", 1, old_value_t.undefined_bit_27, new_value_t.undefined_bit_27 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: lvs_output_enable:1",
              "LVS pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lvs_output_enable, new_value_t.lvs_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: lhs_output_enable:1",
              "LCD_HSYNC pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lhs_output_enable, new_value_t.lhs_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Enable 1";
}

#define COM_PIN_OUTPUT_ENABLE2_OFFSET 0x304
#define COM_PIN_OUTPUT_ENABLE2_UNDEFMASK 0xFFAAFAEA
union com_pin_output_enable2_u {
    struct {
        unsigned int lhp0_output_enable:1;  /* LCD_D21 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_1:1;
        unsigned int lhp1_output_enable:1;  /* LCD_D18 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_3:1;
        unsigned int lhp2_output_enable:1;  /* LCD_D19 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_5_7:3;
        unsigned int lvp0_output_enable:1;  /* LCD_DC1 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_9:1;
        unsigned int lvp1_output_enable:1;  /* LCD_D20 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_11_15:5;
        unsigned int lm0_output_enable:1;   /* LCD_CS1_N pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_17:1;
        unsigned int lm1_output_enable:1;   /* LCD_M1 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_19:1;
        unsigned int ldi_output_enable:1;   /* LCD_D22 pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_21:1;
        unsigned int lpp_output_enable:1;   /* LCD_D23 pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bits_23_31:9;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_enable2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_enable2_u old_value_t = { .reg32 = value };
    const com_pin_output_enable2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lhp0_output_enable:1",
              "LCD_D21 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lhp0_output_enable, new_value_t.lhp0_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: lhp1_output_enable:1",
              "LCD_D18 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lhp1_output_enable, new_value_t.lhp1_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lhp2_output_enable:1",
              "LCD_D19 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lhp2_output_enable, new_value_t.lhp2_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: lvp0_output_enable:1",
              "LCD_DC1 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lvp0_output_enable, new_value_t.lvp0_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bit_9:1", "", 1, old_value_t.undefined_bit_9, new_value_t.undefined_bit_9 };
    m_bit_details_model.bits.append(entry);
    entry = { "10: lvp1_output_enable:1",
              "LCD_D20 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lvp1_output_enable, new_value_t.lvp1_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_15:5", "", 5, old_value_t.undefined_bits_11_15, new_value_t.undefined_bits_11_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lm0_output_enable:1",
              "LCD_CS1_N pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lm0_output_enable, new_value_t.lm0_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: lm1_output_enable:1",
              "LCD_M1 pin output enable \n0 = ENABLE\n1 = DISABLE",
              1, old_value_t.lm1_output_enable, new_value_t.lm1_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ldi_output_enable:1",
              "LCD_D22 pin output enable \n0 = ENABLE\n1 = DISABLE (default after reset)",
              1, old_value_t.ldi_output_enable, new_value_t.ldi_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bit_21:1", "", 1, old_value_t.undefined_bit_21, new_value_t.undefined_bit_21 };
    m_bit_details_model.bits.append(entry);
    entry = { "22: lpp_output_enable:1",
              "LCD_D23 pin output enable \n0 = ENABLE\n1 = DISABLE (default after reset)",
              1, old_value_t.lpp_output_enable, new_value_t.lpp_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bits_23_31:9", "", 9, old_value_t.undefined_bits_23_31, new_value_t.undefined_bits_23_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Enable 2";
}

#define COM_PIN_OUTPUT_ENABLE3_OFFSET 0x305
#define COM_PIN_OUTPUT_ENABLE3_UNDEFMASK 0xFFFFFAAA
union com_pin_output_enable3_u {
    struct {
        unsigned int lsck_output_enable:1;  /* LSCK pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_1:1;
        unsigned int lsda_output_enable:1;  /* LSDA pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_3:1;
        unsigned int lcsn_output_enable:1;  /* LCSN pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_5:1;
        unsigned int ldc_output_enable:1;   /* LDC pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_7:1;
        unsigned int lspi_output_enable:1;  /* LSPI pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_9:1;
        unsigned int lsdi_output_enable:1;  /* LSDI pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bits_11_31:21;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_enable3_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_enable3_u old_value_t = { .reg32 = value };
    const com_pin_output_enable3_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lsck_output_enable:1",
              "LSCK pin output enable \n0 = ENABLE\n1 = DISABLE (default after reset)",
              1, old_value_t.lsck_output_enable, new_value_t.lsck_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: lsda_output_enable:1",
              "LSDA pin output enable \n0 = ENABLE\n1 = DISABLE (default after reset)",
              1, old_value_t.lsda_output_enable, new_value_t.lsda_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lcsn_output_enable:1",
              "LCSN pin output enable \n0 = ENABLE\n1 = DISABLE (default after reset)",
              1, old_value_t.lcsn_output_enable, new_value_t.lcsn_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: ldc_output_enable:1",
              "LDC pin output enable \n0 = ENABLE\n1 = DISABLE (default after reset)",
              1, old_value_t.ldc_output_enable, new_value_t.ldc_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: lspi_output_enable:1",
              "LSPI pin output enable \n0 = ENABLE\n1 = DISABLE (default after reset)",
              1, old_value_t.lspi_output_enable, new_value_t.lspi_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bit_9:1", "", 1, old_value_t.undefined_bit_9, new_value_t.undefined_bit_9 };
    m_bit_details_model.bits.append(entry);
    entry = { "10: lsdi_output_enable:1",
              "LSDI pin output enable \n0 = ENABLE\n1 = DISABLE (default after reset)",
              1, old_value_t.lsdi_output_enable, new_value_t.lsdi_output_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_31:21", "", 21, old_value_t.undefined_bits_11_31, new_value_t.undefined_bits_11_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Enable 3";
}

#define COM_PIN_OUTPUT_POLARITY0_OFFSET 0x306
#define COM_PIN_OUTPUT_POLARITY0_UNDEFMASK 0xAAAAAAAA
union com_pin_output_polarity0_u {
    struct {
        unsigned int ld0_output_polarity:1; /* LD0 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_1:1;
        unsigned int ld1_output_polarity:1; /* LD1 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_3:1;
        unsigned int ld2_output_polarity:1; /* LD2 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int ld3_output_polarity:1; /* LD3 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_7:1;
        unsigned int ld4_output_polarity:1; /* LD4 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_9:1;
        unsigned int ld5_output_polarity:1; /* LD5 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_11:1;
        unsigned int ld6_output_polarity:1; /* LD6 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_13:1;
        unsigned int ld7_output_polarity:1; /* LD7 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_15:1;
        unsigned int ld8_output_polarity:1; /* LD8 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_17:1;
        unsigned int ld9_output_polarity:1; /* LD9 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_19:1;
        unsigned int ld10_output_polarity:1;/* LD10 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_21:1;
        unsigned int ld11_output_polarity:1;/* LD11 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_23:1;
        unsigned int ld12_output_polarity:1;/* LD12 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_25:1;
        unsigned int ld13_output_polarity:1;/* LD13 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_27:1;
        unsigned int ld14_output_polarity:1;/* LD14 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_29:1;
        unsigned int ld15_output_polarity:1;/* LD15 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_polarity0_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_polarity0_u old_value_t = { .reg32 = value };
    const com_pin_output_polarity0_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ld0_output_polarity:1",
              "LD0 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld0_output_polarity, new_value_t.ld0_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: ld1_output_polarity:1",
              "LD1 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld1_output_polarity, new_value_t.ld1_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: ld2_output_polarity:1",
              "LD2 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld2_output_polarity, new_value_t.ld2_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: ld3_output_polarity:1",
              "LD3 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld3_output_polarity, new_value_t.ld3_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ld4_output_polarity:1",
              "LD4 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld4_output_polarity, new_value_t.ld4_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bit_9:1", "", 1, old_value_t.undefined_bit_9, new_value_t.undefined_bit_9 };
    m_bit_details_model.bits.append(entry);
    entry = { "10: ld5_output_polarity:1",
              "LD5 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld5_output_polarity, new_value_t.ld5_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: ld6_output_polarity:1",
              "LD6 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld6_output_polarity, new_value_t.ld6_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: ld7_output_polarity:1",
              "LD7 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld7_output_polarity, new_value_t.ld7_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ld8_output_polarity:1",
              "LD8 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld8_output_polarity, new_value_t.ld8_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: ld9_output_polarity:1",
              "LD9 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld9_output_polarity, new_value_t.ld9_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ld10_output_polarity:1",
              "LD10 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld10_output_polarity, new_value_t.ld10_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bit_21:1", "", 1, old_value_t.undefined_bit_21, new_value_t.undefined_bit_21 };
    m_bit_details_model.bits.append(entry);
    entry = { "22: ld11_output_polarity:1",
              "LD11 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld11_output_polarity, new_value_t.ld11_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: ld12_output_polarity:1",
              "LD12 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld12_output_polarity, new_value_t.ld12_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bit_25:1", "", 1, old_value_t.undefined_bit_25, new_value_t.undefined_bit_25 };
    m_bit_details_model.bits.append(entry);
    entry = { "26: ld13_output_polarity:1",
              "LD13 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld13_output_polarity, new_value_t.ld13_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "27: undefined_bit_27:1", "", 1, old_value_t.undefined_bit_27, new_value_t.undefined_bit_27 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: ld14_output_polarity:1",
              "LD14 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld14_output_polarity, new_value_t.ld14_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: ld15_output_polarity:1",
              "LD15 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld15_output_polarity, new_value_t.ld15_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Polarity 0\nPin Output Polarity registers\nHIGH means the internal signal value is transmitted on pin as-is.\nLOW means the internal signal is inverted before transmission on the pin.";
}

#define COM_PIN_OUTPUT_POLARITY1_OFFSET 0x307
#define COM_PIN_OUTPUT_POLARITY1_UNDEFMASK 0xAAEAFFFA
union com_pin_output_polarity1_u {
    struct {
        unsigned int ld16_output_polarity:1;/* LD16 pin output polarity; 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_1:1;
        unsigned int ld17_output_polarity:1;/* LD17 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_3_15:13;
        unsigned int lpw0_output_polarity:1;/* LCD_PWR0 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_17:1;
        unsigned int lpw1_output_polarity:1;/* LCD_PWR1 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_19:1;
        unsigned int lpw2_output_polarity:1;/* LCD_PWR2 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_21_23:3;
        unsigned int lsc0_output_polarity:1;/* LCD_PCLK pin output polarity. When used as PCLK (pixel clock), HIGH means that rising edge coincides with data transition, and LOW means that falling edge coincides with data transition. 0= active high 1= active low  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_25:1;
        unsigned int lsc1_output_polarity:1;/* LCD_WR_N pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_27:1;
        unsigned int lvs_output_polarity:1; /* LVS pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_29:1;
        unsigned int lhs_output_polarity:1; /* LCD_HSYNC pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_polarity1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_polarity1_u old_value_t = { .reg32 = value };
    const com_pin_output_polarity1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ld16_output_polarity:1",
              "LD16 pin output polarity;\n0 = HIGH\n1 = LOW",
              1, old_value_t.ld16_output_polarity, new_value_t.ld16_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: ld17_output_polarity:1",
              "LD17 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ld17_output_polarity, new_value_t.ld17_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_15:13", "", 13, old_value_t.undefined_bits_3_15, new_value_t.undefined_bits_3_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lpw0_output_polarity:1",
              "LCD_PWR0 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lpw0_output_polarity, new_value_t.lpw0_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: lpw1_output_polarity:1",
              "LCD_PWR1 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lpw1_output_polarity, new_value_t.lpw1_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: lpw2_output_polarity:1",
              "LCD_PWR2 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lpw2_output_polarity, new_value_t.lpw2_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_23:3", "", 3, old_value_t.undefined_bits_21_23, new_value_t.undefined_bits_21_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: lsc0_output_polarity:1",
              "LCD_PCLK pin output polarity. When used as PCLK (pixel clock), HIGH means that rising edge coincides with data transition, and LOW means that falling edge coincides with data transition.\n0= active high\n1= active low \n0 = HIGH\n1 = LOW",
              1, old_value_t.lsc0_output_polarity, new_value_t.lsc0_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bit_25:1", "", 1, old_value_t.undefined_bit_25, new_value_t.undefined_bit_25 };
    m_bit_details_model.bits.append(entry);
    entry = { "26: lsc1_output_polarity:1",
              "LCD_WR_N pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lsc1_output_polarity, new_value_t.lsc1_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "27: undefined_bit_27:1", "", 1, old_value_t.undefined_bit_27, new_value_t.undefined_bit_27 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: lvs_output_polarity:1",
              "LVS pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lvs_output_polarity, new_value_t.lvs_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: lhs_output_polarity:1",
              "LCD_HSYNC pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lhs_output_polarity, new_value_t.lhs_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Polarity 1";
}

#define COM_PIN_OUTPUT_POLARITY2_OFFSET 0x308
#define COM_PIN_OUTPUT_POLARITY2_UNDEFMASK 0xFFAAFAEA
union com_pin_output_polarity2_u {
    struct {
        unsigned int lhp0_output_polarity:1;/* LCD_D21 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_1:1;
        unsigned int lhp1_output_polarity:1;/* LCD_D18 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_3:1;
        unsigned int lhp2_output_polarity:1;/* LCD_D19 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_5_7:3;
        unsigned int lvp0_output_polarity:1;/* LCD_DC1 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_9:1;
        unsigned int lvp1_output_polarity:1;/* LCD_D20 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_11_15:5;
        unsigned int lm0_output_polarity:1; /* LCD_CS1_N pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_17:1;
        unsigned int lm1_output_polarity:1; /* LCD_M1 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_19:1;
        unsigned int ldi_output_polarity:1; /* LCD_D22 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_21:1;
        unsigned int lpp_output_polarity:1; /* LCD_D23 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_23_31:9;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_polarity2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_polarity2_u old_value_t = { .reg32 = value };
    const com_pin_output_polarity2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lhp0_output_polarity:1",
              "LCD_D21 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lhp0_output_polarity, new_value_t.lhp0_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: lhp1_output_polarity:1",
              "LCD_D18 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lhp1_output_polarity, new_value_t.lhp1_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lhp2_output_polarity:1",
              "LCD_D19 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lhp2_output_polarity, new_value_t.lhp2_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: lvp0_output_polarity:1",
              "LCD_DC1 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lvp0_output_polarity, new_value_t.lvp0_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bit_9:1", "", 1, old_value_t.undefined_bit_9, new_value_t.undefined_bit_9 };
    m_bit_details_model.bits.append(entry);
    entry = { "10: lvp1_output_polarity:1",
              "LCD_D20 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lvp1_output_polarity, new_value_t.lvp1_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_15:5", "", 5, old_value_t.undefined_bits_11_15, new_value_t.undefined_bits_11_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lm0_output_polarity:1",
              "LCD_CS1_N pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lm0_output_polarity, new_value_t.lm0_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: lm1_output_polarity:1",
              "LCD_M1 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lm1_output_polarity, new_value_t.lm1_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ldi_output_polarity:1",
              "LCD_D22 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ldi_output_polarity, new_value_t.ldi_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bit_21:1", "", 1, old_value_t.undefined_bit_21, new_value_t.undefined_bit_21 };
    m_bit_details_model.bits.append(entry);
    entry = { "22: lpp_output_polarity:1",
              "LCD_D23 pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lpp_output_polarity, new_value_t.lpp_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bits_23_31:9", "", 9, old_value_t.undefined_bits_23_31, new_value_t.undefined_bits_23_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Polarity 2";
}

#define COM_PIN_OUTPUT_POLARITY3_OFFSET 0x309
#define COM_PIN_OUTPUT_POLARITY3_UNDEFMASK 0xFFFFFAAA
union com_pin_output_polarity3_u {
    struct {
        unsigned int lsck_output_polarity:1;/* LSCK pin output polarity; 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_1:1;
        unsigned int lsda_output_polarity:1;/* LSDA pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_3:1;
        unsigned int lcsn_output_polarity:1;/* LCSN pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int ldc_output_polarity:1; /* LDC pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_7:1;
        unsigned int lspi_output_polarity:1;/* LSPI pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_9:1;
        unsigned int lsdi_output_polarity:1;/* LSDI pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_11_31:21;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_polarity3_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_polarity3_u old_value_t = { .reg32 = value };
    const com_pin_output_polarity3_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lsck_output_polarity:1",
              "LSCK pin output polarity;\n0 = HIGH\n1 = LOW",
              1, old_value_t.lsck_output_polarity, new_value_t.lsck_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: lsda_output_polarity:1",
              "LSDA pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lsda_output_polarity, new_value_t.lsda_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lcsn_output_polarity:1",
              "LCSN pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lcsn_output_polarity, new_value_t.lcsn_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: ldc_output_polarity:1",
              "LDC pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.ldc_output_polarity, new_value_t.ldc_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: lspi_output_polarity:1",
              "LSPI pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lspi_output_polarity, new_value_t.lspi_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bit_9:1", "", 1, old_value_t.undefined_bit_9, new_value_t.undefined_bit_9 };
    m_bit_details_model.bits.append(entry);
    entry = { "10: lsdi_output_polarity:1",
              "LSDI pin output polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.lsdi_output_polarity, new_value_t.lsdi_output_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_31:21", "", 21, old_value_t.undefined_bits_11_31, new_value_t.undefined_bits_11_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Polarity 3";
}

#define COM_PIN_OUTPUT_DATA0_OFFSET 0x30A
#define COM_PIN_OUTPUT_DATA0_UNDEFMASK 0x00000000
union com_pin_output_data0_u {
    struct {
        unsigned int ld0_output_data:1;     /* LD0 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld0_output_data_mask:1;/* LD0 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld1_output_data:1;     /* LD1 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld1_output_data_mask:1;/* LD1 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld2_output_data:1;     /* LD2 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld2_output_data_mask:1;/* LD2 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld3_output_data:1;     /* LD3 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld3_output_data_mask:1;/* LD3 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld4_output_data:1;     /* LD4 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld4_output_data_mask:1;/* LD4 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld5_output_data:1;     /* LD5 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld5_output_data_mask:1;/* LD5 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld6_output_data:1;     /* LD6 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld6_output_data_mask:1;/* LD6 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld7_output_data:1;     /* LD7 pin output data; 0 = LOW 1 = HIGH */
        unsigned int ld7_output_data_mask:1;/* LD7 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld8_output_data:1;     /* LD8 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld8_output_data_mask:1;/* LD8 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld9_output_data:1;     /* LD9 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld9_output_data_mask:1;/* LD9 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld10_output_data:1;    /* LD10 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld10_output_data_mask:1;/* LD10 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld11_output_data:1;    /* LD11 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld11_output_data_mask:1;/* LD11 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld12_output_data:1;    /* LD12 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld12_output_data_mask:1;/* LD12 pin output data  0 = MASKED 1 = NOTMASKED */
        unsigned int ld13_output_data:1;    /* LD13 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld13_output_data_mask:1;/* LD13 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld14_output_data:1;    /* LD14 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld14_output_data_mask:1;/* LD14 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld15_output_data:1;    /* LD15 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld15_output_data_mask:1;/* LD15 pin output data mask  0 = MASKED 1 = NOTMASKED */
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_data0_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_data0_u old_value_t = { .reg32 = value };
    const com_pin_output_data0_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ld0_output_data:1",
              "LD0 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld0_output_data, new_value_t.ld0_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "01: ld0_output_data_mask:1",
              "LD0 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld0_output_data_mask, new_value_t.ld0_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "02: ld1_output_data:1",
              "LD1 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld1_output_data, new_value_t.ld1_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "03: ld1_output_data_mask:1",
              "LD1 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld1_output_data_mask, new_value_t.ld1_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "04: ld2_output_data:1",
              "LD2 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld2_output_data, new_value_t.ld2_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "05: ld2_output_data_mask:1",
              "LD2 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld2_output_data_mask, new_value_t.ld2_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "06: ld3_output_data:1",
              "LD3 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld3_output_data, new_value_t.ld3_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "07: ld3_output_data_mask:1",
              "LD3 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld3_output_data_mask, new_value_t.ld3_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ld4_output_data:1",
              "LD4 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld4_output_data, new_value_t.ld4_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "09: ld4_output_data_mask:1",
              "LD4 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld4_output_data_mask, new_value_t.ld4_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "10: ld5_output_data:1",
              "LD5 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld5_output_data, new_value_t.ld5_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "11: ld5_output_data_mask:1",
              "LD5 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld5_output_data_mask, new_value_t.ld5_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "12: ld6_output_data:1",
              "LD6 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld6_output_data, new_value_t.ld6_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "13: ld6_output_data_mask:1",
              "LD6 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld6_output_data_mask, new_value_t.ld6_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "14: ld7_output_data:1",
              "LD7 pin output data;\n0 = LOW\n1 = HIGH",
              1, old_value_t.ld7_output_data, new_value_t.ld7_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "15: ld7_output_data_mask:1",
              "LD7 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld7_output_data_mask, new_value_t.ld7_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ld8_output_data:1",
              "LD8 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld8_output_data, new_value_t.ld8_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "17: ld8_output_data_mask:1",
              "LD8 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld8_output_data_mask, new_value_t.ld8_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "18: ld9_output_data:1",
              "LD9 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld9_output_data, new_value_t.ld9_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "19: ld9_output_data_mask:1",
              "LD9 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld9_output_data_mask, new_value_t.ld9_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ld10_output_data:1",
              "LD10 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld10_output_data, new_value_t.ld10_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "21: ld10_output_data_mask:1",
              "LD10 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld10_output_data_mask, new_value_t.ld10_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "22: ld11_output_data:1",
              "LD11 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld11_output_data, new_value_t.ld11_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "23: ld11_output_data_mask:1",
              "LD11 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld11_output_data_mask, new_value_t.ld11_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "24: ld12_output_data:1",
              "LD12 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld12_output_data, new_value_t.ld12_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "25: ld12_output_data_mask:1",
              "LD12 pin output data \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld12_output_data_mask, new_value_t.ld12_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "26: ld13_output_data:1",
              "LD13 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld13_output_data, new_value_t.ld13_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "27: ld13_output_data_mask:1",
              "LD13 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld13_output_data_mask, new_value_t.ld13_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "28: ld14_output_data:1",
              "LD14 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld14_output_data, new_value_t.ld14_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "29: ld14_output_data_mask:1",
              "LD14 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld14_output_data_mask, new_value_t.ld14_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "30: ld15_output_data:1",
              "LD15 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld15_output_data, new_value_t.ld15_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "31: ld15_output_data_mask:1",
              "LD15 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld15_output_data_mask, new_value_t.ld15_output_data_mask };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Data 0\nPin Output data registers\nUsed for general purpose I/O, these values only take effect when OUTPUT_SELECT=1, typically.\n The OUTPUT_DATA_MASK bits allow a subset of pins to be atomically changed without requiring a read/modify/write.\nTo change output data, the corresponding mask should be disabled (not masked).";
}

#define COM_PIN_OUTPUT_DATA1_OFFSET 0x30B
#define COM_PIN_OUTPUT_DATA1_UNDEFMASK 0x00C0FFF0
union com_pin_output_data1_u {
    struct {
        unsigned int ld16_output_data:1;    /* LD16 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld16_output_data_mask:1;/* LD16 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld17_output_data:1;    /* LD17 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld17_output_data_mask:1;/* LD17 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_4_15:12;
        unsigned int lpw0_output_data:1;    /* LCD_PWR0 pin output data  0 = LOW 1 = HIGH */
        unsigned int lpw0_output_data_mask:1;/* LCD_PWR0 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lpw1_output_data:1;    /* LCD_PWR1 pin output data  0 = LOW 1 = HIGH */
        unsigned int lpw1_output_data_mask:1;/* LCD_PWR1 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lpw2_output_data:1;    /* LCD_PWR2 pin output data  0 = LOW 1 = HIGH */
        unsigned int lpw2_output_data_mask:1;/* LCD_PWR2 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_22_23:2;
        unsigned int lsc0_output_data:1;    /* LCD_PCLK pin output data  0 = LOW 1 = HIGH */
        unsigned int lsc0_output_data_mask:1;/* LCD_PCLK pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lsc1_output_data:1;    /* LCD_WR_N pin output data  0 = LOW 1 = HIGH */
        unsigned int lsc1_output_data_mask:1;/* LCD_WR_N pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lvs_output_data:1;     /* LVS pin output data  0 = LOW 1 = HIGH */
        unsigned int lvs_output_data_mask:1;/* LVS pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lhs_output_data:1;     /* LCD_HSYNC pin output data  0 = LOW 1 = HIGH */
        unsigned int lhs_output_data_mask:1;/* LCD_HSYNC pin output data mask  0 = MASKED 1 = NOTMASKED */
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_data1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_data1_u old_value_t = { .reg32 = value };
    const com_pin_output_data1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ld16_output_data:1",
              "LD16 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld16_output_data, new_value_t.ld16_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "01: ld16_output_data_mask:1",
              "LD16 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld16_output_data_mask, new_value_t.ld16_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "02: ld17_output_data:1",
              "LD17 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ld17_output_data, new_value_t.ld17_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "03: ld17_output_data_mask:1",
              "LD17 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ld17_output_data_mask, new_value_t.ld17_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_15:12", "", 12, old_value_t.undefined_bits_4_15, new_value_t.undefined_bits_4_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lpw0_output_data:1",
              "LCD_PWR0 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lpw0_output_data, new_value_t.lpw0_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "17: lpw0_output_data_mask:1",
              "LCD_PWR0 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lpw0_output_data_mask, new_value_t.lpw0_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "18: lpw1_output_data:1",
              "LCD_PWR1 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lpw1_output_data, new_value_t.lpw1_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "19: lpw1_output_data_mask:1",
              "LCD_PWR1 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lpw1_output_data_mask, new_value_t.lpw1_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "20: lpw2_output_data:1",
              "LCD_PWR2 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lpw2_output_data, new_value_t.lpw2_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "21: lpw2_output_data_mask:1",
              "LCD_PWR2 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lpw2_output_data_mask, new_value_t.lpw2_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: lsc0_output_data:1",
              "LCD_PCLK pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lsc0_output_data, new_value_t.lsc0_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "25: lsc0_output_data_mask:1",
              "LCD_PCLK pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lsc0_output_data_mask, new_value_t.lsc0_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "26: lsc1_output_data:1",
              "LCD_WR_N pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lsc1_output_data, new_value_t.lsc1_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "27: lsc1_output_data_mask:1",
              "LCD_WR_N pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lsc1_output_data_mask, new_value_t.lsc1_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "28: lvs_output_data:1",
              "LVS pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lvs_output_data, new_value_t.lvs_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "29: lvs_output_data_mask:1",
              "LVS pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lvs_output_data_mask, new_value_t.lvs_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "30: lhs_output_data:1",
              "LCD_HSYNC pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lhs_output_data, new_value_t.lhs_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "31: lhs_output_data_mask:1",
              "LCD_HSYNC pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lhs_output_data_mask, new_value_t.lhs_output_data_mask };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Data 1";
}

#define COM_PIN_OUTPUT_DATA2_OFFSET 0x30C
#define COM_PIN_OUTPUT_DATA2_UNDEFMASK 0xFF00F0C0
union com_pin_output_data2_u {
    struct {
        unsigned int lhp0_output_data:1;    /* LCD_D21 pin output data  0 = LOW 1 = HIGH */
        unsigned int lhp0_output_data_mask:1;/* LCD_D21 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lhp1_output_data:1;    /* LCD_D18 pin output data  0 = LOW 1 = HIGH */
        unsigned int lhp1_output_data_mask:1;/* LCD_D18 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lhp2_output_data:1;    /* LCD_D19 pin output data  0 = LOW 1 = HIGH */
        unsigned int lhp2_output_data_mask:1;/* LCD_D19 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_6_7:2;
        unsigned int lvp0_output_data:1;    /* LCD_DC1 pin output data  0 = LOW 1 = HIGH */
        unsigned int lvp0_output_data_mask:1;/* LCD_DC1 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lvp1_output_data:1;    /* LCD_D20 pin output data  0 = LOW 1 = HIGH */
        unsigned int lvp1_output_data_mask:1;/* LCD_D20 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_12_15:4;
        unsigned int lm0_output_data:1;     /* LCD_CS1_N pin output data  0 = LOW 1 = HIGH */
        unsigned int lm0_output_data_mask:1;/* LCD_CS1_N pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lm1_output_data:1;     /* LCD_M1 pin output data  0 = LOW 1 = HIGH */
        unsigned int lm1_output_data_mask:1;/* LCD_M1 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ldi_output_data:1;     /* LCD_D22 pin output data  0 = LOW 1 = HIGH */
        unsigned int ldi_output_data_mask:1;/* LCD_D22 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lpp_output_data:1;     /* LCD_D23 pin output data  0 = LOW 1 = HIGH */
        unsigned int lpp_output_data_mask:1;/* LCD_D23 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_data2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_data2_u old_value_t = { .reg32 = value };
    const com_pin_output_data2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lhp0_output_data:1",
              "LCD_D21 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lhp0_output_data, new_value_t.lhp0_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "01: lhp0_output_data_mask:1",
              "LCD_D21 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lhp0_output_data_mask, new_value_t.lhp0_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "02: lhp1_output_data:1",
              "LCD_D18 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lhp1_output_data, new_value_t.lhp1_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "03: lhp1_output_data_mask:1",
              "LCD_D18 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lhp1_output_data_mask, new_value_t.lhp1_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lhp2_output_data:1",
              "LCD_D19 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lhp2_output_data, new_value_t.lhp2_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "05: lhp2_output_data_mask:1",
              "LCD_D19 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lhp2_output_data_mask, new_value_t.lhp2_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "06: undefined_bits_6_7:2", "", 2, old_value_t.undefined_bits_6_7, new_value_t.undefined_bits_6_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: lvp0_output_data:1",
              "LCD_DC1 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lvp0_output_data, new_value_t.lvp0_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "09: lvp0_output_data_mask:1",
              "LCD_DC1 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lvp0_output_data_mask, new_value_t.lvp0_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "10: lvp1_output_data:1",
              "LCD_D20 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lvp1_output_data, new_value_t.lvp1_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "11: lvp1_output_data_mask:1",
              "LCD_D20 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lvp1_output_data_mask, new_value_t.lvp1_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "12: undefined_bits_12_15:4", "", 4, old_value_t.undefined_bits_12_15, new_value_t.undefined_bits_12_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lm0_output_data:1",
              "LCD_CS1_N pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lm0_output_data, new_value_t.lm0_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "17: lm0_output_data_mask:1",
              "LCD_CS1_N pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lm0_output_data_mask, new_value_t.lm0_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "18: lm1_output_data:1",
              "LCD_M1 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lm1_output_data, new_value_t.lm1_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "19: lm1_output_data_mask:1",
              "LCD_M1 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lm1_output_data_mask, new_value_t.lm1_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ldi_output_data:1",
              "LCD_D22 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ldi_output_data, new_value_t.ldi_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "21: ldi_output_data_mask:1",
              "LCD_D22 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ldi_output_data_mask, new_value_t.ldi_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "22: lpp_output_data:1",
              "LCD_D23 pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lpp_output_data, new_value_t.lpp_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "23: lpp_output_data_mask:1",
              "LCD_D23 pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lpp_output_data_mask, new_value_t.lpp_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Data 2";
}

#define COM_PIN_OUTPUT_DATA3_OFFSET 0x30D
#define COM_PIN_OUTPUT_DATA3_UNDEFMASK 0xFFFFF000
union com_pin_output_data3_u {
    struct {
        unsigned int lsck_output_data:1;    /* LSCK pin output data  0 = LOW 1 = HIGH */
        unsigned int lsck_output_data_mask:1;/* LSCK pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lsda_output_data:1;    /* LSDA pin output data  0 = LOW 1 = HIGH */
        unsigned int lsda_output_data_mask:1;/* LSDA pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lcsn_output_data:1;    /* LCSN pin output data  0 = LOW 1 = HIGH */
        unsigned int lcsn_output_data_mask:1;/* LCSN pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ldc_output_data:1;     /* LDC pin output data  0 = LOW 1 = HIGH */
        unsigned int ldc_output_data_mask:1;/* LDC pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lspi_output_data:1;    /* LSPI pin output data  0 = LOW 1 = HIGH */
        unsigned int lspi_output_data_mask:1;/* LSPI pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lsdi_output_data:1;    /* LSDI pin output data  0 = LOW 1 = HIGH */
        unsigned int lsdi_output_data_mask:1;/* LSDI pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_12_31:20;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_data3_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_data3_u old_value_t = { .reg32 = value };
    const com_pin_output_data3_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lsck_output_data:1",
              "LSCK pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lsck_output_data, new_value_t.lsck_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "01: lsck_output_data_mask:1",
              "LSCK pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lsck_output_data_mask, new_value_t.lsck_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "02: lsda_output_data:1",
              "LSDA pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lsda_output_data, new_value_t.lsda_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "03: lsda_output_data_mask:1",
              "LSDA pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lsda_output_data_mask, new_value_t.lsda_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lcsn_output_data:1",
              "LCSN pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lcsn_output_data, new_value_t.lcsn_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "05: lcsn_output_data_mask:1",
              "LCSN pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lcsn_output_data_mask, new_value_t.lcsn_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "06: ldc_output_data:1",
              "LDC pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.ldc_output_data, new_value_t.ldc_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "07: ldc_output_data_mask:1",
              "LDC pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.ldc_output_data_mask, new_value_t.ldc_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "08: lspi_output_data:1",
              "LSPI pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lspi_output_data, new_value_t.lspi_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "09: lspi_output_data_mask:1",
              "LSPI pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lspi_output_data_mask, new_value_t.lspi_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "10: lsdi_output_data:1",
              "LSDI pin output data \n0 = LOW\n1 = HIGH",
              1, old_value_t.lsdi_output_data, new_value_t.lsdi_output_data };
    m_bit_details_model.bits.append(entry);
    entry = { "11: lsdi_output_data_mask:1",
              "LSDI pin output data mask \n0 = MASKED\n1 = NOTMASKED",
              1, old_value_t.lsdi_output_data_mask, new_value_t.lsdi_output_data_mask };
    m_bit_details_model.bits.append(entry);
    entry = { "12: undefined_bits_12_31:20", "", 20, old_value_t.undefined_bits_12_31, new_value_t.undefined_bits_12_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Data 3\nPin Output data registers";
}

#define COM_PIN_INPUT_ENABLE0_OFFSET 0x30E
#define COM_PIN_INPUT_ENABLE0_UNDEFMASK 0xAAAAAAAA
union com_pin_input_enable0_u {
    struct {
        unsigned int ld0_input_enable:1;    /* LD0 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int ld1_input_enable:1;    /* LD1 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_3:1;
        unsigned int ld2_input_enable:1;    /* LD2 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_5:1;
        unsigned int ld3_input_enable:1;    /* LD3 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_7:1;
        unsigned int ld4_input_enable:1;    /* LD4 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int ld5_input_enable:1;    /* LD5 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_11:1;
        unsigned int ld6_input_enable:1;    /* LD6 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_13:1;
        unsigned int ld7_input_enable:1;    /* LD7 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_15:1;
        unsigned int ld8_input_enable:1;    /* LD8 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int ld9_input_enable:1;    /* LD9 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_19:1;
        unsigned int ld10_input_enable:1;   /* LD10 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_21:1;
        unsigned int ld11_input_enable:1;   /* LD11 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_23:1;
        unsigned int ld12_input_enable:1;   /* LD12 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_25:1;
        unsigned int ld13_input_enable:1;   /* LD13 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_27:1;
        unsigned int ld14_input_enable:1;   /* LD14 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_29:1;
        unsigned int ld15_input_enable:1;   /* LD15 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_input_enable0_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_input_enable0_u old_value_t = { .reg32 = value };
    const com_pin_input_enable0_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ld0_input_enable:1",
              "LD0 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld0_input_enable, new_value_t.ld0_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: ld1_input_enable:1",
              "LD1 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld1_input_enable, new_value_t.ld1_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: ld2_input_enable:1",
              "LD2 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld2_input_enable, new_value_t.ld2_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: ld3_input_enable:1",
              "LD3 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld3_input_enable, new_value_t.ld3_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ld4_input_enable:1",
              "LD4 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld4_input_enable, new_value_t.ld4_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bit_9:1", "", 1, old_value_t.undefined_bit_9, new_value_t.undefined_bit_9 };
    m_bit_details_model.bits.append(entry);
    entry = { "10: ld5_input_enable:1",
              "LD5 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld5_input_enable, new_value_t.ld5_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: ld6_input_enable:1",
              "LD6 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld6_input_enable, new_value_t.ld6_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: ld7_input_enable:1",
              "LD7 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld7_input_enable, new_value_t.ld7_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ld8_input_enable:1",
              "LD8 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld8_input_enable, new_value_t.ld8_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: ld9_input_enable:1",
              "LD9 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld9_input_enable, new_value_t.ld9_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ld10_input_enable:1",
              "LD10 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld10_input_enable, new_value_t.ld10_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bit_21:1", "", 1, old_value_t.undefined_bit_21, new_value_t.undefined_bit_21 };
    m_bit_details_model.bits.append(entry);
    entry = { "22: ld11_input_enable:1",
              "LD11 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld11_input_enable, new_value_t.ld11_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: ld12_input_enable:1",
              "LD12 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld12_input_enable, new_value_t.ld12_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bit_25:1", "", 1, old_value_t.undefined_bit_25, new_value_t.undefined_bit_25 };
    m_bit_details_model.bits.append(entry);
    entry = { "26: ld13_input_enable:1",
              "LD13 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld13_input_enable, new_value_t.ld13_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "27: undefined_bit_27:1", "", 1, old_value_t.undefined_bit_27, new_value_t.undefined_bit_27 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: ld14_input_enable:1",
              "LD14 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld14_input_enable, new_value_t.ld14_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: ld15_input_enable:1",
              "LD15 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld15_input_enable, new_value_t.ld15_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Input Enable 0\nPin Input Enable registers";
}

#define COM_PIN_INPUT_ENABLE1_OFFSET 0x30F
#define COM_PIN_INPUT_ENABLE1_UNDEFMASK 0xAAEAFFFA
union com_pin_input_enable1_u {
    struct {
        unsigned int ld16_input_enable:1;   /* LD16 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int ld17_input_enable:1;   /* LD17 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_15:13;
        unsigned int lpw0_input_enable:1;   /* LCD_PWR0 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int lpw1_input_enable:1;   /* LCD_PWR1 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_19:1;
        unsigned int lpw2_input_enable:1;   /* LCD_PWR2 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_21_23:3;
        unsigned int lsc0_input_enable:1;   /* LCD_PCLK pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_25:1;
        unsigned int lsc1_input_enable:1;   /* LCD_WR_N pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_27:1;
        unsigned int lvs_input_enable:1;    /* LCD_VSYNC pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_29:1;
        unsigned int lhs_input_enable:1;    /* LCD_HSYNC pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_input_enable1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_input_enable1_u old_value_t = { .reg32 = value };
    const com_pin_input_enable1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ld16_input_enable:1",
              "LD16 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld16_input_enable, new_value_t.ld16_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: ld17_input_enable:1",
              "LD17 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ld17_input_enable, new_value_t.ld17_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_15:13", "", 13, old_value_t.undefined_bits_3_15, new_value_t.undefined_bits_3_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lpw0_input_enable:1",
              "LCD_PWR0 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lpw0_input_enable, new_value_t.lpw0_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: lpw1_input_enable:1",
              "LCD_PWR1 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lpw1_input_enable, new_value_t.lpw1_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: lpw2_input_enable:1",
              "LCD_PWR2 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lpw2_input_enable, new_value_t.lpw2_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_23:3", "", 3, old_value_t.undefined_bits_21_23, new_value_t.undefined_bits_21_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: lsc0_input_enable:1",
              "LCD_PCLK pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lsc0_input_enable, new_value_t.lsc0_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bit_25:1", "", 1, old_value_t.undefined_bit_25, new_value_t.undefined_bit_25 };
    m_bit_details_model.bits.append(entry);
    entry = { "26: lsc1_input_enable:1",
              "LCD_WR_N pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lsc1_input_enable, new_value_t.lsc1_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "27: undefined_bit_27:1", "", 1, old_value_t.undefined_bit_27, new_value_t.undefined_bit_27 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: lvs_input_enable:1",
              "LCD_VSYNC pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lvs_input_enable, new_value_t.lvs_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: lhs_input_enable:1",
              "LCD_HSYNC pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lhs_input_enable, new_value_t.lhs_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Input Enable 1";
}

#define COM_PIN_INPUT_ENABLE2_OFFSET 0x310
#define COM_PIN_INPUT_ENABLE2_UNDEFMASK 0xFFAAFAEA
union com_pin_input_enable2_u {
    struct {
        unsigned int lhp0_input_enable:1;   /* LCD_D21 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int lhp1_input_enable:1;   /* LCD_D18 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_3:1;
        unsigned int lhp2_input_enable:1;   /* LCD_D19 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_5_7:3;
        unsigned int lvp0_input_enable:1;   /* LCD_DC1 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int lvp1_input_enable:1;   /* LCD_D20 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_11_15:5;
        unsigned int lm0_input_enable:1;    /* LCD_CS1_N pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int lm1_input_enable:1;    /* LCD_M1 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_19:1;
        unsigned int ldi_input_enable:1;    /* LCD_D22 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_21:1;
        unsigned int lpp_input_enable:1;    /* LCD_D23 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_23_31:9;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_input_enable2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_input_enable2_u old_value_t = { .reg32 = value };
    const com_pin_input_enable2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lhp0_input_enable:1",
              "LCD_D21 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lhp0_input_enable, new_value_t.lhp0_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: lhp1_input_enable:1",
              "LCD_D18 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lhp1_input_enable, new_value_t.lhp1_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lhp2_input_enable:1",
              "LCD_D19 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lhp2_input_enable, new_value_t.lhp2_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: lvp0_input_enable:1",
              "LCD_DC1 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lvp0_input_enable, new_value_t.lvp0_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bit_9:1", "", 1, old_value_t.undefined_bit_9, new_value_t.undefined_bit_9 };
    m_bit_details_model.bits.append(entry);
    entry = { "10: lvp1_input_enable:1",
              "LCD_D20 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lvp1_input_enable, new_value_t.lvp1_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_15:5", "", 5, old_value_t.undefined_bits_11_15, new_value_t.undefined_bits_11_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lm0_input_enable:1",
              "LCD_CS1_N pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lm0_input_enable, new_value_t.lm0_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: lm1_input_enable:1",
              "LCD_M1 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lm1_input_enable, new_value_t.lm1_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ldi_input_enable:1",
              "LCD_D22 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ldi_input_enable, new_value_t.ldi_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bit_21:1", "", 1, old_value_t.undefined_bit_21, new_value_t.undefined_bit_21 };
    m_bit_details_model.bits.append(entry);
    entry = { "22: lpp_input_enable:1",
              "LCD_D23 pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lpp_input_enable, new_value_t.lpp_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bits_23_31:9", "", 9, old_value_t.undefined_bits_23_31, new_value_t.undefined_bits_23_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Input Enable 2";
}

#define COM_PIN_INPUT_ENABLE3_OFFSET 0x311
#define COM_PIN_INPUT_ENABLE3_UNDEFMASK 0xFFFFFAAA
union com_pin_input_enable3_u {
    struct {
        unsigned int lsck_input_enable:1;   /* LSCK pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int lsda_input_enable:1;   /* LSDA pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_3:1;
        unsigned int lcsn_input_enable:1;   /* LCSN pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_5:1;
        unsigned int ldc_input_enable:1;    /* LDC pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_7:1;
        unsigned int lspi_input_enable:1;   /* LSPI pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int lsdi_input_enable:1;   /* LSDI pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_11_31:21;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_input_enable3_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_input_enable3_u old_value_t = { .reg32 = value };
    const com_pin_input_enable3_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lsck_input_enable:1",
              "LSCK pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lsck_input_enable, new_value_t.lsck_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: lsda_input_enable:1",
              "LSDA pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lsda_input_enable, new_value_t.lsda_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lcsn_input_enable:1",
              "LCSN pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lcsn_input_enable, new_value_t.lcsn_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: ldc_input_enable:1",
              "LDC pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.ldc_input_enable, new_value_t.ldc_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: lspi_input_enable:1",
              "LSPI pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lspi_input_enable, new_value_t.lspi_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bit_9:1", "", 1, old_value_t.undefined_bit_9, new_value_t.undefined_bit_9 };
    m_bit_details_model.bits.append(entry);
    entry = { "10: lsdi_input_enable:1",
              "LSDI pin input enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.lsdi_input_enable, new_value_t.lsdi_input_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_31:21", "", 21, old_value_t.undefined_bits_11_31, new_value_t.undefined_bits_11_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Input Enable 3";
}

#define COM_PIN_INPUT_DATA0_OFFSET 0x312
#define COM_PIN_INPUT_DATA0_UNDEFMASK 0xFFFC0000
union com_pin_input_data0_u {
    struct {
        unsigned int ld0_input_data:1;      /* LD0 pin input data */
        unsigned int ld1_input_data:1;      /* LD1 pin input data */
        unsigned int ld2_input_data:1;      /* LD2 pin input data */
        unsigned int ld3_input_data:1;      /* LD3 pin input data */
        unsigned int ld4_input_data:1;      /* LD4 pin input data */
        unsigned int ld5_input_data:1;      /* LD5 pin input data */
        unsigned int ld6_input_data:1;      /* LD6 pin input data */
        unsigned int ld7_input_data:1;      /* LD7 pin input data */
        unsigned int ld8_input_data:1;      /* LD8 pin input data */
        unsigned int ld9_input_data:1;      /* LD9 pin input data */
        unsigned int ld10_input_data:1;     /* LD10 pin input data */
        unsigned int ld11_input_data:1;     /* LD11 pin input data */
        unsigned int ld12_input_data:1;     /* LD12 pin input data */
        unsigned int ld13_input_data:1;     /* LD13 pin input data */
        unsigned int ld14_input_data:1;     /* LD14 pin input data */
        unsigned int ld15_input_data:1;     /* LD15 pin input data */
        unsigned int ld16_input_data:1;     /* LD16 pin input data */
        unsigned int ld17_input_data:1;     /* LD17 pin input data */
        unsigned int undefined_bits_18_31:14;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_input_data0_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_input_data0_u old_value_t = { .reg32 = value };
    const com_pin_input_data0_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ld0_input_data:1",
              "LD0 pin input data",
              1, old_value_t.ld0_input_data, new_value_t.ld0_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "01: ld1_input_data:1",
              "LD1 pin input data",
              1, old_value_t.ld1_input_data, new_value_t.ld1_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "02: ld2_input_data:1",
              "LD2 pin input data",
              1, old_value_t.ld2_input_data, new_value_t.ld2_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "03: ld3_input_data:1",
              "LD3 pin input data",
              1, old_value_t.ld3_input_data, new_value_t.ld3_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "04: ld4_input_data:1",
              "LD4 pin input data",
              1, old_value_t.ld4_input_data, new_value_t.ld4_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "05: ld5_input_data:1",
              "LD5 pin input data",
              1, old_value_t.ld5_input_data, new_value_t.ld5_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "06: ld6_input_data:1",
              "LD6 pin input data",
              1, old_value_t.ld6_input_data, new_value_t.ld6_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "07: ld7_input_data:1",
              "LD7 pin input data",
              1, old_value_t.ld7_input_data, new_value_t.ld7_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ld8_input_data:1",
              "LD8 pin input data",
              1, old_value_t.ld8_input_data, new_value_t.ld8_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "09: ld9_input_data:1",
              "LD9 pin input data",
              1, old_value_t.ld9_input_data, new_value_t.ld9_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "10: ld10_input_data:1",
              "LD10 pin input data",
              1, old_value_t.ld10_input_data, new_value_t.ld10_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "11: ld11_input_data:1",
              "LD11 pin input data",
              1, old_value_t.ld11_input_data, new_value_t.ld11_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "12: ld12_input_data:1",
              "LD12 pin input data",
              1, old_value_t.ld12_input_data, new_value_t.ld12_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "13: ld13_input_data:1",
              "LD13 pin input data",
              1, old_value_t.ld13_input_data, new_value_t.ld13_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "14: ld14_input_data:1",
              "LD14 pin input data",
              1, old_value_t.ld14_input_data, new_value_t.ld14_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "15: ld15_input_data:1",
              "LD15 pin input data",
              1, old_value_t.ld15_input_data, new_value_t.ld15_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ld16_input_data:1",
              "LD16 pin input data",
              1, old_value_t.ld16_input_data, new_value_t.ld16_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "17: ld17_input_data:1",
              "LD17 pin input data",
              1, old_value_t.ld17_input_data, new_value_t.ld17_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "18: undefined_bits_18_31:14", "", 14, old_value_t.undefined_bits_18_31, new_value_t.undefined_bits_18_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Input Data 0\nPin Input Data registers (read-only)";
}

#define COM_PIN_INPUT_DATA1_OFFSET 0x313
#define COM_PIN_INPUT_DATA1_UNDEFMASK 0xFC00C808
union com_pin_input_data1_u {
    struct {
        unsigned int lpw0_input_data:1;     /* LPW0 pin input data */
        unsigned int lpw1_input_data:1;     /* LPW1 pin input data */
        unsigned int lpw2_input_data:1;     /* LPW2 pin input data */
        unsigned int undefined_bit_3:1;
        unsigned int lsc0_input_data:1;     /* LSC0 pin input data */
        unsigned int lsc1_input_data:1;     /* LSC1 pin input data */
        unsigned int lvs_input_data:1;      /* LVS pin input data */
        unsigned int lhs_input_data:1;      /* LHS pin input data */
        unsigned int lhp0_input_data:1;     /* LHP0 pin input data */
        unsigned int lhp1_input_data:1;     /* LHP1 pin input data */
        unsigned int lhp2_input_data:1;     /* LHP2 pin input data */
        unsigned int undefined_bit_11:1;
        unsigned int lvp0_input_data:1;     /* LVP0 pin input data */
        unsigned int lvp1_input_data:1;     /* LVP1 pin input data */
        unsigned int undefined_bits_14_15:2;
        unsigned int lm0_input_data:1;      /* LM0 pin input data */
        unsigned int lm1_input_data:1;      /* LM1 pin input data */
        unsigned int ldi_input_data:1;      /* LDI pin input data */
        unsigned int lpp_input_data:1;      /* LPP pin input data */
        unsigned int lsck_input_data:1;     /* LSCK pin input data */
        unsigned int lsda_input_data:1;     /* LSDA pin input data */
        unsigned int lcsn_input_data:1;     /* LCSN pin input data */
        unsigned int ldc_input_data:1;      /* LDC pin input data */
        unsigned int lspi_input_data:1;     /* LSPI pin input data */
        unsigned int lsdi_input_data:1;     /* LSDI pin input data */
        unsigned int undefined_bits_26_31:6;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_input_data1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_input_data1_u old_value_t = { .reg32 = value };
    const com_pin_input_data1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lpw0_input_data:1",
              "LPW0 pin input data",
              1, old_value_t.lpw0_input_data, new_value_t.lpw0_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "01: lpw1_input_data:1",
              "LPW1 pin input data",
              1, old_value_t.lpw1_input_data, new_value_t.lpw1_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "02: lpw2_input_data:1",
              "LPW2 pin input data",
              1, old_value_t.lpw2_input_data, new_value_t.lpw2_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lsc0_input_data:1",
              "LSC0 pin input data",
              1, old_value_t.lsc0_input_data, new_value_t.lsc0_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "05: lsc1_input_data:1",
              "LSC1 pin input data",
              1, old_value_t.lsc1_input_data, new_value_t.lsc1_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "06: lvs_input_data:1",
              "LVS pin input data",
              1, old_value_t.lvs_input_data, new_value_t.lvs_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "07: lhs_input_data:1",
              "LHS pin input data",
              1, old_value_t.lhs_input_data, new_value_t.lhs_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "08: lhp0_input_data:1",
              "LHP0 pin input data",
              1, old_value_t.lhp0_input_data, new_value_t.lhp0_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "09: lhp1_input_data:1",
              "LHP1 pin input data",
              1, old_value_t.lhp1_input_data, new_value_t.lhp1_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "10: lhp2_input_data:1",
              "LHP2 pin input data",
              1, old_value_t.lhp2_input_data, new_value_t.lhp2_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: lvp0_input_data:1",
              "LVP0 pin input data",
              1, old_value_t.lvp0_input_data, new_value_t.lvp0_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "13: lvp1_input_data:1",
              "LVP1 pin input data",
              1, old_value_t.lvp1_input_data, new_value_t.lvp1_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "14: undefined_bits_14_15:2", "", 2, old_value_t.undefined_bits_14_15, new_value_t.undefined_bits_14_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lm0_input_data:1",
              "LM0 pin input data",
              1, old_value_t.lm0_input_data, new_value_t.lm0_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "17: lm1_input_data:1",
              "LM1 pin input data",
              1, old_value_t.lm1_input_data, new_value_t.lm1_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "18: ldi_input_data:1",
              "LDI pin input data",
              1, old_value_t.ldi_input_data, new_value_t.ldi_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "19: lpp_input_data:1",
              "LPP pin input data",
              1, old_value_t.lpp_input_data, new_value_t.lpp_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "20: lsck_input_data:1",
              "LSCK pin input data",
              1, old_value_t.lsck_input_data, new_value_t.lsck_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "21: lsda_input_data:1",
              "LSDA pin input data",
              1, old_value_t.lsda_input_data, new_value_t.lsda_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "22: lcsn_input_data:1",
              "LCSN pin input data",
              1, old_value_t.lcsn_input_data, new_value_t.lcsn_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "23: ldc_input_data:1",
              "LDC pin input data",
              1, old_value_t.ldc_input_data, new_value_t.ldc_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "24: lspi_input_data:1",
              "LSPI pin input data",
              1, old_value_t.lspi_input_data, new_value_t.lspi_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "25: lsdi_input_data:1",
              "LSDI pin input data",
              1, old_value_t.lsdi_input_data, new_value_t.lsdi_input_data };
    m_bit_details_model.bits.append(entry);
    entry = { "26: undefined_bits_26_31:6", "", 6, old_value_t.undefined_bits_26_31, new_value_t.undefined_bits_26_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Input Data 1";
}

#define COM_PIN_OUTPUT_SELECT0_OFFSET 0x314
#define COM_PIN_OUTPUT_SELECT0_UNDEFMASK 0x88888888
union com_pin_output_select0_u {
    struct {
        unsigned int ld0_output_select:3;   /* LD0 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int ld1_output_select:3;   /* LD1 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int ld2_output_select:3;   /* LD2 pin output select */
        unsigned int undefined_bit_11:1;
        unsigned int ld3_output_select:3;   /* LD3 pin output select */
        unsigned int undefined_bit_15:1;
        unsigned int ld4_output_select:3;   /* LD4 pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int ld5_output_select:3;   /* LD5 pin output select */
        unsigned int undefined_bit_23:1;
        unsigned int ld6_output_select:3;   /* LD6 pin output select */
        unsigned int undefined_bit_27:1;
        unsigned int ld7_output_select:3;   /* LD7 pin output select */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_select0_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_select0_u old_value_t = { .reg32 = value };
    const com_pin_output_select0_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ld0_output_select:3",
              "LD0 pin output select",
              3, old_value_t.ld0_output_select, new_value_t.ld0_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: ld1_output_select:3",
              "LD1 pin output select",
              3, old_value_t.ld1_output_select, new_value_t.ld1_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ld2_output_select:3",
              "LD2 pin output select",
              3, old_value_t.ld2_output_select, new_value_t.ld2_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: ld3_output_select:3",
              "LD3 pin output select",
              3, old_value_t.ld3_output_select, new_value_t.ld3_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ld4_output_select:3",
              "LD4 pin output select",
              3, old_value_t.ld4_output_select, new_value_t.ld4_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ld5_output_select:3",
              "LD5 pin output select",
              3, old_value_t.ld5_output_select, new_value_t.ld5_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: ld6_output_select:3",
              "LD6 pin output select",
              3, old_value_t.ld6_output_select, new_value_t.ld6_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "27: undefined_bit_27:1", "", 1, old_value_t.undefined_bit_27, new_value_t.undefined_bit_27 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: ld7_output_select:3",
              "LD7 pin output select",
              3, old_value_t.ld7_output_select, new_value_t.ld7_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "3 bits are used to select output on each pin and they are defined as follows:\nPad Name\n Pin Output Select\n0\nOutput Signal\n 1\nOutput Signal\n 2\nOutput Signal\n 3\nOutput Signal\n 4\nOutput Signal\n 5\nOutput Signal\n 6\nOutput Signal\n 7\nOutput Signal\nLD17\n LD17\n LD17 Out\n LPD17\n 0\n 0\n 0\n 0\n 0\nLD16\n LD16\n LD16 Out\n LPD16\n 0\n 0\n 0\n 0\n 0\nLD15\n LD15\n LD15 Out\n LPD15\n 0\n 0\n 0\n 0\n 0\nLD14\n LD14\n LD14 Out\n LPD14\n 0\n 0\n 0\n 0\n 0\nLD13\n LD13\n LD13 Out\n LPD13\n 0\n 0\n 0\n 0\n 0\nLD12\n LD12\n LD12 Out\n LPD12\n 0\n 0\n 0\n 0\n 0\nLD11\n LD11\n LD11 Out\n LPD11\n 0\n 0\n 0\n 0\n 0\nLD10\n LD10\n LD10 Out\n LPD10\n 0\n SD2\n 0\n 0\n 0\nLD9\n LD9\n LD9 Out\n LPD9\n 0\n SD2_\n 0\n 0\n 0\nLD8\n LD8\n LD8 Out\n LPD8\n 0\n STP\n 0\n 0\n 0\nLD7\n LD7\n LD7 Out\n LPD7\n 0\n SDT\n 0\n 0\n 0\nLD6\n LD6\n LD6 Out\n LPD6\n 0\n STH\n 0\n 0\n 0\nLD5\n LD5\n LD5 Out\n LPD5\n 0\n SD1\n 0\n 0\n 0\nLD4\n LD4\n LD4 Out\n LPD4\n 0\n SD1_\n 0\n 0\n 0\nLD3\n LD3\n LD3 Out\n LPD3\n 0\n SD0\n 0\n 0\n 0\nLD2\n LD2\n LD2 Out\n LPD2\n 0\n SD0_\n 0\n 0\n 0\nLD1\n LD1\n LD1 Out\n LPD1\n 0\n SC\n 0\n 0\n 0\nLD0\n LD0\n LD0 Out\n LPD0\n 0\n SC_\n 0\n 0\n 0\nLPW0\n PW0\n LPW0 Out\n PW1\n PM0\n PW2\n MD0\n LPD4\n LSDA\nLPW1\n PW1\n LPW1 Out\n PW2\n PM1\n PW3\n MD1\n LPD8\n PW4\nLPW2\n PW2\n LPW2 Out\n PW3\n PM0\n PW4\n MD2\n LPD5\n PW1\nPad Name\n Pin Output Select\n0\nOutput Signal\n 1\nOutput Signal\n 2\nOutput Signal\n 3\nOutput Signal\n 4\nOutput Signal\n 5\nOutput Signal\n 6\nOutput Signal\n 7\nOutput Signal\nLSC0\n SC0\n LSC0 Out\n 0\n 0\n 0\n 0\n 0\n 0\nLSC1\n SC1\n LSC1 Out\n DE\n 0\n 0\n 0\n 0\n LSCK\nLVS\n Vsync\n LVS Out\n 0\n PM1\n 0\n MD3\n 0\n 0\nLHS\n Hsync\n LHS Out\n 0\n PM0\n 0\n MD2\n 0\n 0\nLHP0\n H Pulse 0\n LHP0 Out\n LD21\n PM0\n 0\n MD0\n LPD7\n 0\nLHP1\n H Pulse 1\n LHP1 Out\n LD18\n PM1\n 0\n MD1\n LPD0\n 0\nLHP2\n H Pulse 2\n LHP2 Out\n LD19\n PM0\n V Pulse 2\n MD2\n Hsync\n 0\nLVP0\n V Pulse 0\n LVP0 Out\n 0\n PM0\n 0\n MD3\n V Pulse1\n LDC\nLVP1\n V Pulse 1\n LVP1 Out\n LD20\n PM1\n PW4\n MD3\n LPD6\n 0\nLM0\n M0\n LM0 Out\n H Pulse 0\n PM0\n V Pulse 2\n MD0\n DE\n SCS_\nLM1\n M1\n LM1 Out\n LD21\n PM1\n V Pulse 3\n MD1\n LPD1\n 0\nLDI\n DI\n LDI Out\n LD22\n PM0\n SCS_\n MD2\n LPD2\n 0\nLPP\n PP\n LPP Out\n LD23\n PM1\n V Pulse 3\n MD3\n LPD3\n 0\nLSCK\n SCK\n LSCK Out\n 0\n PM0\n 0\n MD0\n LPD3\n 0\nLSDA\n SDA\n LSDA Out\n SCS_\n PM1\n 0\n MD1\n LPD4\n 0\nLCS_\n SCS_\n LCS_ Out\n LD22\n PM0\n DE\n MD2\n LPD5\n 0\nLDC\n SDC\n LDC Out\n Vsync\n PM1\n V Pulse 1\n MD3\n LPD6\n 0\nLSPI\n SPI busy\n LSPI Out\n DE\n PM0\n DC Clk\n MD0\n 0\n 0\nLSDI\n SDI\n LSDI Out\n 0\n PM1\n 0\n MD1\n 0\n 0\nNotes:\n 1. LD[23-0]  contain pixel data for 1-pixel/1-clock parallel interface\n2. LPD[17-0] contain pixel data for non 1-pixel/1-clock parallel interface\n3. If output select is set to 1, then corresponding Pin Output Data register value is output (pin is used as general purpose output).\n4. If output select is set to 1 AND display is in 2p1c18 (aka notebook) mode, then all outputs are overloaded. NB this doesn't apply to lsc1 which must be programmed to output-select==0 to get the clock signal.\n5. For dual display, each display has its own instance of the above pad macro. Set up each display according to the panel interface and insure that pins are used by only one display.\nA set of registers outside of display, PIN_MUX_CTL_**, control which one out of 4 inputs, including display and displayb, go to the pads.\nPin Output Select 0";
}

#define COM_PIN_OUTPUT_SELECT1_OFFSET 0x315
#define COM_PIN_OUTPUT_SELECT1_UNDEFMASK 0x88888888
union com_pin_output_select1_u {
    struct {
        unsigned int ld8_output_select:3;   /* LD8 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int ld9_output_select:3;   /* LD9 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int ld10_output_select:3;  /* LD10 pin output select */
        unsigned int undefined_bit_11:1;
        unsigned int ld11_output_select:3;  /* LD11 pin output select */
        unsigned int undefined_bit_15:1;
        unsigned int ld12_output_select:3;  /* LD12 pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int ld13_output_select:3;  /* LD13 pin output select */
        unsigned int undefined_bit_23:1;
        unsigned int ld14_output_select:3;  /* LD14 pin output select */
        unsigned int undefined_bit_27:1;
        unsigned int ld15_output_select:3;  /* LD15 pin output select */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_select1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_select1_u old_value_t = { .reg32 = value };
    const com_pin_output_select1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ld8_output_select:3",
              "LD8 pin output select",
              3, old_value_t.ld8_output_select, new_value_t.ld8_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: ld9_output_select:3",
              "LD9 pin output select",
              3, old_value_t.ld9_output_select, new_value_t.ld9_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ld10_output_select:3",
              "LD10 pin output select",
              3, old_value_t.ld10_output_select, new_value_t.ld10_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: ld11_output_select:3",
              "LD11 pin output select",
              3, old_value_t.ld11_output_select, new_value_t.ld11_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ld12_output_select:3",
              "LD12 pin output select",
              3, old_value_t.ld12_output_select, new_value_t.ld12_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ld13_output_select:3",
              "LD13 pin output select",
              3, old_value_t.ld13_output_select, new_value_t.ld13_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: ld14_output_select:3",
              "LD14 pin output select",
              3, old_value_t.ld14_output_select, new_value_t.ld14_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "27: undefined_bit_27:1", "", 1, old_value_t.undefined_bit_27, new_value_t.undefined_bit_27 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: ld15_output_select:3",
              "LD15 pin output select",
              3, old_value_t.ld15_output_select, new_value_t.ld15_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Select 1";
}

#define COM_PIN_OUTPUT_SELECT2_OFFSET 0x316
#define COM_PIN_OUTPUT_SELECT2_UNDEFMASK 0xFFFFFF88
union com_pin_output_select2_u {
    struct {
        unsigned int ld16_output_select:3;  /* LD16 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int ld17_output_select:3;  /* LD17 pin output select */
        unsigned int undefined_bits_7_31:25;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_select2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_select2_u old_value_t = { .reg32 = value };
    const com_pin_output_select2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ld16_output_select:3",
              "LD16 pin output select",
              3, old_value_t.ld16_output_select, new_value_t.ld16_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: ld17_output_select:3",
              "LD17 pin output select",
              3, old_value_t.ld17_output_select, new_value_t.ld17_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bits_7_31:25", "", 25, old_value_t.undefined_bits_7_31, new_value_t.undefined_bits_7_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Select 2";
}

#define COM_PIN_OUTPUT_SELECT3_OFFSET 0x317
#define COM_PIN_OUTPUT_SELECT3_UNDEFMASK 0x8888F888
union com_pin_output_select3_u {
    struct {
        unsigned int lpw0_output_select:3;  /* LCD_PWR0 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int lpw1_output_select:3;  /* LCD_PWR1 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int lpw2_output_select:3;  /* LCD_PWR2 pin output select */
        unsigned int undefined_bits_11_15:5;
        unsigned int lsc0_output_select:3;  /* LCD_PCLK pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int lsc1_output_select:3;  /* LCD_WR_N pin output select */
        unsigned int undefined_bit_23:1;
        unsigned int lvs_output_select:3;   /* LCD_VSYNC pin output select */
        unsigned int undefined_bit_27:1;
        unsigned int lhs_output_select:3;   /* LCD_HSYNC pin output select */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_select3_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_select3_u old_value_t = { .reg32 = value };
    const com_pin_output_select3_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lpw0_output_select:3",
              "LCD_PWR0 pin output select",
              3, old_value_t.lpw0_output_select, new_value_t.lpw0_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lpw1_output_select:3",
              "LCD_PWR1 pin output select",
              3, old_value_t.lpw1_output_select, new_value_t.lpw1_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: lpw2_output_select:3",
              "LCD_PWR2 pin output select",
              3, old_value_t.lpw2_output_select, new_value_t.lpw2_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_15:5", "", 5, old_value_t.undefined_bits_11_15, new_value_t.undefined_bits_11_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lsc0_output_select:3",
              "LCD_PCLK pin output select",
              3, old_value_t.lsc0_output_select, new_value_t.lsc0_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: lsc1_output_select:3",
              "LCD_WR_N pin output select",
              3, old_value_t.lsc1_output_select, new_value_t.lsc1_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: lvs_output_select:3",
              "LCD_VSYNC pin output select",
              3, old_value_t.lvs_output_select, new_value_t.lvs_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "27: undefined_bit_27:1", "", 1, old_value_t.undefined_bit_27, new_value_t.undefined_bit_27 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: lhs_output_select:3",
              "LCD_HSYNC pin output select",
              3, old_value_t.lhs_output_select, new_value_t.lhs_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Select 3";
}

#define COM_PIN_OUTPUT_SELECT4_OFFSET 0x318
#define COM_PIN_OUTPUT_SELECT4_UNDEFMASK 0xFF88F888
union com_pin_output_select4_u {
    struct {
        unsigned int lhp0_output_select:3;  /* LCD_D21 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int lhp1_output_select:3;  /* LCD_D18 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int lhp2_output_select:3;  /* LCD_D19 pin output select */
        unsigned int undefined_bits_11_15:5;
        unsigned int lvp0_output_select:3;  /* LCD_DC1 pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int lvp1_output_select:3;  /* LCD_D20 pin output select */
        unsigned int undefined_bits_23_31:9;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_select4_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_select4_u old_value_t = { .reg32 = value };
    const com_pin_output_select4_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lhp0_output_select:3",
              "LCD_D21 pin output select",
              3, old_value_t.lhp0_output_select, new_value_t.lhp0_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lhp1_output_select:3",
              "LCD_D18 pin output select",
              3, old_value_t.lhp1_output_select, new_value_t.lhp1_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: lhp2_output_select:3",
              "LCD_D19 pin output select",
              3, old_value_t.lhp2_output_select, new_value_t.lhp2_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_15:5", "", 5, old_value_t.undefined_bits_11_15, new_value_t.undefined_bits_11_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lvp0_output_select:3",
              "LCD_DC1 pin output select",
              3, old_value_t.lvp0_output_select, new_value_t.lvp0_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: lvp1_output_select:3",
              "LCD_D20 pin output select",
              3, old_value_t.lvp1_output_select, new_value_t.lvp1_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bits_23_31:9", "", 9, old_value_t.undefined_bits_23_31, new_value_t.undefined_bits_23_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Select 4";
}

#define COM_PIN_OUTPUT_SELECT5_OFFSET 0x319
#define COM_PIN_OUTPUT_SELECT5_UNDEFMASK 0xFFFF8888
union com_pin_output_select5_u {
    struct {
        unsigned int lm0_output_select:3;   /* LCD_CS1_N pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int lm1_output_select:3;   /* LCD_M1 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int ldi_output_select:3;   /* LCD_D22 pin output select */
        unsigned int undefined_bit_11:1;
        unsigned int lpp_output_select:3;   /* LCD_D23 pin output select */
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_select5_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_select5_u old_value_t = { .reg32 = value };
    const com_pin_output_select5_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lm0_output_select:3",
              "LCD_CS1_N pin output select",
              3, old_value_t.lm0_output_select, new_value_t.lm0_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lm1_output_select:3",
              "LCD_M1 pin output select",
              3, old_value_t.lm1_output_select, new_value_t.lm1_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ldi_output_select:3",
              "LCD_D22 pin output select",
              3, old_value_t.ldi_output_select, new_value_t.ldi_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: lpp_output_select:3",
              "LCD_D23 pin output select",
              3, old_value_t.lpp_output_select, new_value_t.lpp_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Select 5";
}

#define COM_PIN_OUTPUT_SELECT6_OFFSET 0x31A
#define COM_PIN_OUTPUT_SELECT6_UNDEFMASK 0xFF888888
union com_pin_output_select6_u {
    struct {
        unsigned int lsck_output_select:3;  /* LSCK pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int lsda_output_select:3;  /* LSDA pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int lcsn_output_select:3;  /* LCSN pin output select */
        unsigned int undefined_bit_11:1;
        unsigned int ldc_output_select:3;   /* LDC pin output select */
        unsigned int undefined_bit_15:1;
        unsigned int lspi_output_select:3;  /* LSPI pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int lsdi_output_select:3;  /* LSDI pin output select */
        unsigned int undefined_bits_23_31:9;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_output_select6_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_output_select6_u old_value_t = { .reg32 = value };
    const com_pin_output_select6_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lsck_output_select:3",
              "LSCK pin output select",
              3, old_value_t.lsck_output_select, new_value_t.lsck_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lsda_output_select:3",
              "LSDA pin output select",
              3, old_value_t.lsda_output_select, new_value_t.lsda_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: lcsn_output_select:3",
              "LCSN pin output select",
              3, old_value_t.lcsn_output_select, new_value_t.lcsn_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: ldc_output_select:3",
              "LDC pin output select",
              3, old_value_t.ldc_output_select, new_value_t.ldc_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lspi_output_select:3",
              "LSPI pin output select",
              3, old_value_t.lspi_output_select, new_value_t.lspi_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: lsdi_output_select:3",
              "LSDI pin output select",
              3, old_value_t.lsdi_output_select, new_value_t.lsdi_output_select };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bits_23_31:9", "", 9, old_value_t.undefined_bits_23_31, new_value_t.undefined_bits_23_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Output Select 6";
}

#define COM_PIN_MISC_CONTROL_OFFSET 0x31B
#define COM_PIN_MISC_CONTROL_UNDEFMASK 0xFFFFFFFB
union com_pin_misc_control_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int disp_clock_output:1;   /* Display Clock (DCLK) Enable 0= disable 1= enable display clock to be output on LCD_DE pin (LCD_DE output select must be appropriately programmed for this to be effective) 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_31:29;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pin_misc_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pin_misc_control_u old_value_t = { .reg32 = value };
    const com_pin_misc_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_1:2", "", 2, old_value_t.undefined_bits_0_1, new_value_t.undefined_bits_0_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: disp_clock_output:1",
              "Display Clock (DCLK) Enable\n0= disable\n1= enable display clock to be output on LCD_DE pin (LCD_DE output select must be appropriately programmed for this to be effective)\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.disp_clock_output, new_value_t.disp_clock_output };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_31:29", "", 29, old_value_t.undefined_bits_3_31, new_value_t.undefined_bits_3_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Pin Miscellaneous Control\nPin Miscellaneous Control";
}

#define COM_PM0_CONTROL_OFFSET 0x31C
#define COM_PM0_CONTROL_UNDEFMASK 0xFF03FC0C
union com_pm0_control_u {
    struct {
        unsigned int pm0_clock_select:2;    /* PM0 Clock Select 0= output of shift clock divider 1= pixel clock 2= line clock 3= frame clock Notes: 1) Pixel clock, line clock, and frame clock is running only when PW0 signal is enabled. 2) In non-continuous mode, shift clock and pixel clock run continuously, but line clock and frame clock only run while a frame is being sent */
        unsigned int undefined_bits_2_3:2;
        unsigned int pm0_clock_divider:6;   /* PM0 Clock Divider (1 to 64) */
        unsigned int undefined_bits_10_17:8;
        unsigned int pm0_period:6;          /* PM0 Period (4, 8, ... , 256 clock cycles) */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pm0_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pm0_control_u old_value_t = { .reg32 = value };
    const com_pm0_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pm0_clock_select:2",
              "PM0 Clock Select\n0= output of shift clock divider\n1= pixel clock\n2= line clock\n3= frame clock Notes: 1) Pixel clock, line clock, and frame clock is running only when PW0 signal is enabled. 2) In non-continuous mode, shift clock and pixel clock run continuously, but line clock and frame clock only run while a frame is being sent",
              2, old_value_t.pm0_clock_select, new_value_t.pm0_clock_select };
    m_bit_details_model.bits.append(entry);
    entry = { "02: undefined_bits_2_3:2", "", 2, old_value_t.undefined_bits_2_3, new_value_t.undefined_bits_2_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: pm0_clock_divider:6",
              "PM0 Clock Divider (1 to 64)",
              6, old_value_t.pm0_clock_divider, new_value_t.pm0_clock_divider };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_17:8", "", 8, old_value_t.undefined_bits_10_17, new_value_t.undefined_bits_10_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: pm0_period:6",
              "PM0 Period (4, 8, ... , 256 clock cycles)",
              6, old_value_t.pm0_period, new_value_t.pm0_period };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "PM0 signal Control\nClass: Pulse Width Modulation\nPM0 signal is programmable pulse width modulation signal that can be output on several pins. The control register should be initialized once before PM0 is enabled.\nNote:\n The period is expressed as multiples of 4 times the divider value.\nThe actual period - in clock cycles - is given by:\nperiod = (1 + PM0_CLOCK_DIVIDER) * ((PM0_PERIOD + 1) * 4)";
}

#define COM_PM0_DUTY_CYCLE_OFFSET 0x31D
#define COM_PM0_DUTY_CYCLE_UNDEFMASK 0xFFFFFE00
union com_pm0_duty_cycle_u {
    struct {
        unsigned int pm0_duty_cycle:9;      /* PM0 Duty Cycle (or D) From 1/P to D/P pulse high time where P is the period. This must not be larger than the period */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pm0_duty_cycle_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pm0_duty_cycle_u old_value_t = { .reg32 = value };
    const com_pm0_duty_cycle_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pm0_duty_cycle:9",
              "PM0 Duty Cycle (or D) From 1/P to D/P pulse high time where P is the period. This must not be larger than the period",
              9, old_value_t.pm0_duty_cycle, new_value_t.pm0_duty_cycle };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "PM0 Duty Cycle\nA counter repeatedly counts up from 0 to ((PM0_PERIOD << 2) + 3) pre-scaled cycles.\nThe period always starts with the output value == 1. After DUTY_CYCLE number of pre-scaled cycles, the output value is cleared for the remainder of the period. In order to output constant 0, simply set the DUTY_CYCLE to 0. To output a constant 1, set DUTY_CYCLE to be any value greater than ((PM0_PERIOD << 2) + 3).";
}

#define COM_PM1_CONTROL_OFFSET 0x31E
#define COM_PM1_CONTROL_UNDEFMASK 0xFF03FC0C
union com_pm1_control_u {
    struct {
        unsigned int pm1_clock_select:2;    /* PM1 Clock Select 0= output of shift clock divider 1= pixel clock 2= line clock 3= frame clock Notes: 1) Pixel clock, line clock, and frame clock is running only when PW0 signal is enabled. 2) In non-continuous mode, shift clock and pixel clock run continuously, but line clock and frame clock only run while a frame is being sent */
        unsigned int undefined_bits_2_3:2;
        unsigned int pm1_clock_divider:6;   /* PM1 Clock Divider (1 to 64) */
        unsigned int undefined_bits_10_17:8;
        unsigned int pm1_period:6;          /* PM1 Period (4, 8, ... , 256 clock cycles) */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pm1_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pm1_control_u old_value_t = { .reg32 = value };
    const com_pm1_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pm1_clock_select:2",
              "PM1 Clock Select\n0= output of shift clock divider\n1= pixel clock\n2= line clock\n3= frame clock Notes: 1) Pixel clock, line clock, and frame clock is running only when PW0 signal is enabled. 2) In non-continuous mode, shift clock and pixel clock run continuously, but line clock and frame clock only run while a frame is being sent",
              2, old_value_t.pm1_clock_select, new_value_t.pm1_clock_select };
    m_bit_details_model.bits.append(entry);
    entry = { "02: undefined_bits_2_3:2", "", 2, old_value_t.undefined_bits_2_3, new_value_t.undefined_bits_2_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: pm1_clock_divider:6",
              "PM1 Clock Divider (1 to 64)",
              6, old_value_t.pm1_clock_divider, new_value_t.pm1_clock_divider };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_17:8", "", 8, old_value_t.undefined_bits_10_17, new_value_t.undefined_bits_10_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: pm1_period:6",
              "PM1 Period (4, 8, ... , 256 clock cycles)",
              6, old_value_t.pm1_period, new_value_t.pm1_period };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "PM1 signal Control\nPM1 signal is programmable pulse width modulation signal that can be output on several pins.\nThe control register should be initialized once before PM1 is enabled.\nThe actual period (in clock cycles) is given by:\nPERIOD = (1 + PM1_CLOCK_DIVIDER) * ((PM1_PERIOD + 1) * 4)";
}

#define COM_PM1_DUTY_CYCLE_OFFSET 0x31F
#define COM_PM1_DUTY_CYCLE_UNDEFMASK 0xFFFFFE00
union com_pm1_duty_cycle_u {
    struct {
        unsigned int pm1_duty_cycle:9;      /* PM1 Duty Cycle from 1/P to P/P pulse high time where P is the period. This must not be larger than the period */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_pm1_duty_cycle_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_pm1_duty_cycle_u old_value_t = { .reg32 = value };
    const com_pm1_duty_cycle_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pm1_duty_cycle:9",
              "PM1 Duty Cycle from 1/P to P/P pulse high time where P is the period. This must not be larger than the period",
              9, old_value_t.pm1_duty_cycle, new_value_t.pm1_duty_cycle };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "PM1 Duty Cycle\nA counter repeatedly counts up from 0 to ((PM1_PERIOD << 2) + 3) pre-scaled cycles.\nThe period always starts with the output value == 1. After DUTY_CYCLE number of pre-scaled cycles, the output value is cleared for the remainder of the period. In order to output constant 0, simply set the DUTY_CYCLE to 0. To output a constant 1, set DUTY_CYCLE to be any value greater than ((PM1_PERIOD << 2) + 3).";
}

#define COM_SPI_CONTROL_OFFSET 0x320
#define COM_SPI_CONTROL_UNDEFMASK 0xFCE0FF04
union com_spi_control_u {
    struct {
        unsigned int spi_serial_clk_control:2;/* SPI Serial Clock Control 0= SCK rising edge is active edge 1-clock chip select and no SCK clock edge to latch chip select 1= SCK rising edge is active edge 2-clock chip select with SCK rising clock edge to latch it 2= SCK falling edge is active edge 1-clock chip select and no SCK clock edge to latch chip select 3= SCK falling edge is active edge 2-clock chip select with SCK falling clock edge to latch it This is valid for Host, IS, and LCD SPI */
        unsigned int undefined_bit_2:1;
        unsigned int spi_data_direction:1;  /* SPI Data Direction. This is valid for Host SPI and for sending initialization sequence (IS SPI) only. Note that data direction does not affect the start byte direction (always msb to lsb) and position (always first 8-bit of serial data) for SPI16SB mode. 0 = MSB2LSB 1 = LSB2MSB */
        unsigned int spi_bits_per_cycle:4;  /* SPI Bits per Cycle This is valid for Host and IS SPI only. This parameter determines the number of bits/cycle when SPI is used for host write or for sending initialization sequence. If SPI is used for sending pixel data to the display then pixel clock divider determines the SPI bits/cycle. SPI8DC is 8-bit SPI plus data/command bit SPI16DC is 16-bit SPI plus data/command bit SPI16SB is 16-bit SPI plus an 8-bit start byte preceding the 16-bit data. 0 = SPI8 1 = SPI8DC 2 = SPI12 3 = SPI16 4 = SPI16DC 5 = SPI16SB 6 = SPI18 7 = SPI24 */
        unsigned int undefined_bits_8_15:8;
        unsigned int spi_clk_divider:5;     /* SPI Clock Divider (1 to 32) This clock divider is used only if SPI is enabled for host writes (Host SPI) or for sending initialization sequence (IS SPI). Programmed value is 1 less than the desired (actual) clock divider value. This parameter is forced to 0 (clock divide by 1) for LCD SPI */
        unsigned int undefined_bits_21_23:3;
        unsigned int spi_status_enable:2;   /* SPI Status Enable 00= SPI status disable 01= SPI status enabled for host SPI only 10= SPI status enabled for IS and LCD SPI only 11= SPI status enabled for all SPI cycles SPI status is reflected in SPI_BUSY bit and can generate interrupt. SPI status indicates when SPI module is busy (SPI write cycles are in progress) so its falling edge should be used to generate interrupt. SPI status can also be output on LCD_DE pin. When Host SPI is triggered, the SPI busy is asserted within three display clock cycles after the end of the host write cycle. SPI status is disabled when SPI_ENABLE bit is disabled */
        unsigned int undefined_bits_26_31:6;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_spi_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_spi_control_u old_value_t = { .reg32 = value };
    const com_spi_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: spi_serial_clk_control:2",
              "SPI Serial Clock Control\n0= SCK rising edge is active edge 1-clock chip select and no SCK clock edge to latch chip select\n1= SCK rising edge is active edge 2-clock chip select with SCK rising clock edge to latch it\n2= SCK falling edge is active edge 1-clock chip select and no SCK clock edge to latch chip select\n3= SCK falling edge is active edge 2-clock chip select with SCK falling clock edge to latch it This is valid for Host, IS, and LCD SPI",
              2, old_value_t.spi_serial_clk_control, new_value_t.spi_serial_clk_control };
    m_bit_details_model.bits.append(entry);
    entry = { "02: undefined_bit_2:1", "", 1, old_value_t.undefined_bit_2, new_value_t.undefined_bit_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: spi_data_direction:1",
              "SPI Data Direction. This is valid for Host SPI and for sending initialization sequence (IS SPI) only. Note that data direction does not affect the start byte direction (always msb to lsb) and position (always first 8-bit of serial data) for SPI16SB mode.\n0 = MSB2LSB\n1 = LSB2MSB",
              1, old_value_t.spi_data_direction, new_value_t.spi_data_direction };
    m_bit_details_model.bits.append(entry);
    entry = { "04: spi_bits_per_cycle:4",
              "SPI Bits per Cycle This is valid for Host and IS SPI only. This parameter determines the number of bits/cycle when SPI is used for host write or for sending initialization sequence. If SPI is used for sending pixel data to the display then pixel clock divider determines the SPI bits/cycle. SPI8DC is 8-bit SPI plus data/command bit SPI16DC is 16-bit SPI plus data/command bit SPI16SB is 16-bit SPI plus an 8-bit start byte preceding the 16-bit data.\n0 = SPI8\n1 = SPI8DC\n2 = SPI12\n3 = SPI16\n4 = SPI16DC\n5 = SPI16SB\n6 = SPI18\n7 = SPI24",
              4, old_value_t.spi_bits_per_cycle, new_value_t.spi_bits_per_cycle };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: spi_clk_divider:5",
              "SPI Clock Divider (1 to 32) This clock divider is used only if SPI is enabled for host writes (Host SPI) or for sending initialization sequence (IS SPI). Programmed value is 1 less than the desired (actual) clock divider value. This parameter is forced to 0 (clock divide by 1) for LCD SPI",
              5, old_value_t.spi_clk_divider, new_value_t.spi_clk_divider };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_23:3", "", 3, old_value_t.undefined_bits_21_23, new_value_t.undefined_bits_21_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: spi_status_enable:2",
              "SPI Status Enable\n00= SPI status disable\n01= SPI status enabled for host SPI only\n10= SPI status enabled for IS and LCD SPI only\n11= SPI status enabled for all SPI cycles SPI status is reflected in SPI_BUSY bit and can generate interrupt. SPI status indicates when SPI module is busy (SPI write cycles are in progress) so its falling edge should be used to generate interrupt. SPI status can also be output on LCD_DE pin. When Host SPI is triggered, the SPI busy is asserted within three display clock cycles after the end of the host write cycle. SPI status is disabled when SPI_ENABLE bit is disabled",
              2, old_value_t.spi_status_enable, new_value_t.spi_status_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "26: undefined_bits_26_31:6", "", 6, old_value_t.undefined_bits_26_31, new_value_t.undefined_bits_26_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "SPI Control\nClass: Serial Peripheral Interface (SPI)\nSPI interface is a 3-pin or 4-pin serial interface which is typically used to program registers in display device. However, for display with built-in frame buffer, it can also be used to write pixel data to the built-in frame buffer. Currently only write cycles are supported.\nLCD SPI interface signal consists of:\n    * SPI Clock (SCK) which can be output on LCD_SCK pin.\n    * SPI Data (SDA) which can be output on LCD_SDOUT pin.\n    * Optional SPI Data/Command (SDC) which can be output on LCD_DC0 pin.\n    * Main-Display SPI Chip Select (Main SCS_) signal which can be output on LCS_ pin\n    * Sub-Display SPI Chip Select (Sub SCS_) signal which can be output on LCD_CS1_N or LCD_D22 or LCD_SDOUT pins - this is only used only if there is a sub display\nTheoretically if two LCD panels (main and sub displays) are connected, then SPI interface can be connected to both LCD panels and shared between the two panels.\nIn this case two Chip Select pins are required and LCS_ should be connected to the main display and other pin has to be selected to output the sub display SCS_.\nInternally two SPI chip select signals (lmscs_ and lsscs_ for main and sub display SPI chip select) are generated.\nWhen SPI is enabled, there are three possible SPI transactions:\n    * SPI write can be triggered by host by writing to HSPI_CS_DC register\n    * SPI write can be triggered to send pixel data from frame buffer\n    * SPI write can be triggered to send Initialization Sequence (IS). Frame initialization sequence is sent one line prior to active display line.\nFor LCD SPI, pixel data can only be sent to either Main-Display or Sub-Display but not to both but host SPI and IS SPI can be sent to both Main and Sub displays simultaneously.\nIn case a. and c. the SPI root clock is derived from output of shift clock divider which is then further divided by SPI_CLK_DIVIDER. For both cases, the SPI number of bits/cycle is determined by SPI_BITS_PER_CYCLE and the SPI data direction is determined by SPI_DATA_DIRECTION.\nIn case b. the SPI root clock is derived from output of shift clock divider with no further division. For this case, the SPI number of bits/cycle is determined by correct programming of pixel clock divider.\nIf case a. is enabled at the same time with case b. and c. then host SPI triggers is delayed to the beginning of horizontal display active time of a line that does not have IS SPI or LCD SPI cycles. This means that if all cases are enabled, the vertical blank time must be at least 2 lines otherwise host SPI cycles cannot be executed.";
}

#define COM_SPI_START_BYTE_OFFSET 0x321
#define COM_SPI_START_BYTE_UNDEFMASK 0xFFFF0000
union com_spi_start_byte_u {
    struct {
        unsigned int spi_data_start_byte:8; /* SPI Data Start Byte This is valid for Host, IS, and LCD SPI */
        unsigned int spi_command_start_byte:8;/* SPI Command Start Byte This is valid for Host, IS, and LCD SPI */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_spi_start_byte_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_spi_start_byte_u old_value_t = { .reg32 = value };
    const com_spi_start_byte_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: spi_data_start_byte:8",
              "SPI Data Start Byte This is valid for Host, IS, and LCD SPI",
              8, old_value_t.spi_data_start_byte, new_value_t.spi_data_start_byte };
    m_bit_details_model.bits.append(entry);
    entry = { "08: spi_command_start_byte:8",
              "SPI Command Start Byte This is valid for Host, IS, and LCD SPI",
              8, old_value_t.spi_command_start_byte, new_value_t.spi_command_start_byte };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "SPI Start Byte\nSPI Start Bytes are used only for SPI16SB mode (start byte plus 16-bit data). Data direction does not affect the start byte direction (always msb to lsb) and position (always first 8-bit of serial data).";
}

#define COM_HSPI_WRITE_DATA_AB_OFFSET 0x322
#define COM_HSPI_WRITE_DATA_AB_UNDEFMASK 0x00000000
union com_hspi_write_data_ab_u {
    struct {
        unsigned int hspi_write_data_a:16;  /* Host SPI Write Data A bits 15-0 */
        unsigned int hspi_write_data_b:16;  /* Host SPI Write Data B bits 15-0 */
    };

    u_int32_t reg32;
};

void DcDev::fill_com_hspi_write_data_ab_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_hspi_write_data_ab_u old_value_t = { .reg32 = value };
    const com_hspi_write_data_ab_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hspi_write_data_a:16",
              "Host SPI Write Data A bits 15-0",
              16, old_value_t.hspi_write_data_a, new_value_t.hspi_write_data_a };
    m_bit_details_model.bits.append(entry);
    entry = { "16: hspi_write_data_b:16",
              "Host SPI Write Data B bits 15-0",
              16, old_value_t.hspi_write_data_b, new_value_t.hspi_write_data_b };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Host SPI Write Data A & B\nThese registers are used to send write data for Host SPI write cycles (HSPI_ENABLE = 1).\nFor the tables below, these abbreviations of the registers are used:\n    * HSPIWDA = HSPI_WRITE_DATA_A\n    * HSPIWDB = HSPI_WRITE_DATA_B\n    * HSPIWDC = HSPI_WRITE_DATA_C\n    * HSPIWDD = HSPI_WRITE_DATA_D\n    * HSPIMCS = HSPI_MAIN_CS\n    * HSPISCS = HSPI_SUB_CS\n    * HSPIDC = HSPI_DC\nFor 8-bit SPI, up to 4 write cycles can be performed (SPI_BITS_PER_CYCLE equals SPI8)\nWrite cycle\n 0\n 1\n 2\n 3\n Data\n HSPIWDA[7-0]\n HSPIWDA[15-8]\n HSPIWDB[7-0]\n HSPIWDB[15-8]\n Main SCS_\n HSPIMCS[0]\n HSPIMCS[1]\n HSPIMCS[2]\n HSPIMCS[3]\n Sub SCS_\n HSPISCS[0]\n HSPISCS[1]\n HSPISCS[2]\n HSPICSC[3]\n SDC\n HSPIDC[0]\n HSPIDC[1]\n HSPIDC[2]\n HSPIDC[3]\nFor SPI8DC mode, a 9-bit SPI, the first data bit sent comes from HSPI_DC register and the other eight bits come as shown in the table below. Up to 4 write cycles can be performed.\nWrite cycle\n 0\n 1\nData\n HSPIDC[0], HSPIWDA[7-0]\n HSPIDC[1], HSPIWDA[15-8]\nMain SCS_\n HSPIMCS[0]\n HSPIMCS[1]\nSub SCS_\n HSPISCS[0]\n HSPISCS[1]\nSDC\n HSPIDC[0]\n HSPIDC[1]\nWrite cycle\n 2\n 3\nData\n HSPIDC[2], HSPIWDB[7-0]\n HSPIDC[3], HSPIWDB[15-8]\nMain SCS_\n HSPIMCS[2]\n HSPIMCS[3]\nSub SCS_\n HSPISCS[2]\n HSPICSC[3]\nSDC\n HSPIDC[2]\n HSPIDC[3]\nFor 12-bit SPI, up to 4 write cycles can be performed (SPI12)\nWrite cycle\n 0\n 1\n 2\n 3\nData\n HSPIWDA[11-0]\n HSPIWDB[11-0]\n HSPIWDC[11-0]\n HSPIWDD[11-0]\nMain SCS_\n HSPIMCS[0]\n HSPIMCS[1]\n HSPIMCS[2]\n HSPIMCS[3]\nSub SCS_\n HSPISCS[0]\n HSPISCS[1]\n HSPISCS[2]\n HSPISCS[3]\nSDC\n HSPIDC[0]\n HSPIDC[1]\n HSPIDC[2]\n HSPIDC[3]\n For 16-bit SPI, up to 4 write cycles can be performed (SPI16, SPI16SB). Note for SPI16SB mode, the first write cycle will be the start byte, followed by write cycle 0, as shown in the table below.\nWrite cycle\n 0\n 1\n 2\n 3\nData\n HSPIWDA[15-0]\n HSPIWDB[15-0]\n HSPIWDC[15-0]\n HSPIWDD[15-0]\nMain SCS_\n HSPIMCS[0]\n HSPIMCS[1]\n HSPIMCS[2]\n HSPIMCS[3]\nSub SCS_\n HSPISCS[0]\n HSPISCS[1]\n HSPISCS[2]\n HSPISCS[3]\nSDC\n HSPIDC[0]\n HSPIDC[1]\n HSPIDC[2]\n HSPIDC[3]\nFor SPI16DC mode, a 17-bit SPI, the first data bit sent comes from HSPI_DC  register and the other sixteen bits come as shown in the table below. Up to 4 write cycles can be performed.\n Write cycle\n 0\n 1\nData\n HSPIDC[0], HSPIWDA[15-0]\n HSPIDC[1], HSPIWDB[15-0]\nMain SCS_\n HSPIMCS[0]\n HSPIMCS[1]\nSub SCS_\n HSPISCS[0]\n HSPISCS[1]\nSDC\n HSPIDC[0]\n HSPIDC[1]\nWrite cycle\n 2\n 3\nData\n HSPIDC[2], HSPIWDC[15-0]\n HSPIDC[3], HSPIWDD[15-0]\nMain SCS_\n HSPIMCS[2]\n HSPIMCS[3]\nSub SCS_\n HSPISCS[2]\n HSPISCS[3]\nSDC\n HSPIDC[2]\n HSPIDC[3]\nFor 18-bit SPI, up to 2 write cycles can be performed (SPI18)\nWrite cycle\n 0\n 1\nData\n HSPIWDB[1-0], HSPIWDA[15-0]\n HSPIWDC[1-0], HSPIWDD[15-0]\nMain SCS_\n HSPIMCS[0]\n HSPIMCS[1]\nSub SCS_\n HSPISCS[0]\n HSPISCS[1]\nSDC\n HSPIDC[0]\n HSPIDC[1]\nFor 24-bit SPI, up to 2 write cycles can be performed (SPI24)\nWrite cycle\n 0\n 1\nData\n HSPIWDB[7-0], HSPIWDA[15-0]\n HSPIWDC[7-0], HSPIWDD[15-0]\nMain SCS_\n HSPIMCS[0]\n HSPIMCS[1]\nSub SCS_\n HSPISCS[0]\n HSPISCS[1]\nSDC\n HSPIDC[0]\n HSPIDC[1]";
}

#define COM_HSPI_WRITE_DATA_CD_OFFSET 0x323
#define COM_HSPI_WRITE_DATA_CD_UNDEFMASK 0x00000000
union com_hspi_write_data_cd_u {
    struct {
        unsigned int hspi_write_data_c:16;  /* Host SPI Write Data C bits 15-0 */
        unsigned int hspi_write_data_d:16;  /* Host SPI Write Data D bits 15-0 */
    };

    u_int32_t reg32;
};

void DcDev::fill_com_hspi_write_data_cd_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_hspi_write_data_cd_u old_value_t = { .reg32 = value };
    const com_hspi_write_data_cd_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hspi_write_data_c:16",
              "Host SPI Write Data C bits 15-0",
              16, old_value_t.hspi_write_data_c, new_value_t.hspi_write_data_c };
    m_bit_details_model.bits.append(entry);
    entry = { "16: hspi_write_data_d:16",
              "Host SPI Write Data D bits 15-0",
              16, old_value_t.hspi_write_data_d, new_value_t.hspi_write_data_d };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Host SPI Write Data C & D";
}

#define COM_HSPI_CS_DC_OFFSET 0x324
#define COM_HSPI_CS_DC_UNDEFMASK 0xE0F0000E
union com_hspi_cs_dc_u {
    struct {
        unsigned int hspi_raise:1;          /* Host SPI Raise. Raise vector will be returned at the end of the host SPI write cycles 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_1_3:3;
        unsigned int hspi_dc:4;             /* Host SPI Data/Command_ (SDC) 0= Command cycle (SDC=0) 1= Data cycle (SDC=1) This is valid for Host SPI only. Each bit of this parameter corresponds to the four possible host SPI cycles */
        unsigned int hspi_main_cs:4;        /* Host SPI Main display Chip Select (Main SCS_) 0= Main display not selected (Main SCS_=1) 1= Main display selected (Main SCS_=0) This is valid for Host SPI only. Each bit of this parameter corresponds to the four possible host SPI cycles */
        unsigned int hspi_sub_cs:4;         /* Host SPI Sub display Chip Select (Sub SCS_) 0= Sub display not selected (Sub SCS_=1) 1= Sub display selected (Sub SCS_=0) This is valid for Host SPI only. Each bit of this parameter corresponds to the four possible host SPI cycles */
        unsigned int hspi_raise_channel_id:4;/* Win G Channel ID */
        unsigned int undefined_bits_20_23:4;
        unsigned int hspi_raise_vector:5;   /* Host SPI Raise Vector This raise vector is returned after all the triggered host SPI cycles are executed */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_hspi_cs_dc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_hspi_cs_dc_u old_value_t = { .reg32 = value };
    const com_hspi_cs_dc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hspi_raise:1",
              "Host SPI Raise. Raise vector will be returned at the end of the host SPI write cycles\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.hspi_raise, new_value_t.hspi_raise };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: hspi_dc:4",
              "Host SPI Data/Command_ (SDC)\n0= Command cycle (SDC=0)\n1= Data cycle (SDC=1) This is valid for Host SPI only. Each bit of this parameter corresponds to the four possible host SPI cycles",
              4, old_value_t.hspi_dc, new_value_t.hspi_dc };
    m_bit_details_model.bits.append(entry);
    entry = { "08: hspi_main_cs:4",
              "Host SPI Main display Chip Select (Main SCS_)\n0= Main display not selected (Main SCS_=1)\n1= Main display selected (Main SCS_=0) This is valid for Host SPI only. Each bit of this parameter corresponds to the four possible host SPI cycles",
              4, old_value_t.hspi_main_cs, new_value_t.hspi_main_cs };
    m_bit_details_model.bits.append(entry);
    entry = { "12: hspi_sub_cs:4",
              "Host SPI Sub display Chip Select (Sub SCS_)\n0= Sub display not selected (Sub SCS_=1)\n1= Sub display selected (Sub SCS_=0) This is valid for Host SPI only. Each bit of this parameter corresponds to the four possible host SPI cycles",
              4, old_value_t.hspi_sub_cs, new_value_t.hspi_sub_cs };
    m_bit_details_model.bits.append(entry);
    entry = { "16: hspi_raise_channel_id:4",
              "Win G Channel ID",
              4, old_value_t.hspi_raise_channel_id, new_value_t.hspi_raise_channel_id };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_23:4", "", 4, old_value_t.undefined_bits_20_23, new_value_t.undefined_bits_20_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: hspi_raise_vector:5",
              "Host SPI Raise Vector This raise vector is returned after all the triggered host SPI cycles are executed",
              5, old_value_t.hspi_raise_vector, new_value_t.hspi_raise_vector };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Host SPI Chip Select and Data/Command\nA write to this register will trigger the Host SPI write cycle if SPI_ENABLE and HSPI_ENABLE are both enabled. Writing to this register with HSPI_RAISE enabled will cause the raise vector to be returned after all the host SPI cycles are completed. Up to four host SPI cycles can be executed with a single trigger.\n This register should not be written if previous host SPI write cycle is in progress. HSPI_MAIN_CS and HSPI_SUB_CS controls the main and sub display chip selects and therefore also determine how many SPI write cycles to main and sub displays and the write data position.\nHSPI_MAIN_CS or HSPI_SUB_CS should be programmed to have at least one valid cycle when programming HSPI_CS_DC register.";
}

#define COM_SCRATCH_REGISTER_A_OFFSET 0x325
#define COM_SCRATCH_REGISTER_A_UNDEFMASK 0x00000000
union com_scratch_register_a_u {
    struct {
        unsigned int scratch_register_a:32; /* Scratch Register A */
    };

    u_int32_t reg32;
};

void DcDev::fill_com_scratch_register_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_scratch_register_a_u old_value_t = { .reg32 = value };
    const com_scratch_register_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: scratch_register_a:32",
              "Scratch Register A",
              32, old_value_t.scratch_register_a, new_value_t.scratch_register_a };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Scratch Register A\nClass: Software Scratch Registers";
}

#define COM_SCRATCH_REGISTER_B_OFFSET 0x326
#define COM_SCRATCH_REGISTER_B_UNDEFMASK 0x00000000
union com_scratch_register_b_u {
    struct {
        unsigned int scratch_register_b:32; /* Scratch Register B */
    };

    u_int32_t reg32;
};

void DcDev::fill_com_scratch_register_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_scratch_register_b_u old_value_t = { .reg32 = value };
    const com_scratch_register_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: scratch_register_b:32",
              "Scratch Register B",
              32, old_value_t.scratch_register_b, new_value_t.scratch_register_b };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Scratch Register B";
}

#define COM_GPIO_CTRL_OFFSET 0x327
#define COM_GPIO_CTRL_UNDEFMASK 0xFFFFFFF8
union com_gpio_ctrl_u {
    struct {
        unsigned int gpio_0_debounce_enable:1;/* maps to display pin LCD_PWR0  0 = DISABLE 1 = ENABLE */
        unsigned int gpio_1_debounce_enable:1;/* maps to display pin LCD_PWR1  0 = DISABLE 1 = ENABLE */
        unsigned int gpio_2_debounce_enable:1;/* maps to display pin LCD_PWR2  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_31:29;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_gpio_ctrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_gpio_ctrl_u old_value_t = { .reg32 = value };
    const com_gpio_ctrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: gpio_0_debounce_enable:1",
              "maps to display pin LCD_PWR0 \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.gpio_0_debounce_enable, new_value_t.gpio_0_debounce_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: gpio_1_debounce_enable:1",
              "maps to display pin LCD_PWR1 \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.gpio_1_debounce_enable, new_value_t.gpio_1_debounce_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "02: gpio_2_debounce_enable:1",
              "maps to display pin LCD_PWR2 \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.gpio_2_debounce_enable, new_value_t.gpio_2_debounce_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_31:29", "", 29, old_value_t.undefined_bits_3_31, new_value_t.undefined_bits_3_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Display GPIO control, including debounce control";
}

#define COM_GPIO_DEBOUNCE_COUNTER_OFFSET 0x328
#define COM_GPIO_DEBOUNCE_COUNTER_UNDEFMASK 0x00000000
union com_gpio_debounce_counter_u {
    struct {
        unsigned int debounce_counter:32;
    };

    u_int32_t reg32;
};

void DcDev::fill_com_gpio_debounce_counter_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_gpio_debounce_counter_u old_value_t = { .reg32 = value };
    const com_gpio_debounce_counter_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: debounce_counter:32", "", 32, old_value_t.debounce_counter, new_value_t.debounce_counter };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Display GPIO Debounce Counter\nProvides mark_en to debounce logic.\nMARKER\nThe MARKER value sets the interval at which the debounce finite state machines associated with each GPIO input pin evaluate input transitions. An input transition must be stable for at least 4 consecutive MARKER ticks before it is propagated through the debounce circuit.\nMARKER is in display clock tick units. The actual 'gravity delay' of a debounce FSM is 4 * Tmarker, where Tmarker = MARKER * (APB clock duration). For a 100 MHz display clock, a MARKER setting of 10,000,000 results in a gravity delay of 4x100 mS.";
}

#define COM_CRC_CHECKSUM_LATCHED_OFFSET 0x329
#define COM_CRC_CHECKSUM_LATCHED_UNDEFMASK 0x00000000
union com_crc_checksum_latched_u {
    struct {
        unsigned int crc_checksum_latched:32;/* CRC Checksum latched */
    };

    u_int32_t reg32;
};

void DcDev::fill_com_crc_checksum_latched_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const com_crc_checksum_latched_u old_value_t = { .reg32 = value };
    const com_crc_checksum_latched_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: crc_checksum_latched:32",
              "CRC Checksum latched",
              32, old_value_t.crc_checksum_latched, new_value_t.crc_checksum_latched };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "CRC Checksum latched\nThis register is a latched version of CRC_CHECKSUM. Latching happens at frame end.\nNote:\n CRC_INPUT_DATA needs to be set to ACTIVE_DATA if this register is used.  In full frame mode, CRC is frozen two cycles after frame end due to pipelining, so only in active area mode, CRC is consistent and independent of display control mode, and can be checked continuously frame by frame.";
}

#define DISP_DISP_SIGNAL_OPTIONS0_OFFSET 0x400
#define DISP_DISP_SIGNAL_OPTIONS0_UNDEFMASK 0xFAE2EAFF
union disp_disp_signal_options0_u {
    struct {
        unsigned int undefined_bits_0_7:8;
        unsigned int h_pulse0_enable:1;     /* H Pulse 0 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int h_pulse1_enable:1;     /* H Pulse 1 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_11:1;
        unsigned int h_pulse2_enable:1;     /* H Pulse 2 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse0_enable:1;     /* V Pulse 0 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int v_pulse1_enable:1;     /* V Pulse 1 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int v_pulse2_enable:1;     /* V Pulse 2 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int v_pulse3_enable:1;     /* V Pulse 3 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_21_23:3;
        unsigned int m0_enable:1;           /* M0 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_25:1;
        unsigned int m1_enable:1;           /* M1 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_27_31:5;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_disp_signal_options0_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_disp_signal_options0_u old_value_t = { .reg32 = value };
    const disp_disp_signal_options0_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_7:8", "", 8, old_value_t.undefined_bits_0_7, new_value_t.undefined_bits_0_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: h_pulse0_enable:1",
              "H Pulse 0 Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.h_pulse0_enable, new_value_t.h_pulse0_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bit_9:1", "", 1, old_value_t.undefined_bit_9, new_value_t.undefined_bit_9 };
    m_bit_details_model.bits.append(entry);
    entry = { "10: h_pulse1_enable:1",
              "H Pulse 1 Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.h_pulse1_enable, new_value_t.h_pulse1_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: h_pulse2_enable:1",
              "H Pulse 2 Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.h_pulse2_enable, new_value_t.h_pulse2_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_pulse0_enable:1",
              "V Pulse 0 Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.v_pulse0_enable, new_value_t.v_pulse0_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: v_pulse1_enable:1",
              "V Pulse 1 Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.v_pulse1_enable, new_value_t.v_pulse1_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "19: v_pulse2_enable:1",
              "V Pulse 2 Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.v_pulse2_enable, new_value_t.v_pulse2_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "20: v_pulse3_enable:1",
              "V Pulse 3 Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.v_pulse3_enable, new_value_t.v_pulse3_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_23:3", "", 3, old_value_t.undefined_bits_21_23, new_value_t.undefined_bits_21_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: m0_enable:1",
              "M0 Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.m0_enable, new_value_t.m0_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bit_25:1", "", 1, old_value_t.undefined_bit_25, new_value_t.undefined_bit_25 };
    m_bit_details_model.bits.append(entry);
    entry = { "26: m1_enable:1",
              "M1 Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.m1_enable, new_value_t.m1_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "27: undefined_bits_27_31:5", "", 5, old_value_t.undefined_bits_27_31, new_value_t.undefined_bits_27_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Display Signal Options 0";
}

#define DISP_DISP_SIGNAL_OPTIONS1_OFFSET 0x401
#define DISP_DISP_SIGNAL_OPTIONS1_UNDEFMASK 0xFFFAFFFF
union disp_disp_signal_options1_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int di_enable:1;           /* DI Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int pp_enable:1;           /* PP Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_31:13;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_disp_signal_options1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_disp_signal_options1_u old_value_t = { .reg32 = value };
    const disp_disp_signal_options1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_15:16", "", 16, old_value_t.undefined_bits_0_15, new_value_t.undefined_bits_0_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: di_enable:1",
              "DI Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.di_enable, new_value_t.di_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: pp_enable:1",
              "PP Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.pp_enable, new_value_t.pp_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bits_19_31:13", "", 13, old_value_t.undefined_bits_19_31, new_value_t.undefined_bits_19_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Display Signal Options 1";
}

#define DISP_DISP_WIN_OPTIONS_OFFSET 0x402
#define DISP_DISP_WIN_OPTIONS_UNDEFMASK 0x8FFEFFFF
union disp_disp_win_options_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int cursor_enable:1;       /* Cursor Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_17_27:11;
        unsigned int tvo_enable:1;          /* TVO Enable. Steps to start displaying on TV (The order of the first 3 steps can freely change): -- Program and enable TVO module -- Program DISPLAY_CTRL_MODE to NC_DISPLAY -- Program the ASSEMBLY shadow copy of this register field with ENABLE -- Program GENERAL_ACT_REQ to activate the shadow 0 = DISABLE 1 = ENABLE */
        unsigned int dsi_enable:1;          /* MIPI Display Serial Interface Enable. The DSI unit must also be separately enabled in its own register space in order to use DSI functionality. 0 = DISABLE 1 = ENABLE */
        unsigned int hdmi_enable:1;         /* HDMI interface. The HDMI unit must also be separately enabled in its own register space in order to use HDMI functionality. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_disp_win_options_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_disp_win_options_u old_value_t = { .reg32 = value };
    const disp_disp_win_options_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_15:16", "", 16, old_value_t.undefined_bits_0_15, new_value_t.undefined_bits_0_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cursor_enable:1",
              "Cursor Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.cursor_enable, new_value_t.cursor_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_27:11", "", 11, old_value_t.undefined_bits_17_27, new_value_t.undefined_bits_17_27 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: tvo_enable:1",
              "TVO Enable. Steps to start displaying on TV (The order of the first 3 steps can freely change): -- Program and enable TVO module -- Program DISPLAY_CTRL_MODE to NC_DISPLAY -- Program the ASSEMBLY shadow copy of this register field with ENABLE -- Program GENERAL_ACT_REQ to activate the shadow\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.tvo_enable, new_value_t.tvo_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "29: dsi_enable:1",
              "MIPI Display Serial Interface Enable. The DSI unit must also be separately enabled in its own register space in order to use DSI functionality.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.dsi_enable, new_value_t.dsi_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "30: hdmi_enable:1",
              "HDMI interface. The HDMI unit must also be separately enabled in its own register space in order to use HDMI functionality.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.hdmi_enable, new_value_t.hdmi_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Display Window Options";
}

#define DISP_MEM_HIGH_PRIORITY_OFFSET 0x403
#define DISP_MEM_HIGH_PRIORITY_UNDEFMASK 0xF8808000
union disp_mem_high_priority_u {
    struct {
        unsigned int cbr_display0a2mc_hpth:8;/* Window A Memory High Priority threshold Memory access for this window is high priority if the number of filled entries in the return data fifo is less than or equal to this value. Setting this parameter to 0 disables high priority memory request */
        unsigned int cbr_displayb2mc_hpth:7;/* Window B Memory High Priority threshold Memory access for this window is high priority if the number of filled entries in the return data fifo is less than or equal to this value. Setting this parameter to 0 disables high priority memory request. This register is used for both window B0 and B1 */
        unsigned int undefined_bit_15:1;
        unsigned int cbr_display0c2mc_hpth:7;/* Window C Memory High Priority threshold Memory access for this window is high priority if the number of filled entries in the return data fifo is less than or equal to this value. Setting this parameter to 0 disables high priority memory request */
        unsigned int undefined_bit_23:1;
        unsigned int csr_displayhc2mc_hpth:3;/* Cursor Memory High Priority enable 0= memory access for cursor is normal priority 1= memory access for cursor is high priority */
        unsigned int undefined_bits_27_31:5;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_mem_high_priority_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_mem_high_priority_u old_value_t = { .reg32 = value };
    const disp_mem_high_priority_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbr_display0a2mc_hpth:8",
              "Window A Memory High Priority threshold Memory access for this window is high priority if the number of filled entries in the return data fifo is less than or equal to this value. Setting this parameter to 0 disables high priority memory request",
              8, old_value_t.cbr_display0a2mc_hpth, new_value_t.cbr_display0a2mc_hpth };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cbr_displayb2mc_hpth:7",
              "Window B Memory High Priority threshold Memory access for this window is high priority if the number of filled entries in the return data fifo is less than or equal to this value. Setting this parameter to 0 disables high priority memory request. This register is used for both window B0 and B1",
              7, old_value_t.cbr_displayb2mc_hpth, new_value_t.cbr_displayb2mc_hpth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbr_display0c2mc_hpth:7",
              "Window C Memory High Priority threshold Memory access for this window is high priority if the number of filled entries in the return data fifo is less than or equal to this value. Setting this parameter to 0 disables high priority memory request",
              7, old_value_t.cbr_display0c2mc_hpth, new_value_t.cbr_display0c2mc_hpth };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: csr_displayhc2mc_hpth:3",
              "Cursor Memory High Priority enable\n0= memory access for cursor is normal priority\n1= memory access for cursor is high priority",
              3, old_value_t.csr_displayhc2mc_hpth, new_value_t.csr_displayhc2mc_hpth };
    m_bit_details_model.bits.append(entry);
    entry = { "27: undefined_bits_27_31:5", "", 5, old_value_t.undefined_bits_27_31, new_value_t.undefined_bits_27_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Memory High Priority request control\nDisplay Memory High Priority Threshold\nThis controls high priority request for memory read access for each display window and for cursor. High priority request threshold should be increased in scenarios where memory access latency is high.";
}

#define DISP_MEM_HIGH_PRIORITY_TIMER_OFFSET 0x404
#define DISP_MEM_HIGH_PRIORITY_TIMER_UNDEFMASK 0xC0C0C0C0
union disp_mem_high_priority_timer_u {
    struct {
        unsigned int cbr_display0a2mc_hptm:6;/* Window A Memory High Priority timer */
        unsigned int undefined_bits_6_7:2;
        unsigned int cbr_displayb2mc_hptm:6;/* Window B Memory High Priority timer This register is used for both window B0 and B1 */
        unsigned int undefined_bits_14_15:2;
        unsigned int cbr_display0c2mc_hptm:6;/* Window C Memory High Priority timer */
        unsigned int undefined_bits_22_23:2;
        unsigned int csr_displayhc2mc_hptm:6;/* Cursor Memory High Priority timer */
        unsigned int undefined_bits_30_31:2;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_mem_high_priority_timer_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_mem_high_priority_timer_u old_value_t = { .reg32 = value };
    const disp_mem_high_priority_timer_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbr_display0a2mc_hptm:6",
              "Window A Memory High Priority timer",
              6, old_value_t.cbr_display0a2mc_hptm, new_value_t.cbr_display0a2mc_hptm };
    m_bit_details_model.bits.append(entry);
    entry = { "06: undefined_bits_6_7:2", "", 2, old_value_t.undefined_bits_6_7, new_value_t.undefined_bits_6_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cbr_displayb2mc_hptm:6",
              "Window B Memory High Priority timer This register is used for both window B0 and B1",
              6, old_value_t.cbr_displayb2mc_hptm, new_value_t.cbr_displayb2mc_hptm };
    m_bit_details_model.bits.append(entry);
    entry = { "14: undefined_bits_14_15:2", "", 2, old_value_t.undefined_bits_14_15, new_value_t.undefined_bits_14_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbr_display0c2mc_hptm:6",
              "Window C Memory High Priority timer",
              6, old_value_t.cbr_display0c2mc_hptm, new_value_t.cbr_display0c2mc_hptm };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: csr_displayhc2mc_hptm:6",
              "Cursor Memory High Priority timer",
              6, old_value_t.csr_displayhc2mc_hptm, new_value_t.csr_displayhc2mc_hptm };
    m_bit_details_model.bits.append(entry);
    entry = { "30: undefined_bits_30_31:2", "", 2, old_value_t.undefined_bits_30_31, new_value_t.undefined_bits_30_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Memory High Priority request control\nDisplay Memory High Priority Timer\nThe high-priority assertion can be delayed by a number of memory clock cycles indicated by the timer. This creates an hysteresis effect, avoiding setting the high-priority for very short periods of time, which may or may not be desirable.";
}

#define DISP_DISP_TIMING_OPTIONS_OFFSET 0x405
#define DISP_DISP_TIMING_OPTIONS_UNDEFMASK 0xFFFFE000
union disp_disp_timing_options_u {
    struct {
        unsigned int vsync_h_position:13;   /* VSYNC Horizontal Position This parameter specifies the position where VSYNC can toggle with respect to H reference point */
        unsigned int undefined_bits_13_31:19;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_disp_timing_options_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_disp_timing_options_u old_value_t = { .reg32 = value };
    const disp_disp_timing_options_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vsync_h_position:13",
              "VSYNC Horizontal Position This parameter specifies the position where VSYNC can toggle with respect to H reference point",
              13, old_value_t.vsync_h_position, new_value_t.vsync_h_position };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_31:19", "", 19, old_value_t.undefined_bits_13_31, new_value_t.undefined_bits_13_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Display Timing Options\nClass: Display Standard Timings\nProgramming of display timing registers must meet these restrictions:\nConstraint 1: H_REF_TO_SYNC + H_SYNC_WIDTH + H_BACK_PORCH > 11.\nConstraint 2: V_REF_TO_SYNC + V_SYNC_WIDTH + V_BACK_PORCH > 1.\nConstraint 3: V_FRONT_PORCH + V_SYNC_WIDTH + V_BACK_PORCH > 1 (vertical blank).\nConstraint 4: V_SYNC_WIDTH >= 1\n                      H_SYNC_WIDTH >= 1\nConstraint 5:  V_REF_TO_SYNC >= 1\n  H_REF_TO_SYNC >= 0\nConstraint 6:  V_FRONT_PORCH >= (V_REF_TO_SYNC + 1)\n  H_FRONT_PORCH >= (H_REF_TO_SYNC + 1)\nConstraint 7:  H_DISP_ACTIVE >= 16\n  V_DISP_ACTIVE >= 16\nOnly the back porch can be a negative value, though it is typically positive.  Note that the back porch is defined as the distance between the trailing edge of the sync and the beginning of the active area.  Some LCD specifications define the back porch from the leading edge of the sync rather than the trailing edge.  Front porch is defined as the distance between the end of the active area and the leading edge of the sync.  Vertical timing is in terms of lines and horizontal timing is in terms of pixels.\nSync polarity is in terms of the sync width; active low means the sync width pulse will be low, as in the diagram.  Pixel clock polarity is in terms of when data will transition; an active low pixel clock means that the data changes on the falling edge of the clock, to be latched on the rising edge.  Data enable (also called display enable or DE) polarity selects the level of the signal during the active area of display.  The diagram has DE active high.\nTiming Diagram\n    * This diagram applies to both vertical and horizontal timing\n    * Back porch is the only parameter that can be negative\nFigure 90  Display Timing Options Timing Diagram\n syncwidthsyncwidthfrontporchactive areaback porchactive areafrontporchref pointsync leading edgesync trailing edgesync leading edgeref tosyncsyncdataref pointref tosyncConstraints 1, 2Constraint 3Constraint 4Constraint 5Constraint 6Constraint 7> 11 horizontally, > 1 vertically> 1 vertically>= 1 horizontally, >= 1 vertically>= 1 vertically, >= 0 horizontally>= (V_REF_TO_SYNC+1) vertically, >= (H_REF_TO_SYNC+1) horizontally>= 16 vertically, >= 16 horizontallydata enable\nThis register specifies display timing options for HSYNC and VSYNC";
}

#define DISP_REF_TO_SYNC_OFFSET 0x406
#define DISP_REF_TO_SYNC_UNDEFMASK 0xE000E000
union disp_ref_to_sync_u {
    struct {
        unsigned int h_ref_to_sync:13;      /* H reference to HSYNC (minimum 0 pixel clock) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_ref_to_sync:13;      /* V reference to VSYNC (minimum 1 line clock) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_ref_to_sync_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_ref_to_sync_u old_value_t = { .reg32 = value };
    const disp_ref_to_sync_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_ref_to_sync:13",
              "H reference to HSYNC (minimum 0 pixel clock)",
              13, old_value_t.h_ref_to_sync, new_value_t.h_ref_to_sync };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_ref_to_sync:13",
              "V reference to VSYNC (minimum 1 line clock)",
              13, old_value_t.v_ref_to_sync, new_value_t.v_ref_to_sync };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H/V Reference to Sync\nThis register specifies the start position of HSYNC and VSYNC with respect to H and V reference point (line and frame start) correspondingly. The H and V reference points correspond to the time when H and V display timing counter is re-initialized to zero correspondingly.\nThe H reference point also determines the point where V display timing counter is incremented so this points the horizontal relationship between HSYNC and VSYNC.\nNote:\n VSYNC's rising/falling edge is fixed at H reference point zero. In the future,  we may want to add a horizontal position offset so that VSYNC can occur after HSYNC.";
}

#define DISP_SYNC_WIDTH_OFFSET 0x407
#define DISP_SYNC_WIDTH_UNDEFMASK 0xE000E000
union disp_sync_width_u {
    struct {
        unsigned int h_sync_width:13;       /* HSYNC pulse width (minimum 1 pixel clock) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_sync_width:13;       /* VSYNC pulse width (minimum 1 line clock) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sync_width_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sync_width_u old_value_t = { .reg32 = value };
    const disp_sync_width_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_sync_width:13",
              "HSYNC pulse width (minimum 1 pixel clock)",
              13, old_value_t.h_sync_width, new_value_t.h_sync_width };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_sync_width:13",
              "VSYNC pulse width (minimum 1 line clock)",
              13, old_value_t.v_sync_width, new_value_t.v_sync_width };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H/V SYNC Pulse Width\nThis register specifies the width of HSYNC and VSYNC pulses. Check the comment for REF_TO_SYNC for programming restrictions.";
}

#define DISP_BACK_PORCH_OFFSET 0x408
#define DISP_BACK_PORCH_UNDEFMASK 0xE000E000
union disp_back_porch_u {
    struct {
        unsigned int h_back_porch:13;       /* H back porch */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_back_porch:13;       /* V back porch */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_back_porch_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_back_porch_u old_value_t = { .reg32 = value };
    const disp_back_porch_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_back_porch:13",
              "H back porch",
              13, old_value_t.h_back_porch, new_value_t.h_back_porch };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_back_porch:13",
              "V back porch",
              13, old_value_t.v_back_porch, new_value_t.v_back_porch };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H/V Back Porch\nThis register specifies the distance between H/V SYNC trailing edge to beginning of display active area. This is 2's complement value and negative value indicates that H/V SYNC overlaps with the corresponding display active area. Check the comment for REF_TO_SYNC for programming restrictions.";
}

#define DISP_DISP_ACTIVE_OFFSET 0x409
#define DISP_DISP_ACTIVE_UNDEFMASK 0xE000E000
union disp_disp_active_u {
    struct {
        unsigned int h_disp_active:13;      /* H display active width (minimum 16 pixels) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_disp_active:13;      /* V display active width (minimum 16 lines) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_disp_active_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_disp_active_u old_value_t = { .reg32 = value };
    const disp_disp_active_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_disp_active:13",
              "H display active width (minimum 16 pixels)",
              13, old_value_t.h_disp_active, new_value_t.h_disp_active };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_disp_active:13",
              "V display active width (minimum 16 lines)",
              13, old_value_t.v_disp_active, new_value_t.v_disp_active };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H/V Display Active width\nThis register specifies the width of H/V display active area. Check the comment for REF_TO_SYNC for programming restrictions.";
}

#define DISP_FRONT_PORCH_OFFSET 0x40A
#define DISP_FRONT_PORCH_UNDEFMASK 0xE000E000
union disp_front_porch_u {
    struct {
        unsigned int h_front_porch:13;      /* HSYNC front porch (minimum -=PS_=-H_REF_TO_SYNC + 1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_front_porch:13;      /* VSYNC front porch (minimum -=PS_=-V_REF_TO_SYNC + 1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_front_porch_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_front_porch_u old_value_t = { .reg32 = value };
    const disp_front_porch_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_front_porch:13",
              "HSYNC front porch (minimum -=PS_=-H_REF_TO_SYNC + 1)",
              13, old_value_t.h_front_porch, new_value_t.h_front_porch };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_front_porch:13",
              "VSYNC front porch (minimum -=PS_=-V_REF_TO_SYNC + 1)",
              13, old_value_t.v_front_porch, new_value_t.v_front_porch };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H/V Front Porch\nThis register specifies the distance between end of H/V display active area to the leading edge of the corresponding H/V SYNC.\nDesign Note: H/V active end plus the H/V front porch value minus the H/V reference to H/VSYNC determines the the H/V total (final H/V count value for the H/V display counter). Check the comment for REF_TO_SYNC for programming restrictions.";
}

#define DISP_H_PULSE0_CONTROL_OFFSET 0x40B
#define DISP_H_PULSE0_CONTROL_UNDEFMASK 0xFFFFF027
union disp_h_pulse0_control_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int h_pulse0_mode:1;       /* H Pulse 0 Mode 0= Normal mode 1= Single-clock mode 0 = NORMAL 1 = ONE_CLOCK */
        unsigned int h_pulse0_polarity:1;   /* H Pulse 0 Polarity. Polarity adjustment is done before the vertical qualifier is applied. 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int h_pulse0_v_qual:2;     /* H Pulse 0 Vertical Qualifier 0= always running 2= run during vertical active area 3= run during vertical active plus 1 line 0 = ALWAYS 2 = VACTIVE 3 = VACTIVE1 */
        unsigned int h_pulse0_last:4;       /* H Pulse 0 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position 6= end on Start D position 7= end on End D position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C 6 = START_D 7 = END_D */
        unsigned int undefined_bits_12_31:20;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse0_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse0_control_u old_value_t = { .reg32 = value };
    const disp_h_pulse0_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_2:3", "", 3, old_value_t.undefined_bits_0_2, new_value_t.undefined_bits_0_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: h_pulse0_mode:1",
              "H Pulse 0 Mode\n0= Normal mode\n1= Single-clock mode\n0 = NORMAL\n1 = ONE_CLOCK",
              1, old_value_t.h_pulse0_mode, new_value_t.h_pulse0_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "04: h_pulse0_polarity:1",
              "H Pulse 0 Polarity. Polarity adjustment is done before the vertical qualifier is applied.\n0 = HIGH\n1 = LOW",
              1, old_value_t.h_pulse0_polarity, new_value_t.h_pulse0_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: h_pulse0_v_qual:2",
              "H Pulse 0 Vertical Qualifier\n0= always running\n2= run during vertical active area\n3= run during vertical active plus 1 line\n0 = ALWAYS\n2 = VACTIVE\n3 = VACTIVE1",
              2, old_value_t.h_pulse0_v_qual, new_value_t.h_pulse0_v_qual };
    m_bit_details_model.bits.append(entry);
    entry = { "08: h_pulse0_last:4",
              "H Pulse 0 Last point\n0= end on Start A position\n1= end on End A position\n2= end on Start B position\n3= end on End B position\n4= end on Start C position\n5= end on End C position\n6= end on Start D position\n7= end on End D position others= reserved\n0 = START_A\n1 = END_A\n2 = START_B\n3 = END_B\n4 = START_C\n5 = END_C\n6 = START_D\n7 = END_D",
              4, old_value_t.h_pulse0_last, new_value_t.h_pulse0_last };
    m_bit_details_model.bits.append(entry);
    entry = { "12: undefined_bits_12_31:20", "", 20, old_value_t.undefined_bits_12_31, new_value_t.undefined_bits_12_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 0 Control\nClass: Display Extended Timings\nHorizontal pulse 0 is programmable pulse that repeats every line.\nIn the NORMAL mode, this signal can have several pulses (A to D) per line with programmable width as defined by the pairs of start and end positions. The pulses must not overlap and must occur in sequence: pulse A, then pulse B, etc. In this case, the Enable field must be set to one of the End position. If the Enable field is set to one of the Start position then the pulse generator will stop as if the Enable field is set to the previous End position. If Enable field is set to Start A position then no pulse is generated.\n In the ONE_CLOCK mode this signal can have up to twice the number of pulses per line with each pulse having a width of 1 pixel clock. In this mode, the position of the one-clock pulses correspond to the enabled Start and End positions.\nRegardless of the mode, the pulse generator processes the pairs of start and end position sequentially in the order of: Start A, End A, Start B, End B, etc.\nSo these start/end positions should be programmed in increasing order. If any of the positions are programmed in non-increasing order (has invalid value) then the pulse generator will stop at the last valid position.\nPolarity adjustment is made prior to V display qualification. This register specifies options for Horizontal pulse 0.";
}

#define DISP_H_PULSE0_POSITION_A_OFFSET 0x40C
#define DISP_H_PULSE0_POSITION_A_UNDEFMASK 0xE000E000
union disp_h_pulse0_position_a_u {
    struct {
        unsigned int h_pulse0_start_a:13;   /* H Pulse 0 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse0_end_a:13;     /* H Pulse 0 End A (minimum -=PS_=-H_PULSE0_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse0_position_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse0_position_a_u old_value_t = { .reg32 = value };
    const disp_h_pulse0_position_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_pulse0_start_a:13",
              "H Pulse 0 Start A (minimum 0)",
              13, old_value_t.h_pulse0_start_a, new_value_t.h_pulse0_start_a };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: h_pulse0_end_a:13",
              "H Pulse 0 End A (minimum -=PS_=-H_PULSE0_START_A+1)",
              13, old_value_t.h_pulse0_end_a, new_value_t.h_pulse0_end_a };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 0 Position A";
}

#define DISP_H_PULSE0_POSITION_B_OFFSET 0x40D
#define DISP_H_PULSE0_POSITION_B_UNDEFMASK 0xE000E000
union disp_h_pulse0_position_b_u {
    struct {
        unsigned int h_pulse0_start_b:13;   /* H Pulse 0 Start B (minimum -=PS_=-H_PULSE0_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse0_end_b:13;     /* H Pulse 0 End B (minimum -=PS_=-H_PULSE0_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse0_position_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse0_position_b_u old_value_t = { .reg32 = value };
    const disp_h_pulse0_position_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_pulse0_start_b:13",
              "H Pulse 0 Start B (minimum -=PS_=-H_PULSE0_END_A+1)",
              13, old_value_t.h_pulse0_start_b, new_value_t.h_pulse0_start_b };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: h_pulse0_end_b:13",
              "H Pulse 0 End B (minimum -=PS_=-H_PULSE0_START_B+1)",
              13, old_value_t.h_pulse0_end_b, new_value_t.h_pulse0_end_b };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 0 Position B";
}

#define DISP_H_PULSE0_POSITION_C_OFFSET 0x40E
#define DISP_H_PULSE0_POSITION_C_UNDEFMASK 0xE000E000
union disp_h_pulse0_position_c_u {
    struct {
        unsigned int h_pulse0_start_c:13;   /* H Pulse 0 Start C (minimum -=PS_=-H_PULSE0_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse0_end_c:13;     /* H Pulse 0 End C (minimum -=PS_=-H_PULSE0_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse0_position_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse0_position_c_u old_value_t = { .reg32 = value };
    const disp_h_pulse0_position_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_pulse0_start_c:13",
              "H Pulse 0 Start C (minimum -=PS_=-H_PULSE0_END_B+1)",
              13, old_value_t.h_pulse0_start_c, new_value_t.h_pulse0_start_c };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: h_pulse0_end_c:13",
              "H Pulse 0 End C (minimum -=PS_=-H_PULSE0_START_C+1)",
              13, old_value_t.h_pulse0_end_c, new_value_t.h_pulse0_end_c };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 0 Position C";
}

#define DISP_H_PULSE0_POSITION_D_OFFSET 0x40F
#define DISP_H_PULSE0_POSITION_D_UNDEFMASK 0xE000E000
union disp_h_pulse0_position_d_u {
    struct {
        unsigned int h_pulse0_start_d:13;   /* H Pulse 0 Start D (minimum -=PS_=-H_PULSE0_END_C+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse0_end_d:13;     /* H Pulse 0 End D (minimum -=PS_=-H_PULSE0_START_D+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse0_position_d_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse0_position_d_u old_value_t = { .reg32 = value };
    const disp_h_pulse0_position_d_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_pulse0_start_d:13",
              "H Pulse 0 Start D (minimum -=PS_=-H_PULSE0_END_C+1)",
              13, old_value_t.h_pulse0_start_d, new_value_t.h_pulse0_start_d };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: h_pulse0_end_d:13",
              "H Pulse 0 End D (minimum -=PS_=-H_PULSE0_START_D+1)",
              13, old_value_t.h_pulse0_end_d, new_value_t.h_pulse0_end_d };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 0 Position D";
}

#define DISP_H_PULSE1_CONTROL_OFFSET 0x410
#define DISP_H_PULSE1_CONTROL_UNDEFMASK 0xFFFFF027
union disp_h_pulse1_control_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int h_pulse1_mode:1;       /* H Pulse 1 Mode 0= Normal mode 1= Single-clock mode 0 = NORMAL 1 = ONE_CLOCK */
        unsigned int h_pulse1_polarity:1;   /* H Pulse 1 Polarity. Polarity adjustment is done before the vertical qualifier is applied 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int h_pulse1_v_qual:2;     /* H Pulse 1 Vertical Qualifier 0= always running 2= run during vertical active area 3= run during vertical active plus 1 line 0 = ALWAYS 2 = VACTIVE 3 = VACTIVE1 */
        unsigned int h_pulse1_last:4;       /* H Pulse 1 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position 6= end on Start D position 7= end on End D position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C 6 = START_D 7 = END_D */
        unsigned int undefined_bits_12_31:20;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse1_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse1_control_u old_value_t = { .reg32 = value };
    const disp_h_pulse1_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_2:3", "", 3, old_value_t.undefined_bits_0_2, new_value_t.undefined_bits_0_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: h_pulse1_mode:1",
              "H Pulse 1 Mode\n0= Normal mode\n1= Single-clock mode\n0 = NORMAL\n1 = ONE_CLOCK",
              1, old_value_t.h_pulse1_mode, new_value_t.h_pulse1_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "04: h_pulse1_polarity:1",
              "H Pulse 1 Polarity. Polarity adjustment is done before the vertical qualifier is applied\n0 = HIGH\n1 = LOW",
              1, old_value_t.h_pulse1_polarity, new_value_t.h_pulse1_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: h_pulse1_v_qual:2",
              "H Pulse 1 Vertical Qualifier\n0= always running\n2= run during vertical active area\n3= run during vertical active plus 1 line\n0 = ALWAYS\n2 = VACTIVE\n3 = VACTIVE1",
              2, old_value_t.h_pulse1_v_qual, new_value_t.h_pulse1_v_qual };
    m_bit_details_model.bits.append(entry);
    entry = { "08: h_pulse1_last:4",
              "H Pulse 1 Last point\n0= end on Start A position\n1= end on End A position\n2= end on Start B position\n3= end on End B position\n4= end on Start C position\n5= end on End C position\n6= end on Start D position\n7= end on End D position others= reserved\n0 = START_A\n1 = END_A\n2 = START_B\n3 = END_B\n4 = START_C\n5 = END_C\n6 = START_D\n7 = END_D",
              4, old_value_t.h_pulse1_last, new_value_t.h_pulse1_last };
    m_bit_details_model.bits.append(entry);
    entry = { "12: undefined_bits_12_31:20", "", 20, old_value_t.undefined_bits_12_31, new_value_t.undefined_bits_12_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 1 Control\nHorizontal pulse 1 is programmable pulse that repeats every line.\nIn the NORMAL mode, this signal can have several pulses (A to D) per line with programmable width as defined by the pairs of start and end positions. The pulses must not overlap and must occur in sequence: pulse A, then pulse B, etc. In this case, the Enable field must be set to one of the End position. If the Enable field is set to one of the Start position then the pulse generator will stop as if the Enable field is set to the previous End position. If Enable field is set to Start A position then no pulse is generated.\nIn the ONE_CLOCK mode this signal can have up to twice the number of pulses per line with each pulse having a width of 1 pixel clock. In this mode, the position of the one-clock pulses correspond to the enabled Start and End positions.\nRegardless of the mode, the pulse generator processes the pairs of start and end position sequentially in the order of: Start A, End A, Start B, End B, etc.\nSo these start/end positions should be programmed in increasing order. If any of the positions are programmed in non-increasing order (has invalid value) then the pulse generator will stop at the last valid position.\nPolarity adjustment is made prior to V display qualification. This register specifies options for Horizontal pulse 1.";
}

#define DISP_H_PULSE1_POSITION_A_OFFSET 0x411
#define DISP_H_PULSE1_POSITION_A_UNDEFMASK 0xE000E000
union disp_h_pulse1_position_a_u {
    struct {
        unsigned int h_pulse1_start_a:13;   /* H Pulse 1 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse1_end_a:13;     /* H Pulse 1 End A (minimum -=PS_=-H_PULSE1_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse1_position_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse1_position_a_u old_value_t = { .reg32 = value };
    const disp_h_pulse1_position_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_pulse1_start_a:13",
              "H Pulse 1 Start A (minimum 0)",
              13, old_value_t.h_pulse1_start_a, new_value_t.h_pulse1_start_a };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: h_pulse1_end_a:13",
              "H Pulse 1 End A (minimum -=PS_=-H_PULSE1_START_A+1)",
              13, old_value_t.h_pulse1_end_a, new_value_t.h_pulse1_end_a };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 1 Position A";
}

#define DISP_H_PULSE1_POSITION_B_OFFSET 0x412
#define DISP_H_PULSE1_POSITION_B_UNDEFMASK 0xE000E000
union disp_h_pulse1_position_b_u {
    struct {
        unsigned int h_pulse1_start_b:13;   /* H Pulse 1 Start B (minimum -=PS_=-H_PULSE1_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse1_end_b:13;     /* H Pulse 1 End B (minimum -=PS_=-H_PULSE1_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse1_position_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse1_position_b_u old_value_t = { .reg32 = value };
    const disp_h_pulse1_position_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_pulse1_start_b:13",
              "H Pulse 1 Start B (minimum -=PS_=-H_PULSE1_END_A+1)",
              13, old_value_t.h_pulse1_start_b, new_value_t.h_pulse1_start_b };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: h_pulse1_end_b:13",
              "H Pulse 1 End B (minimum -=PS_=-H_PULSE1_START_B+1)",
              13, old_value_t.h_pulse1_end_b, new_value_t.h_pulse1_end_b };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 1 Position B";
}

#define DISP_H_PULSE1_POSITION_C_OFFSET 0x413
#define DISP_H_PULSE1_POSITION_C_UNDEFMASK 0xE000E000
union disp_h_pulse1_position_c_u {
    struct {
        unsigned int h_pulse1_start_c:13;   /* H Pulse 1 Start C (minimum -=PS_=-H_PULSE1_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse1_end_c:13;     /* H Pulse 1 End C (minimum -=PS_=-H_PULSE1_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse1_position_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse1_position_c_u old_value_t = { .reg32 = value };
    const disp_h_pulse1_position_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_pulse1_start_c:13",
              "H Pulse 1 Start C (minimum -=PS_=-H_PULSE1_END_B+1)",
              13, old_value_t.h_pulse1_start_c, new_value_t.h_pulse1_start_c };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: h_pulse1_end_c:13",
              "H Pulse 1 End C (minimum -=PS_=-H_PULSE1_START_C+1)",
              13, old_value_t.h_pulse1_end_c, new_value_t.h_pulse1_end_c };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 1 Position C";
}

#define DISP_H_PULSE1_POSITION_D_OFFSET 0x414
#define DISP_H_PULSE1_POSITION_D_UNDEFMASK 0xE000E000
union disp_h_pulse1_position_d_u {
    struct {
        unsigned int h_pulse1_start_d:13;   /* H Pulse 1 Start D (minimum -=PS_=-H_PULSE1_END_C+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse1_end_d:13;     /* H Pulse 1 End D (minimum -=PS_=-H_PULSE1_START_D+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse1_position_d_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse1_position_d_u old_value_t = { .reg32 = value };
    const disp_h_pulse1_position_d_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_pulse1_start_d:13",
              "H Pulse 1 Start D (minimum -=PS_=-H_PULSE1_END_C+1)",
              13, old_value_t.h_pulse1_start_d, new_value_t.h_pulse1_start_d };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: h_pulse1_end_d:13",
              "H Pulse 1 End D (minimum -=PS_=-H_PULSE1_START_D+1)",
              13, old_value_t.h_pulse1_end_d, new_value_t.h_pulse1_end_d };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 1 Position D";
}

#define DISP_H_PULSE2_CONTROL_OFFSET 0x415
#define DISP_H_PULSE2_CONTROL_UNDEFMASK 0xFFFFF027
union disp_h_pulse2_control_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int h_pulse2_mode:1;       /* H Pulse 2 Mode 0= Normal mode 1= Single-clock mode 0 = NORMAL 1 = ONE_CLOCK */
        unsigned int h_pulse2_polarity:1;   /* H Pulse 2 Polarity. Polarity adjustment is done before the vertical qualifier is applied 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int h_pulse2_v_qual:2;     /* H Pulse 2 Vertical Qualifier 0= always running 2= run during vertical active area 3= run during vertical active plus 1 line 0 = ALWAYS 2 = VACTIVE 3 = VACTIVE1 */
        unsigned int h_pulse2_last:4;       /* H Pulse 2 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position 6= end on Start D position 7= end on End D position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C 6 = START_D 7 = END_D */
        unsigned int undefined_bits_12_31:20;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse2_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse2_control_u old_value_t = { .reg32 = value };
    const disp_h_pulse2_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_2:3", "", 3, old_value_t.undefined_bits_0_2, new_value_t.undefined_bits_0_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: h_pulse2_mode:1",
              "H Pulse 2 Mode\n0= Normal mode\n1= Single-clock mode\n0 = NORMAL\n1 = ONE_CLOCK",
              1, old_value_t.h_pulse2_mode, new_value_t.h_pulse2_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "04: h_pulse2_polarity:1",
              "H Pulse 2 Polarity. Polarity adjustment is done before the vertical qualifier is applied\n0 = HIGH\n1 = LOW",
              1, old_value_t.h_pulse2_polarity, new_value_t.h_pulse2_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: h_pulse2_v_qual:2",
              "H Pulse 2 Vertical Qualifier\n0= always running\n2= run during vertical active area\n3= run during vertical active plus 1 line\n0 = ALWAYS\n2 = VACTIVE\n3 = VACTIVE1",
              2, old_value_t.h_pulse2_v_qual, new_value_t.h_pulse2_v_qual };
    m_bit_details_model.bits.append(entry);
    entry = { "08: h_pulse2_last:4",
              "H Pulse 2 Last point\n0= end on Start A position\n1= end on End A position\n2= end on Start B position\n3= end on End B position\n4= end on Start C position\n5= end on End C position\n6= end on Start D position\n7= end on End D position others= reserved\n0 = START_A\n1 = END_A\n2 = START_B\n3 = END_B\n4 = START_C\n5 = END_C\n6 = START_D\n7 = END_D",
              4, old_value_t.h_pulse2_last, new_value_t.h_pulse2_last };
    m_bit_details_model.bits.append(entry);
    entry = { "12: undefined_bits_12_31:20", "", 20, old_value_t.undefined_bits_12_31, new_value_t.undefined_bits_12_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 2 Control\nHorizontal pulse 2 is programmable pulse that repeats every line.\nIn the NORMAL mode, this signal can have several pulses (A to D) per line with programmable width as defined by the pairs of start and end positions. The pulses must not overlap and must occur in sequence: pulse A, then pulse B, etc. In this case, the Enable field must be set to one of the End position. If the Enable field is set to one of the Start position then the pulse generator will stop as if the Enable field is set to the previous End position. If Enable field is set to Start A position then no pulse is generated.\nIn the ONE_CLOCK mode this signal can have up to twice the number of pulses per line with each pulse having a width of 1 pixel clock. In this mode, the position of the one-clock pulses correspond to the enabled Start and End positions.\nRegardless of the mode, the pulse generator processes the pairs of start and end position sequentially in the order of: Start A, End A, Start B, End B, etc.\nSo these start/end positions should be programmed in increasing order. If any of the positions are programmed in non-increasing order (has invalid value) then the pulse generator will stop at the last valid position.\nPolarity adjustment is made prior to V display qualification. This register specifies options for Horizontal pulse 2.";
}

#define DISP_H_PULSE2_POSITION_A_OFFSET 0x416
#define DISP_H_PULSE2_POSITION_A_UNDEFMASK 0xE000E000
union disp_h_pulse2_position_a_u {
    struct {
        unsigned int h_pulse2_start_a:13;   /* H Pulse 2 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse2_end_a:13;     /* H Pulse 2 End A (minimum -=PS_=-H_PULSE2_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse2_position_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse2_position_a_u old_value_t = { .reg32 = value };
    const disp_h_pulse2_position_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_pulse2_start_a:13",
              "H Pulse 2 Start A (minimum 0)",
              13, old_value_t.h_pulse2_start_a, new_value_t.h_pulse2_start_a };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: h_pulse2_end_a:13",
              "H Pulse 2 End A (minimum -=PS_=-H_PULSE2_START_A+1)",
              13, old_value_t.h_pulse2_end_a, new_value_t.h_pulse2_end_a };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 2 Position A";
}

#define DISP_H_PULSE2_POSITION_B_OFFSET 0x417
#define DISP_H_PULSE2_POSITION_B_UNDEFMASK 0xE000E000
union disp_h_pulse2_position_b_u {
    struct {
        unsigned int h_pulse2_start_b:13;   /* H Pulse 2 Start B (minimum -=PS_=-H_PULSE2_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse2_end_b:13;     /* H Pulse 2 End B (minimum -=PS_=-H_PULSE2_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse2_position_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse2_position_b_u old_value_t = { .reg32 = value };
    const disp_h_pulse2_position_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_pulse2_start_b:13",
              "H Pulse 2 Start B (minimum -=PS_=-H_PULSE2_END_A+1)",
              13, old_value_t.h_pulse2_start_b, new_value_t.h_pulse2_start_b };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: h_pulse2_end_b:13",
              "H Pulse 2 End B (minimum -=PS_=-H_PULSE2_START_B+1)",
              13, old_value_t.h_pulse2_end_b, new_value_t.h_pulse2_end_b };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 2 position B";
}

#define DISP_H_PULSE2_POSITION_C_OFFSET 0x418
#define DISP_H_PULSE2_POSITION_C_UNDEFMASK 0xE000E000
union disp_h_pulse2_position_c_u {
    struct {
        unsigned int h_pulse2_start_c:13;   /* H Pulse 2 Start C (minimum -=PS_=-H_PULSE2_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse2_end_c:13;     /* H Pulse 2 End C (minimum -=PS_=-H_PULSE2_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse2_position_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse2_position_c_u old_value_t = { .reg32 = value };
    const disp_h_pulse2_position_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_pulse2_start_c:13",
              "H Pulse 2 Start C (minimum -=PS_=-H_PULSE2_END_B+1)",
              13, old_value_t.h_pulse2_start_c, new_value_t.h_pulse2_start_c };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: h_pulse2_end_c:13",
              "H Pulse 2 End C (minimum -=PS_=-H_PULSE2_START_C+1)",
              13, old_value_t.h_pulse2_end_c, new_value_t.h_pulse2_end_c };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 2 Position C";
}

#define DISP_H_PULSE2_POSITION_D_OFFSET 0x419
#define DISP_H_PULSE2_POSITION_D_UNDEFMASK 0xE000E000
union disp_h_pulse2_position_d_u {
    struct {
        unsigned int h_pulse2_start_d:13;   /* H Pulse 2 Start D (minimum -=PS_=-H_PULSE2_END_C+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse2_end_d:13;     /* H Pulse 2 End D (minimum -=PS_=-H_PULSE2_START_D+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_h_pulse2_position_d_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_h_pulse2_position_d_u old_value_t = { .reg32 = value };
    const disp_h_pulse2_position_d_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_pulse2_start_d:13",
              "H Pulse 2 Start D (minimum -=PS_=-H_PULSE2_END_C+1)",
              13, old_value_t.h_pulse2_start_d, new_value_t.h_pulse2_start_d };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: h_pulse2_end_d:13",
              "H Pulse 2 End D (minimum -=PS_=-H_PULSE2_START_D+1)",
              13, old_value_t.h_pulse2_end_d, new_value_t.h_pulse2_end_d };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "H Pulse 2 Position D";
}

#define DISP_V_PULSE0_CONTROL_OFFSET 0x41A
#define DISP_V_PULSE0_CONTROL_UNDEFMASK 0xE000F02F
union disp_v_pulse0_control_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int v_pulse0_polarity:1;   /* V Pulse 0 Polarity 0= High 1= Low 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int v_pulse0_delay:2;      /* V Pulse 0 Delay 0= no delay 1= 1-line delay 2= 2-line delay 3= reserved 0 = NODELAY 1 = DELAY1 2 = DELAY2 */
        unsigned int v_pulse0_last:4;       /* V Pulse 0 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C */
        unsigned int undefined_bits_12_15:4;
        unsigned int v_pulse0_h_position:13;/* V Pulse 0 Horizontal Position This parameter specifies the position where V Pulse 0 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_v_pulse0_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_v_pulse0_control_u old_value_t = { .reg32 = value };
    const disp_v_pulse0_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_3:4", "", 4, old_value_t.undefined_bits_0_3, new_value_t.undefined_bits_0_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: v_pulse0_polarity:1",
              "V Pulse 0 Polarity\n0= High\n1= Low\n0 = HIGH\n1 = LOW",
              1, old_value_t.v_pulse0_polarity, new_value_t.v_pulse0_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: v_pulse0_delay:2",
              "V Pulse 0 Delay\n0= no delay\n1= 1-line delay\n2= 2-line delay\n3= reserved\n0 = NODELAY\n1 = DELAY1\n2 = DELAY2",
              2, old_value_t.v_pulse0_delay, new_value_t.v_pulse0_delay };
    m_bit_details_model.bits.append(entry);
    entry = { "08: v_pulse0_last:4",
              "V Pulse 0 Last point\n0= end on Start A position\n1= end on End A position\n2= end on Start B position\n3= end on End B position\n4= end on Start C position\n5= end on End C position others= reserved\n0 = START_A\n1 = END_A\n2 = START_B\n3 = END_B\n4 = START_C\n5 = END_C",
              4, old_value_t.v_pulse0_last, new_value_t.v_pulse0_last };
    m_bit_details_model.bits.append(entry);
    entry = { "12: undefined_bits_12_15:4", "", 4, old_value_t.undefined_bits_12_15, new_value_t.undefined_bits_12_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_pulse0_h_position:13",
              "V Pulse 0 Horizontal Position This parameter specifies the position where V Pulse 0 can toggle with respect to H reference point",
              13, old_value_t.v_pulse0_h_position, new_value_t.v_pulse0_h_position };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "V Pulse 0 Control\nVertical pulse 0 is programmable pulse that repeats every frame.\nThis signal can have several pulses (A to C) per frame with programmable width as defined by the pairs of start and end positions. The pulses must not overlap and must occur in sequence: pulse A, then pulse B, etc. In this case, the Enable field must be set to one of the End position. If the Enable field is set to one of the Start position then the pulse generator will stop as if the Enable field is set to the previous End position. If Enable field is set to Start A position then no pulse is generated.\nThe pulse generator processes the pairs of start and end position sequentially in the order of: Start A, End A, Start B, End B, etc. So these start/end positions should be programmed in increasing order. If any of the positions are programmed in non-increasing order (has invalid value) then the pulse generator will stop at the last valid position.\nThis register specifies options for Vertical pulse 0.";
}

#define DISP_V_PULSE0_POSITION_A_OFFSET 0x41B
#define DISP_V_PULSE0_POSITION_A_UNDEFMASK 0xE000E000
union disp_v_pulse0_position_a_u {
    struct {
        unsigned int v_pulse0_start_a:13;   /* V Pulse 0 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse0_end_a:13;     /* V Pulse 0 End A (minimum -=PS_=-V_PULSE0_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_v_pulse0_position_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_v_pulse0_position_a_u old_value_t = { .reg32 = value };
    const disp_v_pulse0_position_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_pulse0_start_a:13",
              "V Pulse 0 Start A (minimum 0)",
              13, old_value_t.v_pulse0_start_a, new_value_t.v_pulse0_start_a };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_pulse0_end_a:13",
              "V Pulse 0 End A (minimum -=PS_=-V_PULSE0_START_A+1)",
              13, old_value_t.v_pulse0_end_a, new_value_t.v_pulse0_end_a };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "V Pulse 0 Position A";
}

#define DISP_V_PULSE0_POSITION_B_OFFSET 0x41C
#define DISP_V_PULSE0_POSITION_B_UNDEFMASK 0xE000E000
union disp_v_pulse0_position_b_u {
    struct {
        unsigned int v_pulse0_start_b:13;   /* V Pulse 0 Start B (minimum -=PS_=-V_PULSE0_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse0_end_b:13;     /* V Pulse 0 End B (minimum -=PS_=-V_PULSE0_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_v_pulse0_position_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_v_pulse0_position_b_u old_value_t = { .reg32 = value };
    const disp_v_pulse0_position_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_pulse0_start_b:13",
              "V Pulse 0 Start B (minimum -=PS_=-V_PULSE0_END_A+1)",
              13, old_value_t.v_pulse0_start_b, new_value_t.v_pulse0_start_b };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_pulse0_end_b:13",
              "V Pulse 0 End B (minimum -=PS_=-V_PULSE0_START_B+1)",
              13, old_value_t.v_pulse0_end_b, new_value_t.v_pulse0_end_b };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "V Pulse 0 Position B";
}

#define DISP_V_PULSE0_POSITION_C_OFFSET 0x41D
#define DISP_V_PULSE0_POSITION_C_UNDEFMASK 0xE000E000
union disp_v_pulse0_position_c_u {
    struct {
        unsigned int v_pulse0_start_c:13;   /* V Pulse 0 Start C (minimum -=PS_=-V_PULSE0_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse0_end_c:13;     /* V Pulse 0 End C (minimum -=PS_=-V_PULSE0_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_v_pulse0_position_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_v_pulse0_position_c_u old_value_t = { .reg32 = value };
    const disp_v_pulse0_position_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_pulse0_start_c:13",
              "V Pulse 0 Start C (minimum -=PS_=-V_PULSE0_END_B+1)",
              13, old_value_t.v_pulse0_start_c, new_value_t.v_pulse0_start_c };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_pulse0_end_c:13",
              "V Pulse 0 End C (minimum -=PS_=-V_PULSE0_START_C+1)",
              13, old_value_t.v_pulse0_end_c, new_value_t.v_pulse0_end_c };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "V Pulse 0 Position C";
}

#define DISP_V_PULSE1_CONTROL_OFFSET 0x41E
#define DISP_V_PULSE1_CONTROL_UNDEFMASK 0xE000F02F
union disp_v_pulse1_control_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int v_pulse1_polarity:1;   /* V pulse 1 Polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int v_pulse1_delay:2;      /* V pulse 1 Delay 0= no delay 1= 1-line delay 2= 2-line delay 3= reserved 0 = NODELAY 1 = DELAY1 2 = DELAY2 */
        unsigned int v_pulse1_last:4;       /* V pulse 1 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C */
        unsigned int undefined_bits_12_15:4;
        unsigned int v_pulse1_h_position:13;/* V Pulse 1 Horizontal Position This parameter specifies the position where V Pulse 1 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_v_pulse1_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_v_pulse1_control_u old_value_t = { .reg32 = value };
    const disp_v_pulse1_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_3:4", "", 4, old_value_t.undefined_bits_0_3, new_value_t.undefined_bits_0_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: v_pulse1_polarity:1",
              "V pulse 1 Polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.v_pulse1_polarity, new_value_t.v_pulse1_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: v_pulse1_delay:2",
              "V pulse 1 Delay\n0= no delay\n1= 1-line delay\n2= 2-line delay\n3= reserved\n0 = NODELAY\n1 = DELAY1\n2 = DELAY2",
              2, old_value_t.v_pulse1_delay, new_value_t.v_pulse1_delay };
    m_bit_details_model.bits.append(entry);
    entry = { "08: v_pulse1_last:4",
              "V pulse 1 Last point\n0= end on Start A position\n1= end on End A position\n2= end on Start B position\n3= end on End B position\n4= end on Start C position\n5= end on End C position others= reserved\n0 = START_A\n1 = END_A\n2 = START_B\n3 = END_B\n4 = START_C\n5 = END_C",
              4, old_value_t.v_pulse1_last, new_value_t.v_pulse1_last };
    m_bit_details_model.bits.append(entry);
    entry = { "12: undefined_bits_12_15:4", "", 4, old_value_t.undefined_bits_12_15, new_value_t.undefined_bits_12_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_pulse1_h_position:13",
              "V Pulse 1 Horizontal Position This parameter specifies the position where V Pulse 1 can toggle with respect to H reference point",
              13, old_value_t.v_pulse1_h_position, new_value_t.v_pulse1_h_position };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "V pulse 1 Control\nVertical pulse 1 is programmable pulse that repeats every frame.  This signal can have several pulses (A to C) per frame with programmable width as defined by the pairs of start and end positions. The pulses must not overlap and must occur in sequence: pulse A, then pulse B, etc.\nIn this case, the Enable field must be set to one of the End position. If the Enable field is set to one of the Start position then the pulse generator will stop as if the Enable field is set to the previous End position. If Enable field is set to Start A position then no pulse is generated.\nThe pulse generator processes the pairs of start and end position sequentially in the order of: Start A, End A, Start B, End B, etc.\nSo these start/end positions should be programmed in increasing order. If any of the positions are programmed in non-increasing order (has invalid value) then the pulse generator will stop at the last valid position.\nThis register specifies options for Vertical pulse 1.";
}

#define DISP_V_PULSE1_POSITION_A_OFFSET 0x41F
#define DISP_V_PULSE1_POSITION_A_UNDEFMASK 0xE000E000
union disp_v_pulse1_position_a_u {
    struct {
        unsigned int v_pulse1_start_a:13;   /* V Pulse 1 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse1_end_a:13;     /* V Pulse 1 End A (minimum -=PS_=-V_PULSE1_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_v_pulse1_position_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_v_pulse1_position_a_u old_value_t = { .reg32 = value };
    const disp_v_pulse1_position_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_pulse1_start_a:13",
              "V Pulse 1 Start A (minimum 0)",
              13, old_value_t.v_pulse1_start_a, new_value_t.v_pulse1_start_a };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_pulse1_end_a:13",
              "V Pulse 1 End A (minimum -=PS_=-V_PULSE1_START_A+1)",
              13, old_value_t.v_pulse1_end_a, new_value_t.v_pulse1_end_a };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "V Pulse 1 Position A";
}

#define DISP_V_PULSE1_POSITION_B_OFFSET 0x420
#define DISP_V_PULSE1_POSITION_B_UNDEFMASK 0xE000E000
union disp_v_pulse1_position_b_u {
    struct {
        unsigned int v_pulse1_start_b:13;   /* V Pulse 1 Start B (minimum -=PS_=-V_PULSE1_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse1_end_b:13;     /* V Pulse 1 End B (minimum -=PS_=-V_PULSE1_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_v_pulse1_position_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_v_pulse1_position_b_u old_value_t = { .reg32 = value };
    const disp_v_pulse1_position_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_pulse1_start_b:13",
              "V Pulse 1 Start B (minimum -=PS_=-V_PULSE1_END_A+1)",
              13, old_value_t.v_pulse1_start_b, new_value_t.v_pulse1_start_b };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_pulse1_end_b:13",
              "V Pulse 1 End B (minimum -=PS_=-V_PULSE1_START_B+1)",
              13, old_value_t.v_pulse1_end_b, new_value_t.v_pulse1_end_b };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "V Pulse 1 Position B";
}

#define DISP_V_PULSE1_POSITION_C_OFFSET 0x421
#define DISP_V_PULSE1_POSITION_C_UNDEFMASK 0xE000E000
union disp_v_pulse1_position_c_u {
    struct {
        unsigned int v_pulse1_start_c:13;   /* V Pulse 1 Start C (minimum -=PS_=-V_PULSE1_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse1_end_c:13;     /* V Pulse 1 End C (minimum -=PS_=-V_PULSE1_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_v_pulse1_position_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_v_pulse1_position_c_u old_value_t = { .reg32 = value };
    const disp_v_pulse1_position_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_pulse1_start_c:13",
              "V Pulse 1 Start C (minimum -=PS_=-V_PULSE1_END_B+1)",
              13, old_value_t.v_pulse1_start_c, new_value_t.v_pulse1_start_c };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_pulse1_end_c:13",
              "V Pulse 1 End C (minimum -=PS_=-V_PULSE1_START_C+1)",
              13, old_value_t.v_pulse1_end_c, new_value_t.v_pulse1_end_c };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "V Pulse 1 Position C";
}

#define DISP_V_PULSE2_CONTROL_OFFSET 0x422
#define DISP_V_PULSE2_CONTROL_UNDEFMASK 0xE000FEEF
union disp_v_pulse2_control_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int v_pulse2_polarity:1;   /* V pulse 2 Polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_5_7:3;
        unsigned int v_pulse2_last:1;       /* V pulse 2 Last point 0= end on Start A position 1= end on End A position others= reserved 0 = START_A 1 = END_A */
        unsigned int undefined_bits_9_15:7;
        unsigned int v_pulse2_h_position:13;/* V Pulse 2 Horizontal Position This parameter specifies the position where V Pulse 2 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_v_pulse2_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_v_pulse2_control_u old_value_t = { .reg32 = value };
    const disp_v_pulse2_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_3:4", "", 4, old_value_t.undefined_bits_0_3, new_value_t.undefined_bits_0_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: v_pulse2_polarity:1",
              "V pulse 2 Polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.v_pulse2_polarity, new_value_t.v_pulse2_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: v_pulse2_last:1",
              "V pulse 2 Last point\n0= end on Start A position\n1= end on End A position others= reserved\n0 = START_A\n1 = END_A",
              1, old_value_t.v_pulse2_last, new_value_t.v_pulse2_last };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_pulse2_h_position:13",
              "V Pulse 2 Horizontal Position This parameter specifies the position where V Pulse 2 can toggle with respect to H reference point",
              13, old_value_t.v_pulse2_h_position, new_value_t.v_pulse2_h_position };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "V pulse 2 Control\nVertical pulse 2 is programmable pulse that repeats every frame.\nThis signal can have one pulse (A) per frame with programmable width as defined by the pair of start and end positions.\nIn this case, the Enable field must be set to one of the End position. If the Enable field is set to one of the Start position then the pulse generator will stop as if the Enable field is set to the previous End position. If Enable field is set to Start A position then no pulse is generated.\nSo these start/end positions should be programmed in increasing order. If any of the positions are programmed in non-increasing order (has invalid value) then the pulse generator will stop at the last valid position.\nThis register specifies options for Vertical pulse 2.";
}

#define DISP_V_PULSE2_POSITION_A_OFFSET 0x423
#define DISP_V_PULSE2_POSITION_A_UNDEFMASK 0xE000E000
union disp_v_pulse2_position_a_u {
    struct {
        unsigned int v_pulse2_start_a:13;   /* V Pulse 2 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse2_end_a:13;     /* V Pulse 2 End A (minimum -=PS_=-V_PULSE2_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_v_pulse2_position_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_v_pulse2_position_a_u old_value_t = { .reg32 = value };
    const disp_v_pulse2_position_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_pulse2_start_a:13",
              "V Pulse 2 Start A (minimum 0)",
              13, old_value_t.v_pulse2_start_a, new_value_t.v_pulse2_start_a };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_pulse2_end_a:13",
              "V Pulse 2 End A (minimum -=PS_=-V_PULSE2_START_A+1)",
              13, old_value_t.v_pulse2_end_a, new_value_t.v_pulse2_end_a };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " V Pulse 2 Position A";
}

#define DISP_V_PULSE3_CONTROL_OFFSET 0x424
#define DISP_V_PULSE3_CONTROL_UNDEFMASK 0xE000FEEF
union disp_v_pulse3_control_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int v_pulse3_polarity:1;   /* V pulse 3 Polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_5_7:3;
        unsigned int v_pulse3_last:1;       /* V pulse 3 Last point 0= end on Start A position 1= end on End A position others= reserved 0 = START_A 1 = END_A */
        unsigned int undefined_bits_9_15:7;
        unsigned int v_pulse3_h_position:13;/* V Pulse 3 Horizontal Position This parameter specifies the position where V Pulse 3 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_v_pulse3_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_v_pulse3_control_u old_value_t = { .reg32 = value };
    const disp_v_pulse3_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_3:4", "", 4, old_value_t.undefined_bits_0_3, new_value_t.undefined_bits_0_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: v_pulse3_polarity:1",
              "V pulse 3 Polarity \n0 = HIGH\n1 = LOW",
              1, old_value_t.v_pulse3_polarity, new_value_t.v_pulse3_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: v_pulse3_last:1",
              "V pulse 3 Last point\n0= end on Start A position\n1= end on End A position others= reserved\n0 = START_A\n1 = END_A",
              1, old_value_t.v_pulse3_last, new_value_t.v_pulse3_last };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_pulse3_h_position:13",
              "V Pulse 3 Horizontal Position This parameter specifies the position where V Pulse 3 can toggle with respect to H reference point",
              13, old_value_t.v_pulse3_h_position, new_value_t.v_pulse3_h_position };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " V pulse 3 Control\nVertical pulse 3 is programmable pulse that repeats every frame.\nThis signal can have one pulse (A) per frame with programmable width as defined by the pair of start and end positions.\nIn this case, the Enable field must be set to one of the End position. If the Enable field is set to one of the Start position then the pulse generator will stop as if the Enable field is set to the previous End position. If Enable field is set to Start A position then no pulse is generated.\nSo these start/end positions should be programmed in increasing order. If any of the positions are programmed in non-increasing order (has invalid value) then the pulse generator will stop at the last valid position.\nThis register specifies options for Vertical pulse 2.";
}

#define DISP_V_PULSE3_POSITION_A_OFFSET 0x425
#define DISP_V_PULSE3_POSITION_A_UNDEFMASK 0xE000E000
union disp_v_pulse3_position_a_u {
    struct {
        unsigned int v_pulse3_start_a:13;   /* V Pulse 3 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse3_end_a:13;     /* V Pulse 3 End A (minimum -=PS_=-V_PULSE3_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_v_pulse3_position_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_v_pulse3_position_a_u old_value_t = { .reg32 = value };
    const disp_v_pulse3_position_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_pulse3_start_a:13",
              "V Pulse 3 Start A (minimum 0)",
              13, old_value_t.v_pulse3_start_a, new_value_t.v_pulse3_start_a };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_pulse3_end_a:13",
              "V Pulse 3 End A (minimum -=PS_=-V_PULSE3_START_A+1)",
              13, old_value_t.v_pulse3_end_a, new_value_t.v_pulse3_end_a };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "V Pulse 3 Position A";
}

#define DISP_M0_CONTROL_OFFSET 0x426
#define DISP_M0_CONTROL_UNDEFMASK 0xE000E00C
union disp_m0_control_u {
    struct {
        unsigned int m0_clock_select:2;     /* M0 Clock Select 00= pixel clock (for diagnostic) 01= reserved 10= line clock 11= frame clock 0 = PCLK 2 = LCLK 3 = FCLK */
        unsigned int undefined_bits_2_3:2;
        unsigned int m0_phase_control:2;    /* M0 Phase Control 00= free-running 01= reserved 10= reset at beginning of vertical active display 11= invert at beginning of frame This should be set to free-running if frame clock is used. 0 = FREE_RUN 2 = VACTIVE_RESTART 3 = FRAME_INVERT */
        unsigned int m0_phase_reset:1;      /* M0 Phase Reset This bit is effective only when M0 is not free running. 0= frequency (phase) counter is not reset 1= frequency (phase) counter is reset at beginning of vertical active display if phase control is set to VACTIVE_RESTART or at beginning of frame if phase control is set to FRAME_INVERT 0 = DISABLE 1 = ENABLE */
        unsigned int m0_polarity:1;         /* M0 Polarity. Polarity adjustment is applied last after phase control is applied. 0 = HIGH 1 = LOW */
        unsigned int m0_period:5;           /* M0 Period This should be program to the half of the desired M0 period (in lines) minus 1 */
        unsigned int undefined_bits_13_15:3;
        unsigned int m0_h_position:13;      /* M0 Horizontal Position This parameter specifies the position where M0 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_m0_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_m0_control_u old_value_t = { .reg32 = value };
    const disp_m0_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: m0_clock_select:2",
              "M0 Clock Select\n00= pixel clock (for diagnostic)\n01= reserved\n10= line clock\n11= frame clock\n0 = PCLK\n2 = LCLK\n3 = FCLK",
              2, old_value_t.m0_clock_select, new_value_t.m0_clock_select };
    m_bit_details_model.bits.append(entry);
    entry = { "02: undefined_bits_2_3:2", "", 2, old_value_t.undefined_bits_2_3, new_value_t.undefined_bits_2_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: m0_phase_control:2",
              "M0 Phase Control\n00= free-running\n01= reserved\n10= reset at beginning of vertical active display\n11= invert at beginning of frame This should be set to free-running if frame clock is used.\n0 = FREE_RUN\n2 = VACTIVE_RESTART\n3 = FRAME_INVERT",
              2, old_value_t.m0_phase_control, new_value_t.m0_phase_control };
    m_bit_details_model.bits.append(entry);
    entry = { "06: m0_phase_reset:1",
              "M0 Phase Reset This bit is effective only when M0 is not free running.\n0= frequency (phase) counter is not reset\n1= frequency (phase) counter is reset at beginning of vertical active display if phase control is set to VACTIVE_RESTART or at beginning of frame if phase control is set to FRAME_INVERT\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.m0_phase_reset, new_value_t.m0_phase_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "07: m0_polarity:1",
              "M0 Polarity. Polarity adjustment is applied last after phase control is applied.\n0 = HIGH\n1 = LOW",
              1, old_value_t.m0_polarity, new_value_t.m0_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "08: m0_period:5",
              "M0 Period This should be program to the half of the desired M0 period (in lines) minus 1",
              5, old_value_t.m0_period, new_value_t.m0_period };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: m0_h_position:13",
              "M0 Horizontal Position This parameter specifies the position where M0 can toggle with respect to H reference point",
              13, old_value_t.m0_h_position, new_value_t.m0_h_position };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "M0 Control\nDisplay M0 signal\nM0 signal can be generated either using a line (horizontal) or a frame (vertical) clock and it can be horizontally positioned with respect to H reference point. This signal is typically output on LCD_CS1_N pin.\nThis register specifies options for M0 signal.";
}

#define DISP_M1_CONTROL_OFFSET 0x427
#define DISP_M1_CONTROL_UNDEFMASK 0xE000E00C
union disp_m1_control_u {
    struct {
        unsigned int m1_clock_select:2;     /* M1 Clock Select 00= pixel clock (for diagnostic) 01= synchronous to M0 provided that M0 is generated using line clock. This will not work if M0 is not generated using line clock. In this case, M1 is controlled by -=PS_=-M0_PHASE_RESET and -=PS_=-M0_PERIOD, -=PS_=-M1_PHASE_CONTROL and -=PS_=-M1_POLARITY. 10= line clock 11= frame clock 0 = PCLK 1 = M0SYNC 2 = LCLK 3 = FCLK */
        unsigned int undefined_bits_2_3:2;
        unsigned int m1_phase_control:2;    /* M1 Phase Control 00= free-running 01= reserved 10= reset at beginning of vertical active display 11= invert at beginning of frame This should be set to free-running if frame clock is used. 0 = FREE_RUN 2 = VACTIVE_RESTART 3 = FRAME_INVERT */
        unsigned int m1_phase_reset:1;      /* M1 Phase Reset This bit is effective only when M1 is not free running. 0= frequency (phase) counter is not reset 1= frequency (phase) counter is reset at beginning of vertical active display if phase control is set to VACTIVE_RESTART or at beginning of frame if phase control is set to FRAME_INVERT 0 = DISABLE 1 = ENABLE */
        unsigned int m1_polarity:1;         /* M1 Polarity. Polarity adjustment is applied last after phase control is applied. 0 = HIGH 1 = LOW */
        unsigned int m1_period:5;           /* M1 Period This should be program to the half of the desired M1 period (in lines) minus 1 */
        unsigned int undefined_bits_13_15:3;
        unsigned int m1_h_position:13;      /* M1 Horizontal Position This parameter specifies the position where M0 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_m1_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_m1_control_u old_value_t = { .reg32 = value };
    const disp_m1_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: m1_clock_select:2",
              "M1 Clock Select\n00= pixel clock (for diagnostic)\n01= synchronous to M0 provided that M0 is generated using line clock. This will not work if M0 is not generated using line clock. In this case, M1 is controlled by -=PS_=-M0_PHASE_RESET and -=PS_=-M0_PERIOD, -=PS_=-M1_PHASE_CONTROL and -=PS_=-M1_POLARITY.\n10= line clock\n11= frame clock\n0 = PCLK\n1 = M0SYNC\n2 = LCLK\n3 = FCLK",
              2, old_value_t.m1_clock_select, new_value_t.m1_clock_select };
    m_bit_details_model.bits.append(entry);
    entry = { "02: undefined_bits_2_3:2", "", 2, old_value_t.undefined_bits_2_3, new_value_t.undefined_bits_2_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: m1_phase_control:2",
              "M1 Phase Control\n00= free-running\n01= reserved\n10= reset at beginning of vertical active display\n11= invert at beginning of frame This should be set to free-running if frame clock is used.\n0 = FREE_RUN\n2 = VACTIVE_RESTART\n3 = FRAME_INVERT",
              2, old_value_t.m1_phase_control, new_value_t.m1_phase_control };
    m_bit_details_model.bits.append(entry);
    entry = { "06: m1_phase_reset:1",
              "M1 Phase Reset This bit is effective only when M1 is not free running.\n0= frequency (phase) counter is not reset\n1= frequency (phase) counter is reset at beginning of vertical active display if phase control is set to VACTIVE_RESTART or at beginning of frame if phase control is set to FRAME_INVERT\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.m1_phase_reset, new_value_t.m1_phase_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "07: m1_polarity:1",
              "M1 Polarity. Polarity adjustment is applied last after phase control is applied.\n0 = HIGH\n1 = LOW",
              1, old_value_t.m1_polarity, new_value_t.m1_polarity };
    m_bit_details_model.bits.append(entry);
    entry = { "08: m1_period:5",
              "M1 Period This should be program to the half of the desired M1 period (in lines) minus 1",
              5, old_value_t.m1_period, new_value_t.m1_period };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: m1_h_position:13",
              "M1 Horizontal Position This parameter specifies the position where M0 can toggle with respect to H reference point",
              13, old_value_t.m1_h_position, new_value_t.m1_h_position };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "M1 Control\nDisplay M1 signal. M1 signal can be generated either using a line (horizontal) or a frame (vertical) clock and it can be horizontally positioned with respect to H reference point. This signal is typically output on LCD_M1 pin. This register specifies options for M1 signal.";
}

#define DISP_DI_CONTROL_OFFSET 0x428
#define DISP_DI_CONTROL_UNDEFMASK 0xE000FF2C
union disp_di_control_u {
    struct {
        unsigned int di_mode:2;             /* DI signal Mode 00= DI is always low 01= DI is always high 10= DI is forced high every time M0 (before polarity adjustment) toggles from low to high; otherwise then DI toggles every line 11= DI has same frequency (phase) as M0 (before M0 polarity adjustment) */
        unsigned int undefined_bits_2_3:2;
        unsigned int pixdata_inv_select:1;  /* Pixel Data Inversion Select 0= DI signal controls pixel data inversion 1= (DI xor M0) controls pixel data inversion. 0 = DI 1 = DIXORM0 */
        unsigned int undefined_bit_5:1;
        unsigned int pixdata_inv_control:2; /* Pixel Data Inversion Control The control signal for pixel data inversion is defined by -=PS_=-PIXDATA_INV_SELECT 00= no pixel data inversion regardless of control signal state. 01= Pixels 0, 2, 4 ... are inverted if control signal is high. Pixels 1, 3, 5 ... are inverted if control signal is low. 10= Pixels 1, 3, 5 ... are inverted if control signal is high. Pixels 0, 2, 4 ... are inverted if control signal is low. 11= all pixel data is inverted if control signal is high. NOTE: Pixel data inversion is NOT supported for 2-pixel/3-clock 12-bit parallel display data format!!! 0 = NOINV 1 = EVENINV 2 = ODDINV 3 = ALLINV */
        unsigned int undefined_bits_8_15:8;
        unsigned int di_h_position:13;      /* DI signal Horizontal Position This parameter specifies the position where DI signal can toggle with respect to H reference point. It should not be programmed larger than -=PS_=-PP_H_POSITION if DI is used to control PP signal generation */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_di_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_di_control_u old_value_t = { .reg32 = value };
    const disp_di_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: di_mode:2",
              "DI signal Mode\n00= DI is always low\n01= DI is always high\n10= DI is forced high every time M0 (before polarity adjustment) toggles from low to high; otherwise then DI toggles every line\n11= DI has same frequency (phase) as M0 (before M0 polarity adjustment)",
              2, old_value_t.di_mode, new_value_t.di_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "02: undefined_bits_2_3:2", "", 2, old_value_t.undefined_bits_2_3, new_value_t.undefined_bits_2_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: pixdata_inv_select:1",
              "Pixel Data Inversion Select\n0= DI signal controls pixel data inversion 1= (DI xor M0) controls pixel data inversion.\n0 = DI\n1 = DIXORM0",
              1, old_value_t.pixdata_inv_select, new_value_t.pixdata_inv_select };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bit_5:1", "", 1, old_value_t.undefined_bit_5, new_value_t.undefined_bit_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: pixdata_inv_control:2",
              "Pixel Data Inversion Control The control signal for pixel data inversion is defined by -=PS_=-PIXDATA_INV_SELECT\n00= no pixel data inversion regardless of control signal state.\n01= Pixels 0, 2, 4 ... are inverted if control signal is high. Pixels 1, 3, 5 ... are inverted if control signal is low.\n10= Pixels 1, 3, 5 ... are inverted if control signal is high. Pixels 0, 2, 4 ... are inverted if control signal is low.\n11= all pixel data is inverted if control signal is high. NOTE: Pixel data inversion is NOT supported for 2-pixel/3-clock 12-bit parallel display data format!!!\n0 = NOINV\n1 = EVENINV\n2 = ODDINV\n3 = ALLINV",
              2, old_value_t.pixdata_inv_control, new_value_t.pixdata_inv_control };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: di_h_position:13",
              "DI signal Horizontal Position This parameter specifies the position where DI signal can toggle with respect to H reference point. It should not be programmed larger than -=PS_=-PP_H_POSITION if DI is used to control PP signal generation",
              13, old_value_t.di_h_position, new_value_t.di_h_position };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "DI Control\nDisplay Data Inversion (DI) signal generation.\nThis signal is typically needed to control data inversion for PWM panels and is typically output on LCD_D22 pin.\nHorizontal position of this signal with respect to horizontal reference point can be programmed. DI signal together with M0 may also be used to control the actual pixel data inversion.\nPixel data may be controlled by either DI only or by (DI ^ M0) as specified by -=PS_=-PIXDATA_INV_SELECT. The inversion control signal is then used to control pixel data inversion as specified by -=PS_=-PIXDATA_INV_CONTROL. Note that even if the DI signal is disabled, pixel data inversion could still occur depending on the setting of -=PS_=-PIXDATA_INV_CONTROL.\nData inversion is limited to only active area. For the purpose of pixel data inversion, DI and M0 signals are used before the corresponding horizontal positioning so that these signals are always stable during active area.\nIn case M0 signal is used to control data inversion then it should be generated using line clock. M0 polarity control is not accounted when M0 is used to generate DI signal or to control pixel data inversion.\nThis register specifies options for DI signal as well as pixel data inversion.";
}

#define DISP_PP_CONTROL_OFFSET 0x429
#define DISP_PP_CONTROL_UNDEFMASK 0xFFFF0000
union disp_pp_control_u {
    struct {
        unsigned int pp_direction:2;        /* PP Direction (incrementing or decrementing) 0= always from pulse 0 to 127 (regardless of DI signal) 1= 0 to 127 if DI=0 and 127 to 0 if DI=1 2= 127 to 0 if DI=0 and 0 to 127 if DI=1 3= always 127 to 0 regardless of DI 0 = ALWAYS_INC 1 = INC_IF_DI0 2 = DEC_IF_DI0 3 = ALWAYS_DEC */
        unsigned int pp_v_qualifier:2;      /* PP Vertical Qualifier 0= free running (not qualified) 1= V Pulse 1 qualified 2= V Pulse 2 qualified 3= V Pulse 3 qualified 0 = FREE_RUN 1 = VPULSE1 2 = VPULSE2 3 = VPULSE3 */
        unsigned int pp_h_delay:4;          /* PP signal Horizontal Delay (0 to 15) This parameter specifies the position where PP signal generation starts with respect to H reference point. If DI is used to generate PP signal then this parameter should not be smaller than -=PS_=-DI_H_POSITION */
        unsigned int pp_high_pulse:4;       /* PP High Pulse width (1 to 16) */
        unsigned int pp_low_pulse:4;        /* PP Low Pulse width (1 to 16) */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_pp_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_pp_control_u old_value_t = { .reg32 = value };
    const disp_pp_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pp_direction:2",
              "PP Direction (incrementing or decrementing)\n0= always from pulse 0 to 127 (regardless of DI signal)\n1= 0 to 127 if DI=0 and 127 to 0 if DI=1\n2= 127 to 0 if DI=0 and 0 to 127 if DI=1\n3= always 127 to 0 regardless of DI\n0 = ALWAYS_INC\n1 = INC_IF_DI0\n2 = DEC_IF_DI0\n3 = ALWAYS_DEC",
              2, old_value_t.pp_direction, new_value_t.pp_direction };
    m_bit_details_model.bits.append(entry);
    entry = { "02: pp_v_qualifier:2",
              "PP Vertical Qualifier\n0= free running (not qualified)\n1= V Pulse 1 qualified\n2= V Pulse 2 qualified\n3= V Pulse 3 qualified\n0 = FREE_RUN\n1 = VPULSE1\n2 = VPULSE2\n3 = VPULSE3",
              2, old_value_t.pp_v_qualifier, new_value_t.pp_v_qualifier };
    m_bit_details_model.bits.append(entry);
    entry = { "04: pp_h_delay:4",
              "PP signal Horizontal Delay (0 to 15) This parameter specifies the position where PP signal generation starts with respect to H reference point. If DI is used to generate PP signal then this parameter should not be smaller than -=PS_=-DI_H_POSITION",
              4, old_value_t.pp_h_delay, new_value_t.pp_h_delay };
    m_bit_details_model.bits.append(entry);
    entry = { "08: pp_high_pulse:4",
              "PP High Pulse width (1 to 16)",
              4, old_value_t.pp_high_pulse, new_value_t.pp_high_pulse };
    m_bit_details_model.bits.append(entry);
    entry = { "12: pp_low_pulse:4",
              "PP Low Pulse width (1 to 16)",
              4, old_value_t.pp_low_pulse, new_value_t.pp_low_pulse };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "PP Control\nDisplay Programmable Pulse (PP) signal generation\nPP signal generation logic can generate up to 128 pulses per line internally and the PP pulse select registers determines which of the 128 pulses will be output. Any of the 128 internally generated pulse can be independently selected as output if they occur within one line time.\nPP signal is typically output on LCD_D23 pin. Note that DI signal may impact PP generation as controlled by -=PS_=-PP_REVERSAL_CONTROL.\nPP signal generation may be delayed (positioned) from H reference point (line start) controlled by -=PS_=-PP_H_DELAY. Delaying PP may cause the last few internal PP pulses to overflow to the next line.\nPP is always generated using the display clock after the shift clock divider.\nThis register specifies options for PP signal.";
}

#define DISP_PP_SELECT_A_OFFSET 0x42A
#define DISP_PP_SELECT_A_UNDEFMASK 0x00000000
union disp_pp_select_a_u {
    struct {
        unsigned int pp_select_a:32;        /* PP Select bits 31 to 0 */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_pp_select_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_pp_select_a_u old_value_t = { .reg32 = value };
    const disp_pp_select_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pp_select_a:32",
              "PP Select bits 31 to 0",
              32, old_value_t.pp_select_a, new_value_t.pp_select_a };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "PP Select A\nThe next 4 registers and -=PS_=-PP_DIRECTION which of the internal 128 pulses to be output.\nEach bit in the four registers corresponds to one internal pulse.";
}

#define DISP_PP_SELECT_B_OFFSET 0x42B
#define DISP_PP_SELECT_B_UNDEFMASK 0x00000000
union disp_pp_select_b_u {
    struct {
        unsigned int pp_select_b:32;        /* PP Select bits 63 to 32 */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_pp_select_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_pp_select_b_u old_value_t = { .reg32 = value };
    const disp_pp_select_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pp_select_b:32",
              "PP Select bits 63 to 32",
              32, old_value_t.pp_select_b, new_value_t.pp_select_b };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "PP Select B";
}

#define DISP_PP_SELECT_C_OFFSET 0x42C
#define DISP_PP_SELECT_C_UNDEFMASK 0x00000000
union disp_pp_select_c_u {
    struct {
        unsigned int pp_select_c:32;        /* PP Select bits 95 to 64 */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_pp_select_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_pp_select_c_u old_value_t = { .reg32 = value };
    const disp_pp_select_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pp_select_c:32",
              "PP Select bits 95 to 64",
              32, old_value_t.pp_select_c, new_value_t.pp_select_c };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "PP Select C";
}

#define DISP_PP_SELECT_D_OFFSET 0x42D
#define DISP_PP_SELECT_D_UNDEFMASK 0x00000000
union disp_pp_select_d_u {
    struct {
        unsigned int pp_select_d:32;        /* PP Select bits 127 to 96 */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_pp_select_d_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_pp_select_d_u old_value_t = { .reg32 = value };
    const disp_pp_select_d_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pp_select_d:32",
              "PP Select bits 127 to 96",
              32, old_value_t.pp_select_d, new_value_t.pp_select_d };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "PP Select D";
}

#define DISP_DISP_CLOCK_CONTROL_OFFSET 0x42E
#define DISP_DISP_CLOCK_CONTROL_UNDEFMASK 0xFFFFF000
union disp_disp_clock_control_u {
    struct {
        unsigned int shift_clk_divider:8;   /* Shift Clock Divider 0 = divide by 1 1 = divide by 1.5 2 = divide by 2 3 = divide by 2.5 4 = divide by 3 : : : : 254 = divide by 128 255 = divide by 128.5 Pixel clock divider is used to divide output of internal shift clock divider to generate internal pixel clock which is used to clock the internal horizontal and vertical counters. This divider also determines the output format for parallel interface, serial interface, and LCD SPI interface in conjunction with Display Data Format parameter. For 1-pixel/1-clock parallel display interface, valid settings are PCD1, PCD2, and PCD4.  Note that the main reason to use PCD2 and PCD4 is to get higher frequency PP clock because the PP clock is always generated from the output of shift clock divider. For non 1-pixel/1-clock parallel display interface, valid settings are, PCD1H (2-pixel/3-clock), PCD2 (1-pixel/2-clock), and PCD3 (1-pixel/3-clock).  For 1-channel serial display interface, valid settings are PCD3 (3-bpp 1-ch), PCD4 (3-bpp 1-ch), PCD6 (6-bpp 1-ch), PCD9 (9-bpp 1-ch), PCD12 (12-bpp 1-ch), PCD16 (16-bpp 1-ch), PCD18 (18-bpp 1-ch).  For 2-channel serial display interface, valid settings are PCD2 (3-bpp 2-ch), PCD3 (6-bpp 2-ch), PCD6 (12-bpp 2-ch), PCD8 (16-bpp 2-ch), PCD9 (18-bpp 2-ch).  For 3-channel serial display interface, valid settings are PCD1 (3-bpp 3-ch), PCD2 (6-bpp 3-ch), PCD3 (9-bpp 3-ch), PCD4 (12-bpp 3-ch), PCD6 (18-bpp 3-ch).  For LCD SPI interface, valid settings are PCD12 (B4G4R4), PCD16 (B5G6R5), PCD18 (B6G6R6), PCD24 (B8G8R8), PCD8 (B5G6R5 with data/command bit), PCD6 (B5G6R5 with data/command start byte - depending on data/command bit), PCD4 (P8 for spi8), PCD9 (B5G6R5 with chip select deassertion at 8-bit boundary, spi16x2), PCD3 (P8 for spidc), PCD2 (B5G6R5 with data/command bit and chip select deassertion at 9-bit boundary, spi16x2dc), and PCD13 (spi12p2, no chip select deassertion between pairs of pixels) */
        unsigned int pixel_clk_divider:4;   /* Pixel Clock Divider 0000= divide by 1 0001= divide by 1.5 0010= divide by 2 0011= divide by 3 0100= divide by 4 0101= divide by 6 0110= divide by 8 0111= divide by 9 1000= divide by 12 1001= divide by 16 1010= divide by 18 1011= divide by 24 1100= divide by 13 other= reserved 0 = PCD1 1 = PCD1H 2 = PCD2 3 = PCD3 4 = PCD4 5 = PCD6 6 = PCD8 7 = PCD9 8 = PCD12 9 = PCD16 10 = PCD18 11 = PCD24 12 = PCD13 */
        unsigned int undefined_bits_12_31:20;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_disp_clock_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_disp_clock_control_u old_value_t = { .reg32 = value };
    const disp_disp_clock_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: shift_clk_divider:8",
              "Shift Clock Divider\n0 = divide by 1\n1 = divide by 1.5\n2 = divide by 2\n3 = divide by 2.5\n4 = divide by 3 : : : :\n254 = divide by 128\n255 = divide by 128.5 Pixel clock divider is used to divide output of internal shift clock divider to generate internal pixel clock which is used to clock the internal horizontal and vertical counters. This divider also determines the output format for parallel interface, serial interface, and LCD SPI interface in conjunction with Display Data Format parameter. For 1-pixel/1-clock parallel display interface, valid settings are PCD1, PCD2, and PCD4.  Note that the main reason to use PCD2 and PCD4 is to get higher frequency PP clock because the PP clock is always generated from the output of shift clock divider. For non 1-pixel/1-clock parallel display interface, valid settings are, PCD1H (2-pixel/3-clock), PCD2 (1-pixel/2-clock), and PCD3 (1-pixel/3-clock).  For 1-channel serial display interface, valid settings are PCD3 (3-bpp 1-ch), PCD4 (3-bpp 1-ch), PCD6 (6-bpp 1-ch), PCD9 (9-bpp 1-ch), PCD12 (12-bpp 1-ch), PCD16 (16-bpp 1-ch), PCD18 (18-bpp 1-ch).  For 2-channel serial display interface, valid settings are PCD2 (3-bpp 2-ch), PCD3 (6-bpp 2-ch), PCD6 (12-bpp 2-ch), PCD8 (16-bpp 2-ch), PCD9 (18-bpp 2-ch).  For 3-channel serial display interface, valid settings are PCD1 (3-bpp 3-ch), PCD2 (6-bpp 3-ch), PCD3 (9-bpp 3-ch), PCD4 (12-bpp 3-ch), PCD6 (18-bpp 3-ch).  For LCD SPI interface, valid settings are PCD12 (B4G4R4), PCD16 (B5G6R5), PCD18 (B6G6R6), PCD24 (B8G8R8), PCD8 (B5G6R5 with data/command bit), PCD6 (B5G6R5 with data/command start byte - depending on data/command bit), PCD4 (P8 for spi8), PCD9 (B5G6R5 with chip select deassertion at 8-bit boundary, spi16x2), PCD3 (P8 for spidc), PCD2 (B5G6R5 with data/command bit and chip select deassertion at 9-bit boundary, spi16x2dc), and PCD13 (spi12p2, no chip select deassertion between pairs of pixels)",
              8, old_value_t.shift_clk_divider, new_value_t.shift_clk_divider };
    m_bit_details_model.bits.append(entry);
    entry = { "08: pixel_clk_divider:4",
              "Pixel Clock Divider\n0000= divide by 1\n0001= divide by 1.5\n0010= divide by 2\n0011= divide by 3\n0100= divide by 4\n0101= divide by 6\n0110= divide by 8\n0111= divide by 9\n1000= divide by 12\n1001= divide by 16\n1010= divide by 18\n1011= divide by 24\n1100= divide by 13 other= reserved\n0 = PCD1\n1 = PCD1H\n2 = PCD2\n3 = PCD3\n4 = PCD4\n5 = PCD6\n6 = PCD8\n7 = PCD9\n8 = PCD12\n9 = PCD16\n10 = PCD18\n11 = PCD24\n12 = PCD13",
              4, old_value_t.pixel_clk_divider, new_value_t.pixel_clk_divider };
    m_bit_details_model.bits.append(entry);
    entry = { "12: undefined_bits_12_31:20", "", 20, old_value_t.undefined_bits_12_31, new_value_t.undefined_bits_12_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Display Clock Control\nShift clock divider is used to divide root clock for display controller module to generate internal shift clock for shifting data to the display. Output of this divider is typically used to generate the external shift clock which is sent to the display (SC0 and/or SC1) except for 1-pixel/1-clock parallel display.\nThe output of this divider is also used to generate Programmable Pulse (PP) signal. For 1-pixel/1-clock parallel display, SC0 and SC1 are generated using the output of pixel clock divider which can be set to 1, 2, or 4 for 1-pixel/1-clock parallel display.\nThe reason pixel clock divider 2 and 4 are allowed for 1-pixel/1-clock parallel display interface is so that the clock that generates PP can be generated with 2x or 4x higher frequency than pixel clock and therefore can produce higher resolution PP pulse positions. For all cases of parallel display, SC0 and SC1 can be further divided by 1, 2 or 4.\nClass: Display Interface Settings\nThis register controls generation of shift clock to the display and internal pixel clock. Internal display pipeline runs with pixel clock and processes 1 pixel per clock.";
}

#define DISP_DISP_INTERFACE_CONTROL_OFFSET 0x42F
#define DISP_DISP_INTERFACE_CONTROL_UNDEFMASK 0xFFFFFCF0
union disp_disp_interface_control_u {
    struct {
        unsigned int disp_data_format:4;    /* Display Data Format Pixel Clock Divider is used together with this parameter to determine the exact display data format. 0 = DF1P1C : 0= 1-pixel/1-clock up to 24-bit parallel  1 = DF1P2C24B : 1= 1-pixel/2-clock 24-bit parallel  2 = DF1P2C18B : 2= 1-pixel/2-clock 18-bit parallel or 2-pixel/3-clock 12-bit parallel or 1-pixel/3-clock 18-bit parallel NOTE: for 2-pixel/3-clock 12-bit parallel, the horizontal display active time must be even number of pixels.  3 = DF1P2C16B : 3= 1-pixel/2-clock 16-bit parallel  4 = DF1S : 4= 1-channel serial NOTE: 1-/2-/3-channel serial display interface supported is a low-voltage differential serial interface.  5 = DF2S : 5= 2-channel serial  6 = DF3S : 6= 3-channel serial  7 = DFSPI : 7= SPI serial  8 = DF1P3C24B : 8= 1-pixel/3-clock 24-bit parallel  9 = DF2P1C18B : 9= 2-pixel/1-clock 18-bit parallel */
        unsigned int undefined_bits_4_7:4;
        unsigned int disp_data_alignment:1; /* Display Data Alignment This is effective for parallel display data format and the associated Initialization Sequence (IS). 0= Output data is MSB-aligned For 1-pixel/1-clock parallel display the output data ordering is the same regardless of display Base Color Size.  For 1-pixel/1-clock parallel display data alignment is optimized for 18-bpp so the 24-bit data ordering is: LD[5:0] is blue data bits 7-2 LD[11:6] is green data bits 7-2 LD[17:12] is red data bits 7-2 LD[19:18] is blue data bits 1-0 LD[21:20] is green data bits 1-0 LD[23:22] is red data bits 1-0 Note that LD18 to LD23 signals are multiplexed with control pins (see Pin Output Select definition) 1= Output data is LSB-aligned.  For 1-pixel/1-clock parallel display the output data ordering is determined by display Base Color Size. For 1-pixel/1-clock parallel display data alignment is optimized for 24-bpp as follows: LD[7:0] is blue data bits 7-0 LD[15:8] is green data bits 7-0 LD[23:16] is red data bits 7-0 Note that LD18 to LD23 signals are multiplexed with control pins (see Pin Output Select definition) 0 = MSB 1 = LSB */
        unsigned int disp_data_order:1;     /* Display Data Order This is effective only for 1-pixel/2-clock 16-/18-/24- bit parallel interface 0= Red pixel is output in the first clock and blue pixel is output in the second cycle 1= Blue pixel is output in the first clock cycle and red pixel is output in the second clock cycle 0 = RED_BLUE 1 = BLUE_RED */
        unsigned int undefined_bits_10_31:22;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_disp_interface_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_disp_interface_control_u old_value_t = { .reg32 = value };
    const disp_disp_interface_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: disp_data_format:4",
              "Display Data Format Pixel Clock Divider is used together with this parameter to determine the exact display data format.\n0 = DF1P1C :\n0= 1-pixel/1-clock up to 24-bit parallel \n1 = DF1P2C24B :\n1= 1-pixel/2-clock 24-bit parallel \n2 = DF1P2C18B :\n2= 1-pixel/2-clock 18-bit parallel or 2-pixel/3-clock 12-bit parallel or 1-pixel/3-clock 18-bit parallel NOTE: for 2-pixel/3-clock 12-bit parallel, the horizontal display active time must be even number of pixels.\n3 = DF1P2C16B :\n3= 1-pixel/2-clock 16-bit parallel \n4 = DF1S :\n4= 1-channel serial NOTE: 1-/2-/3-channel serial display interface supported is a low-voltage differential serial interface.\n5 = DF2S :\n5= 2-channel serial \n6 = DF3S :\n6= 3-channel serial \n7 = DFSPI :\n7= SPI serial \n8 = DF1P3C24B :\n8= 1-pixel/3-clock 24-bit parallel \n9 = DF2P1C18B :\n9= 2-pixel/1-clock 18-bit parallel",
              4, old_value_t.disp_data_format, new_value_t.disp_data_format };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_7:4", "", 4, old_value_t.undefined_bits_4_7, new_value_t.undefined_bits_4_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: disp_data_alignment:1",
              "Display Data Alignment This is effective for parallel display data format and the associated Initialization Sequence (IS).\n0= Output data is MSB-aligned For 1-pixel/1-clock parallel display the output data ordering is the same regardless of display Base Color Size.  For 1-pixel/1-clock parallel display data alignment is optimized for 18-bpp so the 24-bit data ordering is: LD[5:0] is blue data bits 7-2 LD[11:6] is green data bits 7-2 LD[17:12] is red data bits 7-2 LD[19:18] is blue data bits 1-0 LD[21:20] is green data bits 1-0 LD[23:22] is red data bits 1-0 Note that LD18 to LD23 signals are multiplexed with control pins (see Pin Output Select definition)\n1= Output data is LSB-aligned.  For 1-pixel/1-clock parallel display the output data ordering is determined by display Base Color Size. For 1-pixel/1-clock parallel display data alignment is optimized for 24-bpp as follows: LD[7:0] is blue data bits 7-0 LD[15:8] is green data bits 7-0 LD[23:16] is red data bits 7-0 Note that LD18 to LD23 signals are multiplexed with control pins (see Pin Output Select definition)\n0 = MSB\n1 = LSB",
              1, old_value_t.disp_data_alignment, new_value_t.disp_data_alignment };
    m_bit_details_model.bits.append(entry);
    entry = { "09: disp_data_order:1",
              "Display Data Order This is effective only for 1-pixel/2-clock 16-/18-/24- bit parallel interface\n0= Red pixel is output in the first clock and blue pixel is output in the second cycle\n1= Blue pixel is output in the first clock cycle and red pixel is output in the second clock cycle\n0 = RED_BLUE\n1 = BLUE_RED",
              1, old_value_t.disp_data_order, new_value_t.disp_data_order };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_31:22", "", 22, old_value_t.undefined_bits_10_31, new_value_t.undefined_bits_10_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Display Interface Control\nThis register specifies display interface options";
}

#define DISP_DISP_COLOR_CONTROL_OFFSET 0x430
#define DISP_DISP_COLOR_CONTROL_UNDEFMASK 0xF0F8CCF0
union disp_disp_color_control_u {
    struct {
        unsigned int base_color_size:4;     /* Display Base Color Size This parameter determines the number of bits per color after dither. 0= 6 bits 1= 1 bit 2= 2 bits 3= 3 bits 4= 4 bits 5= 5 bits 6= 5 bits for R,B and 6 bits for G 7= 3 bits for R,G and 2 bits for B 8= 8 bits, this also forces dither to be disabled. This setting can be used to output 24-bit data in 1-pixel/clock parallel display data format. 0 = BASE666 1 = BASE111 2 = BASE222 3 = BASE333 4 = BASE444 5 = BASE555 6 = BASE565 7 = BASE332 8 = BASE888 */
        unsigned int undefined_bits_4_7:4;
        unsigned int dither_control:2;      /* Dither Control 00= dither disabled 01= reserved 10= ordered dither 11= error-diffusion dither  Design Note: initial dither matrix (where d is 2 dither bits) d=00 d=01 d=10 d=11 --------- --------- --------- ---------  0  0   1  0   0  1   0  1  --------- --------- --------- ---------  0  0   0  0   1  0   1  1  --------- --------- --------- ---------  Note: 0 in the matrix specifies no addition to base color 1 in the matrix specifies incrementation of base color (with saturation) 0 = DISABLE 2 = ORDERED 3 = ERRDIFF */
        unsigned int undefined_bits_10_11:2;
        unsigned int ord_dither_rotation:2; /* Ordered Dither Frame Rotation This parameter specifies the rotation frequency of the dither matrix in terms of number of frames. If programmed to 0, there is no dither matrix rotation. If programmed to N where N is larger than 0, the dither matrix is rotated clockwise every N frame */
        unsigned int undefined_bits_14_15:2;
        unsigned int disp_color_swap:1;     /* Display Color Swap 0= RGB (normal) 1= BGR (red-blue reverse) 0 = RGB 1 = BGR */
        unsigned int blank_color:1;         /* Blank Color 0= zeros 1= ones Non Base Color applies to least significant color bits which are not part of base color and it has higher priority over Border Color but lower priority over Blank color */
        unsigned int non_base_color:1;      /* Non Base Color 0= zeros 1= ones MD0-3 signals are general purpose mode signals that can be output in various pins (see Pin Output Select) to configure the display device. These bits are effective at start of frame. Typically these can be programmed in shadow register which takes effect on the next frame */
        unsigned int undefined_bits_19_23:5;
        unsigned int lcd_md0:1;             /* LCD Mode 0 signal  0 = LOW 1 = HIGH */
        unsigned int lcd_md1:1;             /* LCD Mode 1 signal  0 = LOW 1 = HIGH */
        unsigned int lcd_md2:1;             /* LCD Mode 2 signal  0 = LOW 1 = HIGH */
        unsigned int lcd_md3:1;             /* LCD Mode 3 signal  0 = LOW 1 = HIGH */
        unsigned int undefined_bits_28_31:4;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_disp_color_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_disp_color_control_u old_value_t = { .reg32 = value };
    const disp_disp_color_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: base_color_size:4",
              "Display Base Color Size This parameter determines the number of bits per color after dither.\n0= 6 bits\n1= 1 bit\n2= 2 bits\n3= 3 bits\n4= 4 bits\n5= 5 bits\n6= 5 bits for R,B and 6 bits for G\n7= 3 bits for R,G and 2 bits for B\n8= 8 bits, this also forces dither to be disabled. This setting can be used to output 24-bit data in 1-pixel/clock parallel display data format.\n0 = BASE666\n1 = BASE111\n2 = BASE222\n3 = BASE333\n4 = BASE444\n5 = BASE555\n6 = BASE565\n7 = BASE332\n8 = BASE888",
              4, old_value_t.base_color_size, new_value_t.base_color_size };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_7:4", "", 4, old_value_t.undefined_bits_4_7, new_value_t.undefined_bits_4_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: dither_control:2",
              "Dither Control\n00= dither disabled\n01= reserved\n10= ordered dither\n11= error-diffusion dither  Design Note: initial dither matrix (where d is 2 dither bits) d=00 d=01 d=10 d=11 --------- --------- --------- ---------  0  0   1  0   0  1   0  1  --------- --------- --------- ---------  0  0   0  0   1  0   1  1  --------- --------- --------- ---------  Note: 0 in the matrix specifies no addition to base color 1 in the matrix specifies incrementation of base color (with saturation)\n0 = DISABLE\n2 = ORDERED\n3 = ERRDIFF",
              2, old_value_t.dither_control, new_value_t.dither_control };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_11:2", "", 2, old_value_t.undefined_bits_10_11, new_value_t.undefined_bits_10_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: ord_dither_rotation:2",
              "Ordered Dither Frame Rotation This parameter specifies the rotation frequency of the dither matrix in terms of number of frames. If programmed to 0, there is no dither matrix rotation. If programmed to N where N is larger than 0, the dither matrix is rotated clockwise every N frame",
              2, old_value_t.ord_dither_rotation, new_value_t.ord_dither_rotation };
    m_bit_details_model.bits.append(entry);
    entry = { "14: undefined_bits_14_15:2", "", 2, old_value_t.undefined_bits_14_15, new_value_t.undefined_bits_14_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: disp_color_swap:1",
              "Display Color Swap\n0= RGB (normal)\n1= BGR (red-blue reverse)\n0 = RGB\n1 = BGR",
              1, old_value_t.disp_color_swap, new_value_t.disp_color_swap };
    m_bit_details_model.bits.append(entry);
    entry = { "17: blank_color:1",
              "Blank Color\n0= zeros\n1= ones Non Base Color applies to least significant color bits which are not part of base color and it has higher priority over Border Color but lower priority over Blank color",
              1, old_value_t.blank_color, new_value_t.blank_color };
    m_bit_details_model.bits.append(entry);
    entry = { "18: non_base_color:1",
              "Non Base Color\n0= zeros\n1= ones MD0-3 signals are general purpose mode signals that can be output in various pins (see Pin Output Select) to configure the display device. These bits are effective at start of frame. Typically these can be programmed in shadow register which takes effect on the next frame",
              1, old_value_t.non_base_color, new_value_t.non_base_color };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bits_19_23:5", "", 5, old_value_t.undefined_bits_19_23, new_value_t.undefined_bits_19_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: lcd_md0:1",
              "LCD Mode 0 signal \n0 = LOW\n1 = HIGH",
              1, old_value_t.lcd_md0, new_value_t.lcd_md0 };
    m_bit_details_model.bits.append(entry);
    entry = { "25: lcd_md1:1",
              "LCD Mode 1 signal \n0 = LOW\n1 = HIGH",
              1, old_value_t.lcd_md1, new_value_t.lcd_md1 };
    m_bit_details_model.bits.append(entry);
    entry = { "26: lcd_md2:1",
              "LCD Mode 2 signal \n0 = LOW\n1 = HIGH",
              1, old_value_t.lcd_md2, new_value_t.lcd_md2 };
    m_bit_details_model.bits.append(entry);
    entry = { "27: lcd_md3:1",
              "LCD Mode 3 signal \n0 = LOW\n1 = HIGH",
              1, old_value_t.lcd_md3, new_value_t.lcd_md3 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: undefined_bits_28_31:4", "", 4, old_value_t.undefined_bits_28_31, new_value_t.undefined_bits_28_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Display Color Control";
}

#define DISP_SHIFT_CLOCK_OPTIONS_OFFSET 0x431
#define DISP_SHIFT_CLOCK_OPTIONS_UNDEFMASK 0xFF00FF00
union disp_shift_clock_options_u {
    struct {
        unsigned int sc0_h_qualifier:3;     /* SC0 Horizontal Qualifier 0= disable (regardless of vertical qualifier) 1= no horizontal qualifier (V qualifier only) 2= horizontal display active 3= 1-clock early & extended H display active 4= H Pulse 0 (HP0) 5= 1-clock early & extended H Pulse 0 others= reserved 0 = DISABLE 1 = NO_HQUAL 2 = HACTIVE 3 = EXT_HACTIVE 4 = HPULSE0 5 = EXT_HPULSE0 */
        unsigned int sc0_v_qualifier:3;     /* SC0 Vertical Qualifier 0= no vertical qualifier 2= vertical display active 3= 1-line extended vertical display active 4= V Pulse 0 (VP0) 5= 1-line extended V Pulse 0 others= reserved If SC0 is divided by 2 or 4 then it is synchronously reset at the beginning of the horizontal qualifier such that rising edge of SC0 is generated for the first horizontally qualified 'pixel'. In the case where there is no horizontal qualifier start of horizontal display active will be used to generate the synchronous reset. If Initialization Sequence (IS) is enabled on parallel interface then only divide by 1 is allowed for SC0 Clock Divider and SC0 must have vertical and horizontal qualifiers enabled. 0 = NO_VQUAL 1 = RESERVED 2 = VACTIVE 3 = EXT_VACTIVE 4 = VPULSE0 5 = EXT_VPULSE0 */
        unsigned int sc0_clk_divider:2;     /* SC0 Clock Divider 0= divide by 1 - this is valid for all display interface 1= divide by 2 - this is valid only for 1-pixel/1-clock parallel display and 2-pixel/1-clock parallel display 2= divide by 4 - this is valid only for 1-pixel/1-clock parallel display 3= reserved 0 = DIV1 1 = DIV2 2 = DIV4 */
        unsigned int undefined_bits_8_15:8;
        unsigned int sc1_h_qualifier:3;     /* SC1 Horizontal Qualifier 0= disable (regardless of vertical qualifier) 1= no horizontal qualifier (V qualifier only) 2= horizontal display active 3= 1-clock early & extended H display active 4= H Pulse 1 (HP1) 5= 1-clock early & extended H Pulse 1 others= reserved 0 = DISABLE 1 = NO_HQUAL 2 = HACTIVE 3 = EXT_HACTIVE 4 = HPULSE1 5 = EXT_HPULSE1 */
        unsigned int sc1_v_qualifier:3;     /* SC1 Vertical Qualifier 0= no vertical qualifier 2= vertical display active 3= 1-line extended vertical display active 4= V Pulse 1 (VP1) 5= 1-line extended V Pulse 1 others= reserved If SC1 is divided by 2 then it is synchronously reset at the beginning of the horizontal qualifier such that rising edge of SC1 is generated for the first horizontally qualified 'pixel'. If SC1 is divided by 4 then it is synchronously reset at the beginning of the horizontal qualifier such that rising edge of LCD_WR_N is generated for the second horizontally qualified 'pixel'. In the case where there is no horizontal qualifier start of horizontal display active will be used to generate the synchronous reset. If Initialization Sequence (IS) is enabled on parallel interface then only divide by 1 is allowed for SC1 Clock Divider and SC1 must have vertical and horizontal qualifiers enabled. 0 = NO_VQUAL 1 = RESERVED 2 = VACTIVE 3 = EXT_VACTIVE 4 = VPULSE1 5 = EXT_VPULSE1 */
        unsigned int sc1_clk_divider:2;     /* SC1 Clock Divider 0= divide by 1 - this is valid for all display interface 1= divide by 2 - this is valid only for 1-pixel/1-clock parallel display and 2-pixel/1-clock parallel display 2= divide by 4 - this is valid only for 1-pixel/1-clock parallel display 3= reserved 0 = DIV1 1 = DIV2 2 = DIV4 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_shift_clock_options_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_shift_clock_options_u old_value_t = { .reg32 = value };
    const disp_shift_clock_options_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sc0_h_qualifier:3",
              "SC0 Horizontal Qualifier\n0= disable (regardless of vertical qualifier)\n1= no horizontal qualifier (V qualifier only)\n2= horizontal display active\n3= 1-clock early & extended H display active\n4= H Pulse 0 (HP0)\n5= 1-clock early & extended H Pulse 0 others= reserved\n0 = DISABLE\n1 = NO_HQUAL\n2 = HACTIVE\n3 = EXT_HACTIVE\n4 = HPULSE0\n5 = EXT_HPULSE0",
              3, old_value_t.sc0_h_qualifier, new_value_t.sc0_h_qualifier };
    m_bit_details_model.bits.append(entry);
    entry = { "03: sc0_v_qualifier:3",
              "SC0 Vertical Qualifier\n0= no vertical qualifier\n2= vertical display active\n3= 1-line extended vertical display active\n4= V Pulse 0 (VP0)\n5= 1-line extended V Pulse 0 others= reserved If SC0 is divided by 2 or 4 then it is synchronously reset at the beginning of the horizontal qualifier such that rising edge of SC0 is generated for the first horizontally qualified 'pixel'. In the case where there is no horizontal qualifier start of horizontal display active will be used to generate the synchronous reset. If Initialization Sequence (IS) is enabled on parallel interface then only divide by 1 is allowed for SC0 Clock Divider and SC0 must have vertical and horizontal qualifiers enabled.\n0 = NO_VQUAL\n1 = RESERVED\n2 = VACTIVE\n3 = EXT_VACTIVE\n4 = VPULSE0\n5 = EXT_VPULSE0",
              3, old_value_t.sc0_v_qualifier, new_value_t.sc0_v_qualifier };
    m_bit_details_model.bits.append(entry);
    entry = { "06: sc0_clk_divider:2",
              "SC0 Clock Divider\n0= divide by 1 - this is valid for all display interface\n1= divide by 2 - this is valid only for 1-pixel/1-clock parallel display and 2-pixel/1-clock parallel display\n2= divide by 4 - this is valid only for 1-pixel/1-clock parallel display\n3= reserved\n0 = DIV1\n1 = DIV2\n2 = DIV4",
              2, old_value_t.sc0_clk_divider, new_value_t.sc0_clk_divider };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: sc1_h_qualifier:3",
              "SC1 Horizontal Qualifier\n0= disable (regardless of vertical qualifier)\n1= no horizontal qualifier (V qualifier only)\n2= horizontal display active\n3= 1-clock early & extended H display active\n4= H Pulse 1 (HP1)\n5= 1-clock early & extended H Pulse 1 others= reserved\n0 = DISABLE\n1 = NO_HQUAL\n2 = HACTIVE\n3 = EXT_HACTIVE\n4 = HPULSE1\n5 = EXT_HPULSE1",
              3, old_value_t.sc1_h_qualifier, new_value_t.sc1_h_qualifier };
    m_bit_details_model.bits.append(entry);
    entry = { "19: sc1_v_qualifier:3",
              "SC1 Vertical Qualifier\n0= no vertical qualifier\n2= vertical display active\n3= 1-line extended vertical display active\n4= V Pulse 1 (VP1)\n5= 1-line extended V Pulse 1 others= reserved If SC1 is divided by 2 then it is synchronously reset at the beginning of the horizontal qualifier such that rising edge of SC1 is generated for the first horizontally qualified 'pixel'. If SC1 is divided by 4 then it is synchronously reset at the beginning of the horizontal qualifier such that rising edge of LCD_WR_N is generated for the second horizontally qualified 'pixel'. In the case where there is no horizontal qualifier start of horizontal display active will be used to generate the synchronous reset. If Initialization Sequence (IS) is enabled on parallel interface then only divide by 1 is allowed for SC1 Clock Divider and SC1 must have vertical and horizontal qualifiers enabled.\n0 = NO_VQUAL\n1 = RESERVED\n2 = VACTIVE\n3 = EXT_VACTIVE\n4 = VPULSE1\n5 = EXT_VPULSE1",
              3, old_value_t.sc1_v_qualifier, new_value_t.sc1_v_qualifier };
    m_bit_details_model.bits.append(entry);
    entry = { "22: sc1_clk_divider:2",
              "SC1 Clock Divider\n0= divide by 1 - this is valid for all display interface\n1= divide by 2 - this is valid only for 1-pixel/1-clock parallel display and 2-pixel/1-clock parallel display\n2= divide by 4 - this is valid only for 1-pixel/1-clock parallel display\n3= reserved\n0 = DIV1\n1 = DIV2\n2 = DIV4",
              2, old_value_t.sc1_clk_divider, new_value_t.sc1_clk_divider };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Shift Clock options\nThis register specifies options for both display shift clock 0 (SC0) and display shift clock 1 (SC1). SC0 signal is typically output on LCD_PCLK pin and SC1 signal is typically output on LCD_WR_N pin.";
}

#define DISP_DATA_ENABLE_OPTIONS_OFFSET 0x432
#define DISP_DATA_ENABLE_OPTIONS_UNDEFMASK 0xFFFFFFE0
union disp_data_enable_options_u {
    struct {
        unsigned int de_select:2;           /* DE (Data Enable) vertical coverage control 0= DE is generated on every lines (active & blank) 1= DE is generated only for active lines 2= DE is generated for active lines and Initialization sequence (if IS is enabled). DE is also asserted in the time gap between the IS and the first active line. This bit also controls STH for serial display interface in the same manner. 0 = ACTIVE_BLANK 1 = ACTIVE 2 = ACTIVE_IS */
        unsigned int de_control:3;          /* DE (Data Enable) horizontal coverage control 0= 1-pixel clock pulse preceding active line (1-clock DE) 1= LDE active for horizontal display active time (normal DE) 2= LDE starts 1-pixel clock preceding active line but stays high on horizontal display active (early and extended DE) 3= 1-pixel clock early horizontal display active (early DE) 4= DE is active for the whole line, covering both active data and h blank (active and blank)  0 = ONECLK 1 = NORMAL 2 = EARLY_EXT 3 = EARLY 4 = ACTIVE_BLANK */
        unsigned int undefined_bits_5_31:27;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_data_enable_options_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_data_enable_options_u old_value_t = { .reg32 = value };
    const disp_data_enable_options_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: de_select:2",
              "DE (Data Enable) vertical coverage control\n0= DE is generated on every lines (active & blank)\n1= DE is generated only for active lines\n2= DE is generated for active lines and Initialization sequence (if IS is enabled). DE is also asserted in the time gap between the IS and the first active line. This bit also controls STH for serial display interface in the same manner.\n0 = ACTIVE_BLANK\n1 = ACTIVE\n2 = ACTIVE_IS",
              2, old_value_t.de_select, new_value_t.de_select };
    m_bit_details_model.bits.append(entry);
    entry = { "02: de_control:3",
              "DE (Data Enable) horizontal coverage control\n0= 1-pixel clock pulse preceding active line (1-clock DE)\n1= LDE active for horizontal display active time (normal DE)\n2= LDE starts 1-pixel clock preceding active line but stays high on horizontal display active (early and extended DE)\n3= 1-pixel clock early horizontal display active (early DE)\n4= DE is active for the whole line, covering both active data and h blank (active and blank) \n0 = ONECLK\n1 = NORMAL\n2 = EARLY_EXT\n3 = EARLY\n4 = ACTIVE_BLANK",
              3, old_value_t.de_control, new_value_t.de_control };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_31:27", "", 27, old_value_t.undefined_bits_5_31, new_value_t.undefined_bits_5_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Data Enable options\nDE signal is display Data Enable signal which can be used to indicate valid data area and it can be output on LCD_WR_N pin if needed.\nThis signal can also be used to generate PCS (Parallel mode panel Chip Selecter)\n    * 0 = De-asserted during both VBlank and HBlank, except for the IS sequence and the gap between IS and the first active line if IS is enabled.\n    * 1 = De-asserted during VBlank, except for the IS line (whole IS line) if IS is enabled.\n    * 2 = Always asserted during refresh\nOption 0 can be achieved by: DE_SELECT=ACTIVE_IS; DE_CONTROL=NORMAL\nOption 1 can be achieved by: DE_SELECT=ACTIVE_IS; DE_CONTROL=ACTIVE_BLANK\nOption 2 can be achieved by: DE_SELECT=ACTIVE_BLANK; DE_CONTROL=ACTIVE_BLANK";
}

#define DISP_SERIAL_INTERFACE_OPTIONS_OFFSET 0x433
#define DISP_SERIAL_INTERFACE_OPTIONS_UNDEFMASK 0xFFFFFF00
union disp_serial_interface_options_u {
    struct {
        unsigned int sdt_stp_mode:2;        /* SDT and STP modes 0= SDT and STP disabled 1= reserved 2= SDT & STP enabled, duplicate data sent 3= SDT & STP enabled, duplicate data not sent 0 = DISABLE 1 = RESERVED 2 = ENABLE_DUP 3 = ENABLE */
        unsigned int sdt_stp_duration:4;    /* SDT and STP signal duration 0= 1 shift clock 1= 1 pixel clock 2= 1 pixel clock - 1 shift clock 3= 1 pixel clock - 2 shift clock 4= 1 pixel clock - 3 shift clock 5= 1 pixel clock - 4 shift clock : : : F= 1 pixel clock - 14 shift clock STP active duration is same as SDT if next pixel is not the same as current pixel; else, STP active duration is always 1 pixel clock. Maximum valid setting is pixel clock divider - 1 for pixel clock divider > 4. If pixel clock divider is 4 or less, SDT and STP is always low */
        unsigned int sth_duration:1;        /* STH signal duration 0= STH is high for 1 pixel clock in all cases except for 3-bit 2-channel and 6-bit 3-channel where STH is 1.5 pixel clock and for 3-bit 3-channel STH is 3 pixel clocks. 1= STH is high for 2 pixel clock in all cases except for 3-bit 3-channel STH is 4 pixel clocks. 0 = ONE_CLOCK 1 = TWO_CLOCK */
        unsigned int stp_control:1;         /* STP signal control 0= STP is not OR-ed with H Pulse 2 and vertical blank 1= STP is OR-ed with H Pulse 2 and vertical blank This may be set to 1 when STP needs to be forced high during blank time in which case H Pulse 2 should be programmed when STP needs to be forced high. Vertical blank is the area outside vertical display active. 0 = NORMAL 1 = EXTENDED */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_serial_interface_options_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_serial_interface_options_u old_value_t = { .reg32 = value };
    const disp_serial_interface_options_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sdt_stp_mode:2",
              "SDT and STP modes\n0= SDT and STP disabled\n1= reserved\n2= SDT & STP enabled, duplicate data sent\n3= SDT & STP enabled, duplicate data not sent\n0 = DISABLE\n1 = RESERVED\n2 = ENABLE_DUP\n3 = ENABLE",
              2, old_value_t.sdt_stp_mode, new_value_t.sdt_stp_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "02: sdt_stp_duration:4",
              "SDT and STP signal duration\n0= 1 shift clock\n1= 1 pixel clock\n2= 1 pixel clock - 1 shift clock\n3= 1 pixel clock - 2 shift clock\n4= 1 pixel clock - 3 shift clock\n5= 1 pixel clock - 4 shift clock : : : F= 1 pixel clock - 14 shift clock STP active duration is same as SDT if next pixel is not the same as current pixel; else, STP active duration is always 1 pixel clock. Maximum valid setting is pixel clock divider - 1 for pixel clock divider > 4. If pixel clock divider is 4 or less, SDT and STP is always low",
              4, old_value_t.sdt_stp_duration, new_value_t.sdt_stp_duration };
    m_bit_details_model.bits.append(entry);
    entry = { "06: sth_duration:1",
              "STH signal duration\n0= STH is high for 1 pixel clock in all cases except for 3-bit 2-channel and 6-bit 3-channel where STH is 1.5 pixel clock and for 3-bit 3-channel STH is 3 pixel clocks.\n1= STH is high for 2 pixel clock in all cases except for 3-bit 3-channel STH is 4 pixel clocks.\n0 = ONE_CLOCK\n1 = TWO_CLOCK",
              1, old_value_t.sth_duration, new_value_t.sth_duration };
    m_bit_details_model.bits.append(entry);
    entry = { "07: stp_control:1",
              "STP signal control\n0= STP is not OR-ed with H Pulse 2 and vertical blank\n1= STP is OR-ed with H Pulse 2 and vertical blank This may be set to 1 when STP needs to be forced high during blank time in which case H Pulse 2 should be programmed when STP needs to be forced high. Vertical blank is the area outside vertical display active.\n0 = NORMAL\n1 = EXTENDED",
              1, old_value_t.stp_control, new_value_t.stp_control };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Serial Display Interface Options\nControls signals for the low-voltage differential serial display interface consists of: SDT, STP and STH signals. SDT and STP are asserted high if current pixel is same as previous pixel; in this case,\nSDT is toggled low sometime later but STP is either toggled low at same time as SDT (if next pixel is different than current pixel) or remains high if next pixel is same as current pixel.\nWhen doing pixel comparison, output of dither is used, so pixel comparison depends on the base color (which maybe different than the number of output data bits).\nBoth SDT and STP are always low (disabled) if the pixel clock divider is 4 or less.\nSTH is used to indicate the beginning of line and it is asserted high once at the beginning of each line. The STH pulse exact timing width is dependent on the exact mode. STH is generated from Data Enable therefore Data Enable Select bit also\ncontrols STH generation and can be used to generate STH either only for active lines or both for active and blank lines. If STH is sent during blank lines then the blank lines are also transmitted.";
}

#define DISP_LCD_SPI_OPTIONS_OFFSET 0x434
#define DISP_LCD_SPI_OPTIONS_UNDEFMASK 0xFFFFFFE0
union disp_lcd_spi_options_u {
    struct {
        unsigned int lcd_spi_cs:1;          /* LCD SPI Chip Select (SCS_) 0= Send LCD SPI data to Main Display (Main SCS_ is activated) 1= Send LCD SPI data to Sub Display (Sub SCS_ is activated) This bit is also used when SPI Chip Select Control are NOT LCD_IS_SPI to determine either Main SCS_ or Sub SCS_ to be forced active. 0 = MAIN 1 = SUB */
        unsigned int lcd_spi_dc:1;          /* LCD SPI Data/Command (SDC) 0= SPI Data/Command is low for LCD SPI writes to the display. For PCD6 data format, command byte is sent. 1= SPI Data/Command is high for LCD SPI writes to the display. For PCD6 data format, data byte is sent. 0 = LOW 1 = HIGH */
        unsigned int spi_cs_control:2;      /* LCD SPI Chip Select (SCS_) Control for both IS SPI or LCD SPI 0= Main SCS_ or Sub SCS_ is controlled by LCD SPI or by IS SPI 1= Main SCS_ or Sub SCS_ is controlled by LCD SPI, and depending on LCD SPI Chip Select bit, one of them is forced active for 1-line prior to display active when IS SPI is enabled 2= Main SCS_ or Sub SCS_ is controlled by IS SPI, and depending on LCD SPI Chip Select bit, one of them is forced active during vertical display active area when LCD SPI is enabled 3= Main SCS_ or Sub SCS_, depending on LCD SPI Chip Select bit, is forced active 1-line prior to display active when IS SPI is enabled and also during vertical display active area when LCD SPI is enabled 0 = LCD_IS_SPI 1 = LCD_SPI 2 = IS_SPI 3 = FORCED */
        unsigned int lcd_spi_direction:1;   /* LCD SPI Data Direction. Note that data direction does not affect the start byte direction (which is always msb to lsb) and position (always first 8-bit of serial data) for SPI16SB mode. 0 = MSB2LSB 1 = LSB2MSB */
        unsigned int undefined_bits_5_31:27;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_lcd_spi_options_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_lcd_spi_options_u old_value_t = { .reg32 = value };
    const disp_lcd_spi_options_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: lcd_spi_cs:1",
              "LCD SPI Chip Select (SCS_)\n0= Send LCD SPI data to Main Display (Main SCS_ is activated)\n1= Send LCD SPI data to Sub Display (Sub SCS_ is activated) This bit is also used when SPI Chip Select Control are NOT LCD_IS_SPI to determine either Main SCS_ or Sub SCS_ to be forced active.\n0 = MAIN\n1 = SUB",
              1, old_value_t.lcd_spi_cs, new_value_t.lcd_spi_cs };
    m_bit_details_model.bits.append(entry);
    entry = { "01: lcd_spi_dc:1",
              "LCD SPI Data/Command (SDC)\n0= SPI Data/Command is low for LCD SPI writes to the display. For PCD6 data format, command byte is sent.\n1= SPI Data/Command is high for LCD SPI writes to the display. For PCD6 data format, data byte is sent.\n0 = LOW\n1 = HIGH",
              1, old_value_t.lcd_spi_dc, new_value_t.lcd_spi_dc };
    m_bit_details_model.bits.append(entry);
    entry = { "02: spi_cs_control:2",
              "LCD SPI Chip Select (SCS_) Control for both IS SPI or LCD SPI\n0= Main SCS_ or Sub SCS_ is controlled by LCD SPI or by IS SPI\n1= Main SCS_ or Sub SCS_ is controlled by LCD SPI, and depending on LCD SPI Chip Select bit, one of them is forced active for 1-line prior to display active when IS SPI is enabled\n2= Main SCS_ or Sub SCS_ is controlled by IS SPI, and depending on LCD SPI Chip Select bit, one of them is forced active during vertical display active area when LCD SPI is enabled\n3= Main SCS_ or Sub SCS_, depending on LCD SPI Chip Select bit, is forced active 1-line prior to display active when IS SPI is enabled and also during vertical display active area when LCD SPI is enabled\n0 = LCD_IS_SPI\n1 = LCD_SPI\n2 = IS_SPI\n3 = FORCED",
              2, old_value_t.spi_cs_control, new_value_t.spi_cs_control };
    m_bit_details_model.bits.append(entry);
    entry = { "04: lcd_spi_direction:1",
              "LCD SPI Data Direction. Note that data direction does not affect the start byte direction (which is always msb to lsb) and position (always first 8-bit of serial data) for SPI16SB mode.\n0 = MSB2LSB\n1 = LSB2MSB",
              1, old_value_t.lcd_spi_direction, new_value_t.lcd_spi_direction };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_31:27", "", 27, old_value_t.undefined_bits_5_31, new_value_t.undefined_bits_5_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "LCD SPI Interface Options\nLCD SPI interface signals consists of:\n1. SPI Clock (SCK) which can be output on LCD_SCK pin.\n2. SPI Data (SDA) which can be output on LCD_SDOUT pin.\n3. Optional SPI Data/Command (SDC) which can be output on LCD_DC0 pin.\n4. Main-Display SPI Chip Select (Main SCS_) signal which can be output on LCS_ pin.\n5. Sub-Display SPI Chip Select (Sub SCS_) signal which can be optionally output on several pins (see pin output select) - this is optional and it is used only if there is a sub display.\nFor LCD SPI, pixel data can only be sent to either Main-Display or Sub-Display but not to both.\nMain SCS_ or Sub SCS_ signal is always active low and is typically controlled by SPI logic but can also be forced active one line prior to display active (for SIS SPI) and during vertical display active area (for LCD SPI).";
}

#define DISP_BORDER_COLOR_OFFSET 0x435
#define DISP_BORDER_COLOR_UNDEFMASK 0xFF000000
union disp_border_color_u {
    struct {
        unsigned int border_color_r:8;      /* Red Border Color */
        unsigned int border_color_g:8;      /* Green Border Color */
        unsigned int border_color_b:8;      /* Blue Border Color */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_border_color_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_border_color_u old_value_t = { .reg32 = value };
    const disp_border_color_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: border_color_r:8",
              "Red Border Color",
              8, old_value_t.border_color_r, new_value_t.border_color_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: border_color_g:8",
              "Green Border Color",
              8, old_value_t.border_color_g, new_value_t.border_color_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: border_color_b:8",
              "Blue Border Color",
              8, old_value_t.border_color_b, new_value_t.border_color_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Border Color\nBorder Color defines the color of areas within the active display area which are outside the defined active windows. This is 24-bit color which is applied after blending.";
}

#define DISP_COLOR_KEY0_LOWER_OFFSET 0x436
#define DISP_COLOR_KEY0_LOWER_UNDEFMASK 0xFF000000
union disp_color_key0_lower_u {
    struct {
        unsigned int color_key0_l_r:8;      /* Color Key 0 Red (V) Lower value */
        unsigned int color_key0_l_g:8;      /* Color Key 0 Green (Y) Lower value */
        unsigned int color_key0_l_b:8;      /* Color Key 0 Blue (U) Lower value */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_color_key0_lower_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_color_key0_lower_u old_value_t = { .reg32 = value };
    const disp_color_key0_lower_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: color_key0_l_r:8",
              "Color Key 0 Red (V) Lower value",
              8, old_value_t.color_key0_l_r, new_value_t.color_key0_l_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: color_key0_l_g:8",
              "Color Key 0 Green (Y) Lower value",
              8, old_value_t.color_key0_l_g, new_value_t.color_key0_l_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: color_key0_l_b:8",
              "Color Key 0 Blue (U) Lower value",
              8, old_value_t.color_key0_l_b, new_value_t.color_key0_l_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Color Key 0 Lower value\nColor Key 0 and Color Key 1\nTwo ranges of color key are defined and they are common for all windows because it is expected that typically only one window will have color key enabled. Because there are two sets of color key, it is possible to have 2 windows each using one color key set.\nUsage of this color key is described in the Display Color Key and Blending class.";
}

#define DISP_COLOR_KEY0_UPPER_OFFSET 0x437
#define DISP_COLOR_KEY0_UPPER_UNDEFMASK 0xFF000000
union disp_color_key0_upper_u {
    struct {
        unsigned int color_key0_u_r:8;      /* Color Key 0 Red (V) Upper value */
        unsigned int color_key0_u_g:8;      /* Color Key 0 Green (Y) Upper value */
        unsigned int color_key0_u_b:8;      /* Color Key 0 Blue (U) Upper value */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_color_key0_upper_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_color_key0_upper_u old_value_t = { .reg32 = value };
    const disp_color_key0_upper_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: color_key0_u_r:8",
              "Color Key 0 Red (V) Upper value",
              8, old_value_t.color_key0_u_r, new_value_t.color_key0_u_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: color_key0_u_g:8",
              "Color Key 0 Green (Y) Upper value",
              8, old_value_t.color_key0_u_g, new_value_t.color_key0_u_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: color_key0_u_b:8",
              "Color Key 0 Blue (U) Upper value",
              8, old_value_t.color_key0_u_b, new_value_t.color_key0_u_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Color Key 0 Upper value";
}

#define DISP_COLOR_KEY1_LOWER_OFFSET 0x438
#define DISP_COLOR_KEY1_LOWER_UNDEFMASK 0xFF000000
union disp_color_key1_lower_u {
    struct {
        unsigned int color_key1_l_r:8;      /* Color Key 1 Red (V) Lower value */
        unsigned int color_key1_l_g:8;      /* Color Key 1 Green (Y) Lower value */
        unsigned int color_key1_l_b:8;      /* Color Key 1 Blue (U) Lower value */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_color_key1_lower_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_color_key1_lower_u old_value_t = { .reg32 = value };
    const disp_color_key1_lower_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: color_key1_l_r:8",
              "Color Key 1 Red (V) Lower value",
              8, old_value_t.color_key1_l_r, new_value_t.color_key1_l_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: color_key1_l_g:8",
              "Color Key 1 Green (Y) Lower value",
              8, old_value_t.color_key1_l_g, new_value_t.color_key1_l_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: color_key1_l_b:8",
              "Color Key 1 Blue (U) Lower value",
              8, old_value_t.color_key1_l_b, new_value_t.color_key1_l_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Color Key 1 Lower value";
}

#define DISP_COLOR_KEY1_UPPER_OFFSET 0x439
#define DISP_COLOR_KEY1_UPPER_UNDEFMASK 0xFF000000
union disp_color_key1_upper_u {
    struct {
        unsigned int color_key1_u_r:8;      /* Color Key 1 Red (V) Upper value */
        unsigned int color_key1_u_g:8;      /* Color Key 1 Green (Y) Upper value */
        unsigned int color_key1_u_b:8;      /* Color Key 1 Blue (U) Upper value */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_color_key1_upper_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_color_key1_upper_u old_value_t = { .reg32 = value };
    const disp_color_key1_upper_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: color_key1_u_r:8",
              "Color Key 1 Red (V) Upper value",
              8, old_value_t.color_key1_u_r, new_value_t.color_key1_u_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: color_key1_u_g:8",
              "Color Key 1 Green (Y) Upper value",
              8, old_value_t.color_key1_u_g, new_value_t.color_key1_u_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: color_key1_u_b:8",
              "Color Key 1 Blue (U) Upper value",
              8, old_value_t.color_key1_u_b, new_value_t.color_key1_u_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Color Key 1 Upper value";
}

#define DISP_CURSOR_FOREGROUND_OFFSET 0x43C
#define DISP_CURSOR_FOREGROUND_UNDEFMASK 0xFF000000
union disp_cursor_foreground_u {
    struct {
        unsigned int cursor_foreground_r:8; /* Cursor Red Foreground Color */
        unsigned int cursor_foreground_g:8; /* Cursor Green Foreground Color */
        unsigned int cursor_foreground_b:8; /* Cursor Blue Foreground Color */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_cursor_foreground_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_cursor_foreground_u old_value_t = { .reg32 = value };
    const disp_cursor_foreground_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cursor_foreground_r:8",
              "Cursor Red Foreground Color",
              8, old_value_t.cursor_foreground_r, new_value_t.cursor_foreground_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cursor_foreground_g:8",
              "Cursor Green Foreground Color",
              8, old_value_t.cursor_foreground_g, new_value_t.cursor_foreground_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cursor_foreground_b:8",
              "Cursor Blue Foreground Color",
              8, old_value_t.cursor_foreground_b, new_value_t.cursor_foreground_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Cursor Foreground color\nClass: Hardware Cursor\n Hardware cursor is supported for 32x32 or for 64x64 2-bpp cursor.\nCursor start address is aligned to 1 KB boundary. All cursor registers except for cursor foreground and background colors are triple buffered.\nGENERAL_UPDATE controls ASSEMBLY->ARM latching, GENERAL_ACT_REQ controls ARM->ACTIVE latching.\nCursor scaling and flipping are not implemented so this must be done by software if needed. Cursor H/V positions are signed number with respect to one of the display windows or with respect to upper left position of display active area as specified by cursor clipping parameter which also determines cursor clipping boundary. If cursor position is with respect to one of the display window and the corresponding display window is disabled then cursor will also be disabled.";
}

#define DISP_CURSOR_BACKGROUND_OFFSET 0x43D
#define DISP_CURSOR_BACKGROUND_UNDEFMASK 0xFF000000
union disp_cursor_background_u {
    struct {
        unsigned int cursor_background_r:8; /* Cursor Red Background Color */
        unsigned int cursor_background_g:8; /* Cursor Green Background Color */
        unsigned int cursor_background_b:8; /* Cursor Blue Background Color */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_cursor_background_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_cursor_background_u old_value_t = { .reg32 = value };
    const disp_cursor_background_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cursor_background_r:8",
              "Cursor Red Background Color",
              8, old_value_t.cursor_background_r, new_value_t.cursor_background_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cursor_background_g:8",
              "Cursor Green Background Color",
              8, old_value_t.cursor_background_g, new_value_t.cursor_background_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cursor_background_b:8",
              "Cursor Blue Background Color",
              8, old_value_t.cursor_background_b, new_value_t.cursor_background_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Cursor Background color";
}

#define DISP_CURSOR_START_ADDR_OFFSET 0x43E
#define DISP_CURSOR_START_ADDR_UNDEFMASK 0xCEC00000
union disp_cursor_start_addr_u {
    struct {
        unsigned int cursor_start_addr:22;  /* Cursor Start Address bits 25:10 */
        unsigned int undefined_bits_22_23:2;
        unsigned int cursor_size:1;         /* Cursor Size 0= 32x32 1= 64x64 0 = C32X32 1 = C64X64 */
        unsigned int undefined_bits_25_27:3;
        unsigned int cursor_clipping:2;     /* Cursor Clipping Select 0 = DISPLAY : 00= display  1 = WA : 01= window A  2 = WB : 10= window B  3 = WC : 11= window C */
        unsigned int undefined_bits_30_31:2;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_cursor_start_addr_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_cursor_start_addr_u old_value_t = { .reg32 = value };
    const disp_cursor_start_addr_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cursor_start_addr:22",
              "Cursor Start Address bits 25:10",
              22, old_value_t.cursor_start_addr, new_value_t.cursor_start_addr };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cursor_size:1",
              "Cursor Size\n0= 32x32\n1= 64x64\n0 = C32X32\n1 = C64X64",
              1, old_value_t.cursor_size, new_value_t.cursor_size };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bits_25_27:3", "", 3, old_value_t.undefined_bits_25_27, new_value_t.undefined_bits_25_27 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: cursor_clipping:2",
              "Cursor Clipping Select\n0 = DISPLAY :\n00= display \n1 = WA :\n01= window A \n2 = WB :\n10= window B \n3 = WC :\n11= window C",
              2, old_value_t.cursor_clipping, new_value_t.cursor_clipping };
    m_bit_details_model.bits.append(entry);
    entry = { "30: undefined_bits_30_31:2", "", 2, old_value_t.undefined_bits_30_31, new_value_t.undefined_bits_30_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Cursor Start Address";
}

#define DISP_CURSOR_START_ADDR_NS_OFFSET 0x43F
#define DISP_CURSOR_START_ADDR_NS_UNDEFMASK 0xCEC00000
union disp_cursor_start_addr_ns_u {
    struct {
        unsigned int cursor_start_addr_ns:22;/* Cursor Start Address bits 25:10 */
        unsigned int undefined_bits_22_23:2;
        unsigned int cursor_size_ns:1;      /* Cursor Size 0= 32x32 1= 64x64 0 = C32X32 1 = C64X64 */
        unsigned int undefined_bits_25_27:3;
        unsigned int cursor_clipping_ns:2;  /* Cursor Clipping Select 0 = DISPLAY : 00= display  1 = WA : 01= window A  2 = WB : 10= window B  3 = WC : 11= window C */
        unsigned int undefined_bits_30_31:2;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_cursor_start_addr_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_cursor_start_addr_ns_u old_value_t = { .reg32 = value };
    const disp_cursor_start_addr_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cursor_start_addr_ns:22",
              "Cursor Start Address bits 25:10",
              22, old_value_t.cursor_start_addr_ns, new_value_t.cursor_start_addr_ns };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cursor_size_ns:1",
              "Cursor Size\n0= 32x32\n1= 64x64\n0 = C32X32\n1 = C64X64",
              1, old_value_t.cursor_size_ns, new_value_t.cursor_size_ns };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bits_25_27:3", "", 3, old_value_t.undefined_bits_25_27, new_value_t.undefined_bits_25_27 };
    m_bit_details_model.bits.append(entry);
    entry = { "28: cursor_clipping_ns:2",
              "Cursor Clipping Select\n0 = DISPLAY :\n00= display \n1 = WA :\n01= window A \n2 = WB :\n10= window B \n3 = WC :\n11= window C",
              2, old_value_t.cursor_clipping_ns, new_value_t.cursor_clipping_ns };
    m_bit_details_model.bits.append(entry);
    entry = { "30: undefined_bits_30_31:2", "", 2, old_value_t.undefined_bits_30_31, new_value_t.undefined_bits_30_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Shadow of Cursor Start Address";
}

#define DISP_CURSOR_POSITION_OFFSET 0x440
#define DISP_CURSOR_POSITION_UNDEFMASK 0xC000C000
union disp_cursor_position_u {
    struct {
        unsigned int h_cursor_position:14;  /* H cursor position (signed) */
        unsigned int undefined_bits_14_15:2;
        unsigned int v_cursor_position:14;  /* V cursor position (signed) */
        unsigned int undefined_bits_30_31:2;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_cursor_position_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_cursor_position_u old_value_t = { .reg32 = value };
    const disp_cursor_position_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_cursor_position:14",
              "H cursor position (signed)",
              14, old_value_t.h_cursor_position, new_value_t.h_cursor_position };
    m_bit_details_model.bits.append(entry);
    entry = { "14: undefined_bits_14_15:2", "", 2, old_value_t.undefined_bits_14_15, new_value_t.undefined_bits_14_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_cursor_position:14",
              "V cursor position (signed)",
              14, old_value_t.v_cursor_position, new_value_t.v_cursor_position };
    m_bit_details_model.bits.append(entry);
    entry = { "30: undefined_bits_30_31:2", "", 2, old_value_t.undefined_bits_30_31, new_value_t.undefined_bits_30_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Cursor Position\nCursor position is with respect to top-left corner of display active area, or window A, or window B, or window C as specified cursor clipping parameter.";
}

#define DISP_CURSOR_POSITION_NS_OFFSET 0x441
#define DISP_CURSOR_POSITION_NS_UNDEFMASK 0xC000C000
union disp_cursor_position_ns_u {
    struct {
        unsigned int h_cursor_position_ns:14;/* H cursor position (signed) */
        unsigned int undefined_bits_14_15:2;
        unsigned int v_cursor_position_ns:14;/* V cursor position (signed) */
        unsigned int undefined_bits_30_31:2;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_cursor_position_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_cursor_position_ns_u old_value_t = { .reg32 = value };
    const disp_cursor_position_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: h_cursor_position_ns:14",
              "H cursor position (signed)",
              14, old_value_t.h_cursor_position_ns, new_value_t.h_cursor_position_ns };
    m_bit_details_model.bits.append(entry);
    entry = { "14: undefined_bits_14_15:2", "", 2, old_value_t.undefined_bits_14_15, new_value_t.undefined_bits_14_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: v_cursor_position_ns:14",
              "V cursor position (signed)",
              14, old_value_t.v_cursor_position_ns, new_value_t.v_cursor_position_ns };
    m_bit_details_model.bits.append(entry);
    entry = { "30: undefined_bits_30_31:2", "", 2, old_value_t.undefined_bits_30_31, new_value_t.undefined_bits_30_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Shadow of Cursor Position";
}

#define DISP_INIT_SEQ_CONTROL_OFFSET 0x442
#define DISP_INIT_SEQ_CONTROL_UNDEFMASK 0xFFFFF00C
union disp_init_seq_control_u {
    struct {
        unsigned int send_init_sequence:1;  /* Send Initialization Sequence (IS)  0 = DISABLE 1 = ENABLE */
        unsigned int init_sequence_mode:1;  /* Initialization Sequence Mode 0= Send init sequence through parallel LCD interface 1= Send init sequence through SPI serial interface 0 = PLCD_INIT 1 = SPI_INIT */
        unsigned int undefined_bits_2_3:2;
        unsigned int init_seq_dc_signal:3;  /* Frame Initialization Sequence DC Pin This parameter is used only for parallel initialization sequence and it specifies which signal carries the data/command signal. 0= parallel IS DC signal is not needed 1= parallel IS DC on Vertical Sync 2= parallel IS DC on Vertical Pulse 0 3= parallel IS DC on Vertical Pulse 1 4= parallel IS DC on Vertical Pulse 2 5= parallel IS DC on Vertical Pulse 3 other= reserved 0 = NODC 1 = VSYNC 2 = VPULSE0 3 = VPULSE1 4 = VPULSE2 5 = VPULSE3 */
        unsigned int init_seq_dc_control:1; /* Initialization Sequence DC Pin This bit is used only for parallel initialization sequence and it controls how data/command is added to the vertical signal selected by -=PS_=-INIT_SEQ_DC_SIGNAL 0= parallel IS DC is inverted and then AND-ed to the vertical signal 1= parallel IS DC is OR-ed to the vertical signal */
        unsigned int frame_init_seq_cycles:4;/* Frame Initialization Sequence Cycles This parameter specifies the number of frame initialization sequence cycles to send. If programmed to 0, there is no frame initialization cycle generated */
        unsigned int undefined_bits_12_31:20;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_init_seq_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_init_seq_control_u old_value_t = { .reg32 = value };
    const disp_init_seq_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: send_init_sequence:1",
              "Send Initialization Sequence (IS) \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.send_init_sequence, new_value_t.send_init_sequence };
    m_bit_details_model.bits.append(entry);
    entry = { "01: init_sequence_mode:1",
              "Initialization Sequence Mode\n0= Send init sequence through parallel LCD interface\n1= Send init sequence through SPI serial interface\n0 = PLCD_INIT\n1 = SPI_INIT",
              1, old_value_t.init_sequence_mode, new_value_t.init_sequence_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "02: undefined_bits_2_3:2", "", 2, old_value_t.undefined_bits_2_3, new_value_t.undefined_bits_2_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: init_seq_dc_signal:3",
              "Frame Initialization Sequence DC Pin This parameter is used only for parallel initialization sequence and it specifies which signal carries the data/command signal.\n0= parallel IS DC signal is not needed\n1= parallel IS DC on Vertical Sync\n2= parallel IS DC on Vertical Pulse 0\n3= parallel IS DC on Vertical Pulse 1\n4= parallel IS DC on Vertical Pulse 2\n5= parallel IS DC on Vertical Pulse 3 other= reserved\n0 = NODC\n1 = VSYNC\n2 = VPULSE0\n3 = VPULSE1\n4 = VPULSE2\n5 = VPULSE3",
              3, old_value_t.init_seq_dc_signal, new_value_t.init_seq_dc_signal };
    m_bit_details_model.bits.append(entry);
    entry = { "07: init_seq_dc_control:1",
              "Initialization Sequence DC Pin This bit is used only for parallel initialization sequence and it controls how data/command is added to the vertical signal selected by -=PS_=-INIT_SEQ_DC_SIGNAL\n0= parallel IS DC is inverted and then AND-ed to the vertical signal\n1= parallel IS DC is OR-ed to the vertical signal",
              1, old_value_t.init_seq_dc_control, new_value_t.init_seq_dc_control };
    m_bit_details_model.bits.append(entry);
    entry = { "08: frame_init_seq_cycles:4",
              "Frame Initialization Sequence Cycles This parameter specifies the number of frame initialization sequence cycles to send. If programmed to 0, there is no frame initialization cycle generated",
              4, old_value_t.frame_init_seq_cycles, new_value_t.frame_init_seq_cycles };
    m_bit_details_model.bits.append(entry);
    entry = { "12: undefined_bits_12_31:20", "", 20, old_value_t.undefined_bits_12_31, new_value_t.undefined_bits_12_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Initialization Sequence Control\nClass: Initialization Sequence (IS)\n Display initialization sequence may have to be written to the display if the display has built-in frame buffer. This initialization sequence is used typically to reinitialize the display buffer start address and maybe needed once per frame (frame initialization sequence) and/or once per line (line initialization sequence).\nFrame initialization sequence is sent during the horizontal active time of the line just before the first active display line. Line initialization sequence is currently NOT supported.\nInitialization sequence can be done through parallel LCD interface or through SPI serial interface. Software is responsible in making sure that the active line time is sufficient to send initialization sequence.\nFor parallel interface initialization, the signals used as chip selects (typically these are one of the vertical signals) must be programmed to be active one line just before the first active display line. Also SC0/SC1 clock divider must be programmed to divide by 1 if initialization sequence is enabled.";
}

#define DISP_SPI_INIT_SEQ_DATA_A_OFFSET 0x443
#define DISP_SPI_INIT_SEQ_DATA_A_UNDEFMASK 0x00000000
union disp_spi_init_seq_data_a_u {
    struct {
        unsigned int spi_init_seq_data_a:32;/* SPI Init Sequence Write Data bits 31-0 */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_spi_init_seq_data_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_spi_init_seq_data_a_u old_value_t = { .reg32 = value };
    const disp_spi_init_seq_data_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: spi_init_seq_data_a:32",
              "SPI Init Sequence Write Data bits 31-0",
              32, old_value_t.spi_init_seq_data_a, new_value_t.spi_init_seq_data_a };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "SPI Init Sequence Write Data A\nFor parallel initialization sequence there are two possible data widths: 9 bits or 18 bits.\nIf parallel IS is selected, the number of bits per cycle depend on the DISP_DATA_FORMAT register programming. 18-bit parallel IS cycles are performed for 1-pixel/1-clock parallel interface (DF1P1C). 9-bit parallel IS cycles are performed for non 1-pixel/1-clock parallel interface.\nParallel IS cycles must be completed prior to the end of horizontal active of the line where IS cycles are sent. If all the cycles have been completed prior to the end of horizontal active, control signals are held inactive and last output data is held till end of horizontal active. For 9-bit parallel initialization sequence, the data is output in either LCD_D[8:0] pins or LCD_D[17:9] pins depending on display data alignment.\nFor serial initialization sequence using SPI (IS SPI) there are six possible data widths: 8 bits, 9 bits, 12 bits, 16 bits, 16 bits data plus start byte (24 bits), 18 bits, or 24 bits.\nParameters in SPI_CONTROL register and SPI_START_BYTE register is also used for serial initialization sequence using SPI.\nSerial IS cycles must also be completed prior to the end of horizontal active of the line where initialization cycles are sent. The programmer needs to make sure that register programming is such that this is true. If all the cycles have been completed prior to the end of horizontal active, SPI signals will be forced inactive until the next SPI cycles.\n  The following shows how initialization sequence data bits are used when sending initialization sequence:\nFor 9-bit parallel initialization - up to 10 initialization cycles can be done:\nInit cycle\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10\nData\n 8-0\n 17-9\n 26-18\n 35-27\n 44-36\n 53-45\n 62-54\n 71-63\n 80-72\n 89-81\nLCD_PCLK enable\n 90\n 93\n 96\n 99\n 102\n 105\n 108\n 111\n 114\n 117\nLCD_WR_N enable\n 91\n 94\n 97\n 100\n 103\n 106\n 109\n 112\n 115\n 118\ndata/command\n 92\n 95\n 98\n 101\n 104\n 107\n 110\n 113\n 116\n 119\nFor 18-bit parallel initialization - up to 6 initialization cycles can be done:\nInit cycle\n 1\n 2\n 3\n 4\n 5\n 6\nData\n 17-0\n 35-18\n 53-36\n 71-54\n 89-72\n 107-90\nLCD_PCLK enable\n 108\n 111\n 114\n 117\n 120\n 123\nLCD_WR_N enable\n 109\n 112\n 115\n 118\n 121\n 124\ndata/command\n 110\n 113\n 116\n 119\n 122\n 125\nFor serial initialization using SPI, main display SPI chip select (Main SCS_) is always output on LCS_ pin while sub display SPI chip select (Sub SCS_) can be optionally output on several pins (see pin output select definition).\nInitialization cycle through SPI interface can only be sent to either main or sub display but not to both and the selection bits are specified in the tables below.\nNote that 0 indicates main display initialization and 1 indicates sub display initialization.\nFor 8-bit SPI initialization - up to 12 initialization cycles can be done:\nInit cycle\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10\n 11\n 12\nData\n 7-0\n 15-8\n 23-16\n 31-24\n 39-32\n 47-40\n 55-48\n 63-56\n 71-64\n 79-72\n 87-80\n 95-88\nMain/Sub SCS_\n 96\n 98\n 100\n 102\n 104\n 106\n 108\n 110\n 112\n 114\n 116\n 118\n SDC\n 97\n 99\n 101\n 103\n 105\n 107\n 109\n 111\n 113\n 115\n 117\n 119\nFor 12-bit SPI initialization - up to 9 initialization cycles can be done:\nInit cycle\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\nData\n 11-0\n 23-12\n 35-24\n 47-36\n 59-48\n 71-60\n 83-72\n 95-84\n 107-96\nMain/Sub SCS_\n 109\n 111\n 113\n 115\n 117\n 119\n 121\n 123\n 125\n LCD_DC0\n 110\n 112\n 114\n 116\n 118\n 120\n 122\n 124\n 126\nFor 16-bit SPI initialization - up to 7 initialization cycles can be done:\nInit cycle\n 1\n 2\n 3\n 4\n 5\n 6\n 7\nData\n 15-0\n 31-16\n 47-32\n 63-48\n 79-64\n 95-80\n 111-96\nMain/Sub SCS_\n 112\n 114\n 116\n 118\n 120\n 122\n 124\nSDC\n 113\n 115\n 117\n 119\n 121\n 123\n 125\nFor 18-bit SPI initialization - up to 6 initialization cycles can be done:\nInit cycle\n 1\n 2\n 3\n 4\n 5\n 6\nData\n 17-0\n 35-18\n 53-36\n 71-54\n 89-72\n 107-90\nMain/Sub SCS_\n 108\n 110\n 112\n 114\n 116\n 118\nSDC\n 109\n 111\n 113\n 115\n 117\n 119\nFor 24-bit SPI initialization - up to 4 initialization cycles can be done:\nInit cycle\n 1\n 2\n 3\n 4\nData\n 23-0\n 47-24\n 71-48\n 95-72\nMain/Sub SCS_\n 96\n 98\n 100\n 102\nSDC\n 97\n 99\n 101\n 103";
}

#define DISP_SPI_INIT_SEQ_DATA_B_OFFSET 0x444
#define DISP_SPI_INIT_SEQ_DATA_B_UNDEFMASK 0x00000000
union disp_spi_init_seq_data_b_u {
    struct {
        unsigned int spi_init_seq_data_b:32;/* SPI Init Sequence Write Data bits 63-32 */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_spi_init_seq_data_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_spi_init_seq_data_b_u old_value_t = { .reg32 = value };
    const disp_spi_init_seq_data_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: spi_init_seq_data_b:32",
              "SPI Init Sequence Write Data bits 63-32",
              32, old_value_t.spi_init_seq_data_b, new_value_t.spi_init_seq_data_b };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "SPI Init Sequence Write Data B";
}

#define DISP_SPI_INIT_SEQ_DATA_C_OFFSET 0x445
#define DISP_SPI_INIT_SEQ_DATA_C_UNDEFMASK 0x00000000
union disp_spi_init_seq_data_c_u {
    struct {
        unsigned int spi_init_seq_data_c:32;/* SPI Init Sequence Write Data bits 95-64 */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_spi_init_seq_data_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_spi_init_seq_data_c_u old_value_t = { .reg32 = value };
    const disp_spi_init_seq_data_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: spi_init_seq_data_c:32",
              "SPI Init Sequence Write Data bits 95-64",
              32, old_value_t.spi_init_seq_data_c, new_value_t.spi_init_seq_data_c };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "SPI Init Sequence Write Data C";
}

#define DISP_SPI_INIT_SEQ_DATA_D_OFFSET 0x446
#define DISP_SPI_INIT_SEQ_DATA_D_UNDEFMASK 0x00000000
union disp_spi_init_seq_data_d_u {
    struct {
        unsigned int spi_init_seq_data_d:32;/* SPI Init Sequence Write Data bits 127-96 */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_spi_init_seq_data_d_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_spi_init_seq_data_d_u old_value_t = { .reg32 = value };
    const disp_spi_init_seq_data_d_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: spi_init_seq_data_d:32",
              "SPI Init Sequence Write Data bits 127-96",
              32, old_value_t.spi_init_seq_data_d, new_value_t.spi_init_seq_data_d };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "SPI Init Sequence Write Data D";
}

#define DISP_DC_MCCIF_FIFOCTRL_OFFSET 0x480
#define DISP_DC_MCCIF_FIFOCTRL_UNDEFMASK 0xFFFFFFF0
union disp_dc_mccif_fifoctrl_u {
    struct {
        unsigned int dc_mccif_wrcl_mcle2x:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int dc_mccif_rdmc_rdfast:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int dc_mccif_wrmc_clle2x:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int dc_mccif_rdcl_rdfast:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_dc_mccif_fifoctrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_dc_mccif_fifoctrl_u old_value_t = { .reg32 = value };
    const disp_dc_mccif_fifoctrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dc_mccif_wrcl_mcle2x:1",
              "0 = DISABLE\n1 = ENABLE",
              1, old_value_t.dc_mccif_wrcl_mcle2x, new_value_t.dc_mccif_wrcl_mcle2x };
    m_bit_details_model.bits.append(entry);
    entry = { "01: dc_mccif_rdmc_rdfast:1",
              "0 = DISABLE\n1 = ENABLE",
              1, old_value_t.dc_mccif_rdmc_rdfast, new_value_t.dc_mccif_rdmc_rdfast };
    m_bit_details_model.bits.append(entry);
    entry = { "02: dc_mccif_wrmc_clle2x:1",
              "0 = DISABLE\n1 = ENABLE",
              1, old_value_t.dc_mccif_wrmc_clle2x, new_value_t.dc_mccif_wrmc_clle2x };
    m_bit_details_model.bits.append(entry);
    entry = { "03: dc_mccif_rdcl_rdfast:1",
              "0 = DISABLE\n1 = ENABLE",
              1, old_value_t.dc_mccif_rdcl_rdfast, new_value_t.dc_mccif_rdcl_rdfast };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Memory Client Interface FIFO Control Register\nThe registers below enable optimizing of the synchronization timing in the memory client asynchronous FIFOs. When they can be used depends on the client and memory controller clock ratio. The RDMC_RDFAST/RDCL_RDFAST fields can increase power consumption if the asynchronous FIFO is implemented as a real ram.\nThere is no power impact on latch-based FIFOs. Flip-flop-based FIFOs do not use these fields.\nRecommended Settings\n    * Client writing to FIFO, memory controller reading from FIFO\n- MCCLK_FREQ <= CLIENTCLK_FREQ\nYou can enable both RDMC_RDFAST and WRCL_CLLE2X. If one of the FIFOs is a real ram and power is a concern, you should avoid enabling RDMC_RDFAST.\n- CLIENTCLK_FREQ < MCCLK_FREQ <= 2 * CLIENTCLK_FREQ\nYou can enable RDMC_RDFAST or WRCL_MCLE2X, but because the client clock is slower, you should enable only WRCL_MCLE2X.\n- 2 * CLIENTCLK_FREQ < MCCLK_FREQ\nYou can only enable RDMC_RDFAST. If one of the FIFOs is a real ram and power is a concern, you should avoid enabling RDMC_RDFAST.\n    * Memory controller writing to FIFO, client reading from FIFO\n- CLIENTCLK_FREQ <= MCCLK_FREQ\nYou can enable both RDCL_RDFAST and WRMC_CLLE2X. If one of the FIFOs is a real ram and power is a concern, you should avoid enabling RDCL_RDFAST.\n- MCCLK_FREQ < CLIENTCLK_FREQ <= 2 * MCCLK_FREQ\nYou can enable RDCL_RDFAST or WRMC_CLLE2X, but because the memory controller clock is slower, you should enable only WRMC_CLLE2X.\n- - 2 * MCCLK_FREQ < CLIENTCLK_FREQ\nYou can only enable RDCL_RDFAST. If one of the FIFOs is a real ram and power is a concern, you should avoid enabling RDCL_RDFAST.";
}

#define DISP_MCCIF_DISPLAY0A_HYST_OFFSET 0x481
#define DISP_MCCIF_DISPLAY0A_HYST_UNDEFMASK 0x00000000
union disp_mccif_display0a_hyst_u {
    struct {
        unsigned int cbr_display0a2mc_hyst_req_tm:8;
        unsigned int cbr_display0a2mc_dhyst_tm:8;
        unsigned int cbr_display0a2mc_dhyst_th:8;
        unsigned int cbr_display0a2mc_hyst_tm:4;
        unsigned int cbr_display0a2mc_hyst_req_th:3;
        unsigned int cbr_display0a2mc_hyst_en:1;/* 1 = ENABLE 0 = DISABLE */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_mccif_display0a_hyst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_mccif_display0a_hyst_u old_value_t = { .reg32 = value };
    const disp_mccif_display0a_hyst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbr_display0a2mc_hyst_req_tm:8", "", 8, old_value_t.cbr_display0a2mc_hyst_req_tm, new_value_t.cbr_display0a2mc_hyst_req_tm };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cbr_display0a2mc_dhyst_tm:8", "", 8, old_value_t.cbr_display0a2mc_dhyst_tm, new_value_t.cbr_display0a2mc_dhyst_tm };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbr_display0a2mc_dhyst_th:8", "", 8, old_value_t.cbr_display0a2mc_dhyst_th, new_value_t.cbr_display0a2mc_dhyst_th };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cbr_display0a2mc_hyst_tm:4", "", 4, old_value_t.cbr_display0a2mc_hyst_tm, new_value_t.cbr_display0a2mc_hyst_tm };
    m_bit_details_model.bits.append(entry);
    entry = { "28: cbr_display0a2mc_hyst_req_th:3", "", 3, old_value_t.cbr_display0a2mc_hyst_req_th, new_value_t.cbr_display0a2mc_hyst_req_th };
    m_bit_details_model.bits.append(entry);
    entry = { "31: cbr_display0a2mc_hyst_en:1",
              "1 = ENABLE\n0 = DISABLE",
              1, old_value_t.cbr_display0a2mc_hyst_en, new_value_t.cbr_display0a2mc_hyst_en };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Memory Client Hysteresis Control Register\nThis register exists only for clients with hysteresis. HYST_EN can be used to turn on or off the hysteresis logic. HYST_REQ_TH is the threshold of pending requests required before allowing them to pass through (overridden after HYST_REQ_TM cycles). Hysteresis logic will stop holding request after (1<< HYST_TM) cycles (this should not normally have to be used).\nDeep hysteresis is a second level of hysteresis on a longer time-frame. DHYST_TH is the size of the read burst (requests are held until there is space for the entire burst in the return data FIFO). During a burst period, if there are no new requests after DHYST_TM cycles, then the burst is terminated early.";
}

#define DISP_MCCIF_DISPLAY0B_HYST_OFFSET 0x482
#define DISP_MCCIF_DISPLAY0B_HYST_UNDEFMASK 0x00000000
union disp_mccif_display0b_hyst_u {
    struct {
        unsigned int cbr_display0b2mc_hyst_req_tm:8;
        unsigned int cbr_display0b2mc_dhyst_tm:8;
        unsigned int cbr_display0b2mc_dhyst_th:8;
        unsigned int cbr_display0b2mc_hyst_tm:4;
        unsigned int cbr_display0b2mc_hyst_req_th:3;
        unsigned int cbr_display0b2mc_hyst_en:1;/* 1 = ENABLE 0 = DISABLE */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_mccif_display0b_hyst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_mccif_display0b_hyst_u old_value_t = { .reg32 = value };
    const disp_mccif_display0b_hyst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbr_display0b2mc_hyst_req_tm:8", "", 8, old_value_t.cbr_display0b2mc_hyst_req_tm, new_value_t.cbr_display0b2mc_hyst_req_tm };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cbr_display0b2mc_dhyst_tm:8", "", 8, old_value_t.cbr_display0b2mc_dhyst_tm, new_value_t.cbr_display0b2mc_dhyst_tm };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbr_display0b2mc_dhyst_th:8", "", 8, old_value_t.cbr_display0b2mc_dhyst_th, new_value_t.cbr_display0b2mc_dhyst_th };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cbr_display0b2mc_hyst_tm:4", "", 4, old_value_t.cbr_display0b2mc_hyst_tm, new_value_t.cbr_display0b2mc_hyst_tm };
    m_bit_details_model.bits.append(entry);
    entry = { "28: cbr_display0b2mc_hyst_req_th:3", "", 3, old_value_t.cbr_display0b2mc_hyst_req_th, new_value_t.cbr_display0b2mc_hyst_req_th };
    m_bit_details_model.bits.append(entry);
    entry = { "31: cbr_display0b2mc_hyst_en:1",
              "1 = ENABLE\n0 = DISABLE",
              1, old_value_t.cbr_display0b2mc_hyst_en, new_value_t.cbr_display0b2mc_hyst_en };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Memory Client Hysteresis Control Register\nThis register exists only for clients with hysteresis. HYST_EN can be used to turn on or off the hysteresis logic. HYST_REQ_TH is the threshold of pending requests required before allowing them to pass through (overridden after\nHYST_REQ_TM cycles). Hysteresis logic will stop holding request after (1<<HYST_TM) cycles (this should not normally have to be used).\nDeep hysteresis is a second level of hysteresis on a longer time-frame. DHYST_TH is the size of the read burst (requests are held until there is space for the entire burst in the return data FIFO). During a burst period, if there are no new requests after DHYST_TM cycles, then the burst is terminated early.";
}

#define DISP_MCCIF_DISPLAY0C_HYST_OFFSET 0x483
#define DISP_MCCIF_DISPLAY0C_HYST_UNDEFMASK 0x00000000
union disp_mccif_display0c_hyst_u {
    struct {
        unsigned int cbr_display0c2mc_hyst_req_tm:8;
        unsigned int cbr_display0c2mc_dhyst_tm:8;
        unsigned int cbr_display0c2mc_dhyst_th:8;
        unsigned int cbr_display0c2mc_hyst_tm:4;
        unsigned int cbr_display0c2mc_hyst_req_th:3;
        unsigned int cbr_display0c2mc_hyst_en:1;/* 1 = ENABLE 0 = DISABLE */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_mccif_display0c_hyst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_mccif_display0c_hyst_u old_value_t = { .reg32 = value };
    const disp_mccif_display0c_hyst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbr_display0c2mc_hyst_req_tm:8", "", 8, old_value_t.cbr_display0c2mc_hyst_req_tm, new_value_t.cbr_display0c2mc_hyst_req_tm };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cbr_display0c2mc_dhyst_tm:8", "", 8, old_value_t.cbr_display0c2mc_dhyst_tm, new_value_t.cbr_display0c2mc_dhyst_tm };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbr_display0c2mc_dhyst_th:8", "", 8, old_value_t.cbr_display0c2mc_dhyst_th, new_value_t.cbr_display0c2mc_dhyst_th };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cbr_display0c2mc_hyst_tm:4", "", 4, old_value_t.cbr_display0c2mc_hyst_tm, new_value_t.cbr_display0c2mc_hyst_tm };
    m_bit_details_model.bits.append(entry);
    entry = { "28: cbr_display0c2mc_hyst_req_th:3", "", 3, old_value_t.cbr_display0c2mc_hyst_req_th, new_value_t.cbr_display0c2mc_hyst_req_th };
    m_bit_details_model.bits.append(entry);
    entry = { "31: cbr_display0c2mc_hyst_en:1",
              "1 = ENABLE\n0 = DISABLE",
              1, old_value_t.cbr_display0c2mc_hyst_en, new_value_t.cbr_display0c2mc_hyst_en };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Memory Client Hysteresis Control Register\nThis register exists only for clients with hysteresis. HYST_EN can be used to turn on or off the hysteresis logic. HYST_REQ_TH is the threshold of pending requests required before allowing them to pass through (overridden after HYST_REQ_TM cycles). Hysteresis logic will stop holding request after (1<<HYST_TM) cycles (this should not normally have to be used and is only a WAR for unexpected hangs).\nDeep hysteresis is a second level of hysteresis on a longer time-frame. DHYST_TH is the size of the read burst (requests are held until there is space for the entire burst in the return data FIFO). During a burst period, if there are no new requests after DHYST_TM cycles, then the burst is terminated early.";
}

#define DISP_MCCIF_DISPLAY1B_HYST_OFFSET 0x484
#define DISP_MCCIF_DISPLAY1B_HYST_UNDEFMASK 0x00000000
union disp_mccif_display1b_hyst_u {
    struct {
        unsigned int cbr_display1b2mc_hyst_req_tm:8;
        unsigned int cbr_display1b2mc_dhyst_tm:8;
        unsigned int cbr_display1b2mc_dhyst_th:8;
        unsigned int cbr_display1b2mc_hyst_tm:4;
        unsigned int cbr_display1b2mc_hyst_req_th:3;
        unsigned int cbr_display1b2mc_hyst_en:1;/* 1 = ENABLE 0 = DISABLE */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_mccif_display1b_hyst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_mccif_display1b_hyst_u old_value_t = { .reg32 = value };
    const disp_mccif_display1b_hyst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbr_display1b2mc_hyst_req_tm:8", "", 8, old_value_t.cbr_display1b2mc_hyst_req_tm, new_value_t.cbr_display1b2mc_hyst_req_tm };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cbr_display1b2mc_dhyst_tm:8", "", 8, old_value_t.cbr_display1b2mc_dhyst_tm, new_value_t.cbr_display1b2mc_dhyst_tm };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbr_display1b2mc_dhyst_th:8", "", 8, old_value_t.cbr_display1b2mc_dhyst_th, new_value_t.cbr_display1b2mc_dhyst_th };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cbr_display1b2mc_hyst_tm:4", "", 4, old_value_t.cbr_display1b2mc_hyst_tm, new_value_t.cbr_display1b2mc_hyst_tm };
    m_bit_details_model.bits.append(entry);
    entry = { "28: cbr_display1b2mc_hyst_req_th:3", "", 3, old_value_t.cbr_display1b2mc_hyst_req_th, new_value_t.cbr_display1b2mc_hyst_req_th };
    m_bit_details_model.bits.append(entry);
    entry = { "31: cbr_display1b2mc_hyst_en:1",
              "1 = ENABLE\n0 = DISABLE",
              1, old_value_t.cbr_display1b2mc_hyst_en, new_value_t.cbr_display1b2mc_hyst_en };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Memory Client Hysteresis Control Register\nThis register exists only for clients with hysteresis. HYST_EN can be used to turn on or off the hysteresis logic. HYST_REQ_TH is the threshold of pending requests required before allowing them to pass through (overridden after HYST_REQ_TM cycles). Hysteresis logic will stop holding request after (1<<HYST_TM) cycles (this should not normally have to be used).\nDeep hysteresis is a second level of hysteresis on a longer time-frame. DHYST_TH is the size of the read burst (requests are held until there is space for the entire burst in the return data FIFO). During a burst period, if there are no new requests after DHYST_TM cycles, then the burst is terminated early.";
}

#define DISP_DAC_CRT_CTRL_OFFSET 0x4C0
#define DISP_DAC_CRT_CTRL_UNDEFMASK 0xFFFFFFEA
union disp_dac_crt_ctrl_u {
    struct {
        unsigned int override_notblank:1;   /* If enabled, output display2tvdac_NOTBLANK is tied to 1 0= disable 1= enable 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int sync_select:1;         /* Selects the source for display2tvdac_[hv]sync 0 = VSYNC_HSYNC 1 = LVP0_LHP0 */
        unsigned int undefined_bit_3:1;
        unsigned int notblank_select:1;     /* Selects the source for display2tvdac_notblank 0: notblank = d_active[10] (i.e. data_enable) 1: notblank = (lvp[1] & lhp[1]) 0 = DE 1 = LVP1_LHP1 */
        unsigned int undefined_bits_5_31:27;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_dac_crt_ctrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_dac_crt_ctrl_u old_value_t = { .reg32 = value };
    const disp_dac_crt_ctrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: override_notblank:1",
              "If enabled, output display2tvdac_NOTBLANK is tied to 1\n0= disable\n1= enable\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.override_notblank, new_value_t.override_notblank };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: sync_select:1",
              "Selects the source for display2tvdac_[hv]sync\n0 = VSYNC_HSYNC\n1 = LVP0_LHP0",
              1, old_value_t.sync_select, new_value_t.sync_select };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bit_3:1", "", 1, old_value_t.undefined_bit_3, new_value_t.undefined_bit_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: notblank_select:1",
              "Selects the source for display2tvdac_notblank 0: notblank = d_active[10] (i.e. data_enable) 1: notblank = (lvp[1] & lhp[1])\n0 = DE\n1 = LVP1_LHP1",
              1, old_value_t.notblank_select, new_value_t.notblank_select };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_31:27", "", 27, old_value_t.undefined_bits_5_31, new_value_t.undefined_bits_5_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "CRT Control Register\nControl Registers for CRT Mode (including CYA bits). Control registers for triple DAC/CRT operation (display2tvdac signals)\nA register outside of display, TVDACCCONFIG, controls which source among display/displayb/tvo goes to TVDAC.";
}

#define DISP_DISP_MISC_CONTROL_OFFSET 0x4C1
#define DISP_DISP_MISC_CONTROL_UNDEFMASK 0xFFFFFFFC
union disp_disp_misc_control_u {
    struct {
        unsigned int phase_shift_2p1c18b:1; /* Enable phase shift for 2P1C format phase shift SC0/SC1 will be delayed for one pixel clock cycle. In 2P1C format, data will hold for 2 pixel clocks, so either choice should work 0 = DISABLE 1 = ENABLE */
        unsigned int uf_line_flush:1;       /* Enable underflow line flush, a.o.t end-of-frame flush. underflow line flush  0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_2_31:30;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_disp_misc_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_disp_misc_control_u old_value_t = { .reg32 = value };
    const disp_disp_misc_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: phase_shift_2p1c18b:1",
              "Enable phase shift for 2P1C format phase shift SC0/SC1 will be delayed for one pixel clock cycle. In 2P1C format, data will hold for 2 pixel clocks, so either choice should work\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.phase_shift_2p1c18b, new_value_t.phase_shift_2p1c18b };
    m_bit_details_model.bits.append(entry);
    entry = { "01: uf_line_flush:1",
              "Enable underflow line flush, a.o.t end-of-frame flush. underflow line flush \n0 = DISABLE;\n1 = ENABLE",
              1, old_value_t.uf_line_flush, new_value_t.uf_line_flush };
    m_bit_details_model.bits.append(entry);
    entry = { "02: undefined_bits_2_31:30", "", 30, old_value_t.undefined_bits_2_31, new_value_t.undefined_bits_2_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Miscellaneous controls, including CYA features.";
}

#define WINC_A_COLOR_PALETTE_OFFSET 0x500
#define WINC_A_COLOR_PALETTE_UNDEFMASK 0xFF000000
union winc_a_color_palette_u {
    struct {
        unsigned int a_color_palette_r:8;   /* Red Color Palette */
        unsigned int a_color_palette_g:8;   /* Green Color Palette */
        unsigned int a_color_palette_b:8;   /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_a_color_palette_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_a_color_palette_u old_value_t = { .reg32 = value };
    const winc_a_color_palette_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_color_palette_r:8",
              "Red Color Palette",
              8, old_value_t.a_color_palette_r, new_value_t.a_color_palette_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: a_color_palette_g:8",
              "Green Color Palette",
              8, old_value_t.a_color_palette_g, new_value_t.a_color_palette_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: a_color_palette_b:8",
              "Blue Color Palette",
              8, old_value_t.a_color_palette_b, new_value_t.a_color_palette_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "This is used for palletized data format (color depth of 8-bpp or less) or for gamma correction for non-palletized data formats (color depth of more than 8-bpp).\nEach window has its own color palette which consists of three 256x8 register file which can be written by host and indexed (read) by the window.\nFor palletized data format less than 8-bpp the pixel data is aligned to least significant bits of the palette index (address) and the remaining upper bits are filled with the corresponding bits of the Palette Color Extension. For example, for 4-bpp mode, the pixel data occupies bits 3-0 of the palette index and bits 7-4 of the palette index are set to bits 7-4 of the Palette Color Extension.\nNote that host read is assumed to be not needed - software can cache the color palette in system memory.\nThis is an array of 256 identical register entries; the register fields below apply to each entry.\nWindow A Color Palette";
}

#define WINC_A_PALETTE_COLOR_EXT_OFFSET 0x600
#define WINC_A_PALETTE_COLOR_EXT_UNDEFMASK 0xFFFFFF01
union winc_a_palette_color_ext_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int a_palette_color_ext:7; /* Window A Palette Color Extension bits 7-1 are used for 1-bpp mode bits 7-2 are used for 2-bpp mode bits 7-4 are used for 4-bpp mode */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_a_palette_color_ext_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_a_palette_color_ext_u old_value_t = { .reg32 = value };
    const winc_a_palette_color_ext_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bit_0:1", "", 1, old_value_t.undefined_bit_0, new_value_t.undefined_bit_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "01: a_palette_color_ext:7",
              "Window A Palette Color Extension bits 7-1 are used for 1-bpp mode bits 7-2 are used for 2-bpp mode bits 7-4 are used for 4-bpp mode",
              7, old_value_t.a_palette_color_ext, new_value_t.a_palette_color_ext };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Palette extension for 1-bpp, 2-bpp, and 4-bpp. These bits provide the upper most significant bits for indexing the color palette. Supported for window A only. XXX should ifdef for window A, but currently window B spec is assumed to be a superset.\nWindow A Palette Color Extension";
}

#define WIN_A_WIN_OPTIONS_OFFSET 0x700
#define WIN_A_WIN_OPTIONS_UNDEFMASK 0xBFEEFFBA
union win_a_win_options_u {
    struct {
        unsigned int a_h_direction:1;       /* Window A Horizontal (X) drawing Direction  0 = INCREMENT 1 = DECREMENT */
        unsigned int undefined_bit_1:1;
        unsigned int a_v_direction:1;       /* Window A Vertical (Y) drawing Direction  0 = INCREMENT 1 = DECREMENT */
        unsigned int undefined_bits_3_5:3;
        unsigned int a_color_expand:1;      /* Window A 12/15/16/18-to-24 bpp color expansion This bit should be enabled only for 12-bpp B4G4R4A4, 15-bpp B5G5R5A, 16-bpp B5G6R5, 18-bpp B6G6R6 color modes. If enabled the color conversion is performed prior to horizontal scaling.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_7_15:9;
        unsigned int a_cp_enable:1;         /* Window A Color Palette Enable This controls the color palette and should be enabled for palletized color modes. For non-palletized color modes, the color palette can be enabled for gamma correction.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_17_19:3;
        unsigned int a_dv_enable:1;         /* Window A Digital Vibrance Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_21_29:9;
        unsigned int a_win_enable:1;        /* Window A Window enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_win_options_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_win_options_u old_value_t = { .reg32 = value };
    const win_a_win_options_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_h_direction:1",
              "Window A Horizontal (X) drawing Direction \n0 = INCREMENT\n1 = DECREMENT",
              1, old_value_t.a_h_direction, new_value_t.a_h_direction };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: a_v_direction:1",
              "Window A Vertical (Y) drawing Direction \n0 = INCREMENT\n1 = DECREMENT",
              1, old_value_t.a_v_direction, new_value_t.a_v_direction };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_5:3", "", 3, old_value_t.undefined_bits_3_5, new_value_t.undefined_bits_3_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: a_color_expand:1",
              "Window A 12/15/16/18-to-24 bpp color expansion This bit should be enabled only for 12-bpp B4G4R4A4, 15-bpp B5G5R5A, 16-bpp B5G6R5, 18-bpp B6G6R6 color modes. If enabled the color conversion is performed prior to horizontal scaling.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.a_color_expand, new_value_t.a_color_expand };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bits_7_15:9", "", 9, old_value_t.undefined_bits_7_15, new_value_t.undefined_bits_7_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: a_cp_enable:1",
              "Window A Color Palette Enable This controls the color palette and should be enabled for palletized color modes. For non-palletized color modes, the color palette can be enabled for gamma correction.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.a_cp_enable, new_value_t.a_cp_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: a_dv_enable:1",
              "Window A Digital Vibrance Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.a_dv_enable, new_value_t.a_dv_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_29:9", "", 9, old_value_t.undefined_bits_21_29, new_value_t.undefined_bits_21_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: a_win_enable:1",
              "Window A Window enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.a_win_enable, new_value_t.a_win_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A Options\nClass: Display Window Settings\nDisplay Window A parameters";
}

#define WIN_A_BYTE_SWAP_OFFSET 0x701
#define WIN_A_BYTE_SWAP_UNDEFMASK 0xFFFFFFFC
union win_a_byte_swap_u {
    struct {
        unsigned int a_byte_swap:2;         /* Window A Byte Swap This controls byte swap of frame data read from memory prior to any data processing in the display module. 00= no byte swap (3 2 1 0) 01= byte swap for each 2-byte word (2 3 0 1) 10= byte swap for each 4-byte word (0 1 2 3) 11= word swap for each 4-byte word (1 0 3 2) 0 = NOSWAP 1 = SWAP2 2 = SWAP4 3 = SWAP4HW */
        unsigned int undefined_bits_2_31:30;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_byte_swap_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_byte_swap_u old_value_t = { .reg32 = value };
    const win_a_byte_swap_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_byte_swap:2",
              "Window A Byte Swap This controls byte swap of frame data read from memory prior to any data processing in the display module.\n00= no byte swap (3 2 1 0)\n01= byte swap for each 2-byte word (2 3 0 1)\n10= byte swap for each 4-byte word (0 1 2 3)\n11= word swap for each 4-byte word (1 0 3 2)\n0 = NOSWAP\n1 = SWAP2\n2 = SWAP4\n3 = SWAP4HW",
              2, old_value_t.a_byte_swap, new_value_t.a_byte_swap };
    m_bit_details_model.bits.append(entry);
    entry = { "02: undefined_bits_2_31:30", "", 30, old_value_t.undefined_bits_2_31, new_value_t.undefined_bits_2_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A Byte Swap";
}

#define WIN_A_BUFFER_CONTROL_OFFSET 0x702
#define WIN_A_BUFFER_CONTROL_UNDEFMASK 0xFFFFFFF8
union win_a_buffer_control_u {
    struct {
        unsigned int a_buffer_control:3;    /* Window A Buffer Control 0= Host (software) controlled 1= Video Input controlled 2= Encoder Pre-Processor controlled 3= MPEG Encoder controlled 4= StretchBLT or 2D other= reserved If window buffer selection is not controlled by host (software) then buffer start indexes are sent by the respective module specified by this parameter, and in this case, the buffer start address registers are used to specify frame stride and buffer offset for the calculated start address. 0 = HOST 1 = VI 2 = EPP 4 = SB2D 3 = MPEGE */
        unsigned int undefined_bits_3_31:29;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_buffer_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_buffer_control_u old_value_t = { .reg32 = value };
    const win_a_buffer_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_buffer_control:3",
              "Window A Buffer Control\n0= Host (software) controlled\n1= Video Input controlled\n2= Encoder Pre-Processor controlled\n3= MPEG Encoder controlled\n4= StretchBLT or 2D other= reserved If window buffer selection is not controlled by host (software) then buffer start indexes are sent by the respective module specified by this parameter, and in this case, the buffer start address registers are used to specify frame stride and buffer offset for the calculated start address.\n0 = HOST\n1 = VI\n2 = EPP\n4 = SB2D\n3 = MPEGE",
              3, old_value_t.a_buffer_control, new_value_t.a_buffer_control };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_31:29", "", 29, old_value_t.undefined_bits_3_31, new_value_t.undefined_bits_3_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A Buffer Control";
}

#define WIN_A_COLOR_DEPTH_OFFSET 0x703
#define WIN_A_COLOR_DEPTH_UNDEFMASK 0xFFFFFFE0
union win_a_color_depth_u {
    struct {
        unsigned int a_color_depth:5;       /* Window A Color Depth Supported color depths are: P1 = 1-bpp (palletized) P2 = 2-bpp (palletized) P4 = 4-bpp (palletized) P8 = 8-bpp (palletized) B4G4R4A4 = 12-bpp B4G4R4 B5G5R5A = 15-bpp B5G5R5 AB5G5R5 = 15-bpp B5G5R5 B5G6R5 = 16-bpp B5G6R5 B8G8R8A8 = 32-bpp B8G8R8A8 R8G8B8A8 = 32-bpp R8G8B8A8 B6x2G6x2R6x2A8 = 32-bpp B6G6R6A8 R6x2G6x2B6x2A8 = 32-bpp R6G6B6A8 0 = P1 1 = P2 2 = P4 3 = P8 4 = B4G4R4A4 5 = B5G5R5A 6 = B5G6R5 7 = AB5G5R5 12 = B8G8R8A8 13 = R8G8B8A8 14 = B6x2G6x2R6x2A8 15 = R6x2G6x2B6x2A8 16 = YCbCr422 17 = YUV422 18 = YCbCr420P 19 = YUV420P 20 = YCbCr422P 21 = YUV422P 22 = YCbCr422R 23 = YUV422R 24 = YCbCr422RA 25 = YUV422RA */
        unsigned int undefined_bits_5_31:27;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_color_depth_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_color_depth_u old_value_t = { .reg32 = value };
    const win_a_color_depth_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_color_depth:5",
              "Window A Color Depth Supported color depths are: P1 = 1-bpp (palletized) P2 = 2-bpp (palletized) P4 = 4-bpp (palletized) P8 = 8-bpp (palletized) B4G4R4A4 = 12-bpp B4G4R4 B5G5R5A = 15-bpp B5G5R5 AB5G5R5 = 15-bpp B5G5R5 B5G6R5 = 16-bpp B5G6R5 B8G8R8A8 = 32-bpp B8G8R8A8 R8G8B8A8 = 32-bpp R8G8B8A8 B6x2G6x2R6x2A8 = 32-bpp B6G6R6A8 R6x2G6x2B6x2A8 = 32-bpp R6G6B6A8\n0 = P1\n1 = P2\n2 = P4\n3 = P8\n4 = B4G4R4A4\n5 = B5G5R5A\n6 = B5G6R5\n7 = AB5G5R5\n12 = B8G8R8A8\n13 = R8G8B8A8\n14 = B6x2G6x2R6x2A8\n15 = R6x2G6x2B6x2A8\n16 = YCbCr422\n17 = YUV422\n18 = YCbCr420P\n19 = YUV420P\n20 = YCbCr422P\n21 = YUV422P\n22 = YCbCr422R\n23 = YUV422R\n24 = YCbCr422RA\n25 = YUV422RA",
              5, old_value_t.a_color_depth, new_value_t.a_color_depth };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_31:27", "", 27, old_value_t.undefined_bits_5_31, new_value_t.undefined_bits_5_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A Color Depth For YCbCr data format, Cb and Cr are 8-bit unsigned values. For YUV data format, U and V are 8-bit signed values.\nYCbCr422R is similar to YCbCr422P but the Cb and Cr are shared vertically.\nYUV422R is similar to YUV422P but the U and V are shared vertically.\nYCbCr422RA is same as YCbCr422R in memory and YUV422RA is same as YUV422R in memory but while reading from memory, for YCbCr422RA and YUV422RA, chroma averaging is applied for each pixel pair so that they can be processed as YUV422 by the display pipeline.\nFor YCbCr422R and YUV422R, every other chroma pixels are not used (discarded) by the display pipeline. B6x2G6x2R6x2A8 is similar to B8G8R6A8 but with the 2 lsb zeroed out.\nR6x2G6x2B6x2A8 is similar to R8G8B6A8 but with the 2 lsb zeroed out.";
}

#define WIN_A_POSITION_OFFSET 0x704
#define WIN_A_POSITION_UNDEFMASK 0xE000E000
union win_a_position_u {
    struct {
        unsigned int a_h_position:13;       /* Window A H Position This is specified with respect to the left edge of active display area */
        unsigned int undefined_bits_13_15:3;
        unsigned int a_v_position:13;       /* Window A V Position This is specified with respect to the top edge of active display area */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_position_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_position_u old_value_t = { .reg32 = value };
    const win_a_position_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_h_position:13",
              "Window A H Position This is specified with respect to the left edge of active display area",
              13, old_value_t.a_h_position, new_value_t.a_h_position };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: a_v_position:13",
              "Window A V Position This is specified with respect to the top edge of active display area",
              13, old_value_t.a_v_position, new_value_t.a_v_position };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A Position\nThis register defines H position and size of Window A after scaling (if there is any)";
}

#define WIN_A_SIZE_OFFSET 0x705
#define WIN_A_SIZE_UNDEFMASK 0xE000E000
union win_a_size_u {
    struct {
        unsigned int a_h_size:13;           /* Window A H Size (pixels) This is the horizontal size after scaling */
        unsigned int undefined_bits_13_15:3;
        unsigned int a_v_size:13;           /* Window A V Size (lines) This is the vertical size after scaling */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_size_u old_value_t = { .reg32 = value };
    const win_a_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_h_size:13",
              "Window A H Size (pixels) This is the horizontal size after scaling",
              13, old_value_t.a_h_size, new_value_t.a_h_size };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: a_v_size:13",
              "Window A V Size (lines) This is the vertical size after scaling",
              13, old_value_t.a_v_size, new_value_t.a_v_size };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window A Size\nThis register defines V position and size of Window A after scaling (if there is any)\n Note: programming on window size should guarantee the whole window is inside the active area, otherwise extra rows/columns will be fetched and discarded which affects performance.";
}

#define WIN_A_PRESCALED_SIZE_OFFSET 0x706
#define WIN_A_PRESCALED_SIZE_UNDEFMASK 0xE0008000
union win_a_prescaled_size_u {
    struct {
        unsigned int a_h_prescaled_size:15; /* Window A H Pre-scaled Size (bytes) In 420P and 422P formats, it must be even */
        unsigned int undefined_bit_15:1;
        unsigned int a_v_prescaled_size:13; /* Window A V Pre-scaled Size (lines) In 420P/422R/422RA formats, it must be even */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_prescaled_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_prescaled_size_u old_value_t = { .reg32 = value };
    const win_a_prescaled_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_h_prescaled_size:15",
              "Window A H Pre-scaled Size (bytes) In 420P and 422P formats, it must be even",
              15, old_value_t.a_h_prescaled_size, new_value_t.a_h_prescaled_size };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: a_v_prescaled_size:13",
              "Window A V Pre-scaled Size (lines) In 420P/422R/422RA formats, it must be even",
              13, old_value_t.a_v_prescaled_size, new_value_t.a_v_prescaled_size };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A Pre-scaled Size\nThis register defines Window A pre-scaled size.\n The H pre-scaled size is needed to determine how many bytes to fetch from memory per line and this parameter must be programmed exactly as needed taking into account the scaling factor. For planar YUV or YCbCr data formats, this parameter refer to the H pre-scaled of the Y plane.\nThe total number of lines to be fetched from memory is determined by post-scale V size but V pre-scaled size is needed to 'clamp' the last valid line if the vertical DDA is exactly or slightly beyond the specified V pre-scaled size.\nDesign Note: H pre-scaled size ideally should be in terms of pixel but then hardware needs to convert this precisely to bytes to determine the amount of data to request from memory.\nThis could be a risky calculation - maybe this should be made optional on whether we use internal hardware to calculate or left it to software to calculate.";
}

#define WIN_A_H_INITIAL_DDA_OFFSET 0x707
#define WIN_A_H_INITIAL_DDA_UNDEFMASK 0xFFFF0000
union win_a_h_initial_dda_u {
    struct {
        unsigned int a_h_initial_dda:16;    /* Window A H Initial DDA (4.12) This is typically programmed to 0.0 */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_h_initial_dda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_h_initial_dda_u old_value_t = { .reg32 = value };
    const win_a_h_initial_dda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_h_initial_dda:16",
              "Window A H Initial DDA (4.12) This is typically programmed to 0.0",
              16, old_value_t.a_h_initial_dda, new_value_t.a_h_initial_dda };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window A H Initial DDA\nDesign Note: the first pixel of pre-scaled image is always used to output the first pixel so essentially this is the same as forcing the H Initial DDA integer portion to 1 initially even though user typically programs this to 0. If it makes the implementation easier, it is possible to force software to program the Initial DDA integer portion to 1. Similarly with the V Initial DDA.";
}

#define WIN_A_V_INITIAL_DDA_OFFSET 0x708
#define WIN_A_V_INITIAL_DDA_UNDEFMASK 0xFFFF0000
union win_a_v_initial_dda_u {
    struct {
        unsigned int a_v_initial_dda:16;    /* Window A V Initial DDA (4.12) This is typically programmed to 0.0 for both non-interlaced and interlaced sources */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_v_initial_dda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_v_initial_dda_u old_value_t = { .reg32 = value };
    const win_a_v_initial_dda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_v_initial_dda:16",
              "Window A V Initial DDA (4.12) This is typically programmed to 0.0 for both non-interlaced and interlaced sources",
              16, old_value_t.a_v_initial_dda, new_value_t.a_v_initial_dda };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A V Initial DDA";
}

#define WIN_A_DDA_INCREMENT_OFFSET 0x709
#define WIN_A_DDA_INCREMENT_UNDEFMASK 0x00000000
union win_a_dda_increment_u {
    struct {
        unsigned int a_h_dda_increment:16;  /* Window A Horizontal DDA Increment (4.12) This should be set to 1.0 if there is no scaling. The maximum value for downscaling depends on the number of bytes per pixel. For 4-byte/pixel modes (32-bpp) the maximum value is 4.0 and for all other modes the maximum value is 8.0 */
        unsigned int a_v_dda_increment:16;  /* Window A Vertical DDA Increment (4.12) This should be set to 1.0 if there is no scaling. Maximum value is 15.0 regardless of the number of bytes per pixel */
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_dda_increment_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_dda_increment_u old_value_t = { .reg32 = value };
    const win_a_dda_increment_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_h_dda_increment:16",
              "Window A Horizontal DDA Increment (4.12) This should be set to 1.0 if there is no scaling. The maximum value for downscaling depends on the number of bytes per pixel. For 4-byte/pixel modes (32-bpp) the maximum value is 4.0 and for all other modes the maximum value is 8.0",
              16, old_value_t.a_h_dda_increment, new_value_t.a_h_dda_increment };
    m_bit_details_model.bits.append(entry);
    entry = { "16: a_v_dda_increment:16",
              "Window A Vertical DDA Increment (4.12) This should be set to 1.0 if there is no scaling. Maximum value is 15.0 regardless of the number of bytes per pixel",
              16, old_value_t.a_v_dda_increment, new_value_t.a_v_dda_increment };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A DDA Increment\nDDA increment is typically calculated by dividing (Pre-scaled size in pixels - 1) by(Post-scaled size in pixels - 1). The result should be round-ed up and expressed as 4.12 format (4-bit integer and 12-bit fraction). For non-filtered image this value can be slightly larger so that it is not missing the last row/column. Reference programming values (H and V should be calculated separately depending on filter on/off and sizes):\n - Filter on: min(round((prescaled_size_in_pixels - 1) * 0x1000 / (post_scaled_size_in_pixels - 1)), MAX)\n - Filter off: min(round(prescaled_size_in_pixels * 0x1000 / (post_scaled_size_in_pixels - 1) - 0.5), MAX)\n Where the value of MAX is as follows:\n For V_DDA_INCREMENT: 15.0 (0xF000)\n For H_DDA_INCREMETN: 4.0 (0x4000) for 2 Bytes/pix formats.\n 8.0 (0x8000) for 4 Bytes/pix formats.\nThey are theoretically the biggest values that guarantees not displaying beyond an image boundary. If the DDA increment is less than 1.0 then image will be up-scaled and if DDA increment is more than 1.0 then image will be down-scaled.";
}

#define WIN_A_LINE_STRIDE_OFFSET 0x70A
#define WIN_A_LINE_STRIDE_UNDEFMASK 0xFFFF0000
union win_a_line_stride_u {
    struct {
        unsigned int a_line_stride:16;      /* Window A Line Stride This is stride (in bytes) for all non-planar data formats. If the memory surface is tiled, the stride needs to be a multiple of 16. If H_DIRECTION of window A is set to DECREMENT, the stride also needs to be a multiple of 16.  For planar YUV or YCbCr data formats, this is stride (in bytes) for the luma plane with the restriction that it must be multiples of 8 (16 if tiled or in horizontal flipping) For tiled surface this value may affect starting address of a window. Refer to the comment of START_ADDR for detail */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_line_stride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_line_stride_u old_value_t = { .reg32 = value };
    const win_a_line_stride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_line_stride:16",
              "Window A Line Stride This is stride (in bytes) for all non-planar data formats. If the memory surface is tiled, the stride needs to be a multiple of 16. If H_DIRECTION of window A is set to DECREMENT, the stride also needs to be a multiple of 16.  For planar YUV or YCbCr data formats, this is stride (in bytes) for the luma plane with the restriction that it must be multiples of 8 (16 if tiled or in horizontal flipping) For tiled surface this value may affect starting address of a window. Refer to the comment of START_ADDR for detail",
              16, old_value_t.a_line_stride, new_value_t.a_line_stride };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window A Line Stride";
}

#define WIN_A_BUF_STRIDE_OFFSET 0x70B
#define WIN_A_BUF_STRIDE_UNDEFMASK 0x00000000
union win_a_buf_stride_u {
    struct {
        unsigned int a_buf_stride:32;       /* Window A Buffer stride Buffer stride is used to calculate the buffer addresses when the window is triggered by non-host modules. Refer to the comment of of START_ADDR for programming guide. For YUV planar pixel format, this specifies buffer stride for the Y plane. The value is in bytes */
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_buf_stride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_buf_stride_u old_value_t = { .reg32 = value };
    const win_a_buf_stride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_buf_stride:32",
              "Window A Buffer stride Buffer stride is used to calculate the buffer addresses when the window is triggered by non-host modules. Refer to the comment of of START_ADDR for programming guide. For YUV planar pixel format, this specifies buffer stride for the Y plane. The value is in bytes",
              32, old_value_t.a_buf_stride, new_value_t.a_buf_stride };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window A Buffer stride";
}

#define WIN_A_BUFFER_ADDR_MODE_OFFSET 0x70D
#define WIN_A_BUFFER_ADDR_MODE_UNDEFMASK 0xFFFFFFFE
union win_a_buffer_addr_mode_u {
    struct {
        unsigned int a_tile_mode:1;         /* Window A Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the Y plane. 0 = LINEAR 1 = TILED */
        unsigned int undefined_bits_1_31:31;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_buffer_addr_mode_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_buffer_addr_mode_u old_value_t = { .reg32 = value };
    const win_a_buffer_addr_mode_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_tile_mode:1",
              "Window A Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the Y plane.\n0 = LINEAR\n1 = TILED",
              1, old_value_t.a_tile_mode, new_value_t.a_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_31:31", "", 31, old_value_t.undefined_bits_1_31, new_value_t.undefined_bits_1_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Memory Controller Tiling definitions";
}

#define WIN_A_DV_CONTROL_OFFSET 0x70E
#define WIN_A_DV_CONTROL_UNDEFMASK 0xFFF8F8F8
union win_a_dv_control_u {
    struct {
        unsigned int a_dv_control_r:3;      /* Digital Vibrance control for R */
        unsigned int undefined_bits_3_7:5;
        unsigned int a_dv_control_g:3;      /* Digital Vibrance control for G */
        unsigned int undefined_bits_11_15:5;
        unsigned int a_dv_control_b:3;      /* Digital Vibrance control for B */
        unsigned int undefined_bits_19_31:13;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_dv_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_dv_control_u old_value_t = { .reg32 = value };
    const win_a_dv_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_dv_control_r:3",
              "Digital Vibrance control for R",
              3, old_value_t.a_dv_control_r, new_value_t.a_dv_control_r };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_7:5", "", 5, old_value_t.undefined_bits_3_7, new_value_t.undefined_bits_3_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: a_dv_control_g:3",
              "Digital Vibrance control for G",
              3, old_value_t.a_dv_control_g, new_value_t.a_dv_control_g };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_15:5", "", 5, old_value_t.undefined_bits_11_15, new_value_t.undefined_bits_11_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: a_dv_control_b:3",
              "Digital Vibrance control for B",
              3, old_value_t.a_dv_control_b, new_value_t.a_dv_control_b };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bits_19_31:13", "", 13, old_value_t.undefined_bits_19_31, new_value_t.undefined_bits_19_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A Digital Vibrance Control\nIf enabled, Digital Vibrance is applied after H and V scaling and after color palette or color space conversion logic but before color keying multiplexer and before cursor multiplexer.\n    *  After DV, new R = R + (2R - G - B) * FR, where FR is fraction from 0 to 7/8\n    *  After DV, new G = G + (2G - R - B) * FG, where FG is fraction from 0 to 7/8\n    *  After DV, new B = B + (2B - R - G) * FB, where FB is fraction from 0 to 7/8";
}

#define WIN_A_BLEND_NOKEY_OFFSET 0x70F
#define WIN_A_BLEND_NOKEY_UNDEFMASK 0xFF0000FE
union win_a_blend_nokey_u {
    struct {
        unsigned int a_blend_control_nokey:1;/* Window blend control for color key not match areas. 0 = Fix weight using window blend weight 0 for color key not matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 0 = FIX_WEIGHT; 1 = ALPHA_WEIGHT */
        unsigned int undefined_bits_1_7:7;
        unsigned int a_blend_weight0_nokey:8;/* Window blend weight 0 for color key not match areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int a_blend_weight1_nokey:8;/* Window blend weight 1 for color key not match areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_blend_nokey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_blend_nokey_u old_value_t = { .reg32 = value };
    const win_a_blend_nokey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_blend_control_nokey:1",
              "Window blend control for color key not match areas.\n0 = Fix weight using window blend weight 0 for color key not matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n0 = FIX_WEIGHT;\n1 = ALPHA_WEIGHT",
              1, old_value_t.a_blend_control_nokey, new_value_t.a_blend_control_nokey };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: a_blend_weight0_nokey:8",
              "Window blend weight 0 for color key not match areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.a_blend_weight0_nokey, new_value_t.a_blend_weight0_nokey };
    m_bit_details_model.bits.append(entry);
    entry = { "16: a_blend_weight1_nokey:8",
              "Window blend weight 1 for color key not match areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.a_blend_weight1_nokey, new_value_t.a_blend_weight1_nokey };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Blend Control for this window areas where color key is enabled but the pixel color is not within the color key range (color key not match). This is valid for all overlapping condition but only if there is no overlap with other window with higher priority color key enabled and color key not match.\n Class: Display Color Keying and Blending\nColor keying and blending of the display windows are done prior to cursor blending.\nCursor always goes on top of the blended windows. Blending is controlled independently on each possible overlap area of the display windows. If 3 windows are enabled there are 7 possible overlap area combinations. For every window in each overlap area combination, color key can be disabled or enabled. Also, for every window in each overlap area combination, there is a corresponding window blend control parameter and a window blend weight parameter. The window blend control parameter is always effective but the window blend weight is not always used. The window blend weight can also be derived from pixel alpha value or from the reverse of other overlapping windows weight.\nColor keying has the highest priority for display window blending. Color key consists of a range of color which is searched independently for each windows. If more than 1 windows color keys are enabled then Window A color key has the highest priority, followed by\nWindow B color key, and then followed by Window C color key. Two sets of color key range (Color Key 0 and Color Key 1) can be defined and they are shared for all windows. It is possible to use both color key sets for the same window or for two separate windows.\nThe two sets of color key ranges should not overlap and if they do the overlap colors are treated as if they are part of Color Key 0 and not part of Color Key 1.\nAssuming that there is no overlap with other higher priority window with color key not matched, if a window color key is enabled for any overlap condition and the window pixel is not within the color key range (key not match), then the window pixel will not be blended with other overlapping window pixels but it will be weighted. The weight is not dependent on the overlap condition it is controlled by the same set of parameters for all overlapping condition.\nAssuming that there is no overlap with other higher priority window with color key not matched, if a window color key is enabled for a particular overlap condition and the window pixel is within the color key range (key match), then the window pixel will be weighted and blended with other overlapping pixels and this is controlled separately for each overlap condition.\nAssuming that there is no overlap with other higher priority window with color key not matched, if a window color key is disabled then the window pixel will be blended with other overlapping pixels and this is controlled separately for each overlap condition.\n Display Color Key parameters\nFor B4G4R4A4, B5G6R5A, B5G6R5 mode, color key should be compared prior to color conversion to 24-bpp and unused least significant bits of the pixel are filled with zeros.\nFor palletized mode, color key is compared prior to color palette and the palletized color is compared against the green color key values/mask.\nFor YUV mode, U and V are offset by +128 before performing the color key comparison. In all cases, color key is compared prior to horizontal/vertical scaling filter and prior to digital vibrance control.\nBoth upper and lower values are inclusive.";
}

#define WIN_A_BLEND_1WIN_OFFSET 0x710
#define WIN_A_BLEND_1WIN_UNDEFMASK 0xFF0000F8
union win_a_blend_1win_u {
    struct {
        unsigned int a_ckey_enable_1win:2;  /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int a_blend_control_1win:1;/* Window blend control in area where it does not overlap with other windows and either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT */
        unsigned int undefined_bits_3_7:5;
        unsigned int a_blend_weight0_1win:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int a_blend_weight1_1win:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_blend_1win_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_blend_1win_u old_value_t = { .reg32 = value };
    const win_a_blend_1win_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_ckey_enable_1win:2",
              "Window color key enable\n0 = Color Key 0 and 1 Disable\n1 = Color Key 0 Enable\n2 = Color Key 1 Enable\n3 = Color Key 0 and 1 Enable\n0 = NOKEY\n1 = CKEY0\n2 = CKEY1\n3 = CKEY01",
              2, old_value_t.a_ckey_enable_1win, new_value_t.a_ckey_enable_1win };
    m_bit_details_model.bits.append(entry);
    entry = { "02: a_blend_control_1win:1",
              "Window blend control in area where it does not overlap with other windows and either color key disabled or color key enabled with key matched.\n0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n0 = FIX_WEIGHT\n1 = ALPHA_WEIGHT",
              1, old_value_t.a_blend_control_1win, new_value_t.a_blend_control_1win };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_7:5", "", 5, old_value_t.undefined_bits_3_7, new_value_t.undefined_bits_3_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: a_blend_weight0_1win:8",
              "Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.a_blend_weight0_1win, new_value_t.a_blend_weight0_1win };
    m_bit_details_model.bits.append(entry);
    entry = { "16: a_blend_weight1_1win:8",
              "Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.a_blend_weight1_1win, new_value_t.a_blend_weight1_1win };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Blend Control for this window area where it does not overlap with other windows.";
}

#define WIN_A_BLEND_2WIN_B_OFFSET 0x711
#define WIN_A_BLEND_2WIN_B_UNDEFMASK 0xFF0000F0
union win_a_blend_2win_b_u {
    struct {
        unsigned int a_ckey_enable_2win_b:2;/* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int a_blend_control_2win_b:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int a_blend_weight0_2win_b:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int a_blend_weight1_2win_b:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_blend_2win_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_blend_2win_b_u old_value_t = { .reg32 = value };
    const win_a_blend_2win_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_ckey_enable_2win_b:2",
              "Window color key enable\n0 = Color Key 0 and 1 Disable\n1 = Color Key 0 Enable\n2 = Color Key 1 Enable\n3 = Color Key 0 and 1 Enable\n0 = NOKEY\n1 = CKEY0\n2 = CKEY1\n3 = CKEY01",
              2, old_value_t.a_ckey_enable_2win_b, new_value_t.a_ckey_enable_2win_b };
    m_bit_details_model.bits.append(entry);
    entry = { "02: a_blend_control_2win_b:2",
              "Window blend control in area where either color key disabled or color key enabled with key matched.\n0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting.\n0 = FIX_WEIGHT\n1 = ALPHA_WEIGHT\n2 = DEPENDENT_WEIGHT",
              2, old_value_t.a_blend_control_2win_b, new_value_t.a_blend_control_2win_b };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_7:4", "", 4, old_value_t.undefined_bits_4_7, new_value_t.undefined_bits_4_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: a_blend_weight0_2win_b:8",
              "Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.a_blend_weight0_2win_b, new_value_t.a_blend_weight0_2win_b };
    m_bit_details_model.bits.append(entry);
    entry = { "16: a_blend_weight1_2win_b:8",
              "Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.a_blend_weight1_2win_b, new_value_t.a_blend_weight1_2win_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Blend Control for this window area that overlaps with window B only.";
}

#define WIN_A_BLEND_2WIN_C_OFFSET 0x712
#define WIN_A_BLEND_2WIN_C_UNDEFMASK 0xFF0000F0
union win_a_blend_2win_c_u {
    struct {
        unsigned int a_ckey_enable_2win_c:2;/* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int a_blend_control_2win_c:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. Only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int a_blend_weight0_2win_c:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int a_blend_weight1_2win_c:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_blend_2win_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_blend_2win_c_u old_value_t = { .reg32 = value };
    const win_a_blend_2win_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_ckey_enable_2win_c:2",
              "Window color key enable\n0 = Color Key 0 and 1 Disable\n1 = Color Key 0 Enable\n2 = Color Key 1 Enable\n3 = Color Key 0 and 1 Enable\n0 = NOKEY\n1 = CKEY0\n2 = CKEY1\n3 = CKEY01",
              2, old_value_t.a_ckey_enable_2win_c, new_value_t.a_ckey_enable_2win_c };
    m_bit_details_model.bits.append(entry);
    entry = { "02: a_blend_control_2win_c:2",
              "Window blend control in area where either color key disabled or color key enabled with key matched.\n0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched.\n1 = Alpha weight using the alpha value. Only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting.\n0 = FIX_WEIGHT\n1 = ALPHA_WEIGHT\n2 = DEPENDENT_WEIGHT",
              2, old_value_t.a_blend_control_2win_c, new_value_t.a_blend_control_2win_c };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_7:4", "", 4, old_value_t.undefined_bits_4_7, new_value_t.undefined_bits_4_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: a_blend_weight0_2win_c:8",
              "Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.a_blend_weight0_2win_c, new_value_t.a_blend_weight0_2win_c };
    m_bit_details_model.bits.append(entry);
    entry = { "16: a_blend_weight1_2win_c:8",
              "Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.a_blend_weight1_2win_c, new_value_t.a_blend_weight1_2win_c };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Blend Control for this window area that overlaps with window C only.";
}

#define WIN_A_BLEND_3WIN_BC_OFFSET 0x713
#define WIN_A_BLEND_3WIN_BC_UNDEFMASK 0xFF0000F3
union win_a_blend_3win_bc_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int a_blend_control_3win_bc:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight */
        unsigned int undefined_bits_4_7:4;
        unsigned int a_blend_weight0_3win_bc:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int a_blend_weight1_3win_bc:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_blend_3win_bc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_blend_3win_bc_u old_value_t = { .reg32 = value };
    const win_a_blend_3win_bc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_1:2", "", 2, old_value_t.undefined_bits_0_1, new_value_t.undefined_bits_0_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: a_blend_control_3win_bc:2",
              "Window blend control in area where either color key disabled or color key enabled with key matched.\n0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight",
              2, old_value_t.a_blend_control_3win_bc, new_value_t.a_blend_control_3win_bc };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_7:4", "", 4, old_value_t.undefined_bits_4_7, new_value_t.undefined_bits_4_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: a_blend_weight0_3win_bc:8",
              "Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.a_blend_weight0_3win_bc, new_value_t.a_blend_weight0_3win_bc };
    m_bit_details_model.bits.append(entry);
    entry = { "16: a_blend_weight1_3win_bc:8",
              "Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.a_blend_weight1_3win_bc, new_value_t.a_blend_weight1_3win_bc };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Blend Control for this window area that overlaps with windows B and C only.";
}

#define WIN_A_HP_FETCH_CONTROL_OFFSET 0x714
#define WIN_A_HP_FETCH_CONTROL_UNDEFMASK 0x00000000
union win_a_hp_fetch_control_u {
    struct {
        unsigned int a_cycles_per_word:16;  /* Window A clock cycles per memory fetch word. The value of this field is essentially a measure of the data consumption rate for window A. It is computed as follows: A_CYCLES_PER_WORD = A_DDA_INCREMENT.A_H_DDA_INCREMENT / (bytes per pixel) Note that the format for this value is a fixed-point fractional value with 8 bits of integer precision and 8 bits of fractional precision. In other words, it is an '8.8' number. For example, if there is no scaling of the input image, the DDA increment will be 4096. With 32-bit RGBA pixels there will be 4 bytes per pixel, so CYCLES_PER_WORD will be ... 4096 / 4 = 1024, or 4.0 expressed in the 8.8 format. Any scaling performed on the pixels will change the rate at which pixels are consumed. Scaling up will increase the value of DDA increment and will therefore increase the number of cycles between memory fetches. Conversely, scaling down will decrease the value of DDA increment and memory fetches will occur more frequently */
        unsigned int a_words_per_line:15;   /* Window A memory fetch words per scan line. This value is in memory fetch words: Multiples of 16 bytes for Tegra 2 Processor Series devices. It is computed as follows: A_WORDS_PER_LINE = (A_SIZE.A_H_SIZE * (bytes per pixel) + 15) >> 4 bytes per pixel is determined by the pixel format */
        unsigned int a_fetch_info_enable:1; /* Enables the sending of the Window A fetch information. For compatibility with earlier devices, this defaults to DISABLE. 0 = DISABLE : This bit should be enabled only for 12-bpp  1 = ENABLE */
    };

    u_int32_t reg32;
};

void DcDev::fill_win_a_hp_fetch_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_a_hp_fetch_control_u old_value_t = { .reg32 = value };
    const win_a_hp_fetch_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_cycles_per_word:16",
              "Window A clock cycles per memory fetch word. The value of this field is essentially a measure of the data consumption rate for window A. It is computed as follows: A_CYCLES_PER_WORD = A_DDA_INCREMENT.A_H_DDA_INCREMENT / (bytes per pixel) Note that the format for this value is a fixed-point fractional value with 8 bits of integer precision and 8 bits of fractional precision. In other words, it is an '8.8' number. For example, if there is no scaling of the input image, the DDA increment will be 4096. With 32-bit RGBA pixels there will be 4 bytes per pixel, so CYCLES_PER_WORD will be ... 4096 /\n4 = 1024, or 4.0 expressed in the 8.8 format. Any scaling performed on the pixels will change the rate at which pixels are consumed. Scaling up will increase the value of DDA increment and will therefore increase the number of cycles between memory fetches. Conversely, scaling down will decrease the value of DDA increment and memory fetches will occur more frequently",
              16, old_value_t.a_cycles_per_word, new_value_t.a_cycles_per_word };
    m_bit_details_model.bits.append(entry);
    entry = { "16: a_words_per_line:15",
              "Window A memory fetch words per scan line. This value is in memory fetch words: Multiples of 16 bytes for Tegra 2 Processor Series devices. It is computed as follows: A_WORDS_PER_LINE = (A_SIZE.A_H_SIZE * (bytes per pixel) + 15) >> 4 bytes per pixel is determined by the pixel format",
              15, old_value_t.a_words_per_line, new_value_t.a_words_per_line };
    m_bit_details_model.bits.append(entry);
    entry = { "31: a_fetch_info_enable:1",
              "Enables the sending of the Window A fetch information. For compatibility with earlier devices, this defaults to DISABLE.\n0 = DISABLE : This bit should be enabled only for 12-bpp \n1 = ENABLE",
              1, old_value_t.a_fetch_info_enable, new_value_t.a_fetch_info_enable };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A High Priority Avoidance Fetch Parameters\nThis register gives extra information to the Memory Controller Client Interface (MCCIF) about the number of memory words that will be fetched per scan line and about the rate at which those words are consumed. This allows the MCCIF to more accurately arbitrate memory accesses to prevent the use of the High Priority signal. Use of this signal causes all other client accesses to be blocked in preference to the client asserting HP.\nThis is a state which is sometime necessary for Display as it is an isochronous client and MUST be serviced in a timely manner. However, use of this signal should be avoided if possible. These parameters help the MCCIF avoid the over-use of HP.";
}

#define WINBUF_A_START_ADDR_OFFSET 0x800
#define WINBUF_A_START_ADDR_UNDEFMASK 0x00000000
union winbuf_a_start_addr_u {
    struct {
        unsigned int a_start_addr:32;       /* Window A Start Address This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies start address for the Y plane */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_a_start_addr_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_a_start_addr_u old_value_t = { .reg32 = value };
    const winbuf_a_start_addr_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_start_addr:32",
              "Window A Start Address This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies start address for the Y plane",
              32, old_value_t.a_start_addr, new_value_t.a_start_addr };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window A Start Address\nOverview\nSTART_ADDR, BUF_STRIDE, LINE_STRIDE, ADDR_H_OFFSET, ADDR_V_OFFSET combined, specify the starting address of a window buffer in the memory surface. Generally START_ADDR is programmed with the starting address of the memory surface. H/V_OFFSET specify the address offsets of the pixel at the beginning of the window, with respect to the starting address of the memory surface. (There is an exception to that when memory surface is not well aligned, see 3-ii below.)\nNote that \"beginning of the window\" here means the top-left corner of a window in normal mode, top-right corner in horizontal flipping, bottom-left corner in vertical flipping, and bottom-right in horizontal+vertical flipping.\nStarting address calculation\nThese formulae are same for both tiled or linear mode. However, for linear mode, the addresses calculated are real physical addresses, but for tile mode, these addresses will be translated to the real physical addresses by the memory controller client before used.\n    * When a window is host triggered, starting address of a window is calculated as follows by HW.\n- non-yuv-planar modes:\nstarting-address = START_ADDR + ADDR_V_OFFSET * LINE_STRIDE + ADDR_H_OFFSET\n- yuv-planar modes:\ny-starting-address = START_ADDR + ADDR_V_OFFSET * LINE_STRIDE + ADDR_H_OFFSET\nu-starting-address = START_ADDR_U + ADDR_V_OFFSET * UV_LINE_STRIDE / denom1 + ADDR_H_OFFSET / denom2\nv-starting-address = START_ADDR_V + ADDR_V_OFFSET * UV_LINE_STRIDE / denom1 + ADDR_H_OFFSET / denom2 where denom1/denom2 equal to 1 or 2 depending on the actual planar format, derived natively by HW.\n    * When a window is non-host triggered, starting address of a window buffer is calculated as below.\n- non-yuv-planar mode:\nstarting-address = START_ADDR + BUF_STRIDE * buf_index + ADDR_V_OFFSET * LINE_STRIDE + ADDR_H_OFFSET\n- yuv-planar mode:\ny-starting-address = START_ADDR + BUF_STRIDE * buf_index + ADDR_V_OFFSET * LINE_STRIDE + ADDR_H_OFFSET\nu-starting-address = START_ADDR_U + UV_BUF_STRIDE * buf_index + ADDR_V_OFFSET * UV_LINE_STRIDE / denom1 + ADDR_H_OFFSET / denom2\nv-starting-address = START_ADDR_V + UV_BUF_STRIDE * buf_index + ADDR_V_OFFSET * UV_LINE_STRIDE / denom1 + ADDR_H_OFFSET / denom2 where denom1/denom2 equal to 1 or 2 depending on the actual planar format, derived natively by HW.\nbuf_index is the index transmitted by the triggering module pointing to the first buffer of a frame.\nProgramming Restrictions\n i. For tiled address mode:\n Image surface can only aligned to multiples of 256, thus the following restrictions.\n - START_ADDR, START_ADDR_U, START_ADDR_V need to be multiples of 256.\n - BUF_STRIDE, UV_BUF_STRIDE need to be multiples of 256\n - LINE_STRIDE, UV_LINE_STRIDE need to be multiples of 16\n - ADDR_H_OFFSET needs to be multiple of 2 in yuv planar format (the last bit is ignored), but with no restrictions on other color formats.\n - ADDR_V_OFFSET has no restrictions\n ii. For linear address mode:\n Image surface can be aligned 2, 4 or 8 bytes, depending on the color formats.\n As an additional restriction for display, START_ADDR, START_ADDR_U and START_ADDR_V need to be multiples of 16.\n When a surface is not aligned to 16 bytes, program START_ADDR with the memory surface address with its least 4 significant bits zeroed out and add these 4 address bits to the original H_OFFSET. (So the formula in 2-i,ii still hold)\n - For all formats:\n -- START_ADDR, START_ADDR_U and START_ADDR_V need to be multiples of 16.\n - For 16-bpp formats,\n -- (START_ADDR+H_OFFSET) need to be multiple of 2. The least significant bit of H_OFFSTE is ignored.\n - For 32-bpp formats,\n -- (START_ADDR+H_OFFSTE) needs to be multiple of 4. The least two significant bits of H_OFFSTE are ignored.\n - For yuv planar formats:\n -- BUF_STRIDE, UV_BUF_STRIDE:\n BUF_STRIDE[2:1]=UV_BUF_STRIDE[1:0]\n or as a stricter constraint: BUF_STRIDE be multiple of 8, UV_BUF_STRIDE be multiple of 4.\n -- LINE_STRIDE, UV_LINE_STRIDE:\n LINE_STRIDE and UV_LINE_STRIDE need to be at least 16.\n LINE_STRIDE needs to be multiple of 8, UV_LINE_STRIDE needs to be multiple of 4.\n -- ADDR_H_OFFSET: Needs to be multiple of 2. If needs to point to odd pixel position, program ADDR_H_OFFSET to be the previous position (or the next position if H-flipped) and program H_INITIAL_DDA bit 12 to 1.\n -- ADDR_V_OFFSET: Needs to be multiple of 2. If needs to point to odd line number, program ADDR_V_OFFSTE to be the previous line number (or next line number if V-flipped) and program V_INITIAL_DDA bit 12 to 1.\n iii. Memory allocation for non-host triggered case:\n When a window buffer is not controlled by host (software) then a frame may be stored in multiple buffers. In this case, the buffers must be contiguous in the memory because display will use the same luma or chroma line strides for all lines in the frame. Also buffer wraparound must not occur in the middle of the displayed part of the frame.\nThe controlling module will send frame start and frame end indicators (flags) to display module to indicate the beginning and end of frame. Buffer start address is latched when frame start flag is active but the actual buffer start address is not switched\nuntil frame end flag is active. In the case where one buffer correspond to one frame then frame start and frame end flag are active every time a buffer index is sent.";
}

#define WINBUF_A_START_ADDR_NS_OFFSET 0x801
#define WINBUF_A_START_ADDR_NS_UNDEFMASK 0x00000000
union winbuf_a_start_addr_ns_u {
    struct {
        unsigned int a_start_addr_ns:32;    /* Window A Shadowed Start Address This is ARM set shadow of Start Address */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_a_start_addr_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_a_start_addr_ns_u old_value_t = { .reg32 = value };
    const winbuf_a_start_addr_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_start_addr_ns:32",
              "Window A Shadowed Start Address This is ARM set shadow of Start Address",
              32, old_value_t.a_start_addr_ns, new_value_t.a_start_addr_ns };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A Shadowed Start Address";
}

#define WINBUF_A_ADDR_H_OFFSET_OFFSET 0x806
#define WINBUF_A_ADDR_H_OFFSET_UNDEFMASK 0x00000000
union winbuf_a_addr_h_offset_u {
    struct {
        unsigned int a_addr_h_offset:32;    /* Window A Horizontal address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies horizontal offset of Y plane. The horizontal offsets of U/V plane is derived by HW */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_a_addr_h_offset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_a_addr_h_offset_u old_value_t = { .reg32 = value };
    const winbuf_a_addr_h_offset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_addr_h_offset:32",
              "Window A Horizontal address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies horizontal offset of Y plane. The horizontal offsets of U/V plane is derived by HW",
              32, old_value_t.a_addr_h_offset, new_value_t.a_addr_h_offset };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A Horizontal address offset";
}

#define WINBUF_A_ADDR_H_OFFSET_NS_OFFSET 0x807
#define WINBUF_A_ADDR_H_OFFSET_NS_UNDEFMASK 0x00000000
union winbuf_a_addr_h_offset_ns_u {
    struct {
        unsigned int a_addr_h_offset_ns:32; /* Window A Shadowed Horizontal address offset This is ARM set shadow of ADDR_H_OFFSET */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_a_addr_h_offset_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_a_addr_h_offset_ns_u old_value_t = { .reg32 = value };
    const winbuf_a_addr_h_offset_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_addr_h_offset_ns:32",
              "Window A Shadowed Horizontal address offset This is ARM set shadow of ADDR_H_OFFSET",
              32, old_value_t.a_addr_h_offset_ns, new_value_t.a_addr_h_offset_ns };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A Shadowed Horizontal address offset";
}

#define WINBUF_A_ADDR_V_OFFSET_OFFSET 0x808
#define WINBUF_A_ADDR_V_OFFSET_UNDEFMASK 0x00000000
union winbuf_a_addr_v_offset_u {
    struct {
        unsigned int a_addr_v_offset:32;    /* Window A Vertical address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies vertical offset of Y plane. The vertical offsets of U/V plane is derived by HW */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_a_addr_v_offset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_a_addr_v_offset_u old_value_t = { .reg32 = value };
    const winbuf_a_addr_v_offset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_addr_v_offset:32",
              "Window A Vertical address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies vertical offset of Y plane. The vertical offsets of U/V plane is derived by HW",
              32, old_value_t.a_addr_v_offset, new_value_t.a_addr_v_offset };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A Vertical address offset";
}

#define WINBUF_A_ADDR_V_OFFSET_NS_OFFSET 0x809
#define WINBUF_A_ADDR_V_OFFSET_NS_UNDEFMASK 0x00000000
union winbuf_a_addr_v_offset_ns_u {
    struct {
        unsigned int a_addr_v_offset_ns:32; /* Window A Shadowed Vertical address offset This is ARM set shadow of ADDR_V_OFFSET */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_a_addr_v_offset_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_a_addr_v_offset_ns_u old_value_t = { .reg32 = value };
    const winbuf_a_addr_v_offset_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: a_addr_v_offset_ns:32",
              "Window A Shadowed Vertical address offset This is ARM set shadow of ADDR_V_OFFSET",
              32, old_value_t.a_addr_v_offset_ns, new_value_t.a_addr_v_offset_ns };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window A Shadowed Vertical address offset";
}

#define WINBUF_A_UFLOW_STATUS_OFFSET 0x80A
#define WINBUF_A_UFLOW_STATUS_UNDEFMASK 0xBF000000
union winbuf_a_uflow_status_u {
    struct {
        unsigned int uflow_count:24;        /* Underflow count. This field indicates the number of contiguous groups of output pixels for which there was no data in the FIFO. For example, if the valid from the FIFO is low for 10 consecutive cycles and then goes high, the counter will increment by one. Reset to zero on write */
        unsigned int undefined_bits_24_29:6;
        unsigned int count_oflow:1;         /* Flag bit that indicates that the underflow event counter has overflowed. There were too many events. If COUNT_OFLOW is set, UFLOW_COUNT is meaningless. Cleared on write */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_a_uflow_status_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_a_uflow_status_u old_value_t = { .reg32 = value };
    const winbuf_a_uflow_status_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: uflow_count:24",
              "Underflow count. This field indicates the number of contiguous groups of output pixels for which there was no data in the FIFO. For example, if the valid from the FIFO is low for 10 consecutive cycles and then goes high, the counter will increment by one. Reset to zero on write",
              24, old_value_t.uflow_count, new_value_t.uflow_count };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_29:6", "", 6, old_value_t.undefined_bits_24_29, new_value_t.undefined_bits_24_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: count_oflow:1",
              "Flag bit that indicates that the underflow event counter has overflowed. There were too many events. If COUNT_OFLOW is set, UFLOW_COUNT is meaningless. Cleared on write",
              1, old_value_t.count_oflow, new_value_t.count_oflow };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window A FIFO Underflow Status Register";
}

#define WINC_B_COLOR_PALETTE_OFFSET 0x1500
#define WINC_B_COLOR_PALETTE_UNDEFMASK 0xFF000000
union winc_b_color_palette_u {
    struct {
        unsigned int b_color_palette_r:8;   /* Red Color Palette */
        unsigned int b_color_palette_g:8;   /* Green Color Palette */
        unsigned int b_color_palette_b:8;   /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_color_palette_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_color_palette_u old_value_t = { .reg32 = value };
    const winc_b_color_palette_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_color_palette_r:8",
              "Red Color Palette",
              8, old_value_t.b_color_palette_r, new_value_t.b_color_palette_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_color_palette_g:8",
              "Green Color Palette",
              8, old_value_t.b_color_palette_g, new_value_t.b_color_palette_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_color_palette_b:8",
              "Blue Color Palette",
              8, old_value_t.b_color_palette_b, new_value_t.b_color_palette_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Color Palette\nThis is used for palletized data format (color depth of 8-bpp or less) or for gamma correction for non-palletized data formats (color depth of more than 8-bpp).\nEach window has its own color palette which consists of three 256x8 register file which can be written by host and indexed (read) by the window.\nFor palletized data format less than 8-bpp the pixel data is aligned to least significant bits of the palette index (address) and the remaining upper bits are filled with the corresponding bits of the Palette Color Extension. For example, for 4-bpp mode, the pixel data occupies bits 3-0 of the palette index and bits 7-4 of the palette index are set to bits 7-4 of the Palette Color Extension.\nNote that host read is assumed to be not needed - software can cache the color palette in system memory.\nThis is an array of 256 identical register entries; the register fields below apply to each entry.";
}

#define WINC_B_PALETTE_COLOR_EXT_OFFSET 0x1600
#define WINC_B_PALETTE_COLOR_EXT_UNDEFMASK 0xFFFFFF01
union winc_b_palette_color_ext_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int b_palette_color_ext:7; /* Window B Palette Color Extension bits 7-1 are used for 1-bpp mode bits 7-2 are used for 2-bpp mode bits 7-4 are used for 4-bpp mode */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_palette_color_ext_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_palette_color_ext_u old_value_t = { .reg32 = value };
    const winc_b_palette_color_ext_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bit_0:1", "", 1, old_value_t.undefined_bit_0, new_value_t.undefined_bit_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "01: b_palette_color_ext:7",
              "Window B Palette Color Extension bits 7-1 are used for 1-bpp mode bits 7-2 are used for 2-bpp mode bits 7-4 are used for 4-bpp mode",
              7, old_value_t.b_palette_color_ext, new_value_t.b_palette_color_ext };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Palette Color Extension\nPalette extension for 1-bpp, 2-bpp, and 4-bpp. These bits provide the upper most significant bits for indexing the color palette. Supported for window A only.\nXXX should ifdef for window A, but currently window B spec is assumed to be a superset.";
}

#define WINC_B_H_FILTER_P00_OFFSET 0x1601
#define WINC_B_H_FILTER_P00_UNDEFMASK 0x00000000
union winc_b_h_filter_p00_u {
    struct {
        unsigned int b_h_filter_p00c0:3;    /* Phase 00 coefficient 0 (typically 0) */
        unsigned int b_h_filter_p00c1:5;    /* Phase 00 coefficient 1 (typically 0) */
        unsigned int b_h_filter_p00c2:8;    /* Phase 00 coefficient 2 (typically 128) */
        unsigned int b_h_filter_p00c3:8;    /* Phase 00 coefficient 3 (typically 0) */
        unsigned int b_h_filter_p00c4:5;    /* Phase 00 coefficient 4 (typically 0) */
        unsigned int b_h_filter_p00c5:3;    /* Phase 00 coefficient 5 (typically 0) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p00_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p00_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p00_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p00c0:3",
              "Phase 00 coefficient 0 (typically 0)",
              3, old_value_t.b_h_filter_p00c0, new_value_t.b_h_filter_p00c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p00c1:5",
              "Phase 00 coefficient 1 (typically 0)",
              5, old_value_t.b_h_filter_p00c1, new_value_t.b_h_filter_p00c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p00c2:8",
              "Phase 00 coefficient 2 (typically 128)",
              8, old_value_t.b_h_filter_p00c2, new_value_t.b_h_filter_p00c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p00c3:8",
              "Phase 00 coefficient 3 (typically 0)",
              8, old_value_t.b_h_filter_p00c3, new_value_t.b_h_filter_p00c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p00c4:5",
              "Phase 00 coefficient 4 (typically 0)",
              5, old_value_t.b_h_filter_p00c4, new_value_t.b_h_filter_p00c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p00c5:3",
              "Phase 00 coefficient 5 (typically 0)",
              3, old_value_t.b_h_filter_p00c5, new_value_t.b_h_filter_p00c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 00\nHorizontal scaling filter coefficients\nHorizontal scaling filter is a 6-tap filter with 4-bit positional phase.\n    * Coefficients 0 and 5 are 3-bit signed value ranging from -4 to 3.\n    * Coefficients 1 and 4 are 5-bit signed value ranging from -16 to 15.\n    * Coefficients 2 and 3 are 8-bit unsigned value ranging from 0 to 128.\n    * Coefficient 0 is the multiplier for the earliest pixel (P0) in the group of 6-pixel and coefficient 5 is the multiplier for the latest pixel (P5) in the group. The output pixel positional phase is defined as centered in P2 if the positional phase is 0 or proportionally in between P2 and P3 if the positional phase is larger than 0.\nSum of all coefficients for each phase should be 128 typically and software should never program the the sum of all coefficients for a phase to be more than 128. For each horizontal positional phase, the 6 filter coefficients requires 32 reg bits. Note that color value ranges from 0 to 255 for Y, R, G, B and -128 to 127 for U and V.";
}

#define WINC_B_H_FILTER_P01_OFFSET 0x1602
#define WINC_B_H_FILTER_P01_UNDEFMASK 0x00000000
union winc_b_h_filter_p01_u {
    struct {
        unsigned int b_h_filter_p01c0:3;    /* Phase 01 coefficient 0 (typically 1) */
        unsigned int b_h_filter_p01c1:5;    /* Phase 01 coefficient 1 (typically -4) */
        unsigned int b_h_filter_p01c2:8;    /* Phase 01 coefficient 2 (typically 124) */
        unsigned int b_h_filter_p01c3:8;    /* Phase 01 coefficient 3 (typically 8) */
        unsigned int b_h_filter_p01c4:5;    /* Phase 01 coefficient 4 (typically -2) */
        unsigned int b_h_filter_p01c5:3;    /* Phase 01 coefficient 5 (typically 1) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p01_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p01_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p01_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p01c0:3",
              "Phase 01 coefficient 0 (typically 1)",
              3, old_value_t.b_h_filter_p01c0, new_value_t.b_h_filter_p01c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p01c1:5",
              "Phase 01 coefficient 1 (typically -4)",
              5, old_value_t.b_h_filter_p01c1, new_value_t.b_h_filter_p01c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p01c2:8",
              "Phase 01 coefficient 2 (typically 124)",
              8, old_value_t.b_h_filter_p01c2, new_value_t.b_h_filter_p01c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p01c3:8",
              "Phase 01 coefficient 3 (typically 8)",
              8, old_value_t.b_h_filter_p01c3, new_value_t.b_h_filter_p01c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p01c4:5",
              "Phase 01 coefficient 4 (typically -2)",
              5, old_value_t.b_h_filter_p01c4, new_value_t.b_h_filter_p01c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p01c5:3",
              "Phase 01 coefficient 5 (typically 1)",
              3, old_value_t.b_h_filter_p01c5, new_value_t.b_h_filter_p01c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 01";
}

#define WINC_B_H_FILTER_P02_OFFSET 0x1603
#define WINC_B_H_FILTER_P02_UNDEFMASK 0x00000000
union winc_b_h_filter_p02_u {
    struct {
        unsigned int b_h_filter_p02c0:3;    /* Phase 02 coefficient 0 (typically 1) */
        unsigned int b_h_filter_p02c1:5;    /* Phase 02 coefficient 1 (typically -8) */
        unsigned int b_h_filter_p02c2:8;    /* Phase 02 coefficient 2 (typically 122) */
        unsigned int b_h_filter_p02c3:8;    /* Phase 02 coefficient 3 (typically 17) */
        unsigned int b_h_filter_p02c4:5;    /* Phase 02 coefficient 4 (typically -5) */
        unsigned int b_h_filter_p02c5:3;    /* Phase 02 coefficient 5 (typically 1) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p02_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p02_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p02_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p02c0:3",
              "Phase 02 coefficient 0 (typically 1)",
              3, old_value_t.b_h_filter_p02c0, new_value_t.b_h_filter_p02c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p02c1:5",
              "Phase 02 coefficient 1 (typically -8)",
              5, old_value_t.b_h_filter_p02c1, new_value_t.b_h_filter_p02c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p02c2:8",
              "Phase 02 coefficient 2 (typically 122)",
              8, old_value_t.b_h_filter_p02c2, new_value_t.b_h_filter_p02c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p02c3:8",
              "Phase 02 coefficient 3 (typically 17)",
              8, old_value_t.b_h_filter_p02c3, new_value_t.b_h_filter_p02c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p02c4:5",
              "Phase 02 coefficient 4 (typically -5)",
              5, old_value_t.b_h_filter_p02c4, new_value_t.b_h_filter_p02c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p02c5:3",
              "Phase 02 coefficient 5 (typically 1)",
              3, old_value_t.b_h_filter_p02c5, new_value_t.b_h_filter_p02c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 02";
}

#define WINC_B_H_FILTER_P03_OFFSET 0x1604
#define WINC_B_H_FILTER_P03_UNDEFMASK 0x00000000
union winc_b_h_filter_p03_u {
    struct {
        unsigned int b_h_filter_p03c0:3;    /* Phase 03 coefficient 0 (typically 2) */
        unsigned int b_h_filter_p03c1:5;    /* Phase 03 coefficient 1 (typically -11) */
        unsigned int b_h_filter_p03c2:8;    /* Phase 03 coefficient 2 (typically 115) */
        unsigned int b_h_filter_p03c3:8;    /* Phase 03 coefficient 3 (typically 27) */
        unsigned int b_h_filter_p03c4:5;    /* Phase 03 coefficient 4 (typically -7) */
        unsigned int b_h_filter_p03c5:3;    /* Phase 03 coefficient 5 (typically 2) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p03_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p03_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p03_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p03c0:3",
              "Phase 03 coefficient 0 (typically 2)",
              3, old_value_t.b_h_filter_p03c0, new_value_t.b_h_filter_p03c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p03c1:5",
              "Phase 03 coefficient 1 (typically -11)",
              5, old_value_t.b_h_filter_p03c1, new_value_t.b_h_filter_p03c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p03c2:8",
              "Phase 03 coefficient 2 (typically 115)",
              8, old_value_t.b_h_filter_p03c2, new_value_t.b_h_filter_p03c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p03c3:8",
              "Phase 03 coefficient 3 (typically 27)",
              8, old_value_t.b_h_filter_p03c3, new_value_t.b_h_filter_p03c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p03c4:5",
              "Phase 03 coefficient 4 (typically -7)",
              5, old_value_t.b_h_filter_p03c4, new_value_t.b_h_filter_p03c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p03c5:3",
              "Phase 03 coefficient 5 (typically 2)",
              3, old_value_t.b_h_filter_p03c5, new_value_t.b_h_filter_p03c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 03";
}

#define WINC_B_H_FILTER_P04_OFFSET 0x1605
#define WINC_B_H_FILTER_P04_UNDEFMASK 0x00000000
union winc_b_h_filter_p04_u {
    struct {
        unsigned int b_h_filter_p04c0:3;    /* Phase 04 coefficient 0 (typically 2) */
        unsigned int b_h_filter_p04c1:5;    /* Phase 04 coefficient 1 (typically -13) */
        unsigned int b_h_filter_p04c2:8;    /* Phase 04 coefficient 2 (typically 109) */
        unsigned int b_h_filter_p04c3:8;    /* Phase 04 coefficient 3 (typically 37) */
        unsigned int b_h_filter_p04c4:5;    /* Phase 04 coefficient 4 (typically -9) */
        unsigned int b_h_filter_p04c5:3;    /* Phase 04 coefficient 5 (typically 2) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p04_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p04_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p04_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p04c0:3",
              "Phase 04 coefficient 0 (typically 2)",
              3, old_value_t.b_h_filter_p04c0, new_value_t.b_h_filter_p04c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p04c1:5",
              "Phase 04 coefficient 1 (typically -13)",
              5, old_value_t.b_h_filter_p04c1, new_value_t.b_h_filter_p04c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p04c2:8",
              "Phase 04 coefficient 2 (typically 109)",
              8, old_value_t.b_h_filter_p04c2, new_value_t.b_h_filter_p04c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p04c3:8",
              "Phase 04 coefficient 3 (typically 37)",
              8, old_value_t.b_h_filter_p04c3, new_value_t.b_h_filter_p04c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p04c4:5",
              "Phase 04 coefficient 4 (typically -9)",
              5, old_value_t.b_h_filter_p04c4, new_value_t.b_h_filter_p04c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p04c5:3",
              "Phase 04 coefficient 5 (typically 2)",
              3, old_value_t.b_h_filter_p04c5, new_value_t.b_h_filter_p04c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 04";
}

#define WINC_B_H_FILTER_P05_OFFSET 0x1606
#define WINC_B_H_FILTER_P05_UNDEFMASK 0x00000000
union winc_b_h_filter_p05_u {
    struct {
        unsigned int b_h_filter_p05c0:3;    /* Phase 05 coefficient 0 (typically 3) */
        unsigned int b_h_filter_p05c1:5;    /* Phase 05 coefficient 1 (typically -15) */
        unsigned int b_h_filter_p05c2:8;    /* Phase 05 coefficient 2 (typically 102) */
        unsigned int b_h_filter_p05c3:8;    /* Phase 05 coefficient 3 (typically 47) */
        unsigned int b_h_filter_p05c4:5;    /* Phase 05 coefficient 4 (typically -11) */
        unsigned int b_h_filter_p05c5:3;    /* Phase 05 coefficient 5 (typically 2) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p05_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p05_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p05_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p05c0:3",
              "Phase 05 coefficient 0 (typically 3)",
              3, old_value_t.b_h_filter_p05c0, new_value_t.b_h_filter_p05c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p05c1:5",
              "Phase 05 coefficient 1 (typically -15)",
              5, old_value_t.b_h_filter_p05c1, new_value_t.b_h_filter_p05c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p05c2:8",
              "Phase 05 coefficient 2 (typically 102)",
              8, old_value_t.b_h_filter_p05c2, new_value_t.b_h_filter_p05c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p05c3:8",
              "Phase 05 coefficient 3 (typically 47)",
              8, old_value_t.b_h_filter_p05c3, new_value_t.b_h_filter_p05c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p05c4:5",
              "Phase 05 coefficient 4 (typically -11)",
              5, old_value_t.b_h_filter_p05c4, new_value_t.b_h_filter_p05c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p05c5:3",
              "Phase 05 coefficient 5 (typically 2)",
              3, old_value_t.b_h_filter_p05c5, new_value_t.b_h_filter_p05c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 05";
}

#define WINC_B_H_FILTER_P06_OFFSET 0x1607
#define WINC_B_H_FILTER_P06_UNDEFMASK 0x00000000
union winc_b_h_filter_p06_u {
    struct {
        unsigned int b_h_filter_p06c0:3;    /* Phase 06 coefficient 0 (typically 3) */
        unsigned int b_h_filter_p06c1:5;    /* Phase 06 coefficient 1 (typically -15) */
        unsigned int b_h_filter_p06c2:8;    /* Phase 06 coefficient 2 (typically 94) */
        unsigned int b_h_filter_p06c3:8;    /* Phase 06 coefficient 3 (typically 56) */
        unsigned int b_h_filter_p06c4:5;    /* Phase 06 coefficient 4 (typically -13) */
        unsigned int b_h_filter_p06c5:3;    /* Phase 06 coefficient 5 (typically 3) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p06_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p06_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p06_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p06c0:3",
              "Phase 06 coefficient 0 (typically 3)",
              3, old_value_t.b_h_filter_p06c0, new_value_t.b_h_filter_p06c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p06c1:5",
              "Phase 06 coefficient 1 (typically -15)",
              5, old_value_t.b_h_filter_p06c1, new_value_t.b_h_filter_p06c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p06c2:8",
              "Phase 06 coefficient 2 (typically 94)",
              8, old_value_t.b_h_filter_p06c2, new_value_t.b_h_filter_p06c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p06c3:8",
              "Phase 06 coefficient 3 (typically 56)",
              8, old_value_t.b_h_filter_p06c3, new_value_t.b_h_filter_p06c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p06c4:5",
              "Phase 06 coefficient 4 (typically -13)",
              5, old_value_t.b_h_filter_p06c4, new_value_t.b_h_filter_p06c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p06c5:3",
              "Phase 06 coefficient 5 (typically 3)",
              3, old_value_t.b_h_filter_p06c5, new_value_t.b_h_filter_p06c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 06";
}

#define WINC_B_H_FILTER_P07_OFFSET 0x1608
#define WINC_B_H_FILTER_P07_UNDEFMASK 0x00000000
union winc_b_h_filter_p07_u {
    struct {
        unsigned int b_h_filter_p07c0:3;    /* Phase 07 coefficient 0 (typically 3) */
        unsigned int b_h_filter_p07c1:5;    /* Phase 07 coefficient 1 (typically -16) */
        unsigned int b_h_filter_p07c2:8;    /* Phase 07 coefficient 2 (typically 85) */
        unsigned int b_h_filter_p07c3:8;    /* Phase 07 coefficient 3 (typically 67) */
        unsigned int b_h_filter_p07c4:5;    /* Phase 07 coefficient 4 (typically -14) */
        unsigned int b_h_filter_p07c5:3;    /* Phase 07 coefficient 5 (typically 3) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p07_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p07_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p07_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p07c0:3",
              "Phase 07 coefficient 0 (typically 3)",
              3, old_value_t.b_h_filter_p07c0, new_value_t.b_h_filter_p07c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p07c1:5",
              "Phase 07 coefficient 1 (typically -16)",
              5, old_value_t.b_h_filter_p07c1, new_value_t.b_h_filter_p07c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p07c2:8",
              "Phase 07 coefficient 2 (typically 85)",
              8, old_value_t.b_h_filter_p07c2, new_value_t.b_h_filter_p07c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p07c3:8",
              "Phase 07 coefficient 3 (typically 67)",
              8, old_value_t.b_h_filter_p07c3, new_value_t.b_h_filter_p07c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p07c4:5",
              "Phase 07 coefficient 4 (typically -14)",
              5, old_value_t.b_h_filter_p07c4, new_value_t.b_h_filter_p07c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p07c5:3",
              "Phase 07 coefficient 5 (typically 3)",
              3, old_value_t.b_h_filter_p07c5, new_value_t.b_h_filter_p07c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 07";
}

#define WINC_B_H_FILTER_P08_OFFSET 0x1609
#define WINC_B_H_FILTER_P08_UNDEFMASK 0x00000000
union winc_b_h_filter_p08_u {
    struct {
        unsigned int b_h_filter_p08c0:3;    /* Phase 08 coefficient 0 (typically 3) */
        unsigned int b_h_filter_p08c1:5;    /* Phase 08 coefficient 1 (typically -15) */
        unsigned int b_h_filter_p08c2:8;    /* Phase 08 coefficient 2 (typically 76) */
        unsigned int b_h_filter_p08c3:8;    /* Phase 08 coefficient 3 (typically 76) */
        unsigned int b_h_filter_p08c4:5;    /* Phase 08 coefficient 4 (typically -15) */
        unsigned int b_h_filter_p08c5:3;    /* Phase 08 coefficient 5 (typically 3) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p08_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p08_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p08_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p08c0:3",
              "Phase 08 coefficient 0 (typically 3)",
              3, old_value_t.b_h_filter_p08c0, new_value_t.b_h_filter_p08c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p08c1:5",
              "Phase 08 coefficient 1 (typically -15)",
              5, old_value_t.b_h_filter_p08c1, new_value_t.b_h_filter_p08c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p08c2:8",
              "Phase 08 coefficient 2 (typically 76)",
              8, old_value_t.b_h_filter_p08c2, new_value_t.b_h_filter_p08c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p08c3:8",
              "Phase 08 coefficient 3 (typically 76)",
              8, old_value_t.b_h_filter_p08c3, new_value_t.b_h_filter_p08c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p08c4:5",
              "Phase 08 coefficient 4 (typically -15)",
              5, old_value_t.b_h_filter_p08c4, new_value_t.b_h_filter_p08c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p08c5:3",
              "Phase 08 coefficient 5 (typically 3)",
              3, old_value_t.b_h_filter_p08c5, new_value_t.b_h_filter_p08c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 08";
}

#define WINC_B_H_FILTER_P09_OFFSET 0x160A
#define WINC_B_H_FILTER_P09_UNDEFMASK 0x00000000
union winc_b_h_filter_p09_u {
    struct {
        unsigned int b_h_filter_p09c0:3;    /* Phase 09 coefficient 0 (typically 3) */
        unsigned int b_h_filter_p09c1:5;    /* Phase 09 coefficient 1 (typically -14) */
        unsigned int b_h_filter_p09c2:8;    /* Phase 09 coefficient 2 (typically 67) */
        unsigned int b_h_filter_p09c3:8;    /* Phase 09 coefficient 3 (typically 85) */
        unsigned int b_h_filter_p09c4:5;    /* Phase 09 coefficient 4 (typically -16) */
        unsigned int b_h_filter_p09c5:3;    /* Phase 09 coefficient 5 (typically 3) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p09_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p09_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p09_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p09c0:3",
              "Phase 09 coefficient 0 (typically 3)",
              3, old_value_t.b_h_filter_p09c0, new_value_t.b_h_filter_p09c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p09c1:5",
              "Phase 09 coefficient 1 (typically -14)",
              5, old_value_t.b_h_filter_p09c1, new_value_t.b_h_filter_p09c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p09c2:8",
              "Phase 09 coefficient 2 (typically 67)",
              8, old_value_t.b_h_filter_p09c2, new_value_t.b_h_filter_p09c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p09c3:8",
              "Phase 09 coefficient 3 (typically 85)",
              8, old_value_t.b_h_filter_p09c3, new_value_t.b_h_filter_p09c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p09c4:5",
              "Phase 09 coefficient 4 (typically -16)",
              5, old_value_t.b_h_filter_p09c4, new_value_t.b_h_filter_p09c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p09c5:3",
              "Phase 09 coefficient 5 (typically 3)",
              3, old_value_t.b_h_filter_p09c5, new_value_t.b_h_filter_p09c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 09";
}

#define WINC_B_H_FILTER_P0A_OFFSET 0x160B
#define WINC_B_H_FILTER_P0A_UNDEFMASK 0x00000000
union winc_b_h_filter_p0a_u {
    struct {
        unsigned int b_h_filter_p0ac0:3;    /* Phase 0A coefficient 0 (typically 3) */
        unsigned int b_h_filter_p0ac1:5;    /* Phase 0A coefficient 1 (typically -13) */
        unsigned int b_h_filter_p0ac2:8;    /* Phase 0A coefficient 2 (typically 56) */
        unsigned int b_h_filter_p0ac3:8;    /* Phase 0A coefficient 3 (typically 94) */
        unsigned int b_h_filter_p0ac4:5;    /* Phase 0A coefficient 4 (typically -15) */
        unsigned int b_h_filter_p0ac5:3;    /* Phase 0A coefficient 5 (typically 3) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p0a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p0a_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p0a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p0ac0:3",
              "Phase 0A coefficient 0 (typically 3)",
              3, old_value_t.b_h_filter_p0ac0, new_value_t.b_h_filter_p0ac0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p0ac1:5",
              "Phase 0A coefficient 1 (typically -13)",
              5, old_value_t.b_h_filter_p0ac1, new_value_t.b_h_filter_p0ac1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p0ac2:8",
              "Phase 0A coefficient 2 (typically 56)",
              8, old_value_t.b_h_filter_p0ac2, new_value_t.b_h_filter_p0ac2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p0ac3:8",
              "Phase 0A coefficient 3 (typically 94)",
              8, old_value_t.b_h_filter_p0ac3, new_value_t.b_h_filter_p0ac3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p0ac4:5",
              "Phase 0A coefficient 4 (typically -15)",
              5, old_value_t.b_h_filter_p0ac4, new_value_t.b_h_filter_p0ac4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p0ac5:3",
              "Phase 0A coefficient 5 (typically 3)",
              3, old_value_t.b_h_filter_p0ac5, new_value_t.b_h_filter_p0ac5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 0A";
}

#define WINC_B_H_FILTER_P0B_OFFSET 0x160C
#define WINC_B_H_FILTER_P0B_UNDEFMASK 0x00000000
union winc_b_h_filter_p0b_u {
    struct {
        unsigned int b_h_filter_p0bc0:3;    /* Phase 0B coefficient 0 (typically 2) */
        unsigned int b_h_filter_p0bc1:5;    /* Phase 0B coefficient 1 (typically -11) */
        unsigned int b_h_filter_p0bc2:8;    /* Phase 0B coefficient 2 (typically 47) */
        unsigned int b_h_filter_p0bc3:8;    /* Phase 0B coefficient 3 (typically 102) */
        unsigned int b_h_filter_p0bc4:5;    /* Phase 0B coefficient 4 (typically -15) */
        unsigned int b_h_filter_p0bc5:3;    /* Phase 0B coefficient 5 (typically 3) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p0b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p0b_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p0b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p0bc0:3",
              "Phase 0B coefficient 0 (typically 2)",
              3, old_value_t.b_h_filter_p0bc0, new_value_t.b_h_filter_p0bc0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p0bc1:5",
              "Phase 0B coefficient 1 (typically -11)",
              5, old_value_t.b_h_filter_p0bc1, new_value_t.b_h_filter_p0bc1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p0bc2:8",
              "Phase 0B coefficient 2 (typically 47)",
              8, old_value_t.b_h_filter_p0bc2, new_value_t.b_h_filter_p0bc2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p0bc3:8",
              "Phase 0B coefficient 3 (typically 102)",
              8, old_value_t.b_h_filter_p0bc3, new_value_t.b_h_filter_p0bc3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p0bc4:5",
              "Phase 0B coefficient 4 (typically -15)",
              5, old_value_t.b_h_filter_p0bc4, new_value_t.b_h_filter_p0bc4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p0bc5:3",
              "Phase 0B coefficient 5 (typically 3)",
              3, old_value_t.b_h_filter_p0bc5, new_value_t.b_h_filter_p0bc5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 0B";
}

#define WINC_B_H_FILTER_P0C_OFFSET 0x160D
#define WINC_B_H_FILTER_P0C_UNDEFMASK 0x00000000
union winc_b_h_filter_p0c_u {
    struct {
        unsigned int b_h_filter_p0cc0:3;    /* Phase 0C coefficient 0 (typically 2) */
        unsigned int b_h_filter_p0cc1:5;    /* Phase 0C coefficient 1 (typically -9) */
        unsigned int b_h_filter_p0cc2:8;    /* Phase 0C coefficient 2 (typically 37) */
        unsigned int b_h_filter_p0cc3:8;    /* Phase 0C coefficient 3 (typically 109) */
        unsigned int b_h_filter_p0cc4:5;    /* Phase 0C coefficient 4 (typically -13) */
        unsigned int b_h_filter_p0cc5:3;    /* Phase 0C coefficient 5 (typically 2) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p0c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p0c_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p0c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p0cc0:3",
              "Phase 0C coefficient 0 (typically 2)",
              3, old_value_t.b_h_filter_p0cc0, new_value_t.b_h_filter_p0cc0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p0cc1:5",
              "Phase 0C coefficient 1 (typically -9)",
              5, old_value_t.b_h_filter_p0cc1, new_value_t.b_h_filter_p0cc1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p0cc2:8",
              "Phase 0C coefficient 2 (typically 37)",
              8, old_value_t.b_h_filter_p0cc2, new_value_t.b_h_filter_p0cc2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p0cc3:8",
              "Phase 0C coefficient 3 (typically 109)",
              8, old_value_t.b_h_filter_p0cc3, new_value_t.b_h_filter_p0cc3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p0cc4:5",
              "Phase 0C coefficient 4 (typically -13)",
              5, old_value_t.b_h_filter_p0cc4, new_value_t.b_h_filter_p0cc4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p0cc5:3",
              "Phase 0C coefficient 5 (typically 2)",
              3, old_value_t.b_h_filter_p0cc5, new_value_t.b_h_filter_p0cc5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 0C";
}

#define WINC_B_H_FILTER_P0D_OFFSET 0x160E
#define WINC_B_H_FILTER_P0D_UNDEFMASK 0x00000000
union winc_b_h_filter_p0d_u {
    struct {
        unsigned int b_h_filter_p0dc0:3;    /* Phase 0D coefficient 0 (typically 2) */
        unsigned int b_h_filter_p0dc1:5;    /* Phase 0D coefficient 1 (typically -7) */
        unsigned int b_h_filter_p0dc2:8;    /* Phase 0D coefficient 2 (typically 27) */
        unsigned int b_h_filter_p0dc3:8;    /* Phase 0D coefficient 3 (typically 115) */
        unsigned int b_h_filter_p0dc4:5;    /* Phase 0D coefficient 4 (typically -11) */
        unsigned int b_h_filter_p0dc5:3;    /* Phase 0D coefficient 5 (typically 2) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p0d_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p0d_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p0d_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p0dc0:3",
              "Phase 0D coefficient 0 (typically 2)",
              3, old_value_t.b_h_filter_p0dc0, new_value_t.b_h_filter_p0dc0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p0dc1:5",
              "Phase 0D coefficient 1 (typically -7)",
              5, old_value_t.b_h_filter_p0dc1, new_value_t.b_h_filter_p0dc1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p0dc2:8",
              "Phase 0D coefficient 2 (typically 27)",
              8, old_value_t.b_h_filter_p0dc2, new_value_t.b_h_filter_p0dc2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p0dc3:8",
              "Phase 0D coefficient 3 (typically 115)",
              8, old_value_t.b_h_filter_p0dc3, new_value_t.b_h_filter_p0dc3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p0dc4:5",
              "Phase 0D coefficient 4 (typically -11)",
              5, old_value_t.b_h_filter_p0dc4, new_value_t.b_h_filter_p0dc4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p0dc5:3",
              "Phase 0D coefficient 5 (typically 2)",
              3, old_value_t.b_h_filter_p0dc5, new_value_t.b_h_filter_p0dc5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 0D";
}

#define WINC_B_H_FILTER_P0E_OFFSET 0x160F
#define WINC_B_H_FILTER_P0E_UNDEFMASK 0x00000000
union winc_b_h_filter_p0e_u {
    struct {
        unsigned int b_h_filter_p0ec0:3;    /* Phase 0E coefficient 0 (typically 1) */
        unsigned int b_h_filter_p0ec1:5;    /* Phase 0E coefficient 1 (typically -5) */
        unsigned int b_h_filter_p0ec2:8;    /* Phase 0E coefficient 2 (typically 17) */
        unsigned int b_h_filter_p0ec3:8;    /* Phase 0E coefficient 3 (typically 122) */
        unsigned int b_h_filter_p0ec4:5;    /* Phase 0E coefficient 4 (typically -8) */
        unsigned int b_h_filter_p0ec5:3;    /* Phase 0E coefficient 5 (typically 1) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p0e_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p0e_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p0e_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p0ec0:3",
              "Phase 0E coefficient 0 (typically 1)",
              3, old_value_t.b_h_filter_p0ec0, new_value_t.b_h_filter_p0ec0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p0ec1:5",
              "Phase 0E coefficient 1 (typically -5)",
              5, old_value_t.b_h_filter_p0ec1, new_value_t.b_h_filter_p0ec1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p0ec2:8",
              "Phase 0E coefficient 2 (typically 17)",
              8, old_value_t.b_h_filter_p0ec2, new_value_t.b_h_filter_p0ec2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p0ec3:8",
              "Phase 0E coefficient 3 (typically 122)",
              8, old_value_t.b_h_filter_p0ec3, new_value_t.b_h_filter_p0ec3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p0ec4:5",
              "Phase 0E coefficient 4 (typically -8)",
              5, old_value_t.b_h_filter_p0ec4, new_value_t.b_h_filter_p0ec4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p0ec5:3",
              "Phase 0E coefficient 5 (typically 1)",
              3, old_value_t.b_h_filter_p0ec5, new_value_t.b_h_filter_p0ec5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 0E";
}

#define WINC_B_H_FILTER_P0F_OFFSET 0x1610
#define WINC_B_H_FILTER_P0F_UNDEFMASK 0x00000000
union winc_b_h_filter_p0f_u {
    struct {
        unsigned int b_h_filter_p0fc0:3;    /* Phase 0F coefficient 0 (typically 1) */
        unsigned int b_h_filter_p0fc1:5;    /* Phase 0F coefficient 1 (typically -2) */
        unsigned int b_h_filter_p0fc2:8;    /* Phase 0F coefficient 2 (typically 8) */
        unsigned int b_h_filter_p0fc3:8;    /* Phase 0F coefficient 3 (typically 124) */
        unsigned int b_h_filter_p0fc4:5;    /* Phase 0F coefficient 4 (typically -4) */
        unsigned int b_h_filter_p0fc5:3;    /* Phase 0F coefficient 5 (typically 1) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_h_filter_p0f_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_h_filter_p0f_u old_value_t = { .reg32 = value };
    const winc_b_h_filter_p0f_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_filter_p0fc0:3",
              "Phase 0F coefficient 0 (typically 1)",
              3, old_value_t.b_h_filter_p0fc0, new_value_t.b_h_filter_p0fc0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: b_h_filter_p0fc1:5",
              "Phase 0F coefficient 1 (typically -2)",
              5, old_value_t.b_h_filter_p0fc1, new_value_t.b_h_filter_p0fc1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_p0fc2:8",
              "Phase 0F coefficient 2 (typically 8)",
              8, old_value_t.b_h_filter_p0fc2, new_value_t.b_h_filter_p0fc2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_h_filter_p0fc3:8",
              "Phase 0F coefficient 3 (typically 124)",
              8, old_value_t.b_h_filter_p0fc3, new_value_t.b_h_filter_p0fc3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: b_h_filter_p0fc4:5",
              "Phase 0F coefficient 4 (typically -4)",
              5, old_value_t.b_h_filter_p0fc4, new_value_t.b_h_filter_p0fc4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: b_h_filter_p0fc5:3",
              "Phase 0F coefficient 5 (typically 1)",
              3, old_value_t.b_h_filter_p0fc5, new_value_t.b_h_filter_p0fc5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Horizontal Filter phase 0F";
}

#define WINC_B_CSC_YOF_OFFSET 0x1611
#define WINC_B_CSC_YOF_UNDEFMASK 0xFFFFFF00
union winc_b_csc_yof_u {
    struct {
        unsigned int b_csc_yof:8;           /* Y Offset in s.7.0 format */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_csc_yof_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_csc_yof_u old_value_t = { .reg32 = value };
    const winc_b_csc_yof_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_csc_yof:8",
              "Y Offset in s.7.0 format",
              8, old_value_t.b_csc_yof, new_value_t.b_csc_yof };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B CSC Y Offset\nColor Space Conversion coefficients.\nThe CSC can be used for YUV to RGB conversion with brightness and hue/saturation control.\nThe CSC can only be enabled for window B controlled by CSC_ENABLE register bits.\nFor Y color, the Y offset is applied first and saturation (clipping) is performed immediately after the Y offset is applied.\nR = sat(KYRGB * sat(Y + YOF) + KUR * U + KVR * V)\nG = sat(KYRGB * sat(Y + YOF) + KUG * U + KVG * V)\nB = sat(KYRGB * sat(Y + YOF) + KUB * U + KVB * V)\nSaturation and rounding is performed in the range of 0 to 255 for the above equations.\nTypical values are:\nYOF = -16.000, KYRGB = 1.1644\nKUR = 0.0000, KVR = 1.5960\nKUG = -0.3918, KVG = -0.8130\nKUB = 2.0172, KVB = 0.0000\nKUR and KVB are typically 0.0000 but they may be programmed non-zero for hue rotation.\nThe CSC can also take RGB input, in which case YOF, KVB, KUG, KUR should be programmed to 0 and KYRGB will be forced to 0 by the hardware for generating R and B. KYRGB will not be forced to 0 for generating G. KVR, KYRGB, and KUB can be programmed to 1.0 or used as gain control for R, G, B correspondingly.\nNote that color value ranges from 0 to 255 for Y, R, G, B and -128 to 127 for U and V.";
}

#define WINC_B_CSC_KYRGB_OFFSET 0x1612
#define WINC_B_CSC_KYRGB_UNDEFMASK 0xFFFFFC00
union winc_b_csc_kyrgb_u {
    struct {
        unsigned int b_csc_kyrgb:10;        /* Y Gain for R, G, B colors in 2.8 format */
        unsigned int undefined_bits_10_31:22;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_csc_kyrgb_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_csc_kyrgb_u old_value_t = { .reg32 = value };
    const winc_b_csc_kyrgb_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_csc_kyrgb:10",
              "Y Gain for R, G, B colors in 2.8 format",
              10, old_value_t.b_csc_kyrgb, new_value_t.b_csc_kyrgb };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_31:22", "", 22, old_value_t.undefined_bits_10_31, new_value_t.undefined_bits_10_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B CSC Y Coefficient (gain) for RGB";
}

#define WINC_B_CSC_KUR_OFFSET 0x1613
#define WINC_B_CSC_KUR_UNDEFMASK 0xFFFFF800
union winc_b_csc_kur_u {
    struct {
        unsigned int b_csc_kur:11;          /* U coefficients for R in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_csc_kur_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_csc_kur_u old_value_t = { .reg32 = value };
    const winc_b_csc_kur_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_csc_kur:11",
              "U coefficients for R in s.2.8 format",
              11, old_value_t.b_csc_kur, new_value_t.b_csc_kur };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_31:21", "", 21, old_value_t.undefined_bits_11_31, new_value_t.undefined_bits_11_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B CSC U coefficient for R";
}

#define WINC_B_CSC_KVR_OFFSET 0x1614
#define WINC_B_CSC_KVR_UNDEFMASK 0xFFFFF800
union winc_b_csc_kvr_u {
    struct {
        unsigned int b_csc_kvr:11;          /* V coefficients for R in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_csc_kvr_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_csc_kvr_u old_value_t = { .reg32 = value };
    const winc_b_csc_kvr_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_csc_kvr:11",
              "V coefficients for R in s.2.8 format",
              11, old_value_t.b_csc_kvr, new_value_t.b_csc_kvr };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_31:21", "", 21, old_value_t.undefined_bits_11_31, new_value_t.undefined_bits_11_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B CSC V coefficient for R";
}

#define WINC_B_CSC_KUG_OFFSET 0x1615
#define WINC_B_CSC_KUG_UNDEFMASK 0xFFFFFC00
union winc_b_csc_kug_u {
    struct {
        unsigned int b_csc_kug:10;          /* U coefficients for G in s.1.8 format */
        unsigned int undefined_bits_10_31:22;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_csc_kug_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_csc_kug_u old_value_t = { .reg32 = value };
    const winc_b_csc_kug_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_csc_kug:10",
              "U coefficients for G in s.1.8 format",
              10, old_value_t.b_csc_kug, new_value_t.b_csc_kug };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_31:22", "", 22, old_value_t.undefined_bits_10_31, new_value_t.undefined_bits_10_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B CSC U coefficient for G";
}

#define WINC_B_CSC_KVG_OFFSET 0x1616
#define WINC_B_CSC_KVG_UNDEFMASK 0xFFFFFC00
union winc_b_csc_kvg_u {
    struct {
        unsigned int b_csc_kvg:10;          /* V coefficients for G in s.1.8 format */
        unsigned int undefined_bits_10_31:22;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_csc_kvg_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_csc_kvg_u old_value_t = { .reg32 = value };
    const winc_b_csc_kvg_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_csc_kvg:10",
              "V coefficients for G in s.1.8 format",
              10, old_value_t.b_csc_kvg, new_value_t.b_csc_kvg };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_31:22", "", 22, old_value_t.undefined_bits_10_31, new_value_t.undefined_bits_10_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B CSC V coefficient for G";
}

#define WINC_B_CSC_KUB_OFFSET 0x1617
#define WINC_B_CSC_KUB_UNDEFMASK 0xFFFFF800
union winc_b_csc_kub_u {
    struct {
        unsigned int b_csc_kub:11;          /* U coefficients for B in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_csc_kub_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_csc_kub_u old_value_t = { .reg32 = value };
    const winc_b_csc_kub_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_csc_kub:11",
              "U coefficients for B in s.2.8 format",
              11, old_value_t.b_csc_kub, new_value_t.b_csc_kub };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_31:21", "", 21, old_value_t.undefined_bits_11_31, new_value_t.undefined_bits_11_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B CSC U coefficient for B";
}

#define WINC_B_CSC_KVB_OFFSET 0x1618
#define WINC_B_CSC_KVB_UNDEFMASK 0xFFFFF800
union winc_b_csc_kvb_u {
    struct {
        unsigned int b_csc_kvb:11;          /* V coefficients for B in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_csc_kvb_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_csc_kvb_u old_value_t = { .reg32 = value };
    const winc_b_csc_kvb_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_csc_kvb:11",
              "V coefficients for B in s.2.8 format",
              11, old_value_t.b_csc_kvb, new_value_t.b_csc_kvb };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_31:21", "", 21, old_value_t.undefined_bits_11_31, new_value_t.undefined_bits_11_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B CSC V coefficient for B";
}

#define WINC_B_V_FILTER_P00_OFFSET 0x1619
#define WINC_B_V_FILTER_P00_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p00_u {
    struct {
        unsigned int b_v_filter_p00c0:8;    /* Phase 00 coefficient 0 (typically 128) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p00_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p00_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p00_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p00c0:8",
              "Phase 00 coefficient 0 (typically 128)",
              8, old_value_t.b_v_filter_p00c0, new_value_t.b_v_filter_p00c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window B Vertical Filter phase 00\nVertical scaling filter coefficients\nVertical scaling filter is a 2-tap filter with 4-bit positional phase.\nCoefficients 0 and 1 are 8-bit unsigned value ranging from 0 to 128.\n Coefficient 0 is the multiplier for the earlier pixel (P0) in the group of 2-pixel and coefficient 1 is the multiplier for the later pixel (P1) in the group. The output pixel positional phase is defined as centered in P0 if the positional phase is 0 or proportionally in between P0 and P1 if the positional phase is larger than 0.\nSum of all coefficients for each phase should be 128 typically therefore coefficient 1 can be calculated from (1 - coefficient 0) and therefore only coefficient 0 is programmed.\nFor each vertical positional phase, the filter coefficient requires 8 reg bits. Note that color value ranges from 0 to 255 for Y, R, G, B and -128 to 127 for U and V.";
}

#define WINC_B_V_FILTER_P01_OFFSET 0x161A
#define WINC_B_V_FILTER_P01_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p01_u {
    struct {
        unsigned int b_v_filter_p01c0:8;    /* Phase 01 coefficient 0 (typically 120) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p01_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p01_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p01_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p01c0:8",
              "Phase 01 coefficient 0 (typically 120)",
              8, old_value_t.b_v_filter_p01c0, new_value_t.b_v_filter_p01c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Vertical Filter phase 01";
}

#define WINC_B_V_FILTER_P02_OFFSET 0x161B
#define WINC_B_V_FILTER_P02_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p02_u {
    struct {
        unsigned int b_v_filter_p02c0:8;    /* Phase 02 coefficient 0 (typically 112) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p02_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p02_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p02_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p02c0:8",
              "Phase 02 coefficient 0 (typically 112)",
              8, old_value_t.b_v_filter_p02c0, new_value_t.b_v_filter_p02c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Vertical Filter phase 02";
}

#define WINC_B_V_FILTER_P03_OFFSET 0x161C
#define WINC_B_V_FILTER_P03_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p03_u {
    struct {
        unsigned int b_v_filter_p03c0:8;    /* Phase 03 coefficient 0 (typically 104) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p03_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p03_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p03_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p03c0:8",
              "Phase 03 coefficient 0 (typically 104)",
              8, old_value_t.b_v_filter_p03c0, new_value_t.b_v_filter_p03c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Vertical Filter phase 03";
}

#define WINC_B_V_FILTER_P04_OFFSET 0x161D
#define WINC_B_V_FILTER_P04_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p04_u {
    struct {
        unsigned int b_v_filter_p04c0:8;    /* Phase 04 coefficient 0 (typically 96) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p04_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p04_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p04_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p04c0:8",
              "Phase 04 coefficient 0 (typically 96)",
              8, old_value_t.b_v_filter_p04c0, new_value_t.b_v_filter_p04c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Vertical Filter phase 04";
}

#define WINC_B_V_FILTER_P05_OFFSET 0x161E
#define WINC_B_V_FILTER_P05_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p05_u {
    struct {
        unsigned int b_v_filter_p05c0:8;    /* Phase 05 coefficient 0 (typically 88) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p05_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p05_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p05_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p05c0:8",
              "Phase 05 coefficient 0 (typically 88)",
              8, old_value_t.b_v_filter_p05c0, new_value_t.b_v_filter_p05c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Vertical Filter phase 05";
}

#define WINC_B_V_FILTER_P06_OFFSET 0x161F
#define WINC_B_V_FILTER_P06_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p06_u {
    struct {
        unsigned int b_v_filter_p06c0:8;    /* Phase 06 coefficient 0 (typically 80) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p06_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p06_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p06_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p06c0:8",
              "Phase 06 coefficient 0 (typically 80)",
              8, old_value_t.b_v_filter_p06c0, new_value_t.b_v_filter_p06c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Vertical Filter phase 06";
}

#define WINC_B_V_FILTER_P07_OFFSET 0x1620
#define WINC_B_V_FILTER_P07_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p07_u {
    struct {
        unsigned int b_v_filter_p07c0:8;    /* Phase 07 coefficient 0 (typically 72) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p07_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p07_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p07_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p07c0:8",
              "Phase 07 coefficient 0 (typically 72)",
              8, old_value_t.b_v_filter_p07c0, new_value_t.b_v_filter_p07c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Vertical Filter phase 07";
}

#define WINC_B_V_FILTER_P08_OFFSET 0x1621
#define WINC_B_V_FILTER_P08_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p08_u {
    struct {
        unsigned int b_v_filter_p08c0:8;    /* Phase 08 coefficient 0 (typically 64) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p08_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p08_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p08_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p08c0:8",
              "Phase 08 coefficient 0 (typically 64)",
              8, old_value_t.b_v_filter_p08c0, new_value_t.b_v_filter_p08c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Vertical Filter phase 08";
}

#define WINC_B_V_FILTER_P09_OFFSET 0x1622
#define WINC_B_V_FILTER_P09_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p09_u {
    struct {
        unsigned int b_v_filter_p09c0:8;    /* Phase 09 coefficient 0 (typically 56) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p09_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p09_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p09_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p09c0:8",
              "Phase 09 coefficient 0 (typically 56)",
              8, old_value_t.b_v_filter_p09c0, new_value_t.b_v_filter_p09c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Vertical Filter phase 09";
}

#define WINC_B_V_FILTER_P0A_OFFSET 0x1623
#define WINC_B_V_FILTER_P0A_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p0a_u {
    struct {
        unsigned int b_v_filter_p0ac0:8;    /* Phase 0A coefficient 0 (typically 48) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p0a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p0a_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p0a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p0ac0:8",
              "Phase 0A coefficient 0 (typically 48)",
              8, old_value_t.b_v_filter_p0ac0, new_value_t.b_v_filter_p0ac0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window B Vertical Filter phase 0A";
}

#define WINC_B_V_FILTER_P0B_OFFSET 0x1624
#define WINC_B_V_FILTER_P0B_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p0b_u {
    struct {
        unsigned int b_v_filter_p0bc0:8;    /* Phase 0B coefficient 0 (typically 40) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p0b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p0b_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p0b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p0bc0:8",
              "Phase 0B coefficient 0 (typically 40)",
              8, old_value_t.b_v_filter_p0bc0, new_value_t.b_v_filter_p0bc0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window B Vertical Filter phase 0B";
}

#define WINC_B_V_FILTER_P0C_OFFSET 0x1625
#define WINC_B_V_FILTER_P0C_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p0c_u {
    struct {
        unsigned int b_v_filter_p0cc0:8;    /* Phase 0C coefficient 0 (typically 32) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p0c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p0c_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p0c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p0cc0:8",
              "Phase 0C coefficient 0 (typically 32)",
              8, old_value_t.b_v_filter_p0cc0, new_value_t.b_v_filter_p0cc0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window B Vertical Filter phase 0C";
}

#define WINC_B_V_FILTER_P0D_OFFSET 0x1626
#define WINC_B_V_FILTER_P0D_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p0d_u {
    struct {
        unsigned int b_v_filter_p0dc0:8;    /* Phase 0D coefficient 0 (typically 24) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p0d_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p0d_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p0d_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p0dc0:8",
              "Phase 0D coefficient 0 (typically 24)",
              8, old_value_t.b_v_filter_p0dc0, new_value_t.b_v_filter_p0dc0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window B Vertical Filter phase 0D";
}

#define WINC_B_V_FILTER_P0E_OFFSET 0x1627
#define WINC_B_V_FILTER_P0E_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p0e_u {
    struct {
        unsigned int b_v_filter_p0ec0:8;    /* Phase 0E coefficient 0 (typically 16) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p0e_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p0e_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p0e_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p0ec0:8",
              "Phase 0E coefficient 0 (typically 16)",
              8, old_value_t.b_v_filter_p0ec0, new_value_t.b_v_filter_p0ec0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Vertical Filter phase 0E";
}

#define WINC_B_V_FILTER_P0F_OFFSET 0x1628
#define WINC_B_V_FILTER_P0F_UNDEFMASK 0xFFFFFF00
union winc_b_v_filter_p0f_u {
    struct {
        unsigned int b_v_filter_p0fc0:8;    /* Phase 0F coefficient 0 (typically 8) */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_v_filter_p0f_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_v_filter_p0f_u old_value_t = { .reg32 = value };
    const winc_b_v_filter_p0f_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_filter_p0fc0:8",
              "Phase 0F coefficient 0 (typically 8)",
              8, old_value_t.b_v_filter_p0fc0, new_value_t.b_v_filter_p0fc0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Vertical Filter phase 0F";
}

#define WIN_B_WIN_OPTIONS_OFFSET 0x1700
#define WIN_B_WIN_OPTIONS_UNDEFMASK 0xBFAAAABA
union win_b_win_options_u {
    struct {
        unsigned int b_h_direction:1;       /* Window B Horizontal (X) drawing Direction  0 = INCREMENT 1 = DECREMENT */
        unsigned int undefined_bit_1:1;
        unsigned int b_v_direction:1;       /* Window B Vertical (Y) drawing Direction  0 = INCREMENT 1 = DECREMENT */
        unsigned int undefined_bits_3_5:3;
        unsigned int b_color_expand:1;      /* Window B 12/15/16/18-to-24 bpp color expansion This bit should be enabled only for 12-bpp B4G4R4A4, 15-bpp B5G5R5A, 16-bpp B5G6R5, 18-bpp B6G6R6 color modes. If enabled the color conversion is performed prior to horizontal scaling.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_7:1;
        unsigned int b_h_filter_enable:1;   /* Window B H Filter Enable This controls H scaling filter and is effective only for non-palletized color modes.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int b_v_filter_enable:1;   /* Window B V Filter Enable This controls V scaling filter and is effective only for non-palletized color modes. If V filter is disabled, only one line is read from memory for each output line.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_11:1;
        unsigned int b_v_filter_optimize:1; /* Window B V Filter Optimization This is effective only when vertical scaling filter is enabled. This can be used (enabled) to temporarily disable the vertical scaling filter when the vertical scaling DDA fraction is zero. In this case the next line is not fetched from memory to save bandwidth and power. This feature cannot be used in 420P/422R/422RA formats.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_13:1;
        unsigned int b_v_filter_uv_align:1; /* Window B V Filter UV Alignment This is effective only when vertical scaling filter is enabled and only on these formats YCbCr420P, YUV420P, YCbCr422R, YUV422R, YCbCr422RA YUV422RA. When UV alignment is enabled, the chroma components are aligned to the even number of luma component lines. When disabled the chroma components are aligned to half a pixel below the corresponding even number of luma component lines. It is usually disabled unless the incoming video stream specifically indicates otherwise.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_15:1;
        unsigned int b_cp_enable:1;         /* Window B Color Palette Enable This controls the color palette and should be enabled for palletized color modes. For non-palletized color modes, the color palette can be enabled for gamma correction.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int b_csc_enable:1;        /* Window B Color Space Conversion Enable This controls the color space conversion and should be enabled for YCbCr/YUV color modes for conversion to B8G8R8 and for hue and saturation control. This can also be used for gain control for RGB color modes  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_19:1;
        unsigned int b_dv_enable:1;         /* Window B Digital Vibrance Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_21:1;
        unsigned int b_yuv_range_expand:1;  /* Window B Enable range expansion in the cases where RANGEREDFRM is 1 from mpd. Formula: Y = clip(( Y-128)*2 + 128); Cb = clip((Cb-128)*2 + 128); Cr = clip((Cr-128)*2 + 128); where clip() function clips between 0 and 255. 0= disable 1= enable 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_23_29:7;
        unsigned int b_win_enable:1;        /* Window B Window enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_win_options_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_win_options_u old_value_t = { .reg32 = value };
    const win_b_win_options_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_direction:1",
              "Window B Horizontal (X) drawing Direction \n0 = INCREMENT\n1 = DECREMENT",
              1, old_value_t.b_h_direction, new_value_t.b_h_direction };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: b_v_direction:1",
              "Window B Vertical (Y) drawing Direction \n0 = INCREMENT\n1 = DECREMENT",
              1, old_value_t.b_v_direction, new_value_t.b_v_direction };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_5:3", "", 3, old_value_t.undefined_bits_3_5, new_value_t.undefined_bits_3_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: b_color_expand:1",
              "Window B 12/15/16/18-to-24 bpp color expansion This bit should be enabled only for 12-bpp B4G4R4A4, 15-bpp B5G5R5A, 16-bpp B5G6R5, 18-bpp B6G6R6 color modes. If enabled the color conversion is performed prior to horizontal scaling.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.b_color_expand, new_value_t.b_color_expand };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_h_filter_enable:1",
              "Window B H Filter Enable This controls H scaling filter and is effective only for non-palletized color modes.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.b_h_filter_enable, new_value_t.b_h_filter_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bit_9:1", "", 1, old_value_t.undefined_bit_9, new_value_t.undefined_bit_9 };
    m_bit_details_model.bits.append(entry);
    entry = { "10: b_v_filter_enable:1",
              "Window B V Filter Enable This controls V scaling filter and is effective only for non-palletized color modes. If V filter is disabled, only one line is read from memory for each output line.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.b_v_filter_enable, new_value_t.b_v_filter_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: b_v_filter_optimize:1",
              "Window B V Filter Optimization This is effective only when vertical scaling filter is enabled. This can be used (enabled) to temporarily disable the vertical scaling filter when the vertical scaling DDA fraction is zero. In this case the next line is not fetched from memory to save bandwidth and power. This feature cannot be used in 420P/422R/422RA formats.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.b_v_filter_optimize, new_value_t.b_v_filter_optimize };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: b_v_filter_uv_align:1",
              "Window B V Filter UV Alignment This is effective only when vertical scaling filter is enabled and only on these formats YCbCr420P, YUV420P, YCbCr422R, YUV422R, YCbCr422RA YUV422RA. When UV alignment is enabled, the chroma components are aligned to the even number of luma component lines. When disabled the chroma components are aligned to half a pixel below the corresponding even number of luma component lines. It is usually disabled unless the incoming video stream specifically indicates otherwise.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.b_v_filter_uv_align, new_value_t.b_v_filter_uv_align };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_cp_enable:1",
              "Window B Color Palette Enable This controls the color palette and should be enabled for palletized color modes. For non-palletized color modes, the color palette can be enabled for gamma correction.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.b_cp_enable, new_value_t.b_cp_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: b_csc_enable:1",
              "Window B Color Space Conversion Enable This controls the color space conversion and should be enabled for YCbCr/YUV color modes for conversion to B8G8R8 and for hue and saturation control. This can also be used for gain control for RGB color modes \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.b_csc_enable, new_value_t.b_csc_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: b_dv_enable:1",
              "Window B Digital Vibrance Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.b_dv_enable, new_value_t.b_dv_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bit_21:1", "", 1, old_value_t.undefined_bit_21, new_value_t.undefined_bit_21 };
    m_bit_details_model.bits.append(entry);
    entry = { "22: b_yuv_range_expand:1",
              "Window B Enable range expansion in the cases where RANGEREDFRM is 1 from mpd. Formula: Y = clip(( Y-128)*2 + 128); Cb = clip((Cb-128)*2 + 128); Cr = clip((Cr-128)*2 + 128); where clip() function clips between 0 and 255.\n0= disable\n1= enable\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.b_yuv_range_expand, new_value_t.b_yuv_range_expand };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bits_23_29:7", "", 7, old_value_t.undefined_bits_23_29, new_value_t.undefined_bits_23_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: b_win_enable:1",
              "Window B Window enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.b_win_enable, new_value_t.b_win_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Options\nClass: Display Window Settings\nDisplay Window B parameters";
}

#define WIN_B_BYTE_SWAP_OFFSET 0x1701
#define WIN_B_BYTE_SWAP_UNDEFMASK 0xFFFFFFFC
union win_b_byte_swap_u {
    struct {
        unsigned int b_byte_swap:2;         /* Window B Byte Swap This controls byte swap of frame data read from memory prior to any data processing in the display module. 00= no byte swap (3 2 1 0) 01= byte swap for each 2-byte word (2 3 0 1) 10= byte swap for each 4-byte word (0 1 2 3) 11= word swap for each 4-byte word (1 0 3 2) 0 = NOSWAP 1 = SWAP2 2 = SWAP4 3 = SWAP4HW */
        unsigned int undefined_bits_2_31:30;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_byte_swap_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_byte_swap_u old_value_t = { .reg32 = value };
    const win_b_byte_swap_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_byte_swap:2",
              "Window B Byte Swap This controls byte swap of frame data read from memory prior to any data processing in the display module.\n00= no byte swap (3 2 1 0)\n01= byte swap for each 2-byte word (2 3 0 1)\n10= byte swap for each 4-byte word (0 1 2 3)\n11= word swap for each 4-byte word (1 0 3 2)\n0 = NOSWAP\n1 = SWAP2\n2 = SWAP4\n3 = SWAP4HW",
              2, old_value_t.b_byte_swap, new_value_t.b_byte_swap };
    m_bit_details_model.bits.append(entry);
    entry = { "02: undefined_bits_2_31:30", "", 30, old_value_t.undefined_bits_2_31, new_value_t.undefined_bits_2_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Byte Swap";
}

#define WIN_B_BUFFER_CONTROL_OFFSET 0x1702
#define WIN_B_BUFFER_CONTROL_UNDEFMASK 0xFFFFFFF8
union win_b_buffer_control_u {
    struct {
        unsigned int b_buffer_control:3;    /* Window B Buffer Control 0= Host (software) controlled 1= Video Input controlled 2= Encoder Pre-Processor controlled 3= MPEG Encoder controlled 4= StretchBLT or 2D other= reserved If window buffer selection is not controlled by host (software) then buffer start indexes are sent by the respective module specified by this parameter, and in this case, the buffer start address registers are used to specify frame stride and buffer offset for the calculated start address. 0 = HOST 1 = VI 2 = EPP 4 = SB2D 3 = MPEGE */
        unsigned int undefined_bits_3_31:29;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_buffer_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_buffer_control_u old_value_t = { .reg32 = value };
    const win_b_buffer_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_buffer_control:3",
              "Window B Buffer Control\n0= Host (software) controlled\n1= Video Input controlled\n2= Encoder Pre-Processor controlled\n3= MPEG Encoder controlled\n4= StretchBLT or 2D other= reserved If window buffer selection is not controlled by host (software) then buffer start indexes are sent by the respective module specified by this parameter, and in this case, the buffer start address registers are used to specify frame stride and buffer offset for the calculated start address.\n0 = HOST\n1 = VI\n2 = EPP\n4 = SB2D\n3 = MPEGE",
              3, old_value_t.b_buffer_control, new_value_t.b_buffer_control };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_31:29", "", 29, old_value_t.undefined_bits_3_31, new_value_t.undefined_bits_3_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window B Buffer Control";
}

#define WIN_B_COLOR_DEPTH_OFFSET 0x1703
#define WIN_B_COLOR_DEPTH_UNDEFMASK 0xFFFFFFE0
union win_b_color_depth_u {
    struct {
        unsigned int b_color_depth:5;       /* Window B Color Depth Supported color depths are: P8 = 8-bpp (palletized) B4G4R4A4 = 12-bpp B4G4R4 B5G5R5A = 15-bpp B5G5R5 AB5G5R5 = 15-bpp B5G5R5 B5G6R5 = 16-bpp B5G6R5 B8G8R8A8 = 32-bpp B8G8R8A8 R8G8B8A8 = 32-bpp R8G8B8A8 B6x2G6x2R6x2A8 = 32-bpp B6G6R6A8 R6x2G6x2B6x2A8 = 32-bpp R6G6B6A8 YCbCr422 = 16-bpp YCbCr422 packed YUV422 = 16-bpp YUV422 YCbCr420P = 16-bpp YCbCr420 planar YUV420P = 16-bpp YUV420 planar YCbCr422P = 16-bpp YCbCr422 planar YUV422P = 16-bpp YUV422 planar YCbCr422R = 16-bpp YCbCr422 rotated planar YUV422R = 16-bpp YUV422 rotated planar YCbCr422RA= 16-bpp YCbCr422 rotated planar with chroma averaging YUV422RA = 16-bpp YUV422 rotated planar with chroma averaging 0 = P1 1 = P2 2 = P4 3 = P8 4 = B4G4R4A4 5 = B5G5R5A 6 = B5G6R5 7 = AB5G5R5 12 = B8G8R8A8 13 = R8G8B8A8 14 = B6x2G6x2R6x2A8 15 = R6x2G6x2B6x2A8 16 = YCbCr422 17 = YUV422 18 = YCbCr420P 19 = YUV420P 20 = YCbCr422P 21 = YUV422P 22 = YCbCr422R 23 = YUV422R 24 = YCbCr422RA 25 = YUV422RA */
        unsigned int undefined_bits_5_31:27;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_color_depth_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_color_depth_u old_value_t = { .reg32 = value };
    const win_b_color_depth_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_color_depth:5",
              "Window B Color Depth Supported color depths are: P8 = 8-bpp (palletized) B4G4R4A4 = 12-bpp B4G4R4 B5G5R5A = 15-bpp B5G5R5 AB5G5R5 = 15-bpp B5G5R5 B5G6R5 = 16-bpp B5G6R5 B8G8R8A8 = 32-bpp B8G8R8A8 R8G8B8A8 = 32-bpp R8G8B8A8 B6x2G6x2R6x2A8 = 32-bpp B6G6R6A8 R6x2G6x2B6x2A8 = 32-bpp R6G6B6A8 YCbCr422 = 16-bpp YCbCr422 packed YUV422 = 16-bpp YUV422 YCbCr420P = 16-bpp YCbCr420 planar YUV420P = 16-bpp YUV420 planar YCbCr422P = 16-bpp YCbCr422 planar YUV422P = 16-bpp YUV422 planar YCbCr422R = 16-bpp YCbCr422 rotated planar YUV422R = 16-bpp YUV422 rotated planar YCbCr422RA= 16-bpp YCbCr422 rotated planar with chroma averaging YUV422RA = 16-bpp YUV422 rotated planar with chroma averaging\n0 = P1\n1 = P2\n2 = P4\n3 = P8\n4 = B4G4R4A4\n5 = B5G5R5A\n6 = B5G6R5\n7 = AB5G5R5\n12 = B8G8R8A8\n13 = R8G8B8A8\n14 = B6x2G6x2R6x2A8\n15 = R6x2G6x2B6x2A8\n16 = YCbCr422\n17 = YUV422\n18 = YCbCr420P\n19 = YUV420P\n20 = YCbCr422P\n21 = YUV422P\n22 = YCbCr422R\n23 = YUV422R\n24 = YCbCr422RA\n25 = YUV422RA",
              5, old_value_t.b_color_depth, new_value_t.b_color_depth };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_31:27", "", 27, old_value_t.undefined_bits_5_31, new_value_t.undefined_bits_5_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Color Depth For YCbCr data format, Cb and Cr are 8-bit unsigned values. For YUV data format, U and V are 8-bit signed values. YCbCr422R is similar to YCbCr422P but the Cb and Cr are shared vertically.\nYUV422R is similar to YUV422P but the U and V are shared vertically. YCbCr422RA is same as YCbCr422R in memory and YUV422RA is same as YUV422R in memory but while reading from memory, for YCbCr422RA and YUV422RA, chroma averaging is applied for each pixel pair so that they can be processed as YUV422 by the display pipeline.\nFor YCbCr422R and YUV422R, every other chroma pixels are not used (discarded) by the display pipeline. B6x2G6x2R6x2A8 is similar to B8G8R6A8 but with the 2 lsb zeroed out. R6x2G6x2B6x2A8 is similar to R8G8B6A8 but with the 2 lsb zeroed out.";
}

#define WIN_B_POSITION_OFFSET 0x1704
#define WIN_B_POSITION_UNDEFMASK 0xE000E000
union win_b_position_u {
    struct {
        unsigned int b_h_position:13;       /* Window B H Position This is specified with respect to the left edge of active display area */
        unsigned int undefined_bits_13_15:3;
        unsigned int b_v_position:13;       /* Window B V Position This is specified with respect to the top edge of active display area */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_position_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_position_u old_value_t = { .reg32 = value };
    const win_b_position_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_position:13",
              "Window B H Position This is specified with respect to the left edge of active display area",
              13, old_value_t.b_h_position, new_value_t.b_h_position };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_v_position:13",
              "Window B V Position This is specified with respect to the top edge of active display area",
              13, old_value_t.b_v_position, new_value_t.b_v_position };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window B Position\nThis register defines H position and size of Window B after scaling (if there is any)";
}

#define WIN_B_SIZE_OFFSET 0x1705
#define WIN_B_SIZE_UNDEFMASK 0xE000E000
union win_b_size_u {
    struct {
        unsigned int b_h_size:13;           /* Window B H Size (pixels) This is the horizontal size after scaling */
        unsigned int undefined_bits_13_15:3;
        unsigned int b_v_size:13;           /* Window B V Size (lines) This is the vertical size after scaling */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_size_u old_value_t = { .reg32 = value };
    const win_b_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_size:13",
              "Window B H Size (pixels) This is the horizontal size after scaling",
              13, old_value_t.b_h_size, new_value_t.b_h_size };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_v_size:13",
              "Window B V Size (lines) This is the vertical size after scaling",
              13, old_value_t.b_v_size, new_value_t.b_v_size };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Size\nThis register defines V position and size of Window B after scaling (if there is any)\n Note: programming on window size should guarantee the whole window is inside the active area, otherwise extra rows/columns will be fetched and discarded which affects performance.";
}

#define WIN_B_PRESCALED_SIZE_OFFSET 0x1706
#define WIN_B_PRESCALED_SIZE_UNDEFMASK 0xE0008000
union win_b_prescaled_size_u {
    struct {
        unsigned int b_h_prescaled_size:15; /* Window B H Pre-scaled Size (bytes) In 420P and 422P formats, it must be even */
        unsigned int undefined_bit_15:1;
        unsigned int b_v_prescaled_size:13; /* Window B V Pre-scaled Size (lines) In 420P/422R/422RA formats, it must be even */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_prescaled_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_prescaled_size_u old_value_t = { .reg32 = value };
    const win_b_prescaled_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_prescaled_size:15",
              "Window B H Pre-scaled Size (bytes) In 420P and 422P formats, it must be even",
              15, old_value_t.b_h_prescaled_size, new_value_t.b_h_prescaled_size };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_v_prescaled_size:13",
              "Window B V Pre-scaled Size (lines) In 420P/422R/422RA formats, it must be even",
              13, old_value_t.b_v_prescaled_size, new_value_t.b_v_prescaled_size };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Pre-scaled Size\nThis register defines Window B pre-scaled size.\nThe H pre-scaled size is needed to determine how many bytes to fetch from memory per line and this parameter must be programmed exactly as needed taking into account the scaling factor. For planar YUV or YCbCr data formats, this parameter refer to the H pre-scaled of the Y plane.\nThe total number of lines to be fetched from memory is determined by post-scale V size but V pre-scaled size is needed to 'clamp' the last valid line if the vertical DDA is exactly or slightly beyond the specified V pre-scaled size.\nDesign Note: H pre-scaled size ideally should be in terms of pixel but then hardware needs to convert this precisely to bytes to determine the amount of data to request from memory.\nThis could be a risky calculation - maybe this should be made optional on whether we use internal hardware to calculate or left it to software to calculate.";
}

#define WIN_B_H_INITIAL_DDA_OFFSET 0x1707
#define WIN_B_H_INITIAL_DDA_UNDEFMASK 0xFFFF0000
union win_b_h_initial_dda_u {
    struct {
        unsigned int b_h_initial_dda:16;    /* Window B H Initial DDA (4.12) This is typically programmed to 0.0 */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_h_initial_dda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_h_initial_dda_u old_value_t = { .reg32 = value };
    const win_b_h_initial_dda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_initial_dda:16",
              "Window B H Initial DDA (4.12) This is typically programmed to 0.0",
              16, old_value_t.b_h_initial_dda, new_value_t.b_h_initial_dda };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window B H Initial DDA\nDesign Note: the first pixel of pre-scaled image is always used to output the first pixel so essentially this is the same as forcing the H Initial DDA integer portion to 1 initially even though user typically programs this to 0. If it makes the implementation easier, it is possible to force software to program the Initial DDA integer portion to 1. Similarly with the V Initial DDA.";
}

#define WIN_B_V_INITIAL_DDA_OFFSET 0x1708
#define WIN_B_V_INITIAL_DDA_UNDEFMASK 0xFFFF0000
union win_b_v_initial_dda_u {
    struct {
        unsigned int b_v_initial_dda:16;    /* Window B V Initial DDA (4.12) This is typically programmed to 0.0 for both non-interlaced and interlaced sources */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_v_initial_dda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_v_initial_dda_u old_value_t = { .reg32 = value };
    const win_b_v_initial_dda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_v_initial_dda:16",
              "Window B V Initial DDA (4.12) This is typically programmed to 0.0 for both non-interlaced and interlaced sources",
              16, old_value_t.b_v_initial_dda, new_value_t.b_v_initial_dda };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B V Initial DDA";
}

#define WIN_B_DDA_INCREMENT_OFFSET 0x1709
#define WIN_B_DDA_INCREMENT_UNDEFMASK 0x00000000
union win_b_dda_increment_u {
    struct {
        unsigned int b_h_dda_increment:16;  /* Window B Horizontal DDA Increment (4.12) This should be set to 1.0 if there is no scaling. The maximum value for downscaling depends on the number of bytes per pixel. For 4-byte/pixel modes (32-bpp) the maximum value is 4.0 and for all other modes the maximum value is 8.0 */
        unsigned int b_v_dda_increment:16;  /* Window B Vertical DDA Increment (4.12) This should be set to 1.0 if there is no scaling. Maximum value is 15.0 regardless of the number of bytes per pixel */
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_dda_increment_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_dda_increment_u old_value_t = { .reg32 = value };
    const win_b_dda_increment_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_h_dda_increment:16",
              "Window B Horizontal DDA Increment (4.12) This should be set to 1.0 if there is no scaling. The maximum value for downscaling depends on the number of bytes per pixel. For 4-byte/pixel modes (32-bpp) the maximum value is 4.0 and for all other modes the maximum value is 8.0",
              16, old_value_t.b_h_dda_increment, new_value_t.b_h_dda_increment };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_v_dda_increment:16",
              "Window B Vertical DDA Increment (4.12) This should be set to 1.0 if there is no scaling. Maximum value is 15.0 regardless of the number of bytes per pixel",
              16, old_value_t.b_v_dda_increment, new_value_t.b_v_dda_increment };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B DDA Increment\nDDA increment is typically calculated by dividing (Pre-scaled size in pixels - 1) by (Post-scaled size in pixels - 1). The result should be rounded up and expressed as 4.12 format (4-bit integer and 12-bit fraction). For non-filtered image this value can be slightly larger so that it is not missing the last row/column. Reference programming values (H and V should be calculated separately depending on filter on/off and sizes):\n    * Filter on: min(round((prescaled_size_in_pixels - 1) * 0x1000 / (post_scaled_size_in_pixels - 1)), MAX)\n    * Filter off: min(round(prescaled_size_in_pixels * 0x1000 / (post_scaled_size_in_pixels - 1) - 0.5), MAX)\nWhere the value of MAX is as follows:\nFor V_DDA_INCREMENT: 15.0 (0xF000)\nFor H_DDA_INCREMETN: 4.0 (0x4000) for 2 Bytes/pix formats.\n8.0 (0x8000) for 4 Bytes/pix formats.\nThey are theoretically the biggest values that guarantees not displaying beyond an image boundary.\nIf the DDA increment is less than 1.0 then image will be up-scaled and if DDA increment is more than 1.0 then image will be down-scaled.";
}

#define WIN_B_LINE_STRIDE_OFFSET 0x170A
#define WIN_B_LINE_STRIDE_UNDEFMASK 0x00000000
union win_b_line_stride_u {
    struct {
        unsigned int b_line_stride:16;      /* Window B Line Stride This is stride (in bytes) for all non-planar data formats. If the memory surface is tiled, the stride needs to be a multiple of 16. If H_DIRECTION of window B is set to DECREMENT, the stride also needs to be a multiple of 16. For planar YUV or YCbCr data formats, this is stride (in bytes) for the luma plane with the restriction that it must be multiples of 8 (16 if tiled or in horizontal flipping) For tiled surface this value may affect starting address of a window. Refer to the comment of START_ADDR for detail */
        unsigned int b_uv_line_stride:16;   /* Window B Line Stride for Chroma This is stride (in bytes) for planar YUV or YCbCr data formats for the chroma plane, with the restriction that it must be programmed to be multiples of 4 (16 if tiled or in horizontal flipping) This is not used (ignored) for other non-planar data formats */
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_line_stride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_line_stride_u old_value_t = { .reg32 = value };
    const win_b_line_stride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_line_stride:16",
              "Window B Line Stride This is stride (in bytes) for all non-planar data formats. If the memory surface is tiled, the stride needs to be a multiple of 16. If H_DIRECTION of window B is set to DECREMENT, the stride also needs to be a multiple of 16. For planar YUV or YCbCr data formats, this is stride (in bytes) for the luma plane with the restriction that it must be multiples of 8 (16 if tiled or in horizontal flipping) For tiled surface this value may affect starting address of a window. Refer to the comment of START_ADDR for detail",
              16, old_value_t.b_line_stride, new_value_t.b_line_stride };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_uv_line_stride:16",
              "Window B Line Stride for Chroma This is stride (in bytes) for planar YUV or YCbCr data formats for the chroma plane, with the restriction that it must be programmed to be multiples of 4 (16 if tiled or in horizontal flipping) This is not used (ignored) for other non-planar data formats",
              16, old_value_t.b_uv_line_stride, new_value_t.b_uv_line_stride };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Line Stride";
}

#define WIN_B_BUF_STRIDE_OFFSET 0x170B
#define WIN_B_BUF_STRIDE_UNDEFMASK 0x00000000
union win_b_buf_stride_u {
    struct {
        unsigned int b_buf_stride:32;       /* Window B Buffer stride Buffer stride is used to calculate the buffer addresses when the window is triggered by non-host modules. Refer to the comment of of START_ADDR for programming guide. For YUV planar pixel format, this specifies buffer stride for the Y plane. The value is in bytes */
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_buf_stride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_buf_stride_u old_value_t = { .reg32 = value };
    const win_b_buf_stride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_buf_stride:32",
              "Window B Buffer stride Buffer stride is used to calculate the buffer addresses when the window is triggered by non-host modules. Refer to the comment of of START_ADDR for programming guide. For YUV planar pixel format, this specifies buffer stride for the Y plane. The value is in bytes",
              32, old_value_t.b_buf_stride, new_value_t.b_buf_stride };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Buffer stride";
}

#define WIN_B_UV_BUF_STRIDE_OFFSET 0x170C
#define WIN_B_UV_BUF_STRIDE_UNDEFMASK 0x00000000
union win_b_uv_buf_stride_u {
    struct {
        unsigned int b_uv_buf_stride:32;    /* Window B This value is in bytes. For YUV planar pixel format, this specifies buffer stride for the U/V plane */
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_uv_buf_stride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_uv_buf_stride_u old_value_t = { .reg32 = value };
    const win_b_uv_buf_stride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_uv_buf_stride:32",
              "Window B This value is in bytes. For YUV planar pixel format, this specifies buffer stride for the U/V plane",
              32, old_value_t.b_uv_buf_stride, new_value_t.b_uv_buf_stride };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Buffer stride for U/V plane";
}

#define WIN_B_BUFFER_ADDR_MODE_OFFSET 0x170D
#define WIN_B_BUFFER_ADDR_MODE_UNDEFMASK 0xFFFEFFFE
union win_b_buffer_addr_mode_u {
    struct {
        unsigned int b_tile_mode:1;         /* Window B Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the Y plane. 0 = LINEAR 1 = TILED */
        unsigned int undefined_bits_1_15:15;
        unsigned int b_uv_tile_mode:1;      /* Window B Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the U/V plane. 0 = LINEAR 1 = TILED */
        unsigned int undefined_bits_17_31:15;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_buffer_addr_mode_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_buffer_addr_mode_u old_value_t = { .reg32 = value };
    const win_b_buffer_addr_mode_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_tile_mode:1",
              "Window B Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the Y plane.\n0 = LINEAR\n1 = TILED",
              1, old_value_t.b_tile_mode, new_value_t.b_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_15:15", "", 15, old_value_t.undefined_bits_1_15, new_value_t.undefined_bits_1_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_uv_tile_mode:1",
              "Window B Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the U/V plane.\n0 = LINEAR\n1 = TILED",
              1, old_value_t.b_uv_tile_mode, new_value_t.b_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_31:15", "", 15, old_value_t.undefined_bits_17_31, new_value_t.undefined_bits_17_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Memory Controller Tiling definitions";
}

#define WIN_B_DV_CONTROL_OFFSET 0x170E
#define WIN_B_DV_CONTROL_UNDEFMASK 0xFFF8F8F8
union win_b_dv_control_u {
    struct {
        unsigned int b_dv_control_r:3;      /* Digital Vibrance control for R */
        unsigned int undefined_bits_3_7:5;
        unsigned int b_dv_control_g:3;      /* Digital Vibrance control for G */
        unsigned int undefined_bits_11_15:5;
        unsigned int b_dv_control_b:3;      /* Digital Vibrance control for B */
        unsigned int undefined_bits_19_31:13;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_dv_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_dv_control_u old_value_t = { .reg32 = value };
    const win_b_dv_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_dv_control_r:3",
              "Digital Vibrance control for R",
              3, old_value_t.b_dv_control_r, new_value_t.b_dv_control_r };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_7:5", "", 5, old_value_t.undefined_bits_3_7, new_value_t.undefined_bits_3_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_dv_control_g:3",
              "Digital Vibrance control for G",
              3, old_value_t.b_dv_control_g, new_value_t.b_dv_control_g };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_15:5", "", 5, old_value_t.undefined_bits_11_15, new_value_t.undefined_bits_11_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_dv_control_b:3",
              "Digital Vibrance control for B",
              3, old_value_t.b_dv_control_b, new_value_t.b_dv_control_b };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bits_19_31:13", "", 13, old_value_t.undefined_bits_19_31, new_value_t.undefined_bits_19_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window B Digital Vibrance Control\nIf enabled, Digital Vibrance is applied after H and V scaling and after color palette or color space conversion logic but before color keying multiplexer and before cursor multiplexer.\n    * After DV, new R = R + (2R - G - B) * FR, where FR is fraction from 0 to 7/8\n    * After DV, new G = G + (2G - R - B) * FG, where FG is fraction from 0 to 7/8\n    * After DV, new B = B + (2B - R - G) * FB, where FB is fraction from 0 to 7/8";
}

#define WIN_B_BLEND_NOKEY_OFFSET 0x170F
#define WIN_B_BLEND_NOKEY_UNDEFMASK 0xFF0000FE
union win_b_blend_nokey_u {
    struct {
        unsigned int b_blend_control_nokey:1;/* Window blend control for color key not match areas. 0 = Fix weight using window blend weight 0 for color key not matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT */
        unsigned int undefined_bits_1_7:7;
        unsigned int b_blend_weight0_nokey:8;/* Window blend weight 0 for color key not match areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int b_blend_weight1_nokey:8;/* Window blend weight 1 for color key not match areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_blend_nokey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_blend_nokey_u old_value_t = { .reg32 = value };
    const win_b_blend_nokey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_blend_control_nokey:1",
              "Window blend control for color key not match areas.\n0 = Fix weight using window blend weight 0 for color key not matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n0 = FIX_WEIGHT\n1 = ALPHA_WEIGHT",
              1, old_value_t.b_blend_control_nokey, new_value_t.b_blend_control_nokey };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_blend_weight0_nokey:8",
              "Window blend weight 0 for color key not match areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.b_blend_weight0_nokey, new_value_t.b_blend_weight0_nokey };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_blend_weight1_nokey:8",
              "Window blend weight 1 for color key not match areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.b_blend_weight1_nokey, new_value_t.b_blend_weight1_nokey };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Blend Control for this window areas where color key is enabled but the pixel color is not within the color key range (color key not match). This is valid for all overlapping condition but only if there is no overlap with other window with higher priority color key enabled and color key not match.\nClass: Display Color Keying and Blending\nColor keying and blending of the display windows are done prior to cursor blending.\nCursor always goes on top of the blended windows. Blending is controlled independently on each possible overlap area of the display windows. If 3 windows are enabled there are 7 possible overlap area combinations. For every window in each overlap area combination, color key can be disabled or enabled. Also, for every window in each overlap area combination, there is a corresponding window blend control parameter and a window blend weight parameter. The window blend control parameter is always effective but the window blend weight is not always used. The window blend weight can also be derived from pixel alpha value or from the reverse of other overlapping windows weight.\nColor keying has the highest priority for display window blending. Color key consists of a range of color which is searched independently for each windows. If more than 1 windows color keys are enabled then Window A color key has the highest priority, followed by Window B color key, and then followed by Window C color key. Two sets of color key range (Color Key 0 and Color Key 1) can be defined and they are shared for all windows. It is possible to use both color key sets for the same window or for two separate windows.\nThe two sets of color key ranges should not overlap and if they do the overlap colors are treated as if they are part of Color Key 0 and not part of Color Key 1.\nAssuming that there is no overlap with other higher priority window with color key not matched, if a window color key is enabled for any overlap condition and the window pixel is not within the color key range (key not match), then the window pixel will not be blended with other overlapping window pixels but it will be weighted. The weight is not dependent on the overlap condition it is controlled by the same set of parameters for all overlapping condition.\nAssuming that there is no overlap with other higher priority window with color key not matched, if a window color key is enabled for a particular overlap condition and the window pixel is within the color key range (key match), then the window pixel will be weighted and blended with other overlapping pixels and this is controlled separately for each overlap condition.\nAssuming that there is no overlap with other higher priority window with color key not matched, if a window color key is disabled then the window pixel will be blended with other overlapping pixels and this is controlled separately for each overlap condition.\nDisplay Color Key Parameters\nFor B4G4R4A4, B5G6R5A, B5G6R5 mode, color key should be compared prior to color conversion to 24-bpp and unused least significant bits of the pixel are filled with zeros.\nFor palletized mode, color key is compared prior to color palette and the palletized color is compared against the green color key values/mask.\nFor YUV mode, U and V are offset by +128 before performing the color key comparison.\nIn all cases, color key is compared prior to horizontal/vertical scaling filter and prior to digital vibrance control. Both upper and lower values are inclusive.";
}

#define WIN_B_BLEND_1WIN_OFFSET 0x1710
#define WIN_B_BLEND_1WIN_UNDEFMASK 0xFF0000F8
union win_b_blend_1win_u {
    struct {
        unsigned int b_ckey_enable_1win:2;  /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int b_blend_control_1win:1;/* Window blend control in area where it does not overlap with other windows and either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT */
        unsigned int undefined_bits_3_7:5;
        unsigned int b_blend_weight0_1win:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int b_blend_weight1_1win:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_blend_1win_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_blend_1win_u old_value_t = { .reg32 = value };
    const win_b_blend_1win_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_ckey_enable_1win:2",
              "Window color key enable\n0 = Color Key 0 and 1 Disable\n1 = Color Key 0 Enable\n2 = Color Key 1 Enable\n3 = Color Key 0 and 1 Enable\n0 = NOKEY\n1 = CKEY0\n2 = CKEY1\n3 = CKEY01",
              2, old_value_t.b_ckey_enable_1win, new_value_t.b_ckey_enable_1win };
    m_bit_details_model.bits.append(entry);
    entry = { "02: b_blend_control_1win:1",
              "Window blend control in area where it does not overlap with other windows and either color key disabled or color key enabled with key matched.\n0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n0 = FIX_WEIGHT\n1 = ALPHA_WEIGHT",
              1, old_value_t.b_blend_control_1win, new_value_t.b_blend_control_1win };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_7:5", "", 5, old_value_t.undefined_bits_3_7, new_value_t.undefined_bits_3_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_blend_weight0_1win:8",
              "Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.b_blend_weight0_1win, new_value_t.b_blend_weight0_1win };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_blend_weight1_1win:8",
              "Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.b_blend_weight1_1win, new_value_t.b_blend_weight1_1win };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Blend Control for this window area where it does not overlap with other windows.";
}

#define WIN_B_BLEND_2WIN_A_OFFSET 0x1711
#define WIN_B_BLEND_2WIN_A_UNDEFMASK 0xFF0000F0
union win_b_blend_2win_a_u {
    struct {
        unsigned int b_ckey_enable_2win_a:2;/* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int b_blend_control_2win_a:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int b_blend_weight0_2win_a:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int b_blend_weight1_2win_a:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_blend_2win_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_blend_2win_a_u old_value_t = { .reg32 = value };
    const win_b_blend_2win_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_ckey_enable_2win_a:2",
              "Window color key enable\n0 = Color Key 0 and 1 Disable\n1 = Color Key 0 Enable\n2 = Color Key 1 Enable\n3 = Color Key 0 and 1 Enable\n0 = NOKEY\n1 = CKEY0\n2 = CKEY1\n3 = CKEY01",
              2, old_value_t.b_ckey_enable_2win_a, new_value_t.b_ckey_enable_2win_a };
    m_bit_details_model.bits.append(entry);
    entry = { "02: b_blend_control_2win_a:2",
              "Window blend control in area where either color key disabled or color key enabled with key matched.\n0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting.\n0 = FIX_WEIGHT\n1 = ALPHA_WEIGHT\n2 = DEPENDENT_WEIGHT",
              2, old_value_t.b_blend_control_2win_a, new_value_t.b_blend_control_2win_a };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_7:4", "", 4, old_value_t.undefined_bits_4_7, new_value_t.undefined_bits_4_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_blend_weight0_2win_a:8",
              "Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.b_blend_weight0_2win_a, new_value_t.b_blend_weight0_2win_a };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_blend_weight1_2win_a:8",
              "Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.b_blend_weight1_2win_a, new_value_t.b_blend_weight1_2win_a };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Blend Control for this window area that overlaps with window A only.";
}

#define WIN_B_BLEND_2WIN_C_OFFSET 0x1712
#define WIN_B_BLEND_2WIN_C_UNDEFMASK 0xFF0000F0
union win_b_blend_2win_c_u {
    struct {
        unsigned int b_ckey_enable_2win_c:2;/* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int b_blend_control_2win_c:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int b_blend_weight0_2win_c:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int b_blend_weight1_2win_c:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_blend_2win_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_blend_2win_c_u old_value_t = { .reg32 = value };
    const win_b_blend_2win_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_ckey_enable_2win_c:2",
              "Window color key enable\n0 = Color Key 0 and 1 Disable\n1 = Color Key 0 Enable\n2 = Color Key 1 Enable\n3 = Color Key 0 and 1 Enable\n0 = NOKEY\n1 = CKEY0\n2 = CKEY1\n3 = CKEY01",
              2, old_value_t.b_ckey_enable_2win_c, new_value_t.b_ckey_enable_2win_c };
    m_bit_details_model.bits.append(entry);
    entry = { "02: b_blend_control_2win_c:2",
              "Window blend control in area where either color key disabled or color key enabled with key matched.\n0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting.\n0 = FIX_WEIGHT\n1 = ALPHA_WEIGHT\n2 = DEPENDENT_WEIGHT",
              2, old_value_t.b_blend_control_2win_c, new_value_t.b_blend_control_2win_c };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_7:4", "", 4, old_value_t.undefined_bits_4_7, new_value_t.undefined_bits_4_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_blend_weight0_2win_c:8",
              "Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.b_blend_weight0_2win_c, new_value_t.b_blend_weight0_2win_c };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_blend_weight1_2win_c:8",
              "Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.b_blend_weight1_2win_c, new_value_t.b_blend_weight1_2win_c };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Blend Control for this window area that overlaps with window C only.";
}

#define WIN_B_BLEND_3WIN_AC_OFFSET 0x1713
#define WIN_B_BLEND_3WIN_AC_UNDEFMASK 0xFF0000F0
union win_b_blend_3win_ac_u {
    struct {
        unsigned int b_ckey_enable_3win_ac:2;/* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int b_blend_control_3win_ac:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int b_blend_weight0_3win_ac:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int b_blend_weight1_3win_ac:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_blend_3win_ac_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_blend_3win_ac_u old_value_t = { .reg32 = value };
    const win_b_blend_3win_ac_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_ckey_enable_3win_ac:2",
              "Window color key enable\n0 = Color Key 0 and 1 Disable\n1 = Color Key 0 Enable\n2 = Color Key 1 Enable\n3 = Color Key 0 and 1 Enable\n0 = NOKEY\n1 = CKEY0\n2 = CKEY1\n3 = CKEY01",
              2, old_value_t.b_ckey_enable_3win_ac, new_value_t.b_ckey_enable_3win_ac };
    m_bit_details_model.bits.append(entry);
    entry = { "02: b_blend_control_3win_ac:2",
              "Window blend control in area where either color key disabled or color key enabled with key matched.\n0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting.\n0 = FIX_WEIGHT\n1 = ALPHA_WEIGHT\n2 = DEPENDENT_WEIGHT",
              2, old_value_t.b_blend_control_3win_ac, new_value_t.b_blend_control_3win_ac };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_7:4", "", 4, old_value_t.undefined_bits_4_7, new_value_t.undefined_bits_4_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_blend_weight0_3win_ac:8",
              "Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.b_blend_weight0_3win_ac, new_value_t.b_blend_weight0_3win_ac };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_blend_weight1_3win_ac:8",
              "Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.b_blend_weight1_3win_ac, new_value_t.b_blend_weight1_3win_ac };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Blend Control for this window area that overlaps with windows A & C only.";
}

#define WIN_B_HP_FETCH_CONTROL_OFFSET 0x1714
#define WIN_B_HP_FETCH_CONTROL_UNDEFMASK 0x00000000
union win_b_hp_fetch_control_u {
    struct {
        unsigned int b_cycles_per_word:16;  /* Window B clock cycles per memory fetch word. The value of this field is essentially a measure of the data consumption rate for window B. It is computed as follows: B_CYCLES_PER_WORD = B_DDA_INCREMENT.B_H_DDA_INCREMENT / (bytes per pixel) Note that the format for this value is a fixed-point fractional value with 8 bits of integer precision and 8 bits of fractional precision. In other words, it is an '8.8' number. For example, if there is no scaling of the input image, the DDA increment will be 4096. With 32-bit RGBA pixels there will be 4 bytes per pixel, so CYCLES_PER_WORD will be ... 4096 / 4 = 1024, or 4.0 expressed in the 8.8 format. Any scaling performed on the pixels will change the rate at which pixels are consumed. Scaling up will increase the value of DDA increment and will therefore increase the number of cycles between memory fetches. Conversely, scaling down will decrease the value of DDA increment and memory fetches will occur more frequently */
        unsigned int b_words_per_line:15;   /* Window B memory fetch words per scan line. This value is in memory fetch words: Multiples of 16 bytes for Tegra 2 Processor Series devices. It is computed as follows: B_WORDS_PER_LINE = (B_SIZE.B_H_SIZE * (bytes per pixel) + 15) >> 4 bytes per pixel is determined by the pixel format */
        unsigned int b_fetch_info_enable:1; /* Enables the sending of the Window B fetch information. For compatibility with earlier devices, this defaults to DISABLE. 0 = DISABLE : This bit should be enabled only for 12-bpp  1 = ENABLE */
    };

    u_int32_t reg32;
};

void DcDev::fill_win_b_hp_fetch_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_b_hp_fetch_control_u old_value_t = { .reg32 = value };
    const win_b_hp_fetch_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_cycles_per_word:16",
              "Window B clock cycles per memory fetch word. The value of this field is essentially a measure of the data consumption rate for window B. It is computed as follows: B_CYCLES_PER_WORD = B_DDA_INCREMENT.B_H_DDA_INCREMENT / (bytes per pixel) Note that the format for this value is a fixed-point fractional value with 8 bits of integer precision and 8 bits of fractional precision. In other words, it is an '8.8' number. For example, if there is no scaling of the input image, the DDA increment will be 4096. With 32-bit RGBA pixels there will be 4 bytes per pixel, so CYCLES_PER_WORD will be ... 4096 /\n4 = 1024, or 4.0 expressed in the 8.8 format. Any scaling performed on the pixels will change the rate at which pixels are consumed. Scaling up will increase the value of DDA increment and will therefore increase the number of cycles between memory fetches. Conversely, scaling down will decrease the value of DDA increment and memory fetches will occur more frequently",
              16, old_value_t.b_cycles_per_word, new_value_t.b_cycles_per_word };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_words_per_line:15",
              "Window B memory fetch words per scan line. This value is in memory fetch words: Multiples of 16 bytes for Tegra 2 Processor Series devices. It is computed as follows: B_WORDS_PER_LINE = (B_SIZE.B_H_SIZE * (bytes per pixel) + 15) >> 4 bytes per pixel is determined by the pixel format",
              15, old_value_t.b_words_per_line, new_value_t.b_words_per_line };
    m_bit_details_model.bits.append(entry);
    entry = { "31: b_fetch_info_enable:1",
              "Enables the sending of the Window B fetch information. For compatibility with earlier devices, this defaults to DISABLE.\n0 = DISABLE : This bit should be enabled only for 12-bpp \n1 = ENABLE",
              1, old_value_t.b_fetch_info_enable, new_value_t.b_fetch_info_enable };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B High Priority Avoidance Fetch Parameters\nThis register gives extra information to the Memory Controller Client Interface (MCCIF) about the number of memory words that will be fetched per scan line and about the rate at wich those words are consumed. This allows the MCCIF to more accurately arbitrate memory accesses to prevent the use of the High Priority signal. Use of this signal causes all other client accesses to be blocked in preference to the client asserting HP. Obviously, this is a state which is sometime necessary for Display since it is an isochronous client and MUST be serviced in a timely manner. However, use of this signal should be avoided if possible. These parameters help the MCCIF avoid the over-use of HP.";
}

#define WINBUF_B_START_ADDR_OFFSET 0x1800
#define WINBUF_B_START_ADDR_UNDEFMASK 0x00000000
union winbuf_b_start_addr_u {
    struct {
        unsigned int b_start_addr:32;       /* Window B Start Address This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies start address for the Y plane */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_b_start_addr_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_b_start_addr_u old_value_t = { .reg32 = value };
    const winbuf_b_start_addr_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_start_addr:32",
              "Window B Start Address This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies start address for the Y plane",
              32, old_value_t.b_start_addr, new_value_t.b_start_addr };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Start Address\nOverview\nSTART_ADDR, BUF_STRIDE, LINE_STRIDE, ADDR_H_OFFSET, ADDR_V_OFFSET combined, specify the starting address of a window buffer in the memory surface. Generally START_ADDR is programmed with the starting address of the memory surface. H/V_OFFSET specify the address offsets of the pixel at the beginning of the window, with respect to the starting address of the memory surface. (There is an exception to that when memory surface is not well aligned, see 3-ii below.)\nNote that \"beginning of the window\" here means the top-left corner of a window in normal mode, top-right corner in horizontal flipping, bottom-left corner in vertical flipping, and bottom-right in horizontal+vertical flipping.\nStarting Address Calculation\nThese formulae are same for both tiled or linear mode. However, for linear mode, the addresses calculated are real physical addresses, but for tile mode, these addresses will be translated to the real physical addresses by the memory controller client before used.\n    * When a window is host triggered, starting address of a window is calculated as follows by HW.\n- non-yuv-planar modes:\nstarting-address = START_ADDR + ADDR_V_OFFSET * LINE_STRIDE + ADDR_H_OFFSET\n- yuv-planar modes:\ny-starting-address = START_ADDR + ADDR_V_OFFSET * LINE_STRIDE + ADDR_H_OFFSET\nu-starting-address = START_ADDR_U + ADDR_V_OFFSET * UV_LINE_STRIDE / denom1 + ADDR_H_OFFSET / denom2\nv-starting-address = START_ADDR_V + ADDR_V_OFFSET * UV_LINE_STRIDE / denom1 + ADDR_H_OFFSET / denom2 where denom1/denom2 equal to 1 or 2 depending on the actual planar format, derived natively by HW.\n    * When a window is non-host triggered, starting address of a window buffer is calculated as below.\n- non-yuv-planar mode:\nstarting-address = START_ADDR + BUF_STRIDE * buf_index + ADDR_V_OFFSET * LINE_STRIDE + ADDR_H_OFFSET\n- yuv-planar mode:\ny-starting-address = START_ADDR + BUF_STRIDE * buf_index + ADDR_V_OFFSET * LINE_STRIDE + ADDR_H_OFFSET\nu-starting-address = START_ADDR_U + UV_BUF_STRIDE * buf_index + ADDR_V_OFFSET * UV_LINE_STRIDE / denom1 + ADDR_H_OFFSET / denom2\nv-starting-address = START_ADDR_V + UV_BUF_STRIDE * buf_index + ADDR_V_OFFSET * UV_LINE_STRIDE / denom1 + ADDR_H_OFFSET / denom2  where denom1/denom2 equal to 1 or 2 depending on the actual planar format, derived natively by HW.\nbuf_index is the index transmitted by the triggering module pointing to the first buffer of a frame.\nProgramming Restrictions\n    * For tiled address mode:\nImage surface can only aligned to multiples of 256, thus the following restrictions.\n- START_ADDR, START_ADDR_U, START_ADDR_V need to be multiples of 256.\n- BUF_STRIDE, UV_BUF_STRIDE need to be multiples of 256\n- LINE_STRIDE, UV_LINE_STRIDE need to be multiples of 16\n- ADDR_H_OFFSET needs to be multiple of 2 in yuv planar format (the last bit is ignored), but with no restrictions on other color formats.\n- ADDR_V_OFFSET has no restrictions\n    * For linear address mode:\nImage surface can be aligned 2, 4 or 8 bytes, depending on the color formats.\nAs an additional restriction for display, START_ADDR, START_ADDR_U and START_ADDR_V need to be multiples of 16.\nWhen a surface is not aligned to 16 bytes, program START_ADDR with the memory surface address with its least 4 significant bits zeroed out and add these 4 address bits to the original H_OFFSET. (So the formula in 2-i,ii still hold)\n- For all formats:\nSTART_ADDR, START_ADDR_U and START_ADDR_V need to be multiples of 16.\n- For 16-bpp formats,\n(START_ADDR+H_OFFSET) need to be multiple of 2. The least significant bit of H_OFFSTE is ignored.\n- For 32-bpp formats,\n(START_ADDR+H_OFFSTE) needs to be multiple of 4. The least two significant bits of H_OFFSTE are ignored.\n- For yuv planar formats:\nBUF_STRIDE, UV_BUF_STRIDE:\nBUF_STRIDE[2:1]=UV_BUF_STRIDE[1:0]\nor as a stricter constraint: BUF_STRIDE be multiple of 8, UV_BUF_STRIDE be multiple of 4.\nLINE_STRIDE, UV_LINE_STRIDE:\nLINE_STRIDE and UV_LINE_STRIDE need to be at least 16.\nLINE_STRIDE needs to be multiple of 8, UV_LINE_STRIDE needs to be multiple of 4.\nADDR_H_OFFSET:\nNeeds to be multiple of 2. If needs to point to odd pixel position, program ADDR_H_OFFSET to be the previous position (or the next position if H-flipped) and program H_INITIAL_DDA bit 12 to 1.\nADDR_V_OFFSET:\nNeeds to be multiple of 2. If needs to point to odd line number, program ADDR_V_OFFSTE to be the previous line number (or next line number if V-flipped) and program V_INITIAL_DDA bit 12 to 1.\n    * Memory allocation for non-host triggered case\nWhen a window buffer is not controlled by host (software) then a frame may be stored in multiple buffers. In this case, the buffers must be contiguous in the memory because display will use the same luma or chroma line strides for all lines in the frame.\nAlso buffer wraparound must not occur in the middle of the displayed part of the frame. The controlling module will send frame start and frame end indicators (flags) to display module to indicate the beginning and end of frame. Buffer start address is latched when frame start flag is active but the actual buffer start address is not switched until frame end flag is active. In the case where one buffer correspond to one frame then frame start and frame end flag are active everytime a buffer index is sent.";
}

#define WINBUF_B_START_ADDR_NS_OFFSET 0x1801
#define WINBUF_B_START_ADDR_NS_UNDEFMASK 0x00000000
union winbuf_b_start_addr_ns_u {
    struct {
        unsigned int b_start_addr_ns:32;    /* Window B Shadowed Start Address This is ARM set shadow of Start Address */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_b_start_addr_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_b_start_addr_ns_u old_value_t = { .reg32 = value };
    const winbuf_b_start_addr_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_start_addr_ns:32",
              "Window B Shadowed Start Address This is ARM set shadow of Start Address",
              32, old_value_t.b_start_addr_ns, new_value_t.b_start_addr_ns };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window B Shadowed Start Address";
}

#define WINBUF_B_START_ADDR_U_OFFSET 0x1802
#define WINBUF_B_START_ADDR_U_UNDEFMASK 0x00000000
union winbuf_b_start_addr_u_u {
    struct {
        unsigned int b_start_addr_u:32;     /* Window B Start Address for U plane This is a byte address */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_b_start_addr_u_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_b_start_addr_u_u old_value_t = { .reg32 = value };
    const winbuf_b_start_addr_u_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_start_addr_u:32",
              "Window B Start Address for U plane This is a byte address",
              32, old_value_t.b_start_addr_u, new_value_t.b_start_addr_u };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Start Address for U plane";
}

#define WINBUF_B_START_ADDR_U_NS_OFFSET 0x1803
#define WINBUF_B_START_ADDR_U_NS_UNDEFMASK 0x00000000
union winbuf_b_start_addr_u_ns_u {
    struct {
        unsigned int b_start_addr_u_ns:32;  /* Window B Shadowed Start Address for U plane This is ARM set shadow register of U start address */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_b_start_addr_u_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_b_start_addr_u_ns_u old_value_t = { .reg32 = value };
    const winbuf_b_start_addr_u_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_start_addr_u_ns:32",
              "Window B Shadowed Start Address for U plane This is ARM set shadow register of U start address",
              32, old_value_t.b_start_addr_u_ns, new_value_t.b_start_addr_u_ns };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window B Shadowed Start Address for U plane";
}

#define WINBUF_B_START_ADDR_V_OFFSET 0x1804
#define WINBUF_B_START_ADDR_V_UNDEFMASK 0x00000000
union winbuf_b_start_addr_v_u {
    struct {
        unsigned int b_start_addr_v:32;     /* Window B Start Address for V plane This is a byte address */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_b_start_addr_v_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_b_start_addr_v_u old_value_t = { .reg32 = value };
    const winbuf_b_start_addr_v_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_start_addr_v:32",
              "Window B Start Address for V plane This is a byte address",
              32, old_value_t.b_start_addr_v, new_value_t.b_start_addr_v };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Start Address for V plane";
}

#define WINBUF_B_START_ADDR_V_NS_OFFSET 0x1805
#define WINBUF_B_START_ADDR_V_NS_UNDEFMASK 0x00000000
union winbuf_b_start_addr_v_ns_u {
    struct {
        unsigned int b_start_addr_v_ns:32;  /* Window B Shadowed Start Address for V plane This is ARM set shadow register of U start address */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_b_start_addr_v_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_b_start_addr_v_ns_u old_value_t = { .reg32 = value };
    const winbuf_b_start_addr_v_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_start_addr_v_ns:32",
              "Window B Shadowed Start Address for V plane This is ARM set shadow register of U start address",
              32, old_value_t.b_start_addr_v_ns, new_value_t.b_start_addr_v_ns };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Shadowed Start Address for V plane";
}

#define WINBUF_B_ADDR_H_OFFSET_OFFSET 0x1806
#define WINBUF_B_ADDR_H_OFFSET_UNDEFMASK 0x00000000
union winbuf_b_addr_h_offset_u {
    struct {
        unsigned int b_addr_h_offset:32;    /* Window B Horizontal address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format.  For YUV planar pixel format, this specifies horizontal offset of Y plane. The horizontal offsets of U/V plane is derived by HW */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_b_addr_h_offset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_b_addr_h_offset_u old_value_t = { .reg32 = value };
    const winbuf_b_addr_h_offset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_addr_h_offset:32",
              "Window B Horizontal address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format.  For YUV planar pixel format, this specifies horizontal offset of Y plane. The horizontal offsets of U/V plane is derived by HW",
              32, old_value_t.b_addr_h_offset, new_value_t.b_addr_h_offset };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = " Window B Horizontal address offset";
}

#define WINBUF_B_ADDR_H_OFFSET_NS_OFFSET 0x1807
#define WINBUF_B_ADDR_H_OFFSET_NS_UNDEFMASK 0x00000000
union winbuf_b_addr_h_offset_ns_u {
    struct {
        unsigned int b_addr_h_offset_ns:32; /* Window B Shadowed Horizontal address offset This is ARM set shadow of ADDR_H_OFFSET */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_b_addr_h_offset_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_b_addr_h_offset_ns_u old_value_t = { .reg32 = value };
    const winbuf_b_addr_h_offset_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_addr_h_offset_ns:32",
              "Window B Shadowed Horizontal address offset This is ARM set shadow of ADDR_H_OFFSET",
              32, old_value_t.b_addr_h_offset_ns, new_value_t.b_addr_h_offset_ns };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Shadowed Horizontal address offset";
}

#define WINBUF_B_ADDR_V_OFFSET_OFFSET 0x1808
#define WINBUF_B_ADDR_V_OFFSET_UNDEFMASK 0x00000000
union winbuf_b_addr_v_offset_u {
    struct {
        unsigned int b_addr_v_offset:32;    /* Window B Vertical address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format.  For YUV planar pixel format, this specifies vertical offset of Y plane. Vertical offsets of U/V plane is derived by HW */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_b_addr_v_offset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_b_addr_v_offset_u old_value_t = { .reg32 = value };
    const winbuf_b_addr_v_offset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_addr_v_offset:32",
              "Window B Vertical address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format.  For YUV planar pixel format, this specifies vertical offset of Y plane. Vertical offsets of U/V plane is derived by HW",
              32, old_value_t.b_addr_v_offset, new_value_t.b_addr_v_offset };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Vertical address offset";
}

#define WINBUF_B_ADDR_V_OFFSET_NS_OFFSET 0x1809
#define WINBUF_B_ADDR_V_OFFSET_NS_UNDEFMASK 0x00000000
union winbuf_b_addr_v_offset_ns_u {
    struct {
        unsigned int b_addr_v_offset_ns:32; /* Window B Shadowed Vertical address offset This is ARM set shadow of ADDR_V_OFFSET */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_b_addr_v_offset_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_b_addr_v_offset_ns_u old_value_t = { .reg32 = value };
    const winbuf_b_addr_v_offset_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_addr_v_offset_ns:32",
              "Window B Shadowed Vertical address offset This is ARM set shadow of ADDR_V_OFFSET",
              32, old_value_t.b_addr_v_offset_ns, new_value_t.b_addr_v_offset_ns };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B Shadowed Vertical address offset";
}

#define WINBUF_B_UFLOW_STATUS_OFFSET 0x180A
#define WINBUF_B_UFLOW_STATUS_UNDEFMASK 0xBF000000
union winbuf_b_uflow_status_u {
    struct {
        unsigned int uflow_count:24;        /* Underflow count. This field indicates the number of contiguous groups of output pixels for which there was no data in the FIFO. For example, if the valid from the FIFO is low for 10 consecutive cycles and then goes high, the counter will increment by one. Reset to zero on write */
        unsigned int undefined_bits_24_29:6;
        unsigned int count_oflow:1;         /* Flag bit that indicates that the underflow event counter has overflowed. There were too many events. If COUNT_OFLOW is set, UFLOW_COUNT is meaningless. Cleared on write */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_b_uflow_status_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_b_uflow_status_u old_value_t = { .reg32 = value };
    const winbuf_b_uflow_status_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: uflow_count:24",
              "Underflow count. This field indicates the number of contiguous groups of output pixels for which there was no data in the FIFO. For example, if the valid from the FIFO is low for 10 consecutive cycles and then goes high, the counter will increment by one. Reset to zero on write",
              24, old_value_t.uflow_count, new_value_t.uflow_count };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_29:6", "", 6, old_value_t.undefined_bits_24_29, new_value_t.undefined_bits_24_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: count_oflow:1",
              "Flag bit that indicates that the underflow event counter has overflowed. There were too many events. If COUNT_OFLOW is set, UFLOW_COUNT is meaningless. Cleared on write",
              1, old_value_t.count_oflow, new_value_t.count_oflow };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window B FIFO Underflow Status Register";
}

#define WINC_C_COLOR_PALETTE_OFFSET 0x2500
#define WINC_C_COLOR_PALETTE_UNDEFMASK 0xFF000000
union winc_c_color_palette_u {
    struct {
        unsigned int c_color_palette_r:8;   /* Red Color Palette */
        unsigned int c_color_palette_g:8;   /* Green Color Palette */
        unsigned int c_color_palette_b:8;   /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_color_palette_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_color_palette_u old_value_t = { .reg32 = value };
    const winc_c_color_palette_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_color_palette_r:8",
              "Red Color Palette",
              8, old_value_t.c_color_palette_r, new_value_t.c_color_palette_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_color_palette_g:8",
              "Green Color Palette",
              8, old_value_t.c_color_palette_g, new_value_t.c_color_palette_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_color_palette_b:8",
              "Blue Color Palette",
              8, old_value_t.c_color_palette_b, new_value_t.c_color_palette_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Color Palette\nThis is used for palletized data format (color depth of 8-bpp or less) or for gamma correction for non-palletized data formats (color depth of more than 8-bpp). Each window has its own color palette which consists of three 256x8 register file which can be written by host and indexed (read) by the window.\nFor palletized data format less than 8-bpp the pixel data is aligned to least significant bits of the palette index (address) and the remaining upper bits are filled with the corresponding bits of the Palette Color Extension. For example, for 4-bpp mode, the pixel data occupies bits 3-0 of the palette index and bits 7-4 of the palette index are set to bits 7-4 of the Palette Color Extension. Host read is assumed to be not needed - software can cache the color palette in system memory. This is an array of 256 identical register entries; the register fields below apply to each entry.\nColor palette";
}

#define WINC_C_PALETTE_COLOR_EXT_OFFSET 0x2600
#define WINC_C_PALETTE_COLOR_EXT_UNDEFMASK 0xFFFFFF01
union winc_c_palette_color_ext_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int c_palette_color_ext:7; /* Window C Palette Color Extension bits 7-1 are used for 1-bpp mode bits 7-2 are used for 2-bpp mode bits 7-4 are used for 4-bpp mode */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_palette_color_ext_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_palette_color_ext_u old_value_t = { .reg32 = value };
    const winc_c_palette_color_ext_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bit_0:1", "", 1, old_value_t.undefined_bit_0, new_value_t.undefined_bit_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "01: c_palette_color_ext:7",
              "Window C Palette Color Extension bits 7-1 are used for 1-bpp mode bits 7-2 are used for 2-bpp mode bits 7-4 are used for 4-bpp mode",
              7, old_value_t.c_palette_color_ext, new_value_t.c_palette_color_ext };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Palette Color Extension\nPalette extension for 1-bpp, 2-bpp, and 4-bpp. These bits provide the upper most significant bits for indexing the color palette.  Supported for window A only.\nXXX should ifdef for window A, but currently window B spec is assumed to be a superset.";
}

#define WINC_C_H_FILTER_P00_OFFSET 0x2601
#define WINC_C_H_FILTER_P00_UNDEFMASK 0x00000000
union winc_c_h_filter_p00_u {
    struct {
        unsigned int c_h_filter_p00c0:3;    /* Phase 00 coefficient 0 (typically 0) */
        unsigned int c_h_filter_p00c1:5;    /* Phase 00 coefficient 1 (typically 0) */
        unsigned int c_h_filter_p00c2:8;    /* Phase 00 coefficient 2 (typically 128) */
        unsigned int c_h_filter_p00c3:8;    /* Phase 00 coefficient 3 (typically 0) */
        unsigned int c_h_filter_p00c4:5;    /* Phase 00 coefficient 4 (typically 0) */
        unsigned int c_h_filter_p00c5:3;    /* Phase 00 coefficient 5 (typically 0) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p00_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p00_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p00_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p00c0:3",
              "Phase 00 coefficient 0 (typically 0)",
              3, old_value_t.c_h_filter_p00c0, new_value_t.c_h_filter_p00c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p00c1:5",
              "Phase 00 coefficient 1 (typically 0)",
              5, old_value_t.c_h_filter_p00c1, new_value_t.c_h_filter_p00c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p00c2:8",
              "Phase 00 coefficient 2 (typically 128)",
              8, old_value_t.c_h_filter_p00c2, new_value_t.c_h_filter_p00c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p00c3:8",
              "Phase 00 coefficient 3 (typically 0)",
              8, old_value_t.c_h_filter_p00c3, new_value_t.c_h_filter_p00c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p00c4:5",
              "Phase 00 coefficient 4 (typically 0)",
              5, old_value_t.c_h_filter_p00c4, new_value_t.c_h_filter_p00c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p00c5:3",
              "Phase 00 coefficient 5 (typically 0)",
              3, old_value_t.c_h_filter_p00c5, new_value_t.c_h_filter_p00c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 00\nHorizontal scaling filter coefficients.\nHorizontal scaling filter is a 6-tap filter with 4-bit positional phase.\n    * Coefficients 0 and 5 are 3-bit signed value ranging from -4 to 3.\n    * Coefficients 1 and 4 are 5-bit signed value ranging from -16 to 15.\n    * Coefficients 2 and 3 are 8-bit unsigned value ranging from 0 to 128.\n    * Coefficient 0 is the multiplier for the earliest pixel (P0) in the group of 6-pixel and coefficient 5 is the multiplier for the latest pixel (P5) in the group. The output pixel positional phase is defined as centered in P2 if the positional phase is 0 or proportionally in between P2 and P3 if the positional phase is larger than 0.\nSum of all coefficients for each phase should be 128 typically and software should never program the the sum of all coefficients for a phase to be more than 128.\nFor each horizontal positional phase, the 6 filter coefficients require 32 reg bits. Note that color value ranges from 0 to 255 for Y, R, G, B and -128 to 127 for U and V.";
}

#define WINC_C_H_FILTER_P01_OFFSET 0x2602
#define WINC_C_H_FILTER_P01_UNDEFMASK 0x00000000
union winc_c_h_filter_p01_u {
    struct {
        unsigned int c_h_filter_p01c0:3;    /* Phase 01 coefficient 0 (typically 1) */
        unsigned int c_h_filter_p01c1:5;    /* Phase 01 coefficient 1 (typically -4) */
        unsigned int c_h_filter_p01c2:8;    /* Phase 01 coefficient 2 (typically 124) */
        unsigned int c_h_filter_p01c3:8;    /* Phase 01 coefficient 3 (typically 8) */
        unsigned int c_h_filter_p01c4:5;    /* Phase 01 coefficient 4 (typically -2) */
        unsigned int c_h_filter_p01c5:3;    /* Phase 01 coefficient 5 (typically 1) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p01_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p01_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p01_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p01c0:3",
              "Phase 01 coefficient 0 (typically 1)",
              3, old_value_t.c_h_filter_p01c0, new_value_t.c_h_filter_p01c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p01c1:5",
              "Phase 01 coefficient 1 (typically -4)",
              5, old_value_t.c_h_filter_p01c1, new_value_t.c_h_filter_p01c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p01c2:8",
              "Phase 01 coefficient 2 (typically 124)",
              8, old_value_t.c_h_filter_p01c2, new_value_t.c_h_filter_p01c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p01c3:8",
              "Phase 01 coefficient 3 (typically 8)",
              8, old_value_t.c_h_filter_p01c3, new_value_t.c_h_filter_p01c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p01c4:5",
              "Phase 01 coefficient 4 (typically -2)",
              5, old_value_t.c_h_filter_p01c4, new_value_t.c_h_filter_p01c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p01c5:3",
              "Phase 01 coefficient 5 (typically 1)",
              3, old_value_t.c_h_filter_p01c5, new_value_t.c_h_filter_p01c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 01";
}

#define WINC_C_H_FILTER_P02_OFFSET 0x2603
#define WINC_C_H_FILTER_P02_UNDEFMASK 0x00000000
union winc_c_h_filter_p02_u {
    struct {
        unsigned int c_h_filter_p02c0:3;    /* Phase 02 coefficient 0 (typically 1) */
        unsigned int c_h_filter_p02c1:5;    /* Phase 02 coefficient 1 (typically -8) */
        unsigned int c_h_filter_p02c2:8;    /* Phase 02 coefficient 2 (typically 122) */
        unsigned int c_h_filter_p02c3:8;    /* Phase 02 coefficient 3 (typically 17) */
        unsigned int c_h_filter_p02c4:5;    /* Phase 02 coefficient 4 (typically -5) */
        unsigned int c_h_filter_p02c5:3;    /* Phase 02 coefficient 5 (typically 1) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p02_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p02_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p02_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p02c0:3",
              "Phase 02 coefficient 0 (typically 1)",
              3, old_value_t.c_h_filter_p02c0, new_value_t.c_h_filter_p02c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p02c1:5",
              "Phase 02 coefficient 1 (typically -8)",
              5, old_value_t.c_h_filter_p02c1, new_value_t.c_h_filter_p02c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p02c2:8",
              "Phase 02 coefficient 2 (typically 122)",
              8, old_value_t.c_h_filter_p02c2, new_value_t.c_h_filter_p02c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p02c3:8",
              "Phase 02 coefficient 3 (typically 17)",
              8, old_value_t.c_h_filter_p02c3, new_value_t.c_h_filter_p02c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p02c4:5",
              "Phase 02 coefficient 4 (typically -5)",
              5, old_value_t.c_h_filter_p02c4, new_value_t.c_h_filter_p02c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p02c5:3",
              "Phase 02 coefficient 5 (typically 1)",
              3, old_value_t.c_h_filter_p02c5, new_value_t.c_h_filter_p02c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 02";
}

#define WINC_C_H_FILTER_P03_OFFSET 0x2604
#define WINC_C_H_FILTER_P03_UNDEFMASK 0x00000000
union winc_c_h_filter_p03_u {
    struct {
        unsigned int c_h_filter_p03c0:3;    /* Phase 03 coefficient 0 (typically 2) */
        unsigned int c_h_filter_p03c1:5;    /* Phase 03 coefficient 1 (typically -11) */
        unsigned int c_h_filter_p03c2:8;    /* Phase 03 coefficient 2 (typically 115) */
        unsigned int c_h_filter_p03c3:8;    /* Phase 03 coefficient 3 (typically 27) */
        unsigned int c_h_filter_p03c4:5;    /* Phase 03 coefficient 4 (typically -7) */
        unsigned int c_h_filter_p03c5:3;    /* Phase 03 coefficient 5 (typically 2) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p03_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p03_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p03_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p03c0:3",
              "Phase 03 coefficient 0 (typically 2)",
              3, old_value_t.c_h_filter_p03c0, new_value_t.c_h_filter_p03c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p03c1:5",
              "Phase 03 coefficient 1 (typically -11)",
              5, old_value_t.c_h_filter_p03c1, new_value_t.c_h_filter_p03c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p03c2:8",
              "Phase 03 coefficient 2 (typically 115)",
              8, old_value_t.c_h_filter_p03c2, new_value_t.c_h_filter_p03c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p03c3:8",
              "Phase 03 coefficient 3 (typically 27)",
              8, old_value_t.c_h_filter_p03c3, new_value_t.c_h_filter_p03c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p03c4:5",
              "Phase 03 coefficient 4 (typically -7)",
              5, old_value_t.c_h_filter_p03c4, new_value_t.c_h_filter_p03c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p03c5:3",
              "Phase 03 coefficient 5 (typically 2)",
              3, old_value_t.c_h_filter_p03c5, new_value_t.c_h_filter_p03c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 03";
}

#define WINC_C_H_FILTER_P04_OFFSET 0x2605
#define WINC_C_H_FILTER_P04_UNDEFMASK 0x00000000
union winc_c_h_filter_p04_u {
    struct {
        unsigned int c_h_filter_p04c0:3;    /* Phase 04 coefficient 0 (typically 2) */
        unsigned int c_h_filter_p04c1:5;    /* Phase 04 coefficient 1 (typically -13) */
        unsigned int c_h_filter_p04c2:8;    /* Phase 04 coefficient 2 (typically 109) */
        unsigned int c_h_filter_p04c3:8;    /* Phase 04 coefficient 3 (typically 37) */
        unsigned int c_h_filter_p04c4:5;    /* Phase 04 coefficient 4 (typically -9) */
        unsigned int c_h_filter_p04c5:3;    /* Phase 04 coefficient 5 (typically 2) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p04_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p04_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p04_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p04c0:3",
              "Phase 04 coefficient 0 (typically 2)",
              3, old_value_t.c_h_filter_p04c0, new_value_t.c_h_filter_p04c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p04c1:5",
              "Phase 04 coefficient 1 (typically -13)",
              5, old_value_t.c_h_filter_p04c1, new_value_t.c_h_filter_p04c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p04c2:8",
              "Phase 04 coefficient 2 (typically 109)",
              8, old_value_t.c_h_filter_p04c2, new_value_t.c_h_filter_p04c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p04c3:8",
              "Phase 04 coefficient 3 (typically 37)",
              8, old_value_t.c_h_filter_p04c3, new_value_t.c_h_filter_p04c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p04c4:5",
              "Phase 04 coefficient 4 (typically -9)",
              5, old_value_t.c_h_filter_p04c4, new_value_t.c_h_filter_p04c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p04c5:3",
              "Phase 04 coefficient 5 (typically 2)",
              3, old_value_t.c_h_filter_p04c5, new_value_t.c_h_filter_p04c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 04";
}

#define WINC_C_H_FILTER_P05_OFFSET 0x2606
#define WINC_C_H_FILTER_P05_UNDEFMASK 0x00000000
union winc_c_h_filter_p05_u {
    struct {
        unsigned int c_h_filter_p05c0:3;    /* Phase 05 coefficient 0 (typically 3) */
        unsigned int c_h_filter_p05c1:5;    /* Phase 05 coefficient 1 (typically -15) */
        unsigned int c_h_filter_p05c2:8;    /* Phase 05 coefficient 2 (typically 102) */
        unsigned int c_h_filter_p05c3:8;    /* Phase 05 coefficient 3 (typically 47) */
        unsigned int c_h_filter_p05c4:5;    /* Phase 05 coefficient 4 (typically -11) */
        unsigned int c_h_filter_p05c5:3;    /* Phase 05 coefficient 5 (typically 2) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p05_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p05_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p05_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p05c0:3",
              "Phase 05 coefficient 0 (typically 3)",
              3, old_value_t.c_h_filter_p05c0, new_value_t.c_h_filter_p05c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p05c1:5",
              "Phase 05 coefficient 1 (typically -15)",
              5, old_value_t.c_h_filter_p05c1, new_value_t.c_h_filter_p05c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p05c2:8",
              "Phase 05 coefficient 2 (typically 102)",
              8, old_value_t.c_h_filter_p05c2, new_value_t.c_h_filter_p05c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p05c3:8",
              "Phase 05 coefficient 3 (typically 47)",
              8, old_value_t.c_h_filter_p05c3, new_value_t.c_h_filter_p05c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p05c4:5",
              "Phase 05 coefficient 4 (typically -11)",
              5, old_value_t.c_h_filter_p05c4, new_value_t.c_h_filter_p05c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p05c5:3",
              "Phase 05 coefficient 5 (typically 2)",
              3, old_value_t.c_h_filter_p05c5, new_value_t.c_h_filter_p05c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 05";
}

#define WINC_C_H_FILTER_P06_OFFSET 0x2607
#define WINC_C_H_FILTER_P06_UNDEFMASK 0x00000000
union winc_c_h_filter_p06_u {
    struct {
        unsigned int c_h_filter_p06c0:3;    /* Phase 06 coefficient 0 (typically 3) */
        unsigned int c_h_filter_p06c1:5;    /* Phase 06 coefficient 1 (typically -15) */
        unsigned int c_h_filter_p06c2:8;    /* Phase 06 coefficient 2 (typically 94) */
        unsigned int c_h_filter_p06c3:8;    /* Phase 06 coefficient 3 (typically 56) */
        unsigned int c_h_filter_p06c4:5;    /* Phase 06 coefficient 4 (typically -13) */
        unsigned int c_h_filter_p06c5:3;    /* Phase 06 coefficient 5 (typically 3) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p06_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p06_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p06_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p06c0:3",
              "Phase 06 coefficient 0 (typically 3)",
              3, old_value_t.c_h_filter_p06c0, new_value_t.c_h_filter_p06c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p06c1:5",
              "Phase 06 coefficient 1 (typically -15)",
              5, old_value_t.c_h_filter_p06c1, new_value_t.c_h_filter_p06c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p06c2:8",
              "Phase 06 coefficient 2 (typically 94)",
              8, old_value_t.c_h_filter_p06c2, new_value_t.c_h_filter_p06c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p06c3:8",
              "Phase 06 coefficient 3 (typically 56)",
              8, old_value_t.c_h_filter_p06c3, new_value_t.c_h_filter_p06c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p06c4:5",
              "Phase 06 coefficient 4 (typically -13)",
              5, old_value_t.c_h_filter_p06c4, new_value_t.c_h_filter_p06c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p06c5:3",
              "Phase 06 coefficient 5 (typically 3)",
              3, old_value_t.c_h_filter_p06c5, new_value_t.c_h_filter_p06c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 06";
}

#define WINC_C_H_FILTER_P07_OFFSET 0x2608
#define WINC_C_H_FILTER_P07_UNDEFMASK 0x00000000
union winc_c_h_filter_p07_u {
    struct {
        unsigned int c_h_filter_p07c0:3;    /* Phase 07 coefficient 0 (typically 3) */
        unsigned int c_h_filter_p07c1:5;    /* Phase 07 coefficient 1 (typically -16) */
        unsigned int c_h_filter_p07c2:8;    /* Phase 07 coefficient 2 (typically 85) */
        unsigned int c_h_filter_p07c3:8;    /* Phase 07 coefficient 3 (typically 67) */
        unsigned int c_h_filter_p07c4:5;    /* Phase 07 coefficient 4 (typically -14) */
        unsigned int c_h_filter_p07c5:3;    /* Phase 07 coefficient 5 (typically 3) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p07_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p07_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p07_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p07c0:3",
              "Phase 07 coefficient 0 (typically 3)",
              3, old_value_t.c_h_filter_p07c0, new_value_t.c_h_filter_p07c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p07c1:5",
              "Phase 07 coefficient 1 (typically -16)",
              5, old_value_t.c_h_filter_p07c1, new_value_t.c_h_filter_p07c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p07c2:8",
              "Phase 07 coefficient 2 (typically 85)",
              8, old_value_t.c_h_filter_p07c2, new_value_t.c_h_filter_p07c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p07c3:8",
              "Phase 07 coefficient 3 (typically 67)",
              8, old_value_t.c_h_filter_p07c3, new_value_t.c_h_filter_p07c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p07c4:5",
              "Phase 07 coefficient 4 (typically -14)",
              5, old_value_t.c_h_filter_p07c4, new_value_t.c_h_filter_p07c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p07c5:3",
              "Phase 07 coefficient 5 (typically 3)",
              3, old_value_t.c_h_filter_p07c5, new_value_t.c_h_filter_p07c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 07";
}

#define WINC_C_H_FILTER_P08_OFFSET 0x2609
#define WINC_C_H_FILTER_P08_UNDEFMASK 0x00000000
union winc_c_h_filter_p08_u {
    struct {
        unsigned int c_h_filter_p08c0:3;    /* Phase 08 coefficient 0 (typically 3) */
        unsigned int c_h_filter_p08c1:5;    /* Phase 08 coefficient 1 (typically -15) */
        unsigned int c_h_filter_p08c2:8;    /* Phase 08 coefficient 2 (typically 76) */
        unsigned int c_h_filter_p08c3:8;    /* Phase 08 coefficient 3 (typically 76) */
        unsigned int c_h_filter_p08c4:5;    /* Phase 08 coefficient 4 (typically -15) */
        unsigned int c_h_filter_p08c5:3;    /* Phase 08 coefficient 5 (typically 3) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p08_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p08_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p08_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p08c0:3",
              "Phase 08 coefficient 0 (typically 3)",
              3, old_value_t.c_h_filter_p08c0, new_value_t.c_h_filter_p08c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p08c1:5",
              "Phase 08 coefficient 1 (typically -15)",
              5, old_value_t.c_h_filter_p08c1, new_value_t.c_h_filter_p08c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p08c2:8",
              "Phase 08 coefficient 2 (typically 76)",
              8, old_value_t.c_h_filter_p08c2, new_value_t.c_h_filter_p08c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p08c3:8",
              "Phase 08 coefficient 3 (typically 76)",
              8, old_value_t.c_h_filter_p08c3, new_value_t.c_h_filter_p08c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p08c4:5",
              "Phase 08 coefficient 4 (typically -15)",
              5, old_value_t.c_h_filter_p08c4, new_value_t.c_h_filter_p08c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p08c5:3",
              "Phase 08 coefficient 5 (typically 3)",
              3, old_value_t.c_h_filter_p08c5, new_value_t.c_h_filter_p08c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 08";
}

#define WINC_C_H_FILTER_P09_OFFSET 0x260A
#define WINC_C_H_FILTER_P09_UNDEFMASK 0x00000000
union winc_c_h_filter_p09_u {
    struct {
        unsigned int c_h_filter_p09c0:3;    /* Phase 09 coefficient 0 (typically 3) */
        unsigned int c_h_filter_p09c1:5;    /* Phase 09 coefficient 1 (typically -14) */
        unsigned int c_h_filter_p09c2:8;    /* Phase 09 coefficient 2 (typically 67) */
        unsigned int c_h_filter_p09c3:8;    /* Phase 09 coefficient 3 (typically 85) */
        unsigned int c_h_filter_p09c4:5;    /* Phase 09 coefficient 4 (typically -16) */
        unsigned int c_h_filter_p09c5:3;    /* Phase 09 coefficient 5 (typically 3) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p09_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p09_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p09_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p09c0:3",
              "Phase 09 coefficient 0 (typically 3)",
              3, old_value_t.c_h_filter_p09c0, new_value_t.c_h_filter_p09c0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p09c1:5",
              "Phase 09 coefficient 1 (typically -14)",
              5, old_value_t.c_h_filter_p09c1, new_value_t.c_h_filter_p09c1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p09c2:8",
              "Phase 09 coefficient 2 (typically 67)",
              8, old_value_t.c_h_filter_p09c2, new_value_t.c_h_filter_p09c2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p09c3:8",
              "Phase 09 coefficient 3 (typically 85)",
              8, old_value_t.c_h_filter_p09c3, new_value_t.c_h_filter_p09c3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p09c4:5",
              "Phase 09 coefficient 4 (typically -16)",
              5, old_value_t.c_h_filter_p09c4, new_value_t.c_h_filter_p09c4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p09c5:3",
              "Phase 09 coefficient 5 (typically 3)",
              3, old_value_t.c_h_filter_p09c5, new_value_t.c_h_filter_p09c5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 09";
}

#define WINC_C_H_FILTER_P0A_OFFSET 0x260B
#define WINC_C_H_FILTER_P0A_UNDEFMASK 0x00000000
union winc_c_h_filter_p0a_u {
    struct {
        unsigned int c_h_filter_p0ac0:3;    /* Phase 0A coefficient 0 (typically 3) */
        unsigned int c_h_filter_p0ac1:5;    /* Phase 0A coefficient 1 (typically -13) */
        unsigned int c_h_filter_p0ac2:8;    /* Phase 0A coefficient 2 (typically 56) */
        unsigned int c_h_filter_p0ac3:8;    /* Phase 0A coefficient 3 (typically 94) */
        unsigned int c_h_filter_p0ac4:5;    /* Phase 0A coefficient 4 (typically -15) */
        unsigned int c_h_filter_p0ac5:3;    /* Phase 0A coefficient 5 (typically 3) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p0a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p0a_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p0a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p0ac0:3",
              "Phase 0A coefficient 0 (typically 3)",
              3, old_value_t.c_h_filter_p0ac0, new_value_t.c_h_filter_p0ac0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p0ac1:5",
              "Phase 0A coefficient 1 (typically -13)",
              5, old_value_t.c_h_filter_p0ac1, new_value_t.c_h_filter_p0ac1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p0ac2:8",
              "Phase 0A coefficient 2 (typically 56)",
              8, old_value_t.c_h_filter_p0ac2, new_value_t.c_h_filter_p0ac2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p0ac3:8",
              "Phase 0A coefficient 3 (typically 94)",
              8, old_value_t.c_h_filter_p0ac3, new_value_t.c_h_filter_p0ac3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p0ac4:5",
              "Phase 0A coefficient 4 (typically -15)",
              5, old_value_t.c_h_filter_p0ac4, new_value_t.c_h_filter_p0ac4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p0ac5:3",
              "Phase 0A coefficient 5 (typically 3)",
              3, old_value_t.c_h_filter_p0ac5, new_value_t.c_h_filter_p0ac5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 0A";
}

#define WINC_C_H_FILTER_P0B_OFFSET 0x260C
#define WINC_C_H_FILTER_P0B_UNDEFMASK 0x00000000
union winc_c_h_filter_p0b_u {
    struct {
        unsigned int c_h_filter_p0bc0:3;    /* Phase 0B coefficient 0 (typically 2) */
        unsigned int c_h_filter_p0bc1:5;    /* Phase 0B coefficient 1 (typically -11) */
        unsigned int c_h_filter_p0bc2:8;    /* Phase 0B coefficient 2 (typically 47) */
        unsigned int c_h_filter_p0bc3:8;    /* Phase 0B coefficient 3 (typically 102) */
        unsigned int c_h_filter_p0bc4:5;    /* Phase 0B coefficient 4 (typically -15) */
        unsigned int c_h_filter_p0bc5:3;    /* Phase 0B coefficient 5 (typically 3) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p0b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p0b_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p0b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p0bc0:3",
              "Phase 0B coefficient 0 (typically 2)",
              3, old_value_t.c_h_filter_p0bc0, new_value_t.c_h_filter_p0bc0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p0bc1:5",
              "Phase 0B coefficient 1 (typically -11)",
              5, old_value_t.c_h_filter_p0bc1, new_value_t.c_h_filter_p0bc1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p0bc2:8",
              "Phase 0B coefficient 2 (typically 47)",
              8, old_value_t.c_h_filter_p0bc2, new_value_t.c_h_filter_p0bc2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p0bc3:8",
              "Phase 0B coefficient 3 (typically 102)",
              8, old_value_t.c_h_filter_p0bc3, new_value_t.c_h_filter_p0bc3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p0bc4:5",
              "Phase 0B coefficient 4 (typically -15)",
              5, old_value_t.c_h_filter_p0bc4, new_value_t.c_h_filter_p0bc4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p0bc5:3",
              "Phase 0B coefficient 5 (typically 3)",
              3, old_value_t.c_h_filter_p0bc5, new_value_t.c_h_filter_p0bc5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 0B";
}

#define WINC_C_H_FILTER_P0C_OFFSET 0x260D
#define WINC_C_H_FILTER_P0C_UNDEFMASK 0x00000000
union winc_c_h_filter_p0c_u {
    struct {
        unsigned int c_h_filter_p0cc0:3;    /* Phase 0C coefficient 0 (typically 2) */
        unsigned int c_h_filter_p0cc1:5;    /* Phase 0C coefficient 1 (typically -9) */
        unsigned int c_h_filter_p0cc2:8;    /* Phase 0C coefficient 2 (typically 37) */
        unsigned int c_h_filter_p0cc3:8;    /* Phase 0C coefficient 3 (typically 109) */
        unsigned int c_h_filter_p0cc4:5;    /* Phase 0C coefficient 4 (typically -13) */
        unsigned int c_h_filter_p0cc5:3;    /* Phase 0C coefficient 5 (typically 2) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p0c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p0c_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p0c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p0cc0:3",
              "Phase 0C coefficient 0 (typically 2)",
              3, old_value_t.c_h_filter_p0cc0, new_value_t.c_h_filter_p0cc0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p0cc1:5",
              "Phase 0C coefficient 1 (typically -9)",
              5, old_value_t.c_h_filter_p0cc1, new_value_t.c_h_filter_p0cc1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p0cc2:8",
              "Phase 0C coefficient 2 (typically 37)",
              8, old_value_t.c_h_filter_p0cc2, new_value_t.c_h_filter_p0cc2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p0cc3:8",
              "Phase 0C coefficient 3 (typically 109)",
              8, old_value_t.c_h_filter_p0cc3, new_value_t.c_h_filter_p0cc3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p0cc4:5",
              "Phase 0C coefficient 4 (typically -13)",
              5, old_value_t.c_h_filter_p0cc4, new_value_t.c_h_filter_p0cc4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p0cc5:3",
              "Phase 0C coefficient 5 (typically 2)",
              3, old_value_t.c_h_filter_p0cc5, new_value_t.c_h_filter_p0cc5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 0C";
}

#define WINC_C_H_FILTER_P0D_OFFSET 0x260E
#define WINC_C_H_FILTER_P0D_UNDEFMASK 0x00000000
union winc_c_h_filter_p0d_u {
    struct {
        unsigned int c_h_filter_p0dc0:3;    /* Phase 0D coefficient 0 (typically 2) */
        unsigned int c_h_filter_p0dc1:5;    /* Phase 0D coefficient 1 (typically -7) */
        unsigned int c_h_filter_p0dc2:8;    /* Phase 0D coefficient 2 (typically 27) */
        unsigned int c_h_filter_p0dc3:8;    /* Phase 0D coefficient 3 (typically 115) */
        unsigned int c_h_filter_p0dc4:5;    /* Phase 0D coefficient 4 (typically -11) */
        unsigned int c_h_filter_p0dc5:3;    /* Phase 0D coefficient 5 (typically 2) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p0d_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p0d_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p0d_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p0dc0:3",
              "Phase 0D coefficient 0 (typically 2)",
              3, old_value_t.c_h_filter_p0dc0, new_value_t.c_h_filter_p0dc0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p0dc1:5",
              "Phase 0D coefficient 1 (typically -7)",
              5, old_value_t.c_h_filter_p0dc1, new_value_t.c_h_filter_p0dc1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p0dc2:8",
              "Phase 0D coefficient 2 (typically 27)",
              8, old_value_t.c_h_filter_p0dc2, new_value_t.c_h_filter_p0dc2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p0dc3:8",
              "Phase 0D coefficient 3 (typically 115)",
              8, old_value_t.c_h_filter_p0dc3, new_value_t.c_h_filter_p0dc3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p0dc4:5",
              "Phase 0D coefficient 4 (typically -11)",
              5, old_value_t.c_h_filter_p0dc4, new_value_t.c_h_filter_p0dc4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p0dc5:3",
              "Phase 0D coefficient 5 (typically 2)",
              3, old_value_t.c_h_filter_p0dc5, new_value_t.c_h_filter_p0dc5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 0D";
}

#define WINC_C_H_FILTER_P0E_OFFSET 0x260F
#define WINC_C_H_FILTER_P0E_UNDEFMASK 0x00000000
union winc_c_h_filter_p0e_u {
    struct {
        unsigned int c_h_filter_p0ec0:3;    /* Phase 0E coefficient 0 (typically 1) */
        unsigned int c_h_filter_p0ec1:5;    /* Phase 0E coefficient 1 (typically -5) */
        unsigned int c_h_filter_p0ec2:8;    /* Phase 0E coefficient 2 (typically 17) */
        unsigned int c_h_filter_p0ec3:8;    /* Phase 0E coefficient 3 (typically 122) */
        unsigned int c_h_filter_p0ec4:5;    /* Phase 0E coefficient 4 (typically -8) */
        unsigned int c_h_filter_p0ec5:3;    /* Phase 0E coefficient 5 (typically 1) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p0e_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p0e_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p0e_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p0ec0:3",
              "Phase 0E coefficient 0 (typically 1)",
              3, old_value_t.c_h_filter_p0ec0, new_value_t.c_h_filter_p0ec0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p0ec1:5",
              "Phase 0E coefficient 1 (typically -5)",
              5, old_value_t.c_h_filter_p0ec1, new_value_t.c_h_filter_p0ec1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p0ec2:8",
              "Phase 0E coefficient 2 (typically 17)",
              8, old_value_t.c_h_filter_p0ec2, new_value_t.c_h_filter_p0ec2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p0ec3:8",
              "Phase 0E coefficient 3 (typically 122)",
              8, old_value_t.c_h_filter_p0ec3, new_value_t.c_h_filter_p0ec3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p0ec4:5",
              "Phase 0E coefficient 4 (typically -8)",
              5, old_value_t.c_h_filter_p0ec4, new_value_t.c_h_filter_p0ec4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p0ec5:3",
              "Phase 0E coefficient 5 (typically 1)",
              3, old_value_t.c_h_filter_p0ec5, new_value_t.c_h_filter_p0ec5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 0E";
}

#define WINC_C_H_FILTER_P0F_OFFSET 0x2610
#define WINC_C_H_FILTER_P0F_UNDEFMASK 0x00000000
union winc_c_h_filter_p0f_u {
    struct {
        unsigned int c_h_filter_p0fc0:3;    /* Phase 0F coefficient 0 (typically 1) */
        unsigned int c_h_filter_p0fc1:5;    /* Phase 0F coefficient 1 (typically -2) */
        unsigned int c_h_filter_p0fc2:8;    /* Phase 0F coefficient 2 (typically 8) */
        unsigned int c_h_filter_p0fc3:8;    /* Phase 0F coefficient 3 (typically 124) */
        unsigned int c_h_filter_p0fc4:5;    /* Phase 0F coefficient 4 (typically -4) */
        unsigned int c_h_filter_p0fc5:3;    /* Phase 0F coefficient 5 (typically 1) */
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_h_filter_p0f_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_h_filter_p0f_u old_value_t = { .reg32 = value };
    const winc_c_h_filter_p0f_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_filter_p0fc0:3",
              "Phase 0F coefficient 0 (typically 1)",
              3, old_value_t.c_h_filter_p0fc0, new_value_t.c_h_filter_p0fc0 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: c_h_filter_p0fc1:5",
              "Phase 0F coefficient 1 (typically -2)",
              5, old_value_t.c_h_filter_p0fc1, new_value_t.c_h_filter_p0fc1 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_p0fc2:8",
              "Phase 0F coefficient 2 (typically 8)",
              8, old_value_t.c_h_filter_p0fc2, new_value_t.c_h_filter_p0fc2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_h_filter_p0fc3:8",
              "Phase 0F coefficient 3 (typically 124)",
              8, old_value_t.c_h_filter_p0fc3, new_value_t.c_h_filter_p0fc3 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: c_h_filter_p0fc4:5",
              "Phase 0F coefficient 4 (typically -4)",
              5, old_value_t.c_h_filter_p0fc4, new_value_t.c_h_filter_p0fc4 };
    m_bit_details_model.bits.append(entry);
    entry = { "29: c_h_filter_p0fc5:3",
              "Phase 0F coefficient 5 (typically 1)",
              3, old_value_t.c_h_filter_p0fc5, new_value_t.c_h_filter_p0fc5 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal Filter phase 0F";
}

#define WINC_C_CSC_YOF_OFFSET 0x2611
#define WINC_C_CSC_YOF_UNDEFMASK 0xFFFFFF00
union winc_c_csc_yof_u {
    struct {
        unsigned int c_csc_yof:8;           /* Y Offset in s.7.0 format */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_csc_yof_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_csc_yof_u old_value_t = { .reg32 = value };
    const winc_c_csc_yof_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_csc_yof:8",
              "Y Offset in s.7.0 format",
              8, old_value_t.c_csc_yof, new_value_t.c_csc_yof };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C CSC Y Offset\nColor Space Conversion coefficients\nThe CSC can be used for YUV to RGB conversion with brightness and hue/saturation control. The CSC can only be enabled for window C controlled by CSC_ENABLE register bits.\nFor Y color, the Y offset is applied first and saturation (clipping) is performed immediately after the Y offset is applied.\n    *  R = sat(KYRGB * sat(Y + YOF) + KUR * U + KVR * V)\n    *  G = sat(KYRGB * sat(Y + YOF) + KUG * U + KVG * V)\n    *  B = sat(KYRGB * sat(Y + YOF) + KUB * U + KVB * V)\nSaturation and rounding is performed in the range of 0 to 255 for the above equations.\nTypical values are:\n    * YOF = -16.000, KYRGB = 1.1644\n    * KUR = 0.0000, KVR = 1.5960\n    * KUG = -0.3918, KVG = -0.8130\n    * KUB = 2.0172, KVB = 0.0000\nKUR and KVB are typically 0.0000 but they may be programmed non-zero for hue rotation.\nThe CSC can also take RGB input, in which case YOF, KVB, KUG, KUR should be programmed to 0 and KYRGB will be forced to 0 by the hardware for generating R and B. KYRGB will not be forced to 0 for generating G. KVR, KYRGB, and KUB can be programmed to 1.0 or used as gain control for R, G, B correspondingly. Note that color value ranges from 0 to 255 for Y, R, G, B and -128 to 127 for U and V.";
}

#define WINC_C_CSC_KYRGB_OFFSET 0x2612
#define WINC_C_CSC_KYRGB_UNDEFMASK 0xFFFFFC00
union winc_c_csc_kyrgb_u {
    struct {
        unsigned int c_csc_kyrgb:10;        /* Y Gain for R, G, B colors in 2.8 format */
        unsigned int undefined_bits_10_31:22;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_csc_kyrgb_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_csc_kyrgb_u old_value_t = { .reg32 = value };
    const winc_c_csc_kyrgb_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_csc_kyrgb:10",
              "Y Gain for R, G, B colors in 2.8 format",
              10, old_value_t.c_csc_kyrgb, new_value_t.c_csc_kyrgb };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_31:22", "", 22, old_value_t.undefined_bits_10_31, new_value_t.undefined_bits_10_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C CSC Y Coefficient (gain) for RGB";
}

#define WINC_C_CSC_KUR_OFFSET 0x2613
#define WINC_C_CSC_KUR_UNDEFMASK 0xFFFFF800
union winc_c_csc_kur_u {
    struct {
        unsigned int c_csc_kur:11;          /* U coefficients for R in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_csc_kur_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_csc_kur_u old_value_t = { .reg32 = value };
    const winc_c_csc_kur_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_csc_kur:11",
              "U coefficients for R in s.2.8 format",
              11, old_value_t.c_csc_kur, new_value_t.c_csc_kur };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_31:21", "", 21, old_value_t.undefined_bits_11_31, new_value_t.undefined_bits_11_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C CSC U coefficient for R";
}

#define WINC_C_CSC_KVR_OFFSET 0x2614
#define WINC_C_CSC_KVR_UNDEFMASK 0xFFFFF800
union winc_c_csc_kvr_u {
    struct {
        unsigned int c_csc_kvr:11;          /* V coefficients for R in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_csc_kvr_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_csc_kvr_u old_value_t = { .reg32 = value };
    const winc_c_csc_kvr_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_csc_kvr:11",
              "V coefficients for R in s.2.8 format",
              11, old_value_t.c_csc_kvr, new_value_t.c_csc_kvr };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_31:21", "", 21, old_value_t.undefined_bits_11_31, new_value_t.undefined_bits_11_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C CSC V coefficient for R";
}

#define WINC_C_CSC_KUG_OFFSET 0x2615
#define WINC_C_CSC_KUG_UNDEFMASK 0xFFFFFC00
union winc_c_csc_kug_u {
    struct {
        unsigned int c_csc_kug:10;          /* U coefficients for G in s.1.8 format */
        unsigned int undefined_bits_10_31:22;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_csc_kug_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_csc_kug_u old_value_t = { .reg32 = value };
    const winc_c_csc_kug_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_csc_kug:10",
              "U coefficients for G in s.1.8 format",
              10, old_value_t.c_csc_kug, new_value_t.c_csc_kug };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_31:22", "", 22, old_value_t.undefined_bits_10_31, new_value_t.undefined_bits_10_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C CSC U coefficient for G";
}

#define WINC_C_CSC_KVG_OFFSET 0x2616
#define WINC_C_CSC_KVG_UNDEFMASK 0xFFFFFC00
union winc_c_csc_kvg_u {
    struct {
        unsigned int c_csc_kvg:10;          /* V coefficients for G in s.1.8 format */
        unsigned int undefined_bits_10_31:22;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_csc_kvg_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_csc_kvg_u old_value_t = { .reg32 = value };
    const winc_c_csc_kvg_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_csc_kvg:10",
              "V coefficients for G in s.1.8 format",
              10, old_value_t.c_csc_kvg, new_value_t.c_csc_kvg };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_31:22", "", 22, old_value_t.undefined_bits_10_31, new_value_t.undefined_bits_10_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C CSC V coefficient for G";
}

#define WINC_C_CSC_KUB_OFFSET 0x2617
#define WINC_C_CSC_KUB_UNDEFMASK 0xFFFFF800
union winc_c_csc_kub_u {
    struct {
        unsigned int c_csc_kub:11;          /* U coefficients for B in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_csc_kub_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_csc_kub_u old_value_t = { .reg32 = value };
    const winc_c_csc_kub_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_csc_kub:11",
              "U coefficients for B in s.2.8 format",
              11, old_value_t.c_csc_kub, new_value_t.c_csc_kub };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_31:21", "", 21, old_value_t.undefined_bits_11_31, new_value_t.undefined_bits_11_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C CSC U coefficient for B";
}

#define WINC_C_CSC_KVB_OFFSET 0x2618
#define WINC_C_CSC_KVB_UNDEFMASK 0xFFFFF800
union winc_c_csc_kvb_u {
    struct {
        unsigned int c_csc_kvb:11;          /* V coefficients for B in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_c_csc_kvb_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_c_csc_kvb_u old_value_t = { .reg32 = value };
    const winc_c_csc_kvb_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_csc_kvb:11",
              "V coefficients for B in s.2.8 format",
              11, old_value_t.c_csc_kvb, new_value_t.c_csc_kvb };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_31:21", "", 21, old_value_t.undefined_bits_11_31, new_value_t.undefined_bits_11_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C CSC V coefficient for B";
}

#define WIN_C_WIN_OPTIONS_OFFSET 0x2700
#define WIN_C_WIN_OPTIONS_UNDEFMASK 0xBFAAFEBA
union win_c_win_options_u {
    struct {
        unsigned int c_h_direction:1;       /* Window C Horizontal (X) drawing Direction  0 = INCREMENT 1 = DECREMENT */
        unsigned int undefined_bit_1:1;
        unsigned int c_v_direction:1;       /* Window C Vertical (Y) drawing Direction  0 = INCREMENT; 1 = DECREMENT */
        unsigned int undefined_bits_3_5:3;
        unsigned int c_color_expand:1;      /* Window C 12/15/16/18-to-24 bpp color expansion This bit should be enabled only for 12-bpp B4G4R4A4, 15-bpp B5G5R5A, 16-bpp B5G6R5, 18-bpp B6G6R6 color modes. If enabled the color conversion is performed prior to horizontal scaling.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_7:1;
        unsigned int c_h_filter_enable:1;   /* Window C H Filter Enable This controls H scaling filter and is effective only for non-palletized color modes.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_9_15:7;
        unsigned int c_cp_enable:1;         /* Window C Color Palette Enable This controls the color palette and should be enabled for palletized color modes. For non-palletized color modes, the color palette can be enabled for gamma correction.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int c_csc_enable:1;        /* Window C Color Space Conversion Enable This controls the color space conversion and should be enabled for YCbCr/YUV color modes for conversion to B8G8R8 and for hue and saturation control. This can also be used for gain control for RGB color modes.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_19:1;
        unsigned int c_dv_enable:1;         /* Window C Digital Vibrance Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_21:1;
        unsigned int c_yuv_range_expand:1;  /* Window C Enable range expansion in the cases where RANGEREDFRM is 1 from mpd. Formula: Y = clip(( Y-128)*2 + 128); Cb = clip((Cb-128)*2 + 128); Cr = clip((Cr-128)*2 + 128); where clip() function clips between 0 and 255. 0= disable 1= enable 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_23_29:7;
        unsigned int c_win_enable:1;        /* Window C Window enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_win_options_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_win_options_u old_value_t = { .reg32 = value };
    const win_c_win_options_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_direction:1",
              "Window C Horizontal (X) drawing Direction \n0 = INCREMENT\n1 = DECREMENT",
              1, old_value_t.c_h_direction, new_value_t.c_h_direction };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bit_1:1", "", 1, old_value_t.undefined_bit_1, new_value_t.undefined_bit_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "02: c_v_direction:1",
              "Window C Vertical (Y) drawing Direction \n0 = INCREMENT;\n1 = DECREMENT",
              1, old_value_t.c_v_direction, new_value_t.c_v_direction };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_5:3", "", 3, old_value_t.undefined_bits_3_5, new_value_t.undefined_bits_3_5 };
    m_bit_details_model.bits.append(entry);
    entry = { "06: c_color_expand:1",
              "Window C 12/15/16/18-to-24 bpp color expansion This bit should be enabled only for 12-bpp B4G4R4A4, 15-bpp B5G5R5A, 16-bpp B5G6R5, 18-bpp B6G6R6 color modes. If enabled the color conversion is performed prior to horizontal scaling.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.c_color_expand, new_value_t.c_color_expand };
    m_bit_details_model.bits.append(entry);
    entry = { "07: undefined_bit_7:1", "", 1, old_value_t.undefined_bit_7, new_value_t.undefined_bit_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_h_filter_enable:1",
              "Window C H Filter Enable This controls H scaling filter and is effective only for non-palletized color modes.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.c_h_filter_enable, new_value_t.c_h_filter_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_cp_enable:1",
              "Window C Color Palette Enable This controls the color palette and should be enabled for palletized color modes. For non-palletized color modes, the color palette can be enabled for gamma correction.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.c_cp_enable, new_value_t.c_cp_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bit_17:1", "", 1, old_value_t.undefined_bit_17, new_value_t.undefined_bit_17 };
    m_bit_details_model.bits.append(entry);
    entry = { "18: c_csc_enable:1",
              "Window C Color Space Conversion Enable This controls the color space conversion and should be enabled for YCbCr/YUV color modes for conversion to B8G8R8 and for hue and saturation control. This can also be used for gain control for RGB color modes.\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.c_csc_enable, new_value_t.c_csc_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bit_19:1", "", 1, old_value_t.undefined_bit_19, new_value_t.undefined_bit_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: c_dv_enable:1",
              "Window C Digital Vibrance Enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.c_dv_enable, new_value_t.c_dv_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bit_21:1", "", 1, old_value_t.undefined_bit_21, new_value_t.undefined_bit_21 };
    m_bit_details_model.bits.append(entry);
    entry = { "22: c_yuv_range_expand:1",
              "Window C Enable range expansion in the cases where RANGEREDFRM is 1 from mpd. Formula: Y = clip(( Y-128)*2 + 128); Cb = clip((Cb-128)*2 + 128); Cr = clip((Cr-128)*2 + 128); where clip() function clips between 0 and 255.\n0= disable\n1= enable\n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.c_yuv_range_expand, new_value_t.c_yuv_range_expand };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bits_23_29:7", "", 7, old_value_t.undefined_bits_23_29, new_value_t.undefined_bits_23_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: c_win_enable:1",
              "Window C Window enable \n0 = DISABLE\n1 = ENABLE",
              1, old_value_t.c_win_enable, new_value_t.c_win_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Options\nClass: Display Window Settings\nDisplay Window C parameters";
}

#define WIN_C_BYTE_SWAP_OFFSET 0x2701
#define WIN_C_BYTE_SWAP_UNDEFMASK 0xFFFFFFFC
union win_c_byte_swap_u {
    struct {
        unsigned int c_byte_swap:2;         /* Window C Byte Swap This controls byte swap of frame data read from memory prior to any data processing in the display module. 00= no byte swap (3 2 1 0) 01= byte swap for each 2-byte word (2 3 0 1) 10= byte swap for each 4-byte word (0 1 2 3) 11= word swap for each 4-byte word (1 0 3 2) 0 = NOSWAP 1 = SWAP2 2 = SWAP4 3 = SWAP4HW */
        unsigned int undefined_bits_2_31:30;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_byte_swap_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_byte_swap_u old_value_t = { .reg32 = value };
    const win_c_byte_swap_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_byte_swap:2",
              "Window C Byte Swap This controls byte swap of frame data read from memory prior to any data processing in the display module.\n00= no byte swap (3 2 1 0)\n01= byte swap for each 2-byte word (2 3 0 1)\n10= byte swap for each 4-byte word (0 1 2 3)\n11= word swap for each 4-byte word (1 0 3 2)\n0 = NOSWAP\n1 = SWAP2\n2 = SWAP4\n3 = SWAP4HW",
              2, old_value_t.c_byte_swap, new_value_t.c_byte_swap };
    m_bit_details_model.bits.append(entry);
    entry = { "02: undefined_bits_2_31:30", "", 30, old_value_t.undefined_bits_2_31, new_value_t.undefined_bits_2_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Byte Swap";
}

#define WIN_C_BUFFER_CONTROL_OFFSET 0x2702
#define WIN_C_BUFFER_CONTROL_UNDEFMASK 0xFFFFFFF8
union win_c_buffer_control_u {
    struct {
        unsigned int c_buffer_control:3;    /* Window C Buffer Control 0= Host (software) controlled 1= Video Input controlled 2= Encoder Pre-Processor controlled 3= MPEG Encoder controlled 4= StretchBLT or 2D other= reserved If window buffer selection is not controlled by host (software) then buffer start indexes are sent by the respective module specified by this parameter, and in this case, the buffer start address registers are used to specify frame stride and buffer offset for the calculated start address. 0 = HOST 1 = VI 2 = EPP 4 = SB2D 3 = MPEGE */
        unsigned int undefined_bits_3_31:29;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_buffer_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_buffer_control_u old_value_t = { .reg32 = value };
    const win_c_buffer_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_buffer_control:3",
              "Window C Buffer Control\n0= Host (software) controlled\n1= Video Input controlled\n2= Encoder Pre-Processor controlled\n3= MPEG Encoder controlled\n4= StretchBLT or 2D other= reserved If window buffer selection is not controlled by host (software) then buffer start indexes are sent by the respective module specified by this parameter, and in this case, the buffer start address registers are used to specify frame stride and buffer offset for the calculated start address.\n0 = HOST\n1 = VI\n2 = EPP\n4 = SB2D\n3 = MPEGE",
              3, old_value_t.c_buffer_control, new_value_t.c_buffer_control };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_31:29", "", 29, old_value_t.undefined_bits_3_31, new_value_t.undefined_bits_3_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Buffer Control";
}

#define WIN_C_COLOR_DEPTH_OFFSET 0x2703
#define WIN_C_COLOR_DEPTH_UNDEFMASK 0xFFFFFFE0
union win_c_color_depth_u {
    struct {
        unsigned int c_color_depth:5;       /* Window C Color Depth Supported color depths are: P8 = 8-bpp (palletized) B4G4R4A4 = 12-bpp B4G4R4 B5G5R5A = 15-bpp B5G5R5 AB5G5R5 = 15-bpp B5G5R5 B5G6R5 = 16-bpp B5G6R5 B8G8R8A8 = 32-bpp B8G8R8A8 R8G8B8A8 = 32-bpp R8G8B8A8 B6x2G6x2R6x2A8 = 32-bpp B6G6R6A8 R6x2G6x2B6x2A8 = 32-bpp R6G6B6A8 YCbCr422 = 16-bpp YCbCr422 packed YUV422 = 16-bpp YUV422 YCbCr420P = 16-bpp YCbCr420 planar YUV420P = 16-bpp YUV420 planar YCbCr422P = 16-bpp YCbCr422 planar YUV422P = 16-bpp YUV422 planar YCbCr422R = 16-bpp YCbCr422 rotated planar YUV422R = 16-bpp YUV422 rotated planar YCbCr422RA= 16-bpp YCbCr422 rotated planar with chroma averaging YUV422RA = 16-bpp YUV422 rotated planar with chroma averaging 0 = P1 1 = P2 2 = P4 3 = P8 4 = B4G4R4A4 5 = B5G5R5A 6 = B5G6R5 7 = AB5G5R5 12 = B8G8R8A8 13 = R8G8B8A8 14 = B6x2G6x2R6x2A8 15 = R6x2G6x2B6x2A8 16 = YCbCr422 17 = YUV422 18 = YCbCr420P 19 = YUV420P 20 = YCbCr422P 21 = YUV422P 22 = YCbCr422R 23 = YUV422R 24 = YCbCr422RA 25 = YUV422RA */
        unsigned int undefined_bits_5_31:27;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_color_depth_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_color_depth_u old_value_t = { .reg32 = value };
    const win_c_color_depth_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_color_depth:5",
              "Window C Color Depth Supported color depths are: P8 = 8-bpp (palletized) B4G4R4A4 = 12-bpp B4G4R4 B5G5R5A = 15-bpp B5G5R5 AB5G5R5 = 15-bpp B5G5R5 B5G6R5 = 16-bpp B5G6R5 B8G8R8A8 = 32-bpp B8G8R8A8 R8G8B8A8 = 32-bpp R8G8B8A8 B6x2G6x2R6x2A8 = 32-bpp B6G6R6A8 R6x2G6x2B6x2A8 = 32-bpp R6G6B6A8 YCbCr422 = 16-bpp YCbCr422 packed YUV422 = 16-bpp YUV422 YCbCr420P = 16-bpp YCbCr420 planar YUV420P = 16-bpp YUV420 planar YCbCr422P = 16-bpp YCbCr422 planar YUV422P = 16-bpp YUV422 planar YCbCr422R = 16-bpp YCbCr422 rotated planar YUV422R = 16-bpp YUV422 rotated planar YCbCr422RA= 16-bpp YCbCr422 rotated planar with chroma averaging YUV422RA = 16-bpp YUV422 rotated planar with chroma averaging\n0 = P1\n1 = P2\n2 = P4\n3 = P8\n4 = B4G4R4A4\n5 = B5G5R5A\n6 = B5G6R5\n7 = AB5G5R5\n12 = B8G8R8A8\n13 = R8G8B8A8\n14 = B6x2G6x2R6x2A8\n15 = R6x2G6x2B6x2A8\n16 = YCbCr422\n17 = YUV422\n18 = YCbCr420P\n19 = YUV420P\n20 = YCbCr422P\n21 = YUV422P\n22 = YCbCr422R\n23 = YUV422R\n24 = YCbCr422RA\n25 = YUV422RA",
              5, old_value_t.c_color_depth, new_value_t.c_color_depth };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_31:27", "", 27, old_value_t.undefined_bits_5_31, new_value_t.undefined_bits_5_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Color Depth For YCbCr data format, Cb and Cr are 8-bit unsigned values. For YUV data format, U and V are 8-bit signed values. YCbCr422R is similar to YCbCr422P but the Cb and Cr are shared vertically.\nYUV422R is similar to YUV422P but the U and V are shared vertically. YCbCr422RA is same as YCbCr422R in memory and YUV422RA is same as YUV422R in memory but while reading from memory, for YCbCr422RA and YUV422RA, chroma averaging is applied for each pixel pair so that they can be processed as YUV422 by the display pipeline.\nFor YCbCr422R and YUV422R, every other chroma pixels are not used (discarded) by the display pipeline. B6x2G6x2R6x2A8 is similar to B8G8R6A8 but with the 2 lsb zeroed out. R6x2G6x2B6x2A8 is similar to R8G8B6A8 but with the 2 lsb zeroed out.";
}

#define WIN_C_POSITION_OFFSET 0x2704
#define WIN_C_POSITION_UNDEFMASK 0xE000E000
union win_c_position_u {
    struct {
        unsigned int c_h_position:13;       /* Window C H Position This is specified with respect to the left edge of active display area */
        unsigned int undefined_bits_13_15:3;
        unsigned int c_v_position:13;       /* Window C V Position This is specified with respect to the top edge of active display area */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_position_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_position_u old_value_t = { .reg32 = value };
    const win_c_position_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_position:13",
              "Window C H Position This is specified with respect to the left edge of active display area",
              13, old_value_t.c_h_position, new_value_t.c_h_position };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_v_position:13",
              "Window C V Position This is specified with respect to the top edge of active display area",
              13, old_value_t.c_v_position, new_value_t.c_v_position };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Position\nThis register defines H position and size of Window C after scaling (if there is any)";
}

#define WIN_C_SIZE_OFFSET 0x2705
#define WIN_C_SIZE_UNDEFMASK 0xE000E000
union win_c_size_u {
    struct {
        unsigned int c_h_size:13;           /* Window C H Size (pixels) This is the horizontal size after scaling */
        unsigned int undefined_bits_13_15:3;
        unsigned int c_v_size:13;           /* Window C V Size (lines) This is the vertical size after scaling */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_size_u old_value_t = { .reg32 = value };
    const win_c_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_size:13",
              "Window C H Size (pixels) This is the horizontal size after scaling",
              13, old_value_t.c_h_size, new_value_t.c_h_size };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_v_size:13",
              "Window C V Size (lines) This is the vertical size after scaling",
              13, old_value_t.c_v_size, new_value_t.c_v_size };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Size\nThis register defines V position and size of Window C after scaling (if there is any)\nNote:\n Programming on window size should guarantee the whole window is inside the active area, otherwise extra rows/columns will be fetched and discarded which affects performance.\nProgramming on window size should guarantee the whole window is inside the active area, otherwise extra rows/columns will be fetched and discarded which affects performance.";
}

#define WIN_C_PRESCALED_SIZE_OFFSET 0x2706
#define WIN_C_PRESCALED_SIZE_UNDEFMASK 0xE0008000
union win_c_prescaled_size_u {
    struct {
        unsigned int c_h_prescaled_size:15; /* Window C H Pre-scaled Size (bytes) In 420P and 422P formats, it must be even */
        unsigned int undefined_bit_15:1;
        unsigned int c_v_prescaled_size:13; /* Window C V Pre-scaled Size (lines) In 420P/422R/422RA formats, it must be even */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_prescaled_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_prescaled_size_u old_value_t = { .reg32 = value };
    const win_c_prescaled_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_prescaled_size:15",
              "Window C H Pre-scaled Size (bytes) In 420P and 422P formats, it must be even",
              15, old_value_t.c_h_prescaled_size, new_value_t.c_h_prescaled_size };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_v_prescaled_size:13",
              "Window C V Pre-scaled Size (lines) In 420P/422R/422RA formats, it must be even",
              13, old_value_t.c_v_prescaled_size, new_value_t.c_v_prescaled_size };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Pre-scaled Size\nThis register defines Window C pre-scaled size.\nThe H pre-scaled size is needed to determine how many bytes to fetch from memory per line and this parameter must be programmed exactly as needed taking into account the scaling factor. For planar YUV or YCbCr data formats, this parameter refer to the H pre-scaled of the Y plane.\nThe total number of lines to be fetched from memory is determined by post-scale V size but V pre-scaled size is needed to 'clamp' the last valid line if the vertical DDA is exactly or slightly beyond the specified V pre-scaled size.\nDesign Note: H pre-scaled size ideally should be in terms of pixel but then hardware needs to convert this precisely to bytes to determine the amount of data to request from memory.\nThis could be a risky calculation - maybe this should be made optional on whether we use internal hardware to calculate or left it to software to calculate.";
}

#define WIN_C_H_INITIAL_DDA_OFFSET 0x2707
#define WIN_C_H_INITIAL_DDA_UNDEFMASK 0xFFFF0000
union win_c_h_initial_dda_u {
    struct {
        unsigned int c_h_initial_dda:16;    /* Window C H Initial DDA (4.12) This is typically programmed to 0.0 */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_h_initial_dda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_h_initial_dda_u old_value_t = { .reg32 = value };
    const win_c_h_initial_dda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_initial_dda:16",
              "Window C H Initial DDA (4.12) This is typically programmed to 0.0",
              16, old_value_t.c_h_initial_dda, new_value_t.c_h_initial_dda };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C H Initial DDA\nDesign Note: the first pixel of pre-scaled image is always used to output the first pixel so essentially this is the same as forcing the H Initial DDA integer portion to 1 initially even though user typically programs this to 0. If it makes the implementation easier, it is possible to force software to program the Initial DDA integer portion to 1. Similarly with the V Initial DDA.";
}

#define WIN_C_V_INITIAL_DDA_OFFSET 0x2708
#define WIN_C_V_INITIAL_DDA_UNDEFMASK 0xFFFF0000
union win_c_v_initial_dda_u {
    struct {
        unsigned int c_v_initial_dda:16;    /* Window C V Initial DDA (4.12) This is typically programmed to 0.0 for both non-interlaced and interlaced sources */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_v_initial_dda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_v_initial_dda_u old_value_t = { .reg32 = value };
    const win_c_v_initial_dda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_v_initial_dda:16",
              "Window C V Initial DDA (4.12) This is typically programmed to 0.0 for both non-interlaced and interlaced sources",
              16, old_value_t.c_v_initial_dda, new_value_t.c_v_initial_dda };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C V Initial DDA";
}

#define WIN_C_DDA_INCREMENT_OFFSET 0x2709
#define WIN_C_DDA_INCREMENT_UNDEFMASK 0x00000000
union win_c_dda_increment_u {
    struct {
        unsigned int c_h_dda_increment:16;  /* Window C Horizontal DDA Increment (4.12) This should be set to 1.0 if there is no scaling. The maximum value for downscaling depends on the number of bytes per pixel. For 4-byte/pixel modes (32-bpp) the maximum value is 4.0 and for all other modes the maximum value is 8.0 */
        unsigned int c_v_dda_increment:16;  /* Window C Vertical DDA Increment (4.12) This should be set to 1.0 if there is no scaling. Maximum value is 15.0 regardless of the number of bytes per pixel */
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_dda_increment_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_dda_increment_u old_value_t = { .reg32 = value };
    const win_c_dda_increment_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_h_dda_increment:16",
              "Window C Horizontal DDA Increment (4.12) This should be set to 1.0 if there is no scaling. The maximum value for downscaling depends on the number of bytes per pixel. For 4-byte/pixel modes (32-bpp) the maximum value is 4.0 and for all other modes the maximum value is 8.0",
              16, old_value_t.c_h_dda_increment, new_value_t.c_h_dda_increment };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_v_dda_increment:16",
              "Window C Vertical DDA Increment (4.12) This should be set to 1.0 if there is no scaling. Maximum value is 15.0 regardless of the number of bytes per pixel",
              16, old_value_t.c_v_dda_increment, new_value_t.c_v_dda_increment };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C DDA Increment\nDDA increment is typically calculated by dividing (Pre-scaled size in pixels - 1) by (Post-scaled size in pixels - 1). The result should be rounded up and expressed as 4.12 format (4-bit integer and 12-bit fraction). For non-filtered image this value can be slightly larger so that it is not missing the last row/column. Reference programming values (H and V should be calculated separately depending on filter on/off and sizes):\n- Filter on: min(round((prescaled_size_in_pixels - 1) * 0x1000 /(post_scaled_size_in_pixels - 1)), MAX)\n- Filter off: min(round(prescaled_size_in_pixels * 0x1000 / post_scaled_size_in_pixels - 1) - 0.5), MAX)\nWhere the value of MAX is as follows:\nFor V_DDA_INCREMENT: 15.0 (0xF000)\nFor H_DDA_INCREMETN: 4.0 (0x4000) for 2 Bytes/pix formats.\n8.0 (0x8000) for 4 Bytes/pix formats.\nThey are theoretically the biggest values that guarantees not displaying beyond an image boundary. If the DDA increment is less than 1.0 then image will be up-scaled and if DDA increment is more than 1.0 then image will be down-scaled.";
}

#define WIN_C_LINE_STRIDE_OFFSET 0x270A
#define WIN_C_LINE_STRIDE_UNDEFMASK 0x00000000
union win_c_line_stride_u {
    struct {
        unsigned int c_line_stride:16;      /* Window C Line Stride This is stride (in bytes) for all non-planar data formats. If the memory surface is tiled, the stride needs to be a multiple of 16. If H_DIRECTION of window C is set to DECREMENT, the stride also needs to be a multiple of 16. For planar YUV or YCbCr data formats, this is stride (in bytes) for the luma plane with the restriction that it must be multiples of 8 (16 if tiled or in horizontal flipping) For tiled surface this value may affect starting address of a window. Refer to the comment of START_ADDR for detail */
        unsigned int c_uv_line_stride:16;   /* Window C Line Stride for Chroma This is stride (in bytes) for planar YUV or YCbCr data formats for the chroma plane, with the restriction that it must be programmed to be multiples of 4 (16 if tiled or in horizontal flipping) This is not used (ignored) for other non-planar data formats */
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_line_stride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_line_stride_u old_value_t = { .reg32 = value };
    const win_c_line_stride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_line_stride:16",
              "Window C Line Stride This is stride (in bytes) for all non-planar data formats. If the memory surface is tiled, the stride needs to be a multiple of 16. If H_DIRECTION of window C is set to DECREMENT, the stride also needs to be a multiple of 16. For planar YUV or YCbCr data formats, this is stride (in bytes) for the luma plane with the restriction that it must be multiples of 8 (16 if tiled or in horizontal flipping) For tiled surface this value may affect starting address of a window. Refer to the comment of START_ADDR for detail",
              16, old_value_t.c_line_stride, new_value_t.c_line_stride };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_uv_line_stride:16",
              "Window C Line Stride for Chroma This is stride (in bytes) for planar YUV or YCbCr data formats for the chroma plane, with the restriction that it must be programmed to be multiples of 4 (16 if tiled or in horizontal flipping) This is not used (ignored) for other non-planar data formats",
              16, old_value_t.c_uv_line_stride, new_value_t.c_uv_line_stride };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Line Stride";
}

#define WIN_C_BUF_STRIDE_OFFSET 0x270B
#define WIN_C_BUF_STRIDE_UNDEFMASK 0x00000000
union win_c_buf_stride_u {
    struct {
        unsigned int c_buf_stride:32;       /* Window C Buffer stride Buffer stride is used to calculate the buffer addresses when the window is triggered by non-host modules. Refer to the comment of START_ADDR for programming guide. For YUV planar pixel format, this specifies buffer stride for the Y plane. The value is in bytes */
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_buf_stride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_buf_stride_u old_value_t = { .reg32 = value };
    const win_c_buf_stride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_buf_stride:32",
              "Window C Buffer stride Buffer stride is used to calculate the buffer addresses when the window is triggered by non-host modules. Refer to the comment of START_ADDR for programming guide. For YUV planar pixel format, this specifies buffer stride for the Y plane. The value is in bytes",
              32, old_value_t.c_buf_stride, new_value_t.c_buf_stride };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Buffer stride";
}

#define WIN_C_UV_BUF_STRIDE_OFFSET 0x270C
#define WIN_C_UV_BUF_STRIDE_UNDEFMASK 0x00000000
union win_c_uv_buf_stride_u {
    struct {
        unsigned int c_uv_buf_stride:32;    /* Window C This value is in bytes. For YUV planar pixel format, this specifies buffer stride for the U/V plane */
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_uv_buf_stride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_uv_buf_stride_u old_value_t = { .reg32 = value };
    const win_c_uv_buf_stride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_uv_buf_stride:32",
              "Window C This value is in bytes. For YUV planar pixel format, this specifies buffer stride for the U/V plane",
              32, old_value_t.c_uv_buf_stride, new_value_t.c_uv_buf_stride };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Buffer stride for U/V plane";
}

#define WIN_C_BUFFER_ADDR_MODE_OFFSET 0x270D
#define WIN_C_BUFFER_ADDR_MODE_UNDEFMASK 0xFFFEFFFE
union win_c_buffer_addr_mode_u {
    struct {
        unsigned int c_tile_mode:1;         /* Window C Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the Y plane. 0 = LINEAR 1 = TILED */
        unsigned int undefined_bits_1_15:15;
        unsigned int c_uv_tile_mode:1;      /* Window C Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the U/V plane. 0 = LINEAR 1 = TILED */
        unsigned int undefined_bits_17_31:15;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_buffer_addr_mode_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_buffer_addr_mode_u old_value_t = { .reg32 = value };
    const win_c_buffer_addr_mode_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_tile_mode:1",
              "Window C Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the Y plane.\n0 = LINEAR\n1 = TILED",
              1, old_value_t.c_tile_mode, new_value_t.c_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_15:15", "", 15, old_value_t.undefined_bits_1_15, new_value_t.undefined_bits_1_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_uv_tile_mode:1",
              "Window C Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the U/V plane.\n0 = LINEAR\n1 = TILED",
              1, old_value_t.c_uv_tile_mode, new_value_t.c_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_31:15", "", 15, old_value_t.undefined_bits_17_31, new_value_t.undefined_bits_17_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Memory Controller Tiling definitions";
}

#define WIN_C_DV_CONTROL_OFFSET 0x270E
#define WIN_C_DV_CONTROL_UNDEFMASK 0xFFF8F8F8
union win_c_dv_control_u {
    struct {
        unsigned int c_dv_control_r:3;      /* Digital Vibrance control for R */
        unsigned int undefined_bits_3_7:5;
        unsigned int c_dv_control_g:3;      /* Digital Vibrance control for G */
        unsigned int undefined_bits_11_15:5;
        unsigned int c_dv_control_b:3;      /* Digital Vibrance control for B */
        unsigned int undefined_bits_19_31:13;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_dv_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_dv_control_u old_value_t = { .reg32 = value };
    const win_c_dv_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_dv_control_r:3",
              "Digital Vibrance control for R",
              3, old_value_t.c_dv_control_r, new_value_t.c_dv_control_r };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_7:5", "", 5, old_value_t.undefined_bits_3_7, new_value_t.undefined_bits_3_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_dv_control_g:3",
              "Digital Vibrance control for G",
              3, old_value_t.c_dv_control_g, new_value_t.c_dv_control_g };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_15:5", "", 5, old_value_t.undefined_bits_11_15, new_value_t.undefined_bits_11_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_dv_control_b:3",
              "Digital Vibrance control for B",
              3, old_value_t.c_dv_control_b, new_value_t.c_dv_control_b };
    m_bit_details_model.bits.append(entry);
    entry = { "19: undefined_bits_19_31:13", "", 13, old_value_t.undefined_bits_19_31, new_value_t.undefined_bits_19_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Digital Vibrance Control\nIf enabled, Digital Vibrance is applied after H and V scaling and after color palette or color space conversion logic but before color keying multiplexer and before cursor multiplexer.\n    * After DV, new R = R + (2R - G - B) * FR, where FR is fraction from 0 to 7/8\n    * After DV, new G = G + (2G - R - B) * FG, where FG is fraction from 0 to 7/8\n    * After DV, new B = B + (2B - R - G) * FB, where FB is fraction from 0 to 7/8";
}

#define WIN_C_BLEND_NOKEY_OFFSET 0x270F
#define WIN_C_BLEND_NOKEY_UNDEFMASK 0xFF0000FE
union win_c_blend_nokey_u {
    struct {
        unsigned int c_blend_control_nokey:1;/* Window blend control for color key not match areas. 0 = Fix weight using window blend weight 0 for color key not matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT */
        unsigned int undefined_bits_1_7:7;
        unsigned int c_blend_weight0_nokey:8;/* Window blend weight 0 for color key not match areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int c_blend_weight1_nokey:8;/* Window blend weight 1 for color key not match areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_blend_nokey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_blend_nokey_u old_value_t = { .reg32 = value };
    const win_c_blend_nokey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_blend_control_nokey:1",
              "Window blend control for color key not match areas.\n0 = Fix weight using window blend weight 0 for color key not matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n0 = FIX_WEIGHT\n1 = ALPHA_WEIGHT",
              1, old_value_t.c_blend_control_nokey, new_value_t.c_blend_control_nokey };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_blend_weight0_nokey:8",
              "Window blend weight 0 for color key not match areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.c_blend_weight0_nokey, new_value_t.c_blend_weight0_nokey };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_blend_weight1_nokey:8",
              "Window blend weight 1 for color key not match areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.c_blend_weight1_nokey, new_value_t.c_blend_weight1_nokey };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Blend Control for this window area where color key is enabled but the pixel color is not within the color key range (color key not match). This is valid for all overlapping condition but only if there is no overlap with other window with higher priority color key enabled and color key not match.\nClass: Display Color Keying and Blending\nColor keying and blending of the display windows are done prior to cursor blending. Cursor always goes on top of the blended windows. Blending is controlled independently on each possible overlap area of the display windows. If 3 windows are enabled there are 7 possible overlap area combinations. For every window in each overlap area combination, color key can be disabled or enabled. Also, for every window in each overlap area combination, there is a corresponding window blend control parameter and a window blend weight parameter. The window blend control parameter is always effective but the window blend weight is not always used. The window blend weight can also be derived from pixel alpha value or from the reverse of other overlapping windows weight.\nColor keying has the highest priority for display window blending. Color key consists of a range of color which is searched independently for each window. If more than 1 windows color keys are enabled then Window A color key has the highest priority, followed by Window B color key, and then followed by Window C color key. Two sets of color key range (Color Key 0 and Color Key 1) can be defined and they are shared for all windows. It is possible to use both color key sets for the same window or for two separate windows.\nThe two sets of color key ranges should not overlap and if they do the overlap colors are treated as if they are part of Color Key 0 and not part of Color Key 1.\nAssuming that there is no overlap with other higher priority window with color key not matched, if a window color key is enabled for any overlap condition and the window pixel is not within the color key range (key not match), then the window pixel will not be blended with other overlapping window pixels but it will be weighted. The weight is not dependent on the overlap condition it is controlled by the same set of parameters for all overlapping condition.\nAssuming that there is no overlap with other higher priority window with color key not matched, if a window color key is enabled for a particular overlap condition and the window pixel is within the color key range (key match), then the window pixel will be weighted and blended with other overlapping pixels and this is controlled separately for each overlap condition.\nAssuming that there is no overlap with other higher priority window with color key not matched, if a window color key is disabled then the window pixel will be blended with other overlapping pixels and this is controlled separately for each overlap condition.\nDisplay Color Key Parameters\nFor B4G4R4A4, B5G6R5A, B5G6R5 mode, color key should be compared prior to color conversion to 24-bpp and unused least significant bits of the pixel are filled with zeros.\nFor palletized mode, color key is compared prior to color palette and the palletized color is compared against the green color key values/mask.\nFor YUV mode, U and V are offset by +128 before performing the color key comparison.\nIn all cases, color key is compared prior to horizontal/vertical scaling filter and prior to digital vibrance control.\nBoth upper and lower values are inclusive.";
}

#define WIN_C_BLEND_1WIN_OFFSET 0x2710
#define WIN_C_BLEND_1WIN_UNDEFMASK 0xFF0000F8
union win_c_blend_1win_u {
    struct {
        unsigned int c_ckey_enable_1win:2;  /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int c_blend_control_1win:1;/* Window blend control in area where it does not overlap with other windows and either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT */
        unsigned int undefined_bits_3_7:5;
        unsigned int c_blend_weight0_1win:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int c_blend_weight1_1win:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_blend_1win_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_blend_1win_u old_value_t = { .reg32 = value };
    const win_c_blend_1win_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_ckey_enable_1win:2",
              "Window color key enable\n0 = Color Key 0 and 1 Disable\n1 = Color Key 0 Enable\n2 = Color Key 1 Enable\n3 = Color Key 0 and 1 Enable\n0 = NOKEY\n1 = CKEY0\n2 = CKEY1\n3 = CKEY01",
              2, old_value_t.c_ckey_enable_1win, new_value_t.c_ckey_enable_1win };
    m_bit_details_model.bits.append(entry);
    entry = { "02: c_blend_control_1win:1",
              "Window blend control in area where it does not overlap with other windows and either color key disabled or color key enabled with key matched.\n0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n0 = FIX_WEIGHT\n1 = ALPHA_WEIGHT",
              1, old_value_t.c_blend_control_1win, new_value_t.c_blend_control_1win };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_7:5", "", 5, old_value_t.undefined_bits_3_7, new_value_t.undefined_bits_3_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_blend_weight0_1win:8",
              "Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.c_blend_weight0_1win, new_value_t.c_blend_weight0_1win };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_blend_weight1_1win:8",
              "Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.c_blend_weight1_1win, new_value_t.c_blend_weight1_1win };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Blend Control for this window area where it does not overlap with other windows.";
}

#define WIN_C_BLEND_2WIN_A_OFFSET 0x2711
#define WIN_C_BLEND_2WIN_A_UNDEFMASK 0xFF0000F0
union win_c_blend_2win_a_u {
    struct {
        unsigned int c_ckey_enable_2win_a:2;/* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int c_blend_control_2win_a:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int c_blend_weight0_2win_a:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int c_blend_weight1_2win_a:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_blend_2win_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_blend_2win_a_u old_value_t = { .reg32 = value };
    const win_c_blend_2win_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_ckey_enable_2win_a:2",
              "Window color key enable\n0 = Color Key 0 and 1 Disable\n1 = Color Key 0 Enable\n2 = Color Key 1 Enable\n3 = Color Key 0 and 1 Enable\n0 = NOKEY\n1 = CKEY0\n2 = CKEY1\n3 = CKEY01",
              2, old_value_t.c_ckey_enable_2win_a, new_value_t.c_ckey_enable_2win_a };
    m_bit_details_model.bits.append(entry);
    entry = { "02: c_blend_control_2win_a:2",
              "Window blend control in area where either color key disabled or color key enabled with key matched.\n0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting.\n0 = FIX_WEIGHT\n1 = ALPHA_WEIGHT\n2 = DEPENDENT_WEIGHT",
              2, old_value_t.c_blend_control_2win_a, new_value_t.c_blend_control_2win_a };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_7:4", "", 4, old_value_t.undefined_bits_4_7, new_value_t.undefined_bits_4_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_blend_weight0_2win_a:8",
              "Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.c_blend_weight0_2win_a, new_value_t.c_blend_weight0_2win_a };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_blend_weight1_2win_a:8",
              "Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.c_blend_weight1_2win_a, new_value_t.c_blend_weight1_2win_a };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Blend Control for this window area that overlaps with window A only.";
}

#define WIN_C_BLEND_2WIN_B_OFFSET 0x2712
#define WIN_C_BLEND_2WIN_B_UNDEFMASK 0xFF0000F0
union win_c_blend_2win_b_u {
    struct {
        unsigned int c_ckey_enable_2win_b:2;/* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY; 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int c_blend_control_2win_b:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int c_blend_weight0_2win_b:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int c_blend_weight1_2win_b:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_blend_2win_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_blend_2win_b_u old_value_t = { .reg32 = value };
    const win_c_blend_2win_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_ckey_enable_2win_b:2",
              "Window color key enable\n0 = Color Key 0 and 1 Disable\n1 = Color Key 0 Enable\n2 = Color Key 1 Enable\n3 = Color Key 0 and 1 Enable\n0 = NOKEY;\n1 = CKEY0\n2 = CKEY1\n3 = CKEY01",
              2, old_value_t.c_ckey_enable_2win_b, new_value_t.c_ckey_enable_2win_b };
    m_bit_details_model.bits.append(entry);
    entry = { "02: c_blend_control_2win_b:2",
              "Window blend control in area where either color key disabled or color key enabled with key matched.\n0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting.\n0 = FIX_WEIGHT\n1 = ALPHA_WEIGHT\n2 = DEPENDENT_WEIGHT",
              2, old_value_t.c_blend_control_2win_b, new_value_t.c_blend_control_2win_b };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_7:4", "", 4, old_value_t.undefined_bits_4_7, new_value_t.undefined_bits_4_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_blend_weight0_2win_b:8",
              "Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.c_blend_weight0_2win_b, new_value_t.c_blend_weight0_2win_b };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_blend_weight1_2win_b:8",
              "Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.c_blend_weight1_2win_b, new_value_t.c_blend_weight1_2win_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Blend Control for this window area that overlaps with window B only.";
}

#define WIN_C_BLEND_3WIN_AB_OFFSET 0x2713
#define WIN_C_BLEND_3WIN_AB_UNDEFMASK 0xFF0000F0
union win_c_blend_3win_ab_u {
    struct {
        unsigned int c_ckey_enable_3win_ab:2;/* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int c_blend_control_3win_ab:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int c_blend_weight0_3win_ab:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int c_blend_weight1_3win_ab:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_blend_3win_ab_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_blend_3win_ab_u old_value_t = { .reg32 = value };
    const win_c_blend_3win_ab_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_ckey_enable_3win_ab:2",
              "Window color key enable\n0 = Color Key 0 and 1 Disable\n1 = Color Key 0 Enable\n2 = Color Key 1 Enable\n3 = Color Key 0 and 1 Enable\n0 = NOKEY\n1 = CKEY0\n2 = CKEY1\n3 = CKEY01",
              2, old_value_t.c_ckey_enable_3win_ab, new_value_t.c_ckey_enable_3win_ab };
    m_bit_details_model.bits.append(entry);
    entry = { "02: c_blend_control_3win_ab:2",
              "Window blend control in area where either color key disabled or color key enabled with key matched.\n0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched.\n1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used.\n2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting.\n0 = FIX_WEIGHT\n1 = ALPHA_WEIGHT\n2 = DEPENDENT_WEIGHT",
              2, old_value_t.c_blend_control_3win_ab, new_value_t.c_blend_control_3win_ab };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_7:4", "", 4, old_value_t.undefined_bits_4_7, new_value_t.undefined_bits_4_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: c_blend_weight0_3win_ab:8",
              "Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0",
              8, old_value_t.c_blend_weight0_3win_ab, new_value_t.c_blend_weight0_3win_ab };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_blend_weight1_3win_ab:8",
              "Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1",
              8, old_value_t.c_blend_weight1_3win_ab, new_value_t.c_blend_weight1_3win_ab };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Blend Control for this window area that overlaps with windows A & B only.";
}

#define WIN_C_HP_FETCH_CONTROL_OFFSET 0x2714
#define WIN_C_HP_FETCH_CONTROL_UNDEFMASK 0x00000000
union win_c_hp_fetch_control_u {
    struct {
        unsigned int c_cycles_per_word:16;  /* Window C clock cycles per memory fetch word. The value of this field is essentially a measure of the data consumption rate for window C. It is computed as follows: C_CYCLES_PER_WORD = C_DDA_INCREMENT.C_H_DDA_INCREMENT / (bytes per pixel) Note that the format for this value is a fixed-point fractional value with 8 bits of integer precision and 8 bits of fractional precision. In other words, it is an '8.8' number. For example, if there is no scaling of the input image, the DDA increment will be 4096. With 32-bit RGBA pixels there will be 4 bytes per pixel, so CYCLES_PER_WORD will be ... 4096 / 4 = 1024, or 4.0 expressed in the 8.8 format. Any scaling performed on the pixels will change the rate at which pixels are consumed. Scaling up will increase the value of DDA increment and will therefore increase the number of cycles between memory fetches. Conversely, scaling down will decrease the value of DDA increment and memory fetches will occur more frequently */
        unsigned int c_words_per_line:15;   /* Window C memory fetch words per scan line. This value is in memory fetch words: Multiples of 16 bytes for Tegra 2 Processor Series devices. It is computed as follows: C_WORDS_PER_LINE = (C_SIZE.C_H_SIZE * (bytes per pixel) + 15) >> 4 bytes per pixel is determined by the pixel format */
        unsigned int c_fetch_info_enable:1; /* Enables the sending of the Window C fetch information. For compatibility with earlier devices, this defaults to DISABLE. 0 = DISABLE : This bit should be enabled only for 12-bpp  1 = ENABLE */
    };

    u_int32_t reg32;
};

void DcDev::fill_win_c_hp_fetch_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const win_c_hp_fetch_control_u old_value_t = { .reg32 = value };
    const win_c_hp_fetch_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_cycles_per_word:16",
              "Window C clock cycles per memory fetch word. The value of this field is essentially a measure of the data consumption rate for window C. It is computed as follows: C_CYCLES_PER_WORD = C_DDA_INCREMENT.C_H_DDA_INCREMENT / (bytes per pixel) Note that the format for this value is a fixed-point fractional value with 8 bits of integer precision and 8 bits of fractional precision. In other words, it is an '8.8' number. For example, if there is no scaling of the input image, the DDA increment will be 4096. With 32-bit RGBA pixels there will be 4 bytes per pixel, so CYCLES_PER_WORD will be ... 4096 /\n4 = 1024, or 4.0 expressed in the 8.8 format. Any scaling performed on the pixels will change the rate at which pixels are consumed. Scaling up will increase the value of DDA increment and will therefore increase the number of cycles between memory fetches. Conversely, scaling down will decrease the value of DDA increment and memory fetches will occur more frequently",
              16, old_value_t.c_cycles_per_word, new_value_t.c_cycles_per_word };
    m_bit_details_model.bits.append(entry);
    entry = { "16: c_words_per_line:15",
              "Window C memory fetch words per scan line. This value is in memory fetch words: Multiples of 16 bytes for Tegra 2 Processor Series devices. It is computed as follows: C_WORDS_PER_LINE = (C_SIZE.C_H_SIZE * (bytes per pixel) + 15) >> 4 bytes per pixel is determined by the pixel format",
              15, old_value_t.c_words_per_line, new_value_t.c_words_per_line };
    m_bit_details_model.bits.append(entry);
    entry = { "31: c_fetch_info_enable:1",
              "Enables the sending of the Window C fetch information. For compatibility with earlier devices, this defaults to DISABLE.\n0 = DISABLE : This bit should be enabled only for 12-bpp \n1 = ENABLE",
              1, old_value_t.c_fetch_info_enable, new_value_t.c_fetch_info_enable };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C High Priority Avoidance Fetch Parameters\nThis register gives extra information to the Memory Controller Client Interface (MCCIF) about the number of memory words that will be fetched per scan line and about the rate at wich those words are consumed. This allows the MCCIF to more accurately arbitrate memory accesses to prevent the use of the High Priority signal.\nUse of this signal causes all other client accesses to be blocked in preference to the client asserting HP. Obviously, this is a state which is sometime necessary for Display since it is an isochronous client and MUST be serviced in a timely manner. However, use of this signal should be avoided if possible. These parameters help the MCCIF avoid the over-use of HP.";
}

#define WINBUF_C_START_ADDR_OFFSET 0x2800
#define WINBUF_C_START_ADDR_UNDEFMASK 0x00000000
union winbuf_c_start_addr_u {
    struct {
        unsigned int c_start_addr:32;       /* Window C Start Address This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies start address for the Y plane */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_c_start_addr_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_c_start_addr_u old_value_t = { .reg32 = value };
    const winbuf_c_start_addr_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_start_addr:32",
              "Window C Start Address This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies start address for the Y plane",
              32, old_value_t.c_start_addr, new_value_t.c_start_addr };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Start Address\nOverview\nSTART_ADDR, BUF_STRIDE, LINE_STRIDE, ADDR_H_OFFSET, ADDR_V_OFFSET combined, specify the starting address of a window buffer in the memory surface. Generally START_ADDR is programmed with the starting address of the memory surface. H/V_OFFSET specifies the address offsets of the pixel at the beginning of the window, with respect to the starting address of the memory surface. (There is an exception to that when memory surface is not well aligned, see 3-ii below.)\n Note that \"beginning of the window\" here means the top-left corner of a window in normal mode,  top-right corner in horizontal flipping, bottom-left corner in vertical flipping, and bottom-right  in horizontal+vertical flipping.\nStarting Address Calculation\nThese formulae are same for both tiled or linear mode. However, for linear mode, the addresses calculated are real physical addresses, but for tile mode, these addresses will be translated to the real physical addresses by the memory controller client before used.\n    * When a window is host triggered, starting address of a window is calculated as follows by HW.\n- non-yuv-planar modes\nstarting-address = START_ADDR + ADDR_V_OFFSET * LINE_STRIDE + ADDR_H_OFFSET\n- yuv-planar modes\ny-starting-address = START_ADDR + ADDR_V_OFFSET * LINE_STRIDE + ADDR_H_OFFSET\nu-starting-address = START_ADDR_U + ADDR_V_OFFSET * UV_LINE_STRIDE / denom1 + ADDR_H_OFFSET / denom2\nv-starting-address = START_ADDR_V + ADDR_V_OFFSET * UV_LINE_STRIDE / denom1 + ADDR_H_OFFSET / denom2 where denom1/denom2 equal to 1 or 2 depending on the actual planar format, derived natively by HW.\n    * When a window is non-host triggered, starting address of a window buffer is calculated as below.\n- non-yuv-planar mode\nstarting-address = START_ADDR + BUF_STRIDE * buf_index + ADDR_V_OFFSET * LINE_STRIDE + ADDR_H_OFFSET\n- yuv-planar mode:\ny-starting-address = START_ADDR + BUF_STRIDE * buf_index + ADDR_V_OFFSET * LINE_STRIDE + ADDR_H_OFFSET\nu-starting-address = START_ADDR_U + UV_BUF_STRIDE * buf_index + ADDR_V_OFFSET * UV_LINE_STRIDE / denom1 + ADDR_H_OFFSET / denom2\nv-starting-address = START_ADDR_V + UV_BUF_STRIDE * buf_index + ADDR_V_OFFSET * UV_LINE_STRIDE / denom1 + ADDR_H_OFFSET / denom2 where denom1/denom2 equal to 1 or 2 depending on the actual planar format, derived natively by HW.\nbuf_index is the index transmitted by the triggering module pointing to the first buffer of a frame.\nProgramming Restrictions\n    * For tiled address mode\nImage surface can only aligned to multiples of 256, thus the following restrictions.\n- START_ADDR, START_ADDR_U, START_ADDR_V need to be multiples of 256.\n- BUF_STRIDE, UV_BUF_STRIDE need to be multiples of 256\n- LINE_STRIDE, UV_LINE_STRIDE need to be multiples of 16\n- ADDR_H_OFFSET needs to be multiple of 2 in yuv planar format (the last bit is ignored), but with no restrictions on other color formats.\n- ADDR_V_OFFSET has no restrictions\n    * For linear address mode\nImage surface can be aligned 2, 4 or 8 bytes, depending on the color formats.\nAs an additional restriction for display, START_ADDR, START_ADDR_U and START_ADDR_V need to be multiples of 16. When a surface is not aligned to 16 bytes, program START_ADDR with the memory surface address with its least 4 significant bits zeroed out and add these 4 address bits to the original H_OFFSET. (So the formula in 2-i,ii still hold)\n- For all formats:\nSTART_ADDR, START_ADDR_U and START_ADDR_V need to be multiples of 16.\nFor 16-bpp formats,\n(START_ADDR+H_OFFSET) need to be multiple of 2. The least significant bit of H_OFFSTE is ignored.\nFor 32-bpp formats,\n(START_ADDR+H_OFFSTE) needs to be multiple of 4. The least two significant bits of H_OFFSTE are ignored.\n- For yuv planar formats:\nBUF_STRIDE, UV_BUF_STRIDE:\nBUF_STRIDE[2:1]=UV_BUF_STRIDE[1:0]\nor as a stricter constraint: BUF_STRIDE be multiple of 8, UV_BUF_STRIDE be multiple of 4.\nLINE_STRIDE, UV_LINE_STRIDE:\nLINE_STRIDE and UV_LINE_STRIDE need to be at least 16.\nLINE_STRIDE needs to be multiple of 8, UV_LINE_STRIDE needs to be multiple of 4.\nADDR_H_OFFSET:\nNeeds to be multiple of 2. If needs to point to odd pixel position, program ADDR_H_OFFSET to be the previous position (or the next position if H-flipped) and program H_INITIAL_DDA bit 12 to 1.\nADDR_V_OFFSET:\nNeeds to be multiple of 2. If needs to point to odd line number, program ADDR_V_OFFSTE to be the previous line number (or next line number if V-flipped) and program V_INITIAL_DDA bit 12 to 1.\n    * Memory allocation for non-host triggered case:\nWhen a window buffer is not controlled by host (software) then a frame may be stored in multiple buffers. In this case, the buffers must be contiguous in the memory because display will use the same luma or chroma line strides for all lines in the frame.\nAlso buffer wraparound must not occur in the middle of the displayed part of the frame. The controlling module will send frame start and frame end indicators (flags) to display module to indicate the beginning and end of frame. Buffer start address is latched when frame start flag is active but the actual buffer start address is not switched until frame end flag is active. In the case where one buffer correspond to one frame then frame start and frame end flag are active everytime a buffer index is sent.";
}

#define WINBUF_C_START_ADDR_NS_OFFSET 0x2801
#define WINBUF_C_START_ADDR_NS_UNDEFMASK 0x00000000
union winbuf_c_start_addr_ns_u {
    struct {
        unsigned int c_start_addr_ns:32;    /* Window C Shadowed Start Address This is ARM set shadow of Start Address */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_c_start_addr_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_c_start_addr_ns_u old_value_t = { .reg32 = value };
    const winbuf_c_start_addr_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_start_addr_ns:32",
              "Window C Shadowed Start Address This is ARM set shadow of Start Address",
              32, old_value_t.c_start_addr_ns, new_value_t.c_start_addr_ns };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Shadowed Start Address";
}

#define WINBUF_C_START_ADDR_U_OFFSET 0x2802
#define WINBUF_C_START_ADDR_U_UNDEFMASK 0x00000000
union winbuf_c_start_addr_u_u {
    struct {
        unsigned int c_start_addr_u:32;     /* Window C Start Address for U plane This is a byte address */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_c_start_addr_u_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_c_start_addr_u_u old_value_t = { .reg32 = value };
    const winbuf_c_start_addr_u_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_start_addr_u:32",
              "Window C Start Address for U plane This is a byte address",
              32, old_value_t.c_start_addr_u, new_value_t.c_start_addr_u };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Start Address for U plane";
}

#define WINBUF_C_START_ADDR_U_NS_OFFSET 0x2803
#define WINBUF_C_START_ADDR_U_NS_UNDEFMASK 0x00000000
union winbuf_c_start_addr_u_ns_u {
    struct {
        unsigned int c_start_addr_u_ns:32;  /* Window C Shadowed Start Address for U plane This is ARM set shadow register of U start address */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_c_start_addr_u_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_c_start_addr_u_ns_u old_value_t = { .reg32 = value };
    const winbuf_c_start_addr_u_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_start_addr_u_ns:32",
              "Window C Shadowed Start Address for U plane This is ARM set shadow register of U start address",
              32, old_value_t.c_start_addr_u_ns, new_value_t.c_start_addr_u_ns };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Shadowed Start Address for U plane";
}

#define WINBUF_C_START_ADDR_V_OFFSET 0x2804
#define WINBUF_C_START_ADDR_V_UNDEFMASK 0x00000000
union winbuf_c_start_addr_v_u {
    struct {
        unsigned int c_start_addr_v:32;     /* Window C Start Address for V plane This is a byte address */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_c_start_addr_v_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_c_start_addr_v_u old_value_t = { .reg32 = value };
    const winbuf_c_start_addr_v_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_start_addr_v:32",
              "Window C Start Address for V plane This is a byte address",
              32, old_value_t.c_start_addr_v, new_value_t.c_start_addr_v };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Start Address for V plane";
}

#define WINBUF_C_START_ADDR_V_NS_OFFSET 0x2805
#define WINBUF_C_START_ADDR_V_NS_UNDEFMASK 0x00000000
union winbuf_c_start_addr_v_ns_u {
    struct {
        unsigned int c_start_addr_v_ns:32;  /* Window C Shadowed Start Address for V plane This is ARM set shadow register of U start address */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_c_start_addr_v_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_c_start_addr_v_ns_u old_value_t = { .reg32 = value };
    const winbuf_c_start_addr_v_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_start_addr_v_ns:32",
              "Window C Shadowed Start Address for V plane This is ARM set shadow register of U start address",
              32, old_value_t.c_start_addr_v_ns, new_value_t.c_start_addr_v_ns };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Shadowed Start Address for V plane";
}

#define WINBUF_C_ADDR_H_OFFSET_OFFSET 0x2806
#define WINBUF_C_ADDR_H_OFFSET_UNDEFMASK 0x00000000
union winbuf_c_addr_h_offset_u {
    struct {
        unsigned int c_addr_h_offset:32;    /* Window C Horizontal address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies horizontal offset of Y plane. The horizontal offsets of U/V plane is derived by HW */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_c_addr_h_offset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_c_addr_h_offset_u old_value_t = { .reg32 = value };
    const winbuf_c_addr_h_offset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_addr_h_offset:32",
              "Window C Horizontal address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies horizontal offset of Y plane. The horizontal offsets of U/V plane is derived by HW",
              32, old_value_t.c_addr_h_offset, new_value_t.c_addr_h_offset };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Horizontal address offset";
}

#define WINBUF_C_ADDR_H_OFFSET_NS_OFFSET 0x2807
#define WINBUF_C_ADDR_H_OFFSET_NS_UNDEFMASK 0x00000000
union winbuf_c_addr_h_offset_ns_u {
    struct {
        unsigned int c_addr_h_offset_ns:32; /* Window C Shadowed Horizontal address offset This is ARM set shadow of ADDR_H_OFFSET */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_c_addr_h_offset_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_c_addr_h_offset_ns_u old_value_t = { .reg32 = value };
    const winbuf_c_addr_h_offset_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_addr_h_offset_ns:32",
              "Window C Shadowed Horizontal address offset This is ARM set shadow of ADDR_H_OFFSET",
              32, old_value_t.c_addr_h_offset_ns, new_value_t.c_addr_h_offset_ns };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Shadowed Horizontal address offset";
}

#define WINBUF_C_ADDR_V_OFFSET_OFFSET 0x2808
#define WINBUF_C_ADDR_V_OFFSET_UNDEFMASK 0x00000000
union winbuf_c_addr_v_offset_u {
    struct {
        unsigned int c_addr_v_offset:32;    /* Window C Vertical address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies vertical offset of Y plane. The vertical offsets of U/V plane is derived by HW */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_c_addr_v_offset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_c_addr_v_offset_u old_value_t = { .reg32 = value };
    const winbuf_c_addr_v_offset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_addr_v_offset:32",
              "Window C Vertical address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies vertical offset of Y plane. The vertical offsets of U/V plane is derived by HW",
              32, old_value_t.c_addr_v_offset, new_value_t.c_addr_v_offset };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Vertical address offset";
}

#define WINBUF_C_ADDR_V_OFFSET_NS_OFFSET 0x2809
#define WINBUF_C_ADDR_V_OFFSET_NS_UNDEFMASK 0x00000000
union winbuf_c_addr_v_offset_ns_u {
    struct {
        unsigned int c_addr_v_offset_ns:32; /* Window C Shadowed Vertical address offset This is ARM set shadow of ADDR_V_OFFSET */
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_c_addr_v_offset_ns_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_c_addr_v_offset_ns_u old_value_t = { .reg32 = value };
    const winbuf_c_addr_v_offset_ns_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: c_addr_v_offset_ns:32",
              "Window C Shadowed Vertical address offset This is ARM set shadow of ADDR_V_OFFSET",
              32, old_value_t.c_addr_v_offset_ns, new_value_t.c_addr_v_offset_ns };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C Shadowed Vertical address offset";
}

#define WINBUF_C_UFLOW_STATUS_OFFSET 0x280A
#define WINBUF_C_UFLOW_STATUS_UNDEFMASK 0xBF000000
union winbuf_c_uflow_status_u {
    struct {
        unsigned int uflow_count:24;        /* Underflow count. This field indicates the number of contiguous groups of output pixels for which there was no data in the FIFO. For example, if the valid from the FIFO is low for 10 consecutive cycles and then goes high, the counter will increment by one. Reset to zero on write */
        unsigned int undefined_bits_24_29:6;
        unsigned int count_oflow:1;         /* Flag bit that indicates that the underflow event counter has overflowed. There were too many events. If COUNT_OFLOW is set, UFLOW_COUNT is meaningless. Cleared on write */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void DcDev::fill_winbuf_c_uflow_status_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winbuf_c_uflow_status_u old_value_t = { .reg32 = value };
    const winbuf_c_uflow_status_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: uflow_count:24",
              "Underflow count. This field indicates the number of contiguous groups of output pixels for which there was no data in the FIFO. For example, if the valid from the FIFO is low for 10 consecutive cycles and then goes high, the counter will increment by one. Reset to zero on write",
              24, old_value_t.uflow_count, new_value_t.uflow_count };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_29:6", "", 6, old_value_t.undefined_bits_24_29, new_value_t.undefined_bits_24_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: count_oflow:1",
              "Flag bit that indicates that the underflow event counter has overflowed. There were too many events. If COUNT_OFLOW is set, UFLOW_COUNT is meaningless. Cleared on write",
              1, old_value_t.count_oflow, new_value_t.count_oflow };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);

    m_bit_details_model.desc = "Window C FIFO Underflow Status Register";
}

#define DISP_SD_CONTROL_OFFSET 0x4C2
#define DISP_SD_CONTROL_UNDEFMASK 0xFFFFFE00
union disp_sd_control_u {
    struct {
        unsigned int sd_enable:1;           /* Enables the Smart Dimmer Function */
        unsigned int use_vid_luma:1;        /* Use Video Luminance control of luminance: Luminance = MAX(R, G, B) ENABLE = use "video" luminance, which is determined by the coefficients in the SD_CSC_COEFFS register See the SD_CSC_COEFFS register for details. */
        unsigned int bin_width:2;           /* Width of the Histogram bins, in quantisation levels. EIGHT = 8 levels per bin. Bins span range from   0 to 255 */
        unsigned int aggressiveness:3;      /* The "aggressiveness" level of the Smart Dimmer algorithm. Higher aggressiveness levels result in higher power savings at the potential expense of image quality. The number programmed determines how many highlight pixels will be allowed to exceed the maximum representable brightness value and be clipped to that value. It also determines the maximum allowed enhancement value (k) applied to the pixel brightness. AGGRESSIVENESS Description         % pixels  Max. k      value                          crushed  value        0       Essentially off          0%    1.00        1       Highest quality       <  5%    1.10        2       Higher quality        < 10%    1.15        3       Balanced              < 15%    1.20        4       Higher battery life   < 20%    1.25        5       Highest battery life  < 25%    1.50 */
        unsigned int hw_update_dly:2;       /* Determines the delay - in video frames - of the update of the hardware enhancement value that is applied to the pixels. This is useful for allowing the software some time to update the backlight control, when the control must be sent via side-band control packets or by some other means of control that incurs a sizeable delay. Being able to delay the hardware update ensures that the modification of the pixels occurs as nearly simultaneously with the update of the backlight as possible. Value Description   0   No delay - pixels modified immediately   1   New enhancemant value delayed by 1 frame.   2   New enhancement value delayed by 2 frames.   3   New enhancement value delayed by 3 frames. */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_control_u old_value_t = { .reg32 = value };
    const disp_sd_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sd_enable:1",
              "Enables the Smart Dimmer Function",
              1, old_value_t.sd_enable, new_value_t.sd_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: use_vid_luma:1",
              "Use Video Luminance control of luminance: Luminance = MAX(R, G, B) ENABLE = use \"video\" luminance, which is determined by the coefficients in the SD_CSC_COEFFS register See the SD_CSC_COEFFS register for details.",
              1, old_value_t.use_vid_luma, new_value_t.use_vid_luma };
    m_bit_details_model.bits.append(entry);
    entry = { "02: bin_width:2",
              "Width of the Histogram bins, in quantisation levels. EIGHT = 8 levels per bin. Bins span range from   0 to 255",
              2, old_value_t.bin_width, new_value_t.bin_width };
    m_bit_details_model.bits.append(entry);
    entry = { "04: aggressiveness:3",
              "The \"aggressiveness\" level of the Smart Dimmer algorithm. Higher aggressiveness levels result in higher power savings at the potential expense of image quality. The number programmed determines how many highlight pixels will be allowed to exceed the maximum representable brightness value and be clipped to that value. It also determines the maximum allowed enhancement value (k) applied to the pixel brightness. AGGRESSIVENESS Description         % pixels  Max. k      value                          crushed  value        0       Essentially off          0%    1.00        1       Highest quality       <  5%    1.10        2       Higher quality        < 10%    1.15        3       Balanced              < 15%    1.20        4       Higher battery life   < 20%    1.25        5       Highest battery life  < 25%    1.50",
              3, old_value_t.aggressiveness, new_value_t.aggressiveness };
    m_bit_details_model.bits.append(entry);
    entry = { "07: hw_update_dly:2",
              "Determines the delay - in video frames - of the update of the hardware enhancement value that is applied to the pixels. This is useful for allowing the software some time to update the backlight control, when the control must be sent via side-band control packets or by some other means of control that incurs a sizeable delay. Being able to delay the hardware update ensures that the modification of the pixels occurs as nearly simultaneously with the update of the backlight as possible. Value Description   0   No delay - pixels modified immediately   1   New enhancemant value delayed by 1 frame.   2   New enhancement value delayed by 2 frames.   3   New enhancement value delayed by 3 frames.",
              2, old_value_t.hw_update_dly, new_value_t.hw_update_dly };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_CSC_COEFF_OFFSET 0x4C3
#define DISP_SD_CSC_COEFF_UNDEFMASK 0xFF0F0F0F
union disp_sd_csc_coeff_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int r_coeff:4;             /* green and blue color components into a luminance value. */
        unsigned int undefined_bits_8_11:4;
        unsigned int g_coeff:4;             /* The conversion is performed according to the following equation: */
        unsigned int undefined_bits_16_19:4;
        unsigned int b_coeff:4;             /* Luminance = (R * R_COEFF + G * G_COEFF + B * B_COEFF) >> 4 It is suggested that the values of the coefficients be programmed as shown below, though user-defined color spaces are also accommodated. Color Space  R_COEFF G_COEFF B_COEFF ITU-R Bt601      5       9       2 ITU-R Bt709      3      12       1 The coefficients do not have to be particularly accurate, hence their low precision and the coefficients used are open to experimentation to obtain the best results. */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_csc_coeff_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_csc_coeff_u old_value_t = { .reg32 = value };
    const disp_sd_csc_coeff_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_3:4", "", 4, old_value_t.undefined_bits_0_3, new_value_t.undefined_bits_0_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: r_coeff:4",
              "green and blue color components into a luminance value.",
              4, old_value_t.r_coeff, new_value_t.r_coeff };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_11:4", "", 4, old_value_t.undefined_bits_8_11, new_value_t.undefined_bits_8_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: g_coeff:4",
              "The conversion is performed according to the following equation:",
              4, old_value_t.g_coeff, new_value_t.g_coeff };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_19:4", "", 4, old_value_t.undefined_bits_16_19, new_value_t.undefined_bits_16_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: b_coeff:4",
              "Luminance = (R * R_COEFF + G * G_COEFF + B * B_COEFF) >> 4 It is suggested that the values of the coefficients be programmed as shown below, though user-defined color spaces are also accommodated. Color Space  R_COEFF G_COEFF B_COEFF ITU-R Bt601      5       9       2 ITU-R Bt709      3      12       1 The coefficients do not have to be particularly accurate, hence their low precision and the coefficients used are open to experimentation to obtain the best results.",
              4, old_value_t.b_coeff, new_value_t.b_coeff };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_LUT_OFFSET 0x4C4
#define DISP_SD_LUT_UNDEFMASK 0xFF000000
union disp_sd_lut_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_lut_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_lut_u old_value_t = { .reg32 = value };
    const disp_sd_lut_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: r_lut:8",
              "Each LUT entry contains the value of k for each of the three color",
              8, old_value_t.r_lut, new_value_t.r_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g_lut:8",
              "components. Since the value of k for the color components must be",
              8, old_value_t.g_lut, new_value_t.g_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_lut:8",
              "the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified.",
              8, old_value_t.b_lut, new_value_t.b_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_LUT_1_OFFSET 0x4C5
#define DISP_SD_LUT_1_UNDEFMASK 0xFF000000
union disp_sd_lut_1_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_lut_1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_lut_1_u old_value_t = { .reg32 = value };
    const disp_sd_lut_1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: r_lut:8",
              "Each LUT entry contains the value of k for each of the three color",
              8, old_value_t.r_lut, new_value_t.r_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g_lut:8",
              "components. Since the value of k for the color components must be",
              8, old_value_t.g_lut, new_value_t.g_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_lut:8",
              "the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified.",
              8, old_value_t.b_lut, new_value_t.b_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_LUT_2_OFFSET 0x4C6
#define DISP_SD_LUT_2_UNDEFMASK 0xFF000000
union disp_sd_lut_2_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_lut_2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_lut_2_u old_value_t = { .reg32 = value };
    const disp_sd_lut_2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: r_lut:8",
              "Each LUT entry contains the value of k for each of the three color",
              8, old_value_t.r_lut, new_value_t.r_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g_lut:8",
              "components. Since the value of k for the color components must be",
              8, old_value_t.g_lut, new_value_t.g_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_lut:8",
              "the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified.",
              8, old_value_t.b_lut, new_value_t.b_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_LUT_3_OFFSET 0x4C7
#define DISP_SD_LUT_3_UNDEFMASK 0xFF000000
union disp_sd_lut_3_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_lut_3_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_lut_3_u old_value_t = { .reg32 = value };
    const disp_sd_lut_3_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: r_lut:8",
              "Each LUT entry contains the value of k for each of the three color",
              8, old_value_t.r_lut, new_value_t.r_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g_lut:8",
              "components. Since the value of k for the color components must be",
              8, old_value_t.g_lut, new_value_t.g_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_lut:8",
              "the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified.",
              8, old_value_t.b_lut, new_value_t.b_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_LUT_4_OFFSET 0x4C8
#define DISP_SD_LUT_4_UNDEFMASK 0xFF000000
union disp_sd_lut_4_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_lut_4_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_lut_4_u old_value_t = { .reg32 = value };
    const disp_sd_lut_4_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: r_lut:8",
              "Each LUT entry contains the value of k for each of the three color",
              8, old_value_t.r_lut, new_value_t.r_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g_lut:8",
              "components. Since the value of k for the color components must be",
              8, old_value_t.g_lut, new_value_t.g_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_lut:8",
              "the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified.",
              8, old_value_t.b_lut, new_value_t.b_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_LUT_5_OFFSET 0x4C9
#define DISP_SD_LUT_5_UNDEFMASK 0xFF000000
union disp_sd_lut_5_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_lut_5_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_lut_5_u old_value_t = { .reg32 = value };
    const disp_sd_lut_5_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: r_lut:8",
              "Each LUT entry contains the value of k for each of the three color",
              8, old_value_t.r_lut, new_value_t.r_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g_lut:8",
              "components. Since the value of k for the color components must be",
              8, old_value_t.g_lut, new_value_t.g_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_lut:8",
              "the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified.",
              8, old_value_t.b_lut, new_value_t.b_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_LUT_6_OFFSET 0x4CA
#define DISP_SD_LUT_6_UNDEFMASK 0xFF000000
union disp_sd_lut_6_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_lut_6_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_lut_6_u old_value_t = { .reg32 = value };
    const disp_sd_lut_6_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: r_lut:8",
              "Each LUT entry contains the value of k for each of the three color",
              8, old_value_t.r_lut, new_value_t.r_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g_lut:8",
              "components. Since the value of k for the color components must be",
              8, old_value_t.g_lut, new_value_t.g_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_lut:8",
              "the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified.",
              8, old_value_t.b_lut, new_value_t.b_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_LUT_7_OFFSET 0x4CB
#define DISP_SD_LUT_7_UNDEFMASK 0xFF000000
union disp_sd_lut_7_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_lut_7_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_lut_7_u old_value_t = { .reg32 = value };
    const disp_sd_lut_7_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: r_lut:8",
              "Each LUT entry contains the value of k for each of the three color",
              8, old_value_t.r_lut, new_value_t.r_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g_lut:8",
              "components. Since the value of k for the color components must be",
              8, old_value_t.g_lut, new_value_t.g_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_lut:8",
              "the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified.",
              8, old_value_t.b_lut, new_value_t.b_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_LUT_8_OFFSET 0x4CC
#define DISP_SD_LUT_8_UNDEFMASK 0xFF000000
union disp_sd_lut_8_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_lut_8_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_lut_8_u old_value_t = { .reg32 = value };
    const disp_sd_lut_8_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: r_lut:8",
              "Each LUT entry contains the value of k for each of the three color",
              8, old_value_t.r_lut, new_value_t.r_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g_lut:8",
              "components. Since the value of k for the color components must be",
              8, old_value_t.g_lut, new_value_t.g_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_lut:8",
              "the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified.",
              8, old_value_t.b_lut, new_value_t.b_lut };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_FLICKER_CONTROL_OFFSET 0x4CD
#define DISP_SD_FLICKER_CONTROL_UNDEFMASK 0xFFFF0000
union disp_sd_flicker_control_u {
    struct {
        unsigned int time_limit:8;          /* Length of time - in frames - that the enhancement value must deviate from the current value by more than THRESHOLD, before the enhancement value changes. */
        unsigned int threshold:8;           /* The amount by which the currently calcualted enhancement value must deviate from the currently active enhancement value for it to increment the TIME_LIMIT counter. */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_flicker_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_flicker_control_u old_value_t = { .reg32 = value };
    const disp_sd_flicker_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: time_limit:8",
              "Length of time - in frames - that the enhancement value must deviate from the current value by more than THRESHOLD, before the enhancement value changes.",
              8, old_value_t.time_limit, new_value_t.time_limit };
    m_bit_details_model.bits.append(entry);
    entry = { "08: threshold:8",
              "The amount by which the currently calcualted enhancement value must deviate from the currently active enhancement value for it to increment the TIME_LIMIT counter.",
              8, old_value_t.threshold, new_value_t.threshold };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_PIXEL_COUNT_OFFSET 0x4CE
#define DISP_SD_PIXEL_COUNT_UNDEFMASK 0xFFFF0000
union disp_sd_pixel_count_u {
    struct {
        unsigned int num_pixels:16;         /* in the preceeding output frame. Expressed as a quantity of 256 pixels. In other words, a 640 x 480 image has 307200 pixels. The value in this register would be 307200 / 256 = 1200 */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_pixel_count_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_pixel_count_u old_value_t = { .reg32 = value };
    const disp_sd_pixel_count_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: num_pixels:16",
              "in the preceeding output frame. Expressed as a quantity of 256 pixels. In other words, a 640 x 480 image has 307200 pixels. The value in this register would be 307200 /\n256 = 1200",
              16, old_value_t.num_pixels, new_value_t.num_pixels };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_HISTOGRAM_OFFSET 0x4CF
#define DISP_SD_HISTOGRAM_UNDEFMASK 0x00000000
union disp_sd_histogram_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_histogram_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_histogram_u old_value_t = { .reg32 = value };
    const disp_sd_histogram_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: bin_0:8",
              "Each register contains 4 histogram bins, for a total of 8 x\n4 = 32 bins.",
              8, old_value_t.bin_0, new_value_t.bin_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: bin_1:8",
              "Each bin has been approximtely scaled to the number of pixels in the image",
              8, old_value_t.bin_1, new_value_t.bin_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: bin_2:8",
              "so that a single quantisation step in a bin represents a fraction of",
              8, old_value_t.bin_2, new_value_t.bin_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: bin_3:8",
              "between 1/256 and 1/128 of the total number of pixels in the image.",
              8, old_value_t.bin_3, new_value_t.bin_3 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_HISTOGRAM_1_OFFSET 0x4D0
#define DISP_SD_HISTOGRAM_1_UNDEFMASK 0x00000000
union disp_sd_histogram_1_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_histogram_1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_histogram_1_u old_value_t = { .reg32 = value };
    const disp_sd_histogram_1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: bin_0:8",
              "Each register contains 4 histogram bins, for a total of 8 x\n4 = 32 bins.",
              8, old_value_t.bin_0, new_value_t.bin_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: bin_1:8",
              "Each bin has been approximtely scaled to the number of pixels in the image",
              8, old_value_t.bin_1, new_value_t.bin_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: bin_2:8",
              "so that a single quantisation step in a bin represents a fraction of",
              8, old_value_t.bin_2, new_value_t.bin_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: bin_3:8",
              "between 1/256 and 1/128 of the total number of pixels in the image.",
              8, old_value_t.bin_3, new_value_t.bin_3 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_HISTOGRAM_2_OFFSET 0x4D1
#define DISP_SD_HISTOGRAM_2_UNDEFMASK 0x00000000
union disp_sd_histogram_2_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_histogram_2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_histogram_2_u old_value_t = { .reg32 = value };
    const disp_sd_histogram_2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: bin_0:8",
              "Each register contains 4 histogram bins, for a total of 8 x\n4 = 32 bins.",
              8, old_value_t.bin_0, new_value_t.bin_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: bin_1:8",
              "Each bin has been approximtely scaled to the number of pixels in the image",
              8, old_value_t.bin_1, new_value_t.bin_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: bin_2:8",
              "so that a single quantisation step in a bin represents a fraction of",
              8, old_value_t.bin_2, new_value_t.bin_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: bin_3:8",
              "between 1/256 and 1/128 of the total number of pixels in the image.",
              8, old_value_t.bin_3, new_value_t.bin_3 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_HISTOGRAM_3_OFFSET 0x4D2
#define DISP_SD_HISTOGRAM_3_UNDEFMASK 0x00000000
union disp_sd_histogram_3_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_histogram_3_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_histogram_3_u old_value_t = { .reg32 = value };
    const disp_sd_histogram_3_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: bin_0:8",
              "Each register contains 4 histogram bins, for a total of 8 x\n4 = 32 bins.",
              8, old_value_t.bin_0, new_value_t.bin_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: bin_1:8",
              "Each bin has been approximtely scaled to the number of pixels in the image",
              8, old_value_t.bin_1, new_value_t.bin_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: bin_2:8",
              "so that a single quantisation step in a bin represents a fraction of",
              8, old_value_t.bin_2, new_value_t.bin_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: bin_3:8",
              "between 1/256 and 1/128 of the total number of pixels in the image.",
              8, old_value_t.bin_3, new_value_t.bin_3 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_HISTOGRAM_4_OFFSET 0x4D3
#define DISP_SD_HISTOGRAM_4_UNDEFMASK 0x00000000
union disp_sd_histogram_4_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_histogram_4_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_histogram_4_u old_value_t = { .reg32 = value };
    const disp_sd_histogram_4_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: bin_0:8",
              "Each register contains 4 histogram bins, for a total of 8 x\n4 = 32 bins.",
              8, old_value_t.bin_0, new_value_t.bin_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: bin_1:8",
              "Each bin has been approximtely scaled to the number of pixels in the image",
              8, old_value_t.bin_1, new_value_t.bin_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: bin_2:8",
              "so that a single quantisation step in a bin represents a fraction of",
              8, old_value_t.bin_2, new_value_t.bin_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: bin_3:8",
              "between 1/256 and 1/128 of the total number of pixels in the image.",
              8, old_value_t.bin_3, new_value_t.bin_3 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_HISTOGRAM_5_OFFSET 0x4D4
#define DISP_SD_HISTOGRAM_5_UNDEFMASK 0x00000000
union disp_sd_histogram_5_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_histogram_5_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_histogram_5_u old_value_t = { .reg32 = value };
    const disp_sd_histogram_5_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: bin_0:8",
              "Each register contains 4 histogram bins, for a total of 8 x\n4 = 32 bins.",
              8, old_value_t.bin_0, new_value_t.bin_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: bin_1:8",
              "Each bin has been approximtely scaled to the number of pixels in the image",
              8, old_value_t.bin_1, new_value_t.bin_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: bin_2:8",
              "so that a single quantisation step in a bin represents a fraction of",
              8, old_value_t.bin_2, new_value_t.bin_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: bin_3:8",
              "between 1/256 and 1/128 of the total number of pixels in the image.",
              8, old_value_t.bin_3, new_value_t.bin_3 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_HISTOGRAM_6_OFFSET 0x4D5
#define DISP_SD_HISTOGRAM_6_UNDEFMASK 0x00000000
union disp_sd_histogram_6_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_histogram_6_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_histogram_6_u old_value_t = { .reg32 = value };
    const disp_sd_histogram_6_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: bin_0:8",
              "Each register contains 4 histogram bins, for a total of 8 x\n4 = 32 bins.",
              8, old_value_t.bin_0, new_value_t.bin_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: bin_1:8",
              "Each bin has been approximtely scaled to the number of pixels in the image",
              8, old_value_t.bin_1, new_value_t.bin_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: bin_2:8",
              "so that a single quantisation step in a bin represents a fraction of",
              8, old_value_t.bin_2, new_value_t.bin_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: bin_3:8",
              "between 1/256 and 1/128 of the total number of pixels in the image.",
              8, old_value_t.bin_3, new_value_t.bin_3 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_HISTOGRAM_7_OFFSET 0x4D6
#define DISP_SD_HISTOGRAM_7_UNDEFMASK 0x00000000
union disp_sd_histogram_7_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_histogram_7_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_histogram_7_u old_value_t = { .reg32 = value };
    const disp_sd_histogram_7_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: bin_0:8",
              "Each register contains 4 histogram bins, for a total of 8 x\n4 = 32 bins.",
              8, old_value_t.bin_0, new_value_t.bin_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: bin_1:8",
              "Each bin has been approximtely scaled to the number of pixels in the image",
              8, old_value_t.bin_1, new_value_t.bin_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: bin_2:8",
              "so that a single quantisation step in a bin represents a fraction of",
              8, old_value_t.bin_2, new_value_t.bin_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: bin_3:8",
              "between 1/256 and 1/128 of the total number of pixels in the image.",
              8, old_value_t.bin_3, new_value_t.bin_3 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_BL_PARAMETERS_OFFSET 0x4D7
#define DISP_SD_BL_PARAMETERS_UNDEFMASK 0xFF00F800
union disp_sd_bl_parameters_u {
    struct {
        unsigned int time_constant:11;      /* The time constant for the response curve. This value represents the fraction by which the value of enhancement value approaches the target value each frame. Example values are shown below:    0 : The value will never reach the target (infinite TC)  512 : The next value will be half-way betwen the current value and the        target value. 1024 : The next value will be 100% of the target value. In other words -        an instantaneous response. */
        unsigned int undefined_bits_11_15:5;
        unsigned int step:8;                /* Determines the instantaneous portion of the target value of enhancement that is applied.   0 =   0% : response is entirely exponential and determined by TIME_CONSTANT 128 =  50% : response will instantly step up by 50% and will then be exponential. 255 = 100% : response is entirely instantaneous. TIME_CONSTANT has no effect. */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_bl_parameters_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_bl_parameters_u old_value_t = { .reg32 = value };
    const disp_sd_bl_parameters_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: time_constant:11",
              "The time constant for the response curve. This value represents the fraction by which the value of enhancement value approaches the target value each frame. Example values are shown below:    0 : The value will never reach the target (infinite TC)  512 : The next value will be half-way betwen the current value and the        target value. 1024 : The next value will be 100% of the target value. In other words -        an instantaneous response.",
              11, old_value_t.time_constant, new_value_t.time_constant };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_15:5", "", 5, old_value_t.undefined_bits_11_15, new_value_t.undefined_bits_11_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: step:8",
              "Determines the instantaneous portion of the target value of enhancement that is applied.\n0 =   0% : response is entirely exponential and determined by TIME_CONSTANT\n128 =  50% : response will instantly step up by 50% and will then be exponential.\n255 = 100% : response is entirely instantaneous. TIME_CONSTANT has no effect.",
              8, old_value_t.step, new_value_t.step };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_BL_TF_OFFSET 0x4D8
#define DISP_SD_BL_TF_UNDEFMASK 0x00000000
union disp_sd_bl_tf_u {
    struct {
        unsigned int point_0:8;             /* Each register contains 4 points on the Transfer Function curve that defines */
        unsigned int point_1:8;             /* how the backlight output changes with respect to the control input. Each point */
        unsigned int point_2:8;             /* defines a value at the vertex of a 16 segment line. The 17th point is defined */
        unsigned int point_3:8;             /* to be the maximum value (it is assumed 100% control == 100% light output). */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_bl_tf_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_bl_tf_u old_value_t = { .reg32 = value };
    const disp_sd_bl_tf_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: point_0:8",
              "Each register contains 4 points on the Transfer Function curve that defines",
              8, old_value_t.point_0, new_value_t.point_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: point_1:8",
              "how the backlight output changes with respect to the control input. Each point",
              8, old_value_t.point_1, new_value_t.point_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: point_2:8",
              "defines a value at the vertex of a 16 segment line. The 17th point is defined",
              8, old_value_t.point_2, new_value_t.point_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: point_3:8",
              "to be the maximum value (it is assumed 100% control == 100% light output).",
              8, old_value_t.point_3, new_value_t.point_3 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_BL_TF_1_OFFSET 0x4D9
#define DISP_SD_BL_TF_1_UNDEFMASK 0x00000000
union disp_sd_bl_tf_1_u {
    struct {
        unsigned int point_0:8;             /* Each register contains 4 points on the Transfer Function curve that defines */
        unsigned int point_1:8;             /* how the backlight output changes with respect to the control input. Each point */
        unsigned int point_2:8;             /* defines a value at the vertex of a 16 segment line. The 17th point is defined */
        unsigned int point_3:8;             /* to be the maximum value (it is assumed 100% control == 100% light output). */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_bl_tf_1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_bl_tf_1_u old_value_t = { .reg32 = value };
    const disp_sd_bl_tf_1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: point_0:8",
              "Each register contains 4 points on the Transfer Function curve that defines",
              8, old_value_t.point_0, new_value_t.point_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: point_1:8",
              "how the backlight output changes with respect to the control input. Each point",
              8, old_value_t.point_1, new_value_t.point_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: point_2:8",
              "defines a value at the vertex of a 16 segment line. The 17th point is defined",
              8, old_value_t.point_2, new_value_t.point_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: point_3:8",
              "to be the maximum value (it is assumed 100% control == 100% light output).",
              8, old_value_t.point_3, new_value_t.point_3 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_BL_TF_2_OFFSET 0x4DA
#define DISP_SD_BL_TF_2_UNDEFMASK 0x00000000
union disp_sd_bl_tf_2_u {
    struct {
        unsigned int point_0:8;             /* Each register contains 4 points on the Transfer Function curve that defines */
        unsigned int point_1:8;             /* how the backlight output changes with respect to the control input. Each point */
        unsigned int point_2:8;             /* defines a value at the vertex of a 16 segment line. The 17th point is defined */
        unsigned int point_3:8;             /* to be the maximum value (it is assumed 100% control == 100% light output). */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_bl_tf_2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_bl_tf_2_u old_value_t = { .reg32 = value };
    const disp_sd_bl_tf_2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: point_0:8",
              "Each register contains 4 points on the Transfer Function curve that defines",
              8, old_value_t.point_0, new_value_t.point_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: point_1:8",
              "how the backlight output changes with respect to the control input. Each point",
              8, old_value_t.point_1, new_value_t.point_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: point_2:8",
              "defines a value at the vertex of a 16 segment line. The 17th point is defined",
              8, old_value_t.point_2, new_value_t.point_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: point_3:8",
              "to be the maximum value (it is assumed 100% control == 100% light output).",
              8, old_value_t.point_3, new_value_t.point_3 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_BL_TF_3_OFFSET 0x4DB
#define DISP_SD_BL_TF_3_UNDEFMASK 0x00000000
union disp_sd_bl_tf_3_u {
    struct {
        unsigned int point_0:8;             /* Each register contains 4 points on the Transfer Function curve that defines */
        unsigned int point_1:8;             /* how the backlight output changes with respect to the control input. Each point */
        unsigned int point_2:8;             /* defines a value at the vertex of a 16 segment line. The 17th point is defined */
        unsigned int point_3:8;             /* to be the maximum value (it is assumed 100% control == 100% light output). */
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_bl_tf_3_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_bl_tf_3_u old_value_t = { .reg32 = value };
    const disp_sd_bl_tf_3_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: point_0:8",
              "Each register contains 4 points on the Transfer Function curve that defines",
              8, old_value_t.point_0, new_value_t.point_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: point_1:8",
              "how the backlight output changes with respect to the control input. Each point",
              8, old_value_t.point_1, new_value_t.point_1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: point_2:8",
              "defines a value at the vertex of a 16 segment line. The 17th point is defined",
              8, old_value_t.point_2, new_value_t.point_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: point_3:8",
              "to be the maximum value (it is assumed 100% control == 100% light output).",
              8, old_value_t.point_3, new_value_t.point_3 };
    m_bit_details_model.bits.append(entry);
}

#define DISP_SD_BL_CONTROL_OFFSET 0x4DC
#define DISP_SD_BL_CONTROL_UNDEFMASK 0xFFFF00FC
union disp_sd_bl_control_u {
    struct {
        unsigned int bl_mode:2;             /* Control Mode:            and adjust the backlight brightness itself. PWM_AUTO : Hardware willadjust the backlight PWM control signal directly using            the value in BRIGHTNESS. * OTHER VALUES ARE RESERVED FOR FUTURE USE * */
        unsigned int undefined_bits_2_7:6;
        unsigned int brightness:8;          /* Backlight brightness modification value. This value is determined by the hardware according to all the other control registers and the image content. The amount by which the backlight should be modified is given as a fraction with 0 representing that the backlight should be off and 255 representing no change in the backlight intensity. Other values vary linearly between these two extremes. Put another way: New BL control = (Old BL control * BRIGHTNESS) / 255 */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void DcDev::fill_disp_sd_bl_control_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const disp_sd_bl_control_u old_value_t = { .reg32 = value };
    const disp_sd_bl_control_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: bl_mode:2",
              "Control Mode:            and adjust the backlight brightness itself. PWM_AUTO : Hardware willadjust the backlight PWM control signal directly using            the value in BRIGHTNESS. * OTHER VALUES ARE RESERVED FOR FUTURE USE *",
              2, old_value_t.bl_mode, new_value_t.bl_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "02: undefined_bits_2_7:6", "", 6, old_value_t.undefined_bits_2_7, new_value_t.undefined_bits_2_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: brightness:8",
              "Backlight brightness modification value. This value is determined by the hardware according to all the other control registers and the image content. The amount by which the backlight should be modified is given as a fraction with 0 representing that the backlight should be off and 255 representing no change in the backlight intensity. Other values vary linearly between these two extremes. Put another way: New BL control = (Old BL control * BRIGHTNESS) / 255",
              8, old_value_t.brightness, new_value_t.brightness };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define WINC_B_COLOR_PALETTE_1_OFFSET 0x1501
#define WINC_B_COLOR_PALETTE_1_UNDEFMASK 0xFF000000
union winc_b_color_palette_1_u {
    struct {
        unsigned int b_color_palette_r:8;   /* Red Color Palette */
        unsigned int b_color_palette_g:8;   /* Green Color Palette */
        unsigned int b_color_palette_b:8;   /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_color_palette_1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_color_palette_1_u old_value_t = { .reg32 = value };
    const winc_b_color_palette_1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_color_palette_r:8",
              "Red Color Palette",
              8, old_value_t.b_color_palette_r, new_value_t.b_color_palette_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_color_palette_g:8",
              "Green Color Palette",
              8, old_value_t.b_color_palette_g, new_value_t.b_color_palette_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_color_palette_b:8",
              "Blue Color Palette",
              8, old_value_t.b_color_palette_b, new_value_t.b_color_palette_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define WINC_B_COLOR_PALETTE_2_OFFSET 0x1502
#define WINC_B_COLOR_PALETTE_2_UNDEFMASK 0xFF000000
union winc_b_color_palette_2_u {
    struct {
        unsigned int b_color_palette_r:8;   /* Red Color Palette */
        unsigned int b_color_palette_g:8;   /* Green Color Palette */
        unsigned int b_color_palette_b:8;   /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_color_palette_2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_color_palette_2_u old_value_t = { .reg32 = value };
    const winc_b_color_palette_2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_color_palette_r:8",
              "Red Color Palette",
              8, old_value_t.b_color_palette_r, new_value_t.b_color_palette_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_color_palette_g:8",
              "Green Color Palette",
              8, old_value_t.b_color_palette_g, new_value_t.b_color_palette_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_color_palette_b:8",
              "Blue Color Palette",
              8, old_value_t.b_color_palette_b, new_value_t.b_color_palette_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define WINC_B_COLOR_PALETTE_3_OFFSET 0x1503
#define WINC_B_COLOR_PALETTE_3_UNDEFMASK 0xFF000000
union winc_b_color_palette_3_u {
    struct {
        unsigned int b_color_palette_r:8;   /* Red Color Palette */
        unsigned int b_color_palette_g:8;   /* Green Color Palette */
        unsigned int b_color_palette_b:8;   /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_color_palette_3_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_color_palette_3_u old_value_t = { .reg32 = value };
    const winc_b_color_palette_3_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_color_palette_r:8",
              "Red Color Palette",
              8, old_value_t.b_color_palette_r, new_value_t.b_color_palette_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_color_palette_g:8",
              "Green Color Palette",
              8, old_value_t.b_color_palette_g, new_value_t.b_color_palette_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_color_palette_b:8",
              "Blue Color Palette",
              8, old_value_t.b_color_palette_b, new_value_t.b_color_palette_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define WINC_B_COLOR_PALETTE_4_OFFSET 0x1504
#define WINC_B_COLOR_PALETTE_4_UNDEFMASK 0xFF000000
union winc_b_color_palette_4_u {
    struct {
        unsigned int b_color_palette_r:8;   /* Red Color Palette */
        unsigned int b_color_palette_g:8;   /* Green Color Palette */
        unsigned int b_color_palette_b:8;   /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_color_palette_4_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_color_palette_4_u old_value_t = { .reg32 = value };
    const winc_b_color_palette_4_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_color_palette_r:8",
              "Red Color Palette",
              8, old_value_t.b_color_palette_r, new_value_t.b_color_palette_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_color_palette_g:8",
              "Green Color Palette",
              8, old_value_t.b_color_palette_g, new_value_t.b_color_palette_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_color_palette_b:8",
              "Blue Color Palette",
              8, old_value_t.b_color_palette_b, new_value_t.b_color_palette_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define WINC_B_COLOR_PALETTE_5_OFFSET 0x1505
#define WINC_B_COLOR_PALETTE_5_UNDEFMASK 0xFF000000
union winc_b_color_palette_5_u {
    struct {
        unsigned int b_color_palette_r:8;   /* Red Color Palette */
        unsigned int b_color_palette_g:8;   /* Green Color Palette */
        unsigned int b_color_palette_b:8;   /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_color_palette_5_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_color_palette_5_u old_value_t = { .reg32 = value };
    const winc_b_color_palette_5_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_color_palette_r:8",
              "Red Color Palette",
              8, old_value_t.b_color_palette_r, new_value_t.b_color_palette_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_color_palette_g:8",
              "Green Color Palette",
              8, old_value_t.b_color_palette_g, new_value_t.b_color_palette_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_color_palette_b:8",
              "Blue Color Palette",
              8, old_value_t.b_color_palette_b, new_value_t.b_color_palette_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define WINC_B_COLOR_PALETTE_6_OFFSET 0x1506
#define WINC_B_COLOR_PALETTE_6_UNDEFMASK 0xFF000000
union winc_b_color_palette_6_u {
    struct {
        unsigned int b_color_palette_r:8;   /* Red Color Palette */
        unsigned int b_color_palette_g:8;   /* Green Color Palette */
        unsigned int b_color_palette_b:8;   /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_color_palette_6_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_color_palette_6_u old_value_t = { .reg32 = value };
    const winc_b_color_palette_6_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_color_palette_r:8",
              "Red Color Palette",
              8, old_value_t.b_color_palette_r, new_value_t.b_color_palette_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_color_palette_g:8",
              "Green Color Palette",
              8, old_value_t.b_color_palette_g, new_value_t.b_color_palette_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_color_palette_b:8",
              "Blue Color Palette",
              8, old_value_t.b_color_palette_b, new_value_t.b_color_palette_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define WINC_B_COLOR_PALETTE_7_OFFSET 0x1507
#define WINC_B_COLOR_PALETTE_7_UNDEFMASK 0xFF000000
union winc_b_color_palette_7_u {
    struct {
        unsigned int b_color_palette_r:8;   /* Red Color Palette */
        unsigned int b_color_palette_g:8;   /* Green Color Palette */
        unsigned int b_color_palette_b:8;   /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_color_palette_7_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_color_palette_7_u old_value_t = { .reg32 = value };
    const winc_b_color_palette_7_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_color_palette_r:8",
              "Red Color Palette",
              8, old_value_t.b_color_palette_r, new_value_t.b_color_palette_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_color_palette_g:8",
              "Green Color Palette",
              8, old_value_t.b_color_palette_g, new_value_t.b_color_palette_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_color_palette_b:8",
              "Blue Color Palette",
              8, old_value_t.b_color_palette_b, new_value_t.b_color_palette_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define WINC_B_COLOR_PALETTE_8_OFFSET 0x1508
#define WINC_B_COLOR_PALETTE_8_UNDEFMASK 0xFF000000
union winc_b_color_palette_8_u {
    struct {
        unsigned int b_color_palette_r:8;   /* Red Color Palette */
        unsigned int b_color_palette_g:8;   /* Green Color Palette */
        unsigned int b_color_palette_b:8;   /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_color_palette_8_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_color_palette_8_u old_value_t = { .reg32 = value };
    const winc_b_color_palette_8_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_color_palette_r:8",
              "Red Color Palette",
              8, old_value_t.b_color_palette_r, new_value_t.b_color_palette_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_color_palette_g:8",
              "Green Color Palette",
              8, old_value_t.b_color_palette_g, new_value_t.b_color_palette_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_color_palette_b:8",
              "Blue Color Palette",
              8, old_value_t.b_color_palette_b, new_value_t.b_color_palette_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define WINC_B_COLOR_PALETTE_9_OFFSET 0x1509
#define WINC_B_COLOR_PALETTE_9_UNDEFMASK 0xFF000000
union winc_b_color_palette_9_u {
    struct {
        unsigned int b_color_palette_r:8;   /* Red Color Palette */
        unsigned int b_color_palette_g:8;   /* Green Color Palette */
        unsigned int b_color_palette_b:8;   /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void DcDev::fill_winc_b_color_palette_9_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const winc_b_color_palette_9_u old_value_t = { .reg32 = value };
    const winc_b_color_palette_9_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: b_color_palette_r:8",
              "Red Color Palette",
              8, old_value_t.b_color_palette_r, new_value_t.b_color_palette_r };
    m_bit_details_model.bits.append(entry);
    entry = { "08: b_color_palette_g:8",
              "Green Color Palette",
              8, old_value_t.b_color_palette_g, new_value_t.b_color_palette_g };
    m_bit_details_model.bits.append(entry);
    entry = { "16: b_color_palette_b:8",
              "Blue Color Palette",
              8, old_value_t.b_color_palette_b, new_value_t.b_color_palette_b };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

bool DcDev::is_offset_valid(const u_int32_t &offset) const
{
    switch (offset) {
    case CMD_GENERAL_INCR_SYNCPT_OFFSET:
    case CMD_GENERAL_INCR_SYNCPT_CNTRL_OFFSET:
    case CMD_GENERAL_INCR_SYNCPT_ERROR_OFFSET:
    case CMD_WIN_A_INCR_SYNCPT_OFFSET:
    case CMD_WIN_A_INCR_SYNCPT_CNTRL_OFFSET:
    case CMD_WIN_A_INCR_SYNCPT_ERROR_OFFSET:
    case CMD_WIN_B_INCR_SYNCPT_OFFSET:
    case CMD_WIN_B_INCR_SYNCPT_CNTRL_OFFSET:
    case CMD_WIN_B_INCR_SYNCPT_ERROR_OFFSET:
    case CMD_WIN_C_INCR_SYNCPT_OFFSET:
    case CMD_WIN_C_INCR_SYNCPT_CNTRL_OFFSET:
    case CMD_WIN_C_INCR_SYNCPT_ERROR_OFFSET:
    case CMD_CONT_SYNCPT_VSYNC_OFFSET:
    case CMD_CTXSW_OFFSET:
    case CMD_DISPLAY_COMMAND_OPTION0_OFFSET:
    case CMD_DISPLAY_COMMAND_OFFSET:
    case CMD_SIGNAL_RAISE_OFFSET:
    case CMD_DISPLAY_POWER_CONTROL_OFFSET:
    case CMD_INT_STATUS_OFFSET:
    case CMD_INT_MASK_OFFSET:
    case CMD_INT_ENABLE_OFFSET:
    case CMD_INT_TYPE_OFFSET:
    case CMD_INT_POLARITY_OFFSET:
    case CMD_SIGNAL_RAISE1_OFFSET:
    case CMD_SIGNAL_RAISE2_OFFSET:
    case CMD_SIGNAL_RAISE3_OFFSET:
    case CMD_STATE_ACCESS_OFFSET:
    case CMD_STATE_CONTROL_OFFSET:
    case CMD_DISPLAY_WINDOW_HEADER_OFFSET:
    case CMD_REG_ACT_CONTROL_OFFSET:
    case COM_CRC_CONTROL_OFFSET:
    case COM_CRC_CHECKSUM_OFFSET:
    case COM_PIN_OUTPUT_ENABLE0_OFFSET:
    case COM_PIN_OUTPUT_ENABLE1_OFFSET:
    case COM_PIN_OUTPUT_ENABLE2_OFFSET:
    case COM_PIN_OUTPUT_ENABLE3_OFFSET:
    case COM_PIN_OUTPUT_POLARITY0_OFFSET:
    case COM_PIN_OUTPUT_POLARITY1_OFFSET:
    case COM_PIN_OUTPUT_POLARITY2_OFFSET:
    case COM_PIN_OUTPUT_POLARITY3_OFFSET:
    case COM_PIN_OUTPUT_DATA0_OFFSET:
    case COM_PIN_OUTPUT_DATA1_OFFSET:
    case COM_PIN_OUTPUT_DATA2_OFFSET:
    case COM_PIN_OUTPUT_DATA3_OFFSET:
    case COM_PIN_INPUT_ENABLE0_OFFSET:
    case COM_PIN_INPUT_ENABLE1_OFFSET:
    case COM_PIN_INPUT_ENABLE2_OFFSET:
    case COM_PIN_INPUT_ENABLE3_OFFSET:
    case COM_PIN_INPUT_DATA0_OFFSET:
    case COM_PIN_INPUT_DATA1_OFFSET:
    case COM_PIN_OUTPUT_SELECT0_OFFSET:
    case COM_PIN_OUTPUT_SELECT1_OFFSET:
    case COM_PIN_OUTPUT_SELECT2_OFFSET:
    case COM_PIN_OUTPUT_SELECT3_OFFSET:
    case COM_PIN_OUTPUT_SELECT4_OFFSET:
    case COM_PIN_OUTPUT_SELECT5_OFFSET:
    case COM_PIN_OUTPUT_SELECT6_OFFSET:
    case COM_PIN_MISC_CONTROL_OFFSET:
    case COM_PM0_CONTROL_OFFSET:
    case COM_PM0_DUTY_CYCLE_OFFSET:
    case COM_PM1_CONTROL_OFFSET:
    case COM_PM1_DUTY_CYCLE_OFFSET:
    case COM_SPI_CONTROL_OFFSET:
    case COM_SPI_START_BYTE_OFFSET:
    case COM_HSPI_WRITE_DATA_AB_OFFSET:
    case COM_HSPI_WRITE_DATA_CD_OFFSET:
    case COM_HSPI_CS_DC_OFFSET:
    case COM_SCRATCH_REGISTER_A_OFFSET:
    case COM_SCRATCH_REGISTER_B_OFFSET:
    case COM_GPIO_CTRL_OFFSET:
    case COM_GPIO_DEBOUNCE_COUNTER_OFFSET:
    case COM_CRC_CHECKSUM_LATCHED_OFFSET:
    case DISP_DISP_SIGNAL_OPTIONS0_OFFSET:
    case DISP_DISP_SIGNAL_OPTIONS1_OFFSET:
    case DISP_DISP_WIN_OPTIONS_OFFSET:
    case DISP_MEM_HIGH_PRIORITY_OFFSET:
    case DISP_MEM_HIGH_PRIORITY_TIMER_OFFSET:
    case DISP_DISP_TIMING_OPTIONS_OFFSET:
    case DISP_REF_TO_SYNC_OFFSET:
    case DISP_SYNC_WIDTH_OFFSET:
    case DISP_BACK_PORCH_OFFSET:
    case DISP_DISP_ACTIVE_OFFSET:
    case DISP_FRONT_PORCH_OFFSET:
    case DISP_H_PULSE0_CONTROL_OFFSET:
    case DISP_H_PULSE0_POSITION_A_OFFSET:
    case DISP_H_PULSE0_POSITION_B_OFFSET:
    case DISP_H_PULSE0_POSITION_C_OFFSET:
    case DISP_H_PULSE0_POSITION_D_OFFSET:
    case DISP_H_PULSE1_CONTROL_OFFSET:
    case DISP_H_PULSE1_POSITION_A_OFFSET:
    case DISP_H_PULSE1_POSITION_B_OFFSET:
    case DISP_H_PULSE1_POSITION_C_OFFSET:
    case DISP_H_PULSE1_POSITION_D_OFFSET:
    case DISP_H_PULSE2_CONTROL_OFFSET:
    case DISP_H_PULSE2_POSITION_A_OFFSET:
    case DISP_H_PULSE2_POSITION_B_OFFSET:
    case DISP_H_PULSE2_POSITION_C_OFFSET:
    case DISP_H_PULSE2_POSITION_D_OFFSET:
    case DISP_V_PULSE0_CONTROL_OFFSET:
    case DISP_V_PULSE0_POSITION_A_OFFSET:
    case DISP_V_PULSE0_POSITION_B_OFFSET:
    case DISP_V_PULSE0_POSITION_C_OFFSET:
    case DISP_V_PULSE1_CONTROL_OFFSET:
    case DISP_V_PULSE1_POSITION_A_OFFSET:
    case DISP_V_PULSE1_POSITION_B_OFFSET:
    case DISP_V_PULSE1_POSITION_C_OFFSET:
    case DISP_V_PULSE2_CONTROL_OFFSET:
    case DISP_V_PULSE2_POSITION_A_OFFSET:
    case DISP_V_PULSE3_CONTROL_OFFSET:
    case DISP_V_PULSE3_POSITION_A_OFFSET:
    case DISP_M0_CONTROL_OFFSET:
    case DISP_M1_CONTROL_OFFSET:
    case DISP_DI_CONTROL_OFFSET:
    case DISP_PP_CONTROL_OFFSET:
    case DISP_PP_SELECT_A_OFFSET:
    case DISP_PP_SELECT_B_OFFSET:
    case DISP_PP_SELECT_C_OFFSET:
    case DISP_PP_SELECT_D_OFFSET:
    case DISP_DISP_CLOCK_CONTROL_OFFSET:
    case DISP_DISP_INTERFACE_CONTROL_OFFSET:
    case DISP_DISP_COLOR_CONTROL_OFFSET:
    case DISP_SHIFT_CLOCK_OPTIONS_OFFSET:
    case DISP_DATA_ENABLE_OPTIONS_OFFSET:
    case DISP_SERIAL_INTERFACE_OPTIONS_OFFSET:
    case DISP_LCD_SPI_OPTIONS_OFFSET:
    case DISP_BORDER_COLOR_OFFSET:
    case DISP_COLOR_KEY0_LOWER_OFFSET:
    case DISP_COLOR_KEY0_UPPER_OFFSET:
    case DISP_COLOR_KEY1_LOWER_OFFSET:
    case DISP_COLOR_KEY1_UPPER_OFFSET:
    case DISP_CURSOR_FOREGROUND_OFFSET:
    case DISP_CURSOR_BACKGROUND_OFFSET:
    case DISP_CURSOR_START_ADDR_OFFSET:
    case DISP_CURSOR_START_ADDR_NS_OFFSET:
    case DISP_CURSOR_POSITION_OFFSET:
    case DISP_CURSOR_POSITION_NS_OFFSET:
    case DISP_INIT_SEQ_CONTROL_OFFSET:
    case DISP_SPI_INIT_SEQ_DATA_A_OFFSET:
    case DISP_SPI_INIT_SEQ_DATA_B_OFFSET:
    case DISP_SPI_INIT_SEQ_DATA_C_OFFSET:
    case DISP_SPI_INIT_SEQ_DATA_D_OFFSET:
    case DISP_DC_MCCIF_FIFOCTRL_OFFSET:
    case DISP_MCCIF_DISPLAY0A_HYST_OFFSET:
    case DISP_MCCIF_DISPLAY0B_HYST_OFFSET:
    case DISP_MCCIF_DISPLAY0C_HYST_OFFSET:
    case DISP_MCCIF_DISPLAY1B_HYST_OFFSET:
    case DISP_DAC_CRT_CTRL_OFFSET:
    case DISP_DISP_MISC_CONTROL_OFFSET:
    case WINC_A_COLOR_PALETTE_OFFSET:
    case WINC_A_PALETTE_COLOR_EXT_OFFSET:
    case WIN_A_WIN_OPTIONS_OFFSET:
    case WIN_A_BYTE_SWAP_OFFSET:
    case WIN_A_BUFFER_CONTROL_OFFSET:
    case WIN_A_COLOR_DEPTH_OFFSET:
    case WIN_A_POSITION_OFFSET:
    case WIN_A_SIZE_OFFSET:
    case WIN_A_PRESCALED_SIZE_OFFSET:
    case WIN_A_H_INITIAL_DDA_OFFSET:
    case WIN_A_V_INITIAL_DDA_OFFSET:
    case WIN_A_DDA_INCREMENT_OFFSET:
    case WIN_A_LINE_STRIDE_OFFSET:
    case WIN_A_BUF_STRIDE_OFFSET:
    case WIN_A_BUFFER_ADDR_MODE_OFFSET:
    case WIN_A_DV_CONTROL_OFFSET:
    case WIN_A_BLEND_NOKEY_OFFSET:
    case WIN_A_BLEND_1WIN_OFFSET:
    case WIN_A_BLEND_2WIN_B_OFFSET:
    case WIN_A_BLEND_2WIN_C_OFFSET:
    case WIN_A_BLEND_3WIN_BC_OFFSET:
    case WIN_A_HP_FETCH_CONTROL_OFFSET:
    case WINBUF_A_START_ADDR_OFFSET:
    case WINBUF_A_START_ADDR_NS_OFFSET:
    case WINBUF_A_ADDR_H_OFFSET_OFFSET:
    case WINBUF_A_ADDR_H_OFFSET_NS_OFFSET:
    case WINBUF_A_ADDR_V_OFFSET_OFFSET:
    case WINBUF_A_ADDR_V_OFFSET_NS_OFFSET:
    case WINBUF_A_UFLOW_STATUS_OFFSET:
    case WINC_B_COLOR_PALETTE_OFFSET:
    case WINC_B_PALETTE_COLOR_EXT_OFFSET:
    case WINC_B_H_FILTER_P00_OFFSET:
    case WINC_B_H_FILTER_P01_OFFSET:
    case WINC_B_H_FILTER_P02_OFFSET:
    case WINC_B_H_FILTER_P03_OFFSET:
    case WINC_B_H_FILTER_P04_OFFSET:
    case WINC_B_H_FILTER_P05_OFFSET:
    case WINC_B_H_FILTER_P06_OFFSET:
    case WINC_B_H_FILTER_P07_OFFSET:
    case WINC_B_H_FILTER_P08_OFFSET:
    case WINC_B_H_FILTER_P09_OFFSET:
    case WINC_B_H_FILTER_P0A_OFFSET:
    case WINC_B_H_FILTER_P0B_OFFSET:
    case WINC_B_H_FILTER_P0C_OFFSET:
    case WINC_B_H_FILTER_P0D_OFFSET:
    case WINC_B_H_FILTER_P0E_OFFSET:
    case WINC_B_H_FILTER_P0F_OFFSET:
    case WINC_B_CSC_YOF_OFFSET:
    case WINC_B_CSC_KYRGB_OFFSET:
    case WINC_B_CSC_KUR_OFFSET:
    case WINC_B_CSC_KVR_OFFSET:
    case WINC_B_CSC_KUG_OFFSET:
    case WINC_B_CSC_KVG_OFFSET:
    case WINC_B_CSC_KUB_OFFSET:
    case WINC_B_CSC_KVB_OFFSET:
    case WINC_B_V_FILTER_P00_OFFSET:
    case WINC_B_V_FILTER_P01_OFFSET:
    case WINC_B_V_FILTER_P02_OFFSET:
    case WINC_B_V_FILTER_P03_OFFSET:
    case WINC_B_V_FILTER_P04_OFFSET:
    case WINC_B_V_FILTER_P05_OFFSET:
    case WINC_B_V_FILTER_P06_OFFSET:
    case WINC_B_V_FILTER_P07_OFFSET:
    case WINC_B_V_FILTER_P08_OFFSET:
    case WINC_B_V_FILTER_P09_OFFSET:
    case WINC_B_V_FILTER_P0A_OFFSET:
    case WINC_B_V_FILTER_P0B_OFFSET:
    case WINC_B_V_FILTER_P0C_OFFSET:
    case WINC_B_V_FILTER_P0D_OFFSET:
    case WINC_B_V_FILTER_P0E_OFFSET:
    case WINC_B_V_FILTER_P0F_OFFSET:
    case WIN_B_WIN_OPTIONS_OFFSET:
    case WIN_B_BYTE_SWAP_OFFSET:
    case WIN_B_BUFFER_CONTROL_OFFSET:
    case WIN_B_COLOR_DEPTH_OFFSET:
    case WIN_B_POSITION_OFFSET:
    case WIN_B_SIZE_OFFSET:
    case WIN_B_PRESCALED_SIZE_OFFSET:
    case WIN_B_H_INITIAL_DDA_OFFSET:
    case WIN_B_V_INITIAL_DDA_OFFSET:
    case WIN_B_DDA_INCREMENT_OFFSET:
    case WIN_B_LINE_STRIDE_OFFSET:
    case WIN_B_BUF_STRIDE_OFFSET:
    case WIN_B_UV_BUF_STRIDE_OFFSET:
    case WIN_B_BUFFER_ADDR_MODE_OFFSET:
    case WIN_B_DV_CONTROL_OFFSET:
    case WIN_B_BLEND_NOKEY_OFFSET:
    case WIN_B_BLEND_1WIN_OFFSET:
    case WIN_B_BLEND_2WIN_A_OFFSET:
    case WIN_B_BLEND_2WIN_C_OFFSET:
    case WIN_B_BLEND_3WIN_AC_OFFSET:
    case WIN_B_HP_FETCH_CONTROL_OFFSET:
    case WINBUF_B_START_ADDR_OFFSET:
    case WINBUF_B_START_ADDR_NS_OFFSET:
    case WINBUF_B_START_ADDR_U_OFFSET:
    case WINBUF_B_START_ADDR_U_NS_OFFSET:
    case WINBUF_B_START_ADDR_V_OFFSET:
    case WINBUF_B_START_ADDR_V_NS_OFFSET:
    case WINBUF_B_ADDR_H_OFFSET_OFFSET:
    case WINBUF_B_ADDR_H_OFFSET_NS_OFFSET:
    case WINBUF_B_ADDR_V_OFFSET_OFFSET:
    case WINBUF_B_ADDR_V_OFFSET_NS_OFFSET:
    case WINBUF_B_UFLOW_STATUS_OFFSET:
    case WINC_C_COLOR_PALETTE_OFFSET:
    case WINC_C_PALETTE_COLOR_EXT_OFFSET:
    case WINC_C_H_FILTER_P00_OFFSET:
    case WINC_C_H_FILTER_P01_OFFSET:
    case WINC_C_H_FILTER_P02_OFFSET:
    case WINC_C_H_FILTER_P03_OFFSET:
    case WINC_C_H_FILTER_P04_OFFSET:
    case WINC_C_H_FILTER_P05_OFFSET:
    case WINC_C_H_FILTER_P06_OFFSET:
    case WINC_C_H_FILTER_P07_OFFSET:
    case WINC_C_H_FILTER_P08_OFFSET:
    case WINC_C_H_FILTER_P09_OFFSET:
    case WINC_C_H_FILTER_P0A_OFFSET:
    case WINC_C_H_FILTER_P0B_OFFSET:
    case WINC_C_H_FILTER_P0C_OFFSET:
    case WINC_C_H_FILTER_P0D_OFFSET:
    case WINC_C_H_FILTER_P0E_OFFSET:
    case WINC_C_H_FILTER_P0F_OFFSET:
    case WINC_C_CSC_YOF_OFFSET:
    case WINC_C_CSC_KYRGB_OFFSET:
    case WINC_C_CSC_KUR_OFFSET:
    case WINC_C_CSC_KVR_OFFSET:
    case WINC_C_CSC_KUG_OFFSET:
    case WINC_C_CSC_KVG_OFFSET:
    case WINC_C_CSC_KUB_OFFSET:
    case WINC_C_CSC_KVB_OFFSET:
    case WIN_C_WIN_OPTIONS_OFFSET:
    case WIN_C_BYTE_SWAP_OFFSET:
    case WIN_C_BUFFER_CONTROL_OFFSET:
    case WIN_C_COLOR_DEPTH_OFFSET:
    case WIN_C_POSITION_OFFSET:
    case WIN_C_SIZE_OFFSET:
    case WIN_C_PRESCALED_SIZE_OFFSET:
    case WIN_C_H_INITIAL_DDA_OFFSET:
    case WIN_C_V_INITIAL_DDA_OFFSET:
    case WIN_C_DDA_INCREMENT_OFFSET:
    case WIN_C_LINE_STRIDE_OFFSET:
    case WIN_C_BUF_STRIDE_OFFSET:
    case WIN_C_UV_BUF_STRIDE_OFFSET:
    case WIN_C_BUFFER_ADDR_MODE_OFFSET:
    case WIN_C_DV_CONTROL_OFFSET:
    case WIN_C_BLEND_NOKEY_OFFSET:
    case WIN_C_BLEND_1WIN_OFFSET:
    case WIN_C_BLEND_2WIN_A_OFFSET:
    case WIN_C_BLEND_2WIN_B_OFFSET:
    case WIN_C_BLEND_3WIN_AB_OFFSET:
    case WIN_C_HP_FETCH_CONTROL_OFFSET:
    case WINBUF_C_START_ADDR_OFFSET:
    case WINBUF_C_START_ADDR_NS_OFFSET:
    case WINBUF_C_START_ADDR_U_OFFSET:
    case WINBUF_C_START_ADDR_U_NS_OFFSET:
    case WINBUF_C_START_ADDR_V_OFFSET:
    case WINBUF_C_START_ADDR_V_NS_OFFSET:
    case WINBUF_C_ADDR_H_OFFSET_OFFSET:
    case WINBUF_C_ADDR_H_OFFSET_NS_OFFSET:
    case WINBUF_C_ADDR_V_OFFSET_OFFSET:
    case WINBUF_C_ADDR_V_OFFSET_NS_OFFSET:
    case WINBUF_C_UFLOW_STATUS_OFFSET:
    case DISP_SD_CONTROL_OFFSET:
    case DISP_SD_CSC_COEFF_OFFSET:
    case DISP_SD_LUT_OFFSET:
    case DISP_SD_LUT_1_OFFSET:
    case DISP_SD_LUT_2_OFFSET:
    case DISP_SD_LUT_3_OFFSET:
    case DISP_SD_LUT_4_OFFSET:
    case DISP_SD_LUT_5_OFFSET:
    case DISP_SD_LUT_6_OFFSET:
    case DISP_SD_LUT_7_OFFSET:
    case DISP_SD_LUT_8_OFFSET:
    case DISP_SD_FLICKER_CONTROL_OFFSET:
    case DISP_SD_PIXEL_COUNT_OFFSET:
    case DISP_SD_HISTOGRAM_OFFSET:
    case DISP_SD_HISTOGRAM_1_OFFSET:
    case DISP_SD_HISTOGRAM_2_OFFSET:
    case DISP_SD_HISTOGRAM_3_OFFSET:
    case DISP_SD_HISTOGRAM_4_OFFSET:
    case DISP_SD_HISTOGRAM_5_OFFSET:
    case DISP_SD_HISTOGRAM_6_OFFSET:
    case DISP_SD_HISTOGRAM_7_OFFSET:
    case DISP_SD_BL_PARAMETERS_OFFSET:
    case DISP_SD_BL_TF_OFFSET:
    case DISP_SD_BL_TF_1_OFFSET:
    case DISP_SD_BL_TF_2_OFFSET:
    case DISP_SD_BL_TF_3_OFFSET:
    case DISP_SD_BL_CONTROL_OFFSET:
    case WINC_B_COLOR_PALETTE_1_OFFSET:
    case WINC_B_COLOR_PALETTE_2_OFFSET:
    case WINC_B_COLOR_PALETTE_3_OFFSET:
    case WINC_B_COLOR_PALETTE_4_OFFSET:
    case WINC_B_COLOR_PALETTE_5_OFFSET:
    case WINC_B_COLOR_PALETTE_6_OFFSET:
    case WINC_B_COLOR_PALETTE_7_OFFSET:
    case WINC_B_COLOR_PALETTE_8_OFFSET:
    case WINC_B_COLOR_PALETTE_9_OFFSET:
        return true;
    default:
        break;
    }

    return false;
}

bool DcDev::is_undef_changed(const u_int32_t &offset,
                                           const u_int32_t &value,
                                           const u_int32_t &new_value) const
{
    switch (offset) {
    case CMD_GENERAL_INCR_SYNCPT_OFFSET:
        if ((value ^ new_value) & CMD_GENERAL_INCR_SYNCPT_UNDEFMASK)
            return true;
        break;
    case CMD_GENERAL_INCR_SYNCPT_CNTRL_OFFSET:
        if ((value ^ new_value) & CMD_GENERAL_INCR_SYNCPT_CNTRL_UNDEFMASK)
            return true;
        break;
    case CMD_GENERAL_INCR_SYNCPT_ERROR_OFFSET:
        if ((value ^ new_value) & CMD_GENERAL_INCR_SYNCPT_ERROR_UNDEFMASK)
            return true;
        break;
    case CMD_WIN_A_INCR_SYNCPT_OFFSET:
        if ((value ^ new_value) & CMD_WIN_A_INCR_SYNCPT_UNDEFMASK)
            return true;
        break;
    case CMD_WIN_A_INCR_SYNCPT_CNTRL_OFFSET:
        if ((value ^ new_value) & CMD_WIN_A_INCR_SYNCPT_CNTRL_UNDEFMASK)
            return true;
        break;
    case CMD_WIN_A_INCR_SYNCPT_ERROR_OFFSET:
        if ((value ^ new_value) & CMD_WIN_A_INCR_SYNCPT_ERROR_UNDEFMASK)
            return true;
        break;
    case CMD_WIN_B_INCR_SYNCPT_OFFSET:
        if ((value ^ new_value) & CMD_WIN_B_INCR_SYNCPT_UNDEFMASK)
            return true;
        break;
    case CMD_WIN_B_INCR_SYNCPT_CNTRL_OFFSET:
        if ((value ^ new_value) & CMD_WIN_B_INCR_SYNCPT_CNTRL_UNDEFMASK)
            return true;
        break;
    case CMD_WIN_B_INCR_SYNCPT_ERROR_OFFSET:
        if ((value ^ new_value) & CMD_WIN_B_INCR_SYNCPT_ERROR_UNDEFMASK)
            return true;
        break;
    case CMD_WIN_C_INCR_SYNCPT_OFFSET:
        if ((value ^ new_value) & CMD_WIN_C_INCR_SYNCPT_UNDEFMASK)
            return true;
        break;
    case CMD_WIN_C_INCR_SYNCPT_CNTRL_OFFSET:
        if ((value ^ new_value) & CMD_WIN_C_INCR_SYNCPT_CNTRL_UNDEFMASK)
            return true;
        break;
    case CMD_WIN_C_INCR_SYNCPT_ERROR_OFFSET:
        if ((value ^ new_value) & CMD_WIN_C_INCR_SYNCPT_ERROR_UNDEFMASK)
            return true;
        break;
    case CMD_CONT_SYNCPT_VSYNC_OFFSET:
        if ((value ^ new_value) & CMD_CONT_SYNCPT_VSYNC_UNDEFMASK)
            return true;
        break;
    case CMD_CTXSW_OFFSET:
        if ((value ^ new_value) & CMD_CTXSW_UNDEFMASK)
            return true;
        break;
    case CMD_DISPLAY_COMMAND_OPTION0_OFFSET:
        if ((value ^ new_value) & CMD_DISPLAY_COMMAND_OPTION0_UNDEFMASK)
            return true;
        break;
    case CMD_DISPLAY_COMMAND_OFFSET:
        if ((value ^ new_value) & CMD_DISPLAY_COMMAND_UNDEFMASK)
            return true;
        break;
    case CMD_SIGNAL_RAISE_OFFSET:
        if ((value ^ new_value) & CMD_SIGNAL_RAISE_UNDEFMASK)
            return true;
        break;
    case CMD_DISPLAY_POWER_CONTROL_OFFSET:
        if ((value ^ new_value) & CMD_DISPLAY_POWER_CONTROL_UNDEFMASK)
            return true;
        break;
    case CMD_INT_STATUS_OFFSET:
        if ((value ^ new_value) & CMD_INT_STATUS_UNDEFMASK)
            return true;
        break;
    case CMD_INT_MASK_OFFSET:
        if ((value ^ new_value) & CMD_INT_MASK_UNDEFMASK)
            return true;
        break;
    case CMD_INT_ENABLE_OFFSET:
        if ((value ^ new_value) & CMD_INT_ENABLE_UNDEFMASK)
            return true;
        break;
    case CMD_INT_TYPE_OFFSET:
        if ((value ^ new_value) & CMD_INT_TYPE_UNDEFMASK)
            return true;
        break;
    case CMD_INT_POLARITY_OFFSET:
        if ((value ^ new_value) & CMD_INT_POLARITY_UNDEFMASK)
            return true;
        break;
    case CMD_SIGNAL_RAISE1_OFFSET:
        if ((value ^ new_value) & CMD_SIGNAL_RAISE1_UNDEFMASK)
            return true;
        break;
    case CMD_SIGNAL_RAISE2_OFFSET:
        if ((value ^ new_value) & CMD_SIGNAL_RAISE2_UNDEFMASK)
            return true;
        break;
    case CMD_SIGNAL_RAISE3_OFFSET:
        if ((value ^ new_value) & CMD_SIGNAL_RAISE3_UNDEFMASK)
            return true;
        break;
    case CMD_STATE_ACCESS_OFFSET:
        if ((value ^ new_value) & CMD_STATE_ACCESS_UNDEFMASK)
            return true;
        break;
    case CMD_STATE_CONTROL_OFFSET:
        if ((value ^ new_value) & CMD_STATE_CONTROL_UNDEFMASK)
            return true;
        break;
    case CMD_DISPLAY_WINDOW_HEADER_OFFSET:
        if ((value ^ new_value) & CMD_DISPLAY_WINDOW_HEADER_UNDEFMASK)
            return true;
        break;
    case CMD_REG_ACT_CONTROL_OFFSET:
        if ((value ^ new_value) & CMD_REG_ACT_CONTROL_UNDEFMASK)
            return true;
        break;
    case COM_CRC_CONTROL_OFFSET:
        if ((value ^ new_value) & COM_CRC_CONTROL_UNDEFMASK)
            return true;
        break;
    case COM_CRC_CHECKSUM_OFFSET:
        if ((value ^ new_value) & COM_CRC_CHECKSUM_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_ENABLE0_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_ENABLE0_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_ENABLE1_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_ENABLE1_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_ENABLE2_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_ENABLE2_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_ENABLE3_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_ENABLE3_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_POLARITY0_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_POLARITY0_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_POLARITY1_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_POLARITY1_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_POLARITY2_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_POLARITY2_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_POLARITY3_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_POLARITY3_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_DATA0_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_DATA0_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_DATA1_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_DATA1_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_DATA2_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_DATA2_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_DATA3_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_DATA3_UNDEFMASK)
            return true;
        break;
    case COM_PIN_INPUT_ENABLE0_OFFSET:
        if ((value ^ new_value) & COM_PIN_INPUT_ENABLE0_UNDEFMASK)
            return true;
        break;
    case COM_PIN_INPUT_ENABLE1_OFFSET:
        if ((value ^ new_value) & COM_PIN_INPUT_ENABLE1_UNDEFMASK)
            return true;
        break;
    case COM_PIN_INPUT_ENABLE2_OFFSET:
        if ((value ^ new_value) & COM_PIN_INPUT_ENABLE2_UNDEFMASK)
            return true;
        break;
    case COM_PIN_INPUT_ENABLE3_OFFSET:
        if ((value ^ new_value) & COM_PIN_INPUT_ENABLE3_UNDEFMASK)
            return true;
        break;
    case COM_PIN_INPUT_DATA0_OFFSET:
        if ((value ^ new_value) & COM_PIN_INPUT_DATA0_UNDEFMASK)
            return true;
        break;
    case COM_PIN_INPUT_DATA1_OFFSET:
        if ((value ^ new_value) & COM_PIN_INPUT_DATA1_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_SELECT0_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_SELECT0_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_SELECT1_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_SELECT1_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_SELECT2_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_SELECT2_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_SELECT3_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_SELECT3_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_SELECT4_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_SELECT4_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_SELECT5_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_SELECT5_UNDEFMASK)
            return true;
        break;
    case COM_PIN_OUTPUT_SELECT6_OFFSET:
        if ((value ^ new_value) & COM_PIN_OUTPUT_SELECT6_UNDEFMASK)
            return true;
        break;
    case COM_PIN_MISC_CONTROL_OFFSET:
        if ((value ^ new_value) & COM_PIN_MISC_CONTROL_UNDEFMASK)
            return true;
        break;
    case COM_PM0_CONTROL_OFFSET:
        if ((value ^ new_value) & COM_PM0_CONTROL_UNDEFMASK)
            return true;
        break;
    case COM_PM0_DUTY_CYCLE_OFFSET:
        if ((value ^ new_value) & COM_PM0_DUTY_CYCLE_UNDEFMASK)
            return true;
        break;
    case COM_PM1_CONTROL_OFFSET:
        if ((value ^ new_value) & COM_PM1_CONTROL_UNDEFMASK)
            return true;
        break;
    case COM_PM1_DUTY_CYCLE_OFFSET:
        if ((value ^ new_value) & COM_PM1_DUTY_CYCLE_UNDEFMASK)
            return true;
        break;
    case COM_SPI_CONTROL_OFFSET:
        if ((value ^ new_value) & COM_SPI_CONTROL_UNDEFMASK)
            return true;
        break;
    case COM_SPI_START_BYTE_OFFSET:
        if ((value ^ new_value) & COM_SPI_START_BYTE_UNDEFMASK)
            return true;
        break;
    case COM_HSPI_WRITE_DATA_AB_OFFSET:
        if ((value ^ new_value) & COM_HSPI_WRITE_DATA_AB_UNDEFMASK)
            return true;
        break;
    case COM_HSPI_WRITE_DATA_CD_OFFSET:
        if ((value ^ new_value) & COM_HSPI_WRITE_DATA_CD_UNDEFMASK)
            return true;
        break;
    case COM_HSPI_CS_DC_OFFSET:
        if ((value ^ new_value) & COM_HSPI_CS_DC_UNDEFMASK)
            return true;
        break;
    case COM_SCRATCH_REGISTER_A_OFFSET:
        if ((value ^ new_value) & COM_SCRATCH_REGISTER_A_UNDEFMASK)
            return true;
        break;
    case COM_SCRATCH_REGISTER_B_OFFSET:
        if ((value ^ new_value) & COM_SCRATCH_REGISTER_B_UNDEFMASK)
            return true;
        break;
    case COM_GPIO_CTRL_OFFSET:
        if ((value ^ new_value) & COM_GPIO_CTRL_UNDEFMASK)
            return true;
        break;
    case COM_GPIO_DEBOUNCE_COUNTER_OFFSET:
        if ((value ^ new_value) & COM_GPIO_DEBOUNCE_COUNTER_UNDEFMASK)
            return true;
        break;
    case COM_CRC_CHECKSUM_LATCHED_OFFSET:
        if ((value ^ new_value) & COM_CRC_CHECKSUM_LATCHED_UNDEFMASK)
            return true;
        break;
    case DISP_DISP_SIGNAL_OPTIONS0_OFFSET:
        if ((value ^ new_value) & DISP_DISP_SIGNAL_OPTIONS0_UNDEFMASK)
            return true;
        break;
    case DISP_DISP_SIGNAL_OPTIONS1_OFFSET:
        if ((value ^ new_value) & DISP_DISP_SIGNAL_OPTIONS1_UNDEFMASK)
            return true;
        break;
    case DISP_DISP_WIN_OPTIONS_OFFSET:
        if ((value ^ new_value) & DISP_DISP_WIN_OPTIONS_UNDEFMASK)
            return true;
        break;
    case DISP_MEM_HIGH_PRIORITY_OFFSET:
        if ((value ^ new_value) & DISP_MEM_HIGH_PRIORITY_UNDEFMASK)
            return true;
        break;
    case DISP_MEM_HIGH_PRIORITY_TIMER_OFFSET:
        if ((value ^ new_value) & DISP_MEM_HIGH_PRIORITY_TIMER_UNDEFMASK)
            return true;
        break;
    case DISP_DISP_TIMING_OPTIONS_OFFSET:
        if ((value ^ new_value) & DISP_DISP_TIMING_OPTIONS_UNDEFMASK)
            return true;
        break;
    case DISP_REF_TO_SYNC_OFFSET:
        if ((value ^ new_value) & DISP_REF_TO_SYNC_UNDEFMASK)
            return true;
        break;
    case DISP_SYNC_WIDTH_OFFSET:
        if ((value ^ new_value) & DISP_SYNC_WIDTH_UNDEFMASK)
            return true;
        break;
    case DISP_BACK_PORCH_OFFSET:
        if ((value ^ new_value) & DISP_BACK_PORCH_UNDEFMASK)
            return true;
        break;
    case DISP_DISP_ACTIVE_OFFSET:
        if ((value ^ new_value) & DISP_DISP_ACTIVE_UNDEFMASK)
            return true;
        break;
    case DISP_FRONT_PORCH_OFFSET:
        if ((value ^ new_value) & DISP_FRONT_PORCH_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE0_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE0_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE0_POSITION_A_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE0_POSITION_A_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE0_POSITION_B_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE0_POSITION_B_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE0_POSITION_C_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE0_POSITION_C_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE0_POSITION_D_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE0_POSITION_D_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE1_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE1_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE1_POSITION_A_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE1_POSITION_A_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE1_POSITION_B_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE1_POSITION_B_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE1_POSITION_C_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE1_POSITION_C_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE1_POSITION_D_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE1_POSITION_D_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE2_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE2_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE2_POSITION_A_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE2_POSITION_A_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE2_POSITION_B_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE2_POSITION_B_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE2_POSITION_C_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE2_POSITION_C_UNDEFMASK)
            return true;
        break;
    case DISP_H_PULSE2_POSITION_D_OFFSET:
        if ((value ^ new_value) & DISP_H_PULSE2_POSITION_D_UNDEFMASK)
            return true;
        break;
    case DISP_V_PULSE0_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_V_PULSE0_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_V_PULSE0_POSITION_A_OFFSET:
        if ((value ^ new_value) & DISP_V_PULSE0_POSITION_A_UNDEFMASK)
            return true;
        break;
    case DISP_V_PULSE0_POSITION_B_OFFSET:
        if ((value ^ new_value) & DISP_V_PULSE0_POSITION_B_UNDEFMASK)
            return true;
        break;
    case DISP_V_PULSE0_POSITION_C_OFFSET:
        if ((value ^ new_value) & DISP_V_PULSE0_POSITION_C_UNDEFMASK)
            return true;
        break;
    case DISP_V_PULSE1_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_V_PULSE1_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_V_PULSE1_POSITION_A_OFFSET:
        if ((value ^ new_value) & DISP_V_PULSE1_POSITION_A_UNDEFMASK)
            return true;
        break;
    case DISP_V_PULSE1_POSITION_B_OFFSET:
        if ((value ^ new_value) & DISP_V_PULSE1_POSITION_B_UNDEFMASK)
            return true;
        break;
    case DISP_V_PULSE1_POSITION_C_OFFSET:
        if ((value ^ new_value) & DISP_V_PULSE1_POSITION_C_UNDEFMASK)
            return true;
        break;
    case DISP_V_PULSE2_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_V_PULSE2_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_V_PULSE2_POSITION_A_OFFSET:
        if ((value ^ new_value) & DISP_V_PULSE2_POSITION_A_UNDEFMASK)
            return true;
        break;
    case DISP_V_PULSE3_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_V_PULSE3_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_V_PULSE3_POSITION_A_OFFSET:
        if ((value ^ new_value) & DISP_V_PULSE3_POSITION_A_UNDEFMASK)
            return true;
        break;
    case DISP_M0_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_M0_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_M1_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_M1_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_DI_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_DI_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_PP_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_PP_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_PP_SELECT_A_OFFSET:
        if ((value ^ new_value) & DISP_PP_SELECT_A_UNDEFMASK)
            return true;
        break;
    case DISP_PP_SELECT_B_OFFSET:
        if ((value ^ new_value) & DISP_PP_SELECT_B_UNDEFMASK)
            return true;
        break;
    case DISP_PP_SELECT_C_OFFSET:
        if ((value ^ new_value) & DISP_PP_SELECT_C_UNDEFMASK)
            return true;
        break;
    case DISP_PP_SELECT_D_OFFSET:
        if ((value ^ new_value) & DISP_PP_SELECT_D_UNDEFMASK)
            return true;
        break;
    case DISP_DISP_CLOCK_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_DISP_CLOCK_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_DISP_INTERFACE_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_DISP_INTERFACE_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_DISP_COLOR_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_DISP_COLOR_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_SHIFT_CLOCK_OPTIONS_OFFSET:
        if ((value ^ new_value) & DISP_SHIFT_CLOCK_OPTIONS_UNDEFMASK)
            return true;
        break;
    case DISP_DATA_ENABLE_OPTIONS_OFFSET:
        if ((value ^ new_value) & DISP_DATA_ENABLE_OPTIONS_UNDEFMASK)
            return true;
        break;
    case DISP_SERIAL_INTERFACE_OPTIONS_OFFSET:
        if ((value ^ new_value) & DISP_SERIAL_INTERFACE_OPTIONS_UNDEFMASK)
            return true;
        break;
    case DISP_LCD_SPI_OPTIONS_OFFSET:
        if ((value ^ new_value) & DISP_LCD_SPI_OPTIONS_UNDEFMASK)
            return true;
        break;
    case DISP_BORDER_COLOR_OFFSET:
        if ((value ^ new_value) & DISP_BORDER_COLOR_UNDEFMASK)
            return true;
        break;
    case DISP_COLOR_KEY0_LOWER_OFFSET:
        if ((value ^ new_value) & DISP_COLOR_KEY0_LOWER_UNDEFMASK)
            return true;
        break;
    case DISP_COLOR_KEY0_UPPER_OFFSET:
        if ((value ^ new_value) & DISP_COLOR_KEY0_UPPER_UNDEFMASK)
            return true;
        break;
    case DISP_COLOR_KEY1_LOWER_OFFSET:
        if ((value ^ new_value) & DISP_COLOR_KEY1_LOWER_UNDEFMASK)
            return true;
        break;
    case DISP_COLOR_KEY1_UPPER_OFFSET:
        if ((value ^ new_value) & DISP_COLOR_KEY1_UPPER_UNDEFMASK)
            return true;
        break;
    case DISP_CURSOR_FOREGROUND_OFFSET:
        if ((value ^ new_value) & DISP_CURSOR_FOREGROUND_UNDEFMASK)
            return true;
        break;
    case DISP_CURSOR_BACKGROUND_OFFSET:
        if ((value ^ new_value) & DISP_CURSOR_BACKGROUND_UNDEFMASK)
            return true;
        break;
    case DISP_CURSOR_START_ADDR_OFFSET:
        if ((value ^ new_value) & DISP_CURSOR_START_ADDR_UNDEFMASK)
            return true;
        break;
    case DISP_CURSOR_START_ADDR_NS_OFFSET:
        if ((value ^ new_value) & DISP_CURSOR_START_ADDR_NS_UNDEFMASK)
            return true;
        break;
    case DISP_CURSOR_POSITION_OFFSET:
        if ((value ^ new_value) & DISP_CURSOR_POSITION_UNDEFMASK)
            return true;
        break;
    case DISP_CURSOR_POSITION_NS_OFFSET:
        if ((value ^ new_value) & DISP_CURSOR_POSITION_NS_UNDEFMASK)
            return true;
        break;
    case DISP_INIT_SEQ_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_INIT_SEQ_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_SPI_INIT_SEQ_DATA_A_OFFSET:
        if ((value ^ new_value) & DISP_SPI_INIT_SEQ_DATA_A_UNDEFMASK)
            return true;
        break;
    case DISP_SPI_INIT_SEQ_DATA_B_OFFSET:
        if ((value ^ new_value) & DISP_SPI_INIT_SEQ_DATA_B_UNDEFMASK)
            return true;
        break;
    case DISP_SPI_INIT_SEQ_DATA_C_OFFSET:
        if ((value ^ new_value) & DISP_SPI_INIT_SEQ_DATA_C_UNDEFMASK)
            return true;
        break;
    case DISP_SPI_INIT_SEQ_DATA_D_OFFSET:
        if ((value ^ new_value) & DISP_SPI_INIT_SEQ_DATA_D_UNDEFMASK)
            return true;
        break;
    case DISP_DC_MCCIF_FIFOCTRL_OFFSET:
        if ((value ^ new_value) & DISP_DC_MCCIF_FIFOCTRL_UNDEFMASK)
            return true;
        break;
    case DISP_MCCIF_DISPLAY0A_HYST_OFFSET:
        if ((value ^ new_value) & DISP_MCCIF_DISPLAY0A_HYST_UNDEFMASK)
            return true;
        break;
    case DISP_MCCIF_DISPLAY0B_HYST_OFFSET:
        if ((value ^ new_value) & DISP_MCCIF_DISPLAY0B_HYST_UNDEFMASK)
            return true;
        break;
    case DISP_MCCIF_DISPLAY0C_HYST_OFFSET:
        if ((value ^ new_value) & DISP_MCCIF_DISPLAY0C_HYST_UNDEFMASK)
            return true;
        break;
    case DISP_MCCIF_DISPLAY1B_HYST_OFFSET:
        if ((value ^ new_value) & DISP_MCCIF_DISPLAY1B_HYST_UNDEFMASK)
            return true;
        break;
    case DISP_DAC_CRT_CTRL_OFFSET:
        if ((value ^ new_value) & DISP_DAC_CRT_CTRL_UNDEFMASK)
            return true;
        break;
    case DISP_DISP_MISC_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_DISP_MISC_CONTROL_UNDEFMASK)
            return true;
        break;
    case WINC_A_COLOR_PALETTE_OFFSET:
        if ((value ^ new_value) & WINC_A_COLOR_PALETTE_UNDEFMASK)
            return true;
        break;
    case WINC_A_PALETTE_COLOR_EXT_OFFSET:
        if ((value ^ new_value) & WINC_A_PALETTE_COLOR_EXT_UNDEFMASK)
            return true;
        break;
    case WIN_A_WIN_OPTIONS_OFFSET:
        if ((value ^ new_value) & WIN_A_WIN_OPTIONS_UNDEFMASK)
            return true;
        break;
    case WIN_A_BYTE_SWAP_OFFSET:
        if ((value ^ new_value) & WIN_A_BYTE_SWAP_UNDEFMASK)
            return true;
        break;
    case WIN_A_BUFFER_CONTROL_OFFSET:
        if ((value ^ new_value) & WIN_A_BUFFER_CONTROL_UNDEFMASK)
            return true;
        break;
    case WIN_A_COLOR_DEPTH_OFFSET:
        if ((value ^ new_value) & WIN_A_COLOR_DEPTH_UNDEFMASK)
            return true;
        break;
    case WIN_A_POSITION_OFFSET:
        if ((value ^ new_value) & WIN_A_POSITION_UNDEFMASK)
            return true;
        break;
    case WIN_A_SIZE_OFFSET:
        if ((value ^ new_value) & WIN_A_SIZE_UNDEFMASK)
            return true;
        break;
    case WIN_A_PRESCALED_SIZE_OFFSET:
        if ((value ^ new_value) & WIN_A_PRESCALED_SIZE_UNDEFMASK)
            return true;
        break;
    case WIN_A_H_INITIAL_DDA_OFFSET:
        if ((value ^ new_value) & WIN_A_H_INITIAL_DDA_UNDEFMASK)
            return true;
        break;
    case WIN_A_V_INITIAL_DDA_OFFSET:
        if ((value ^ new_value) & WIN_A_V_INITIAL_DDA_UNDEFMASK)
            return true;
        break;
    case WIN_A_DDA_INCREMENT_OFFSET:
        if ((value ^ new_value) & WIN_A_DDA_INCREMENT_UNDEFMASK)
            return true;
        break;
    case WIN_A_LINE_STRIDE_OFFSET:
        if ((value ^ new_value) & WIN_A_LINE_STRIDE_UNDEFMASK)
            return true;
        break;
    case WIN_A_BUF_STRIDE_OFFSET:
        if ((value ^ new_value) & WIN_A_BUF_STRIDE_UNDEFMASK)
            return true;
        break;
    case WIN_A_BUFFER_ADDR_MODE_OFFSET:
        if ((value ^ new_value) & WIN_A_BUFFER_ADDR_MODE_UNDEFMASK)
            return true;
        break;
    case WIN_A_DV_CONTROL_OFFSET:
        if ((value ^ new_value) & WIN_A_DV_CONTROL_UNDEFMASK)
            return true;
        break;
    case WIN_A_BLEND_NOKEY_OFFSET:
        if ((value ^ new_value) & WIN_A_BLEND_NOKEY_UNDEFMASK)
            return true;
        break;
    case WIN_A_BLEND_1WIN_OFFSET:
        if ((value ^ new_value) & WIN_A_BLEND_1WIN_UNDEFMASK)
            return true;
        break;
    case WIN_A_BLEND_2WIN_B_OFFSET:
        if ((value ^ new_value) & WIN_A_BLEND_2WIN_B_UNDEFMASK)
            return true;
        break;
    case WIN_A_BLEND_2WIN_C_OFFSET:
        if ((value ^ new_value) & WIN_A_BLEND_2WIN_C_UNDEFMASK)
            return true;
        break;
    case WIN_A_BLEND_3WIN_BC_OFFSET:
        if ((value ^ new_value) & WIN_A_BLEND_3WIN_BC_UNDEFMASK)
            return true;
        break;
    case WIN_A_HP_FETCH_CONTROL_OFFSET:
        if ((value ^ new_value) & WIN_A_HP_FETCH_CONTROL_UNDEFMASK)
            return true;
        break;
    case WINBUF_A_START_ADDR_OFFSET:
        if ((value ^ new_value) & WINBUF_A_START_ADDR_UNDEFMASK)
            return true;
        break;
    case WINBUF_A_START_ADDR_NS_OFFSET:
        if ((value ^ new_value) & WINBUF_A_START_ADDR_NS_UNDEFMASK)
            return true;
        break;
    case WINBUF_A_ADDR_H_OFFSET_OFFSET:
        if ((value ^ new_value) & WINBUF_A_ADDR_H_OFFSET_UNDEFMASK)
            return true;
        break;
    case WINBUF_A_ADDR_H_OFFSET_NS_OFFSET:
        if ((value ^ new_value) & WINBUF_A_ADDR_H_OFFSET_NS_UNDEFMASK)
            return true;
        break;
    case WINBUF_A_ADDR_V_OFFSET_OFFSET:
        if ((value ^ new_value) & WINBUF_A_ADDR_V_OFFSET_UNDEFMASK)
            return true;
        break;
    case WINBUF_A_ADDR_V_OFFSET_NS_OFFSET:
        if ((value ^ new_value) & WINBUF_A_ADDR_V_OFFSET_NS_UNDEFMASK)
            return true;
        break;
    case WINBUF_A_UFLOW_STATUS_OFFSET:
        if ((value ^ new_value) & WINBUF_A_UFLOW_STATUS_UNDEFMASK)
            return true;
        break;
    case WINC_B_COLOR_PALETTE_OFFSET:
        if ((value ^ new_value) & WINC_B_COLOR_PALETTE_UNDEFMASK)
            return true;
        break;
    case WINC_B_PALETTE_COLOR_EXT_OFFSET:
        if ((value ^ new_value) & WINC_B_PALETTE_COLOR_EXT_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P00_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P00_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P01_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P01_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P02_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P02_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P03_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P03_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P04_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P04_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P05_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P05_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P06_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P06_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P07_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P07_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P08_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P08_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P09_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P09_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P0A_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P0A_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P0B_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P0B_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P0C_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P0C_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P0D_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P0D_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P0E_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P0E_UNDEFMASK)
            return true;
        break;
    case WINC_B_H_FILTER_P0F_OFFSET:
        if ((value ^ new_value) & WINC_B_H_FILTER_P0F_UNDEFMASK)
            return true;
        break;
    case WINC_B_CSC_YOF_OFFSET:
        if ((value ^ new_value) & WINC_B_CSC_YOF_UNDEFMASK)
            return true;
        break;
    case WINC_B_CSC_KYRGB_OFFSET:
        if ((value ^ new_value) & WINC_B_CSC_KYRGB_UNDEFMASK)
            return true;
        break;
    case WINC_B_CSC_KUR_OFFSET:
        if ((value ^ new_value) & WINC_B_CSC_KUR_UNDEFMASK)
            return true;
        break;
    case WINC_B_CSC_KVR_OFFSET:
        if ((value ^ new_value) & WINC_B_CSC_KVR_UNDEFMASK)
            return true;
        break;
    case WINC_B_CSC_KUG_OFFSET:
        if ((value ^ new_value) & WINC_B_CSC_KUG_UNDEFMASK)
            return true;
        break;
    case WINC_B_CSC_KVG_OFFSET:
        if ((value ^ new_value) & WINC_B_CSC_KVG_UNDEFMASK)
            return true;
        break;
    case WINC_B_CSC_KUB_OFFSET:
        if ((value ^ new_value) & WINC_B_CSC_KUB_UNDEFMASK)
            return true;
        break;
    case WINC_B_CSC_KVB_OFFSET:
        if ((value ^ new_value) & WINC_B_CSC_KVB_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P00_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P00_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P01_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P01_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P02_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P02_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P03_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P03_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P04_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P04_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P05_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P05_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P06_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P06_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P07_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P07_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P08_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P08_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P09_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P09_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P0A_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P0A_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P0B_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P0B_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P0C_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P0C_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P0D_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P0D_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P0E_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P0E_UNDEFMASK)
            return true;
        break;
    case WINC_B_V_FILTER_P0F_OFFSET:
        if ((value ^ new_value) & WINC_B_V_FILTER_P0F_UNDEFMASK)
            return true;
        break;
    case WIN_B_WIN_OPTIONS_OFFSET:
        if ((value ^ new_value) & WIN_B_WIN_OPTIONS_UNDEFMASK)
            return true;
        break;
    case WIN_B_BYTE_SWAP_OFFSET:
        if ((value ^ new_value) & WIN_B_BYTE_SWAP_UNDEFMASK)
            return true;
        break;
    case WIN_B_BUFFER_CONTROL_OFFSET:
        if ((value ^ new_value) & WIN_B_BUFFER_CONTROL_UNDEFMASK)
            return true;
        break;
    case WIN_B_COLOR_DEPTH_OFFSET:
        if ((value ^ new_value) & WIN_B_COLOR_DEPTH_UNDEFMASK)
            return true;
        break;
    case WIN_B_POSITION_OFFSET:
        if ((value ^ new_value) & WIN_B_POSITION_UNDEFMASK)
            return true;
        break;
    case WIN_B_SIZE_OFFSET:
        if ((value ^ new_value) & WIN_B_SIZE_UNDEFMASK)
            return true;
        break;
    case WIN_B_PRESCALED_SIZE_OFFSET:
        if ((value ^ new_value) & WIN_B_PRESCALED_SIZE_UNDEFMASK)
            return true;
        break;
    case WIN_B_H_INITIAL_DDA_OFFSET:
        if ((value ^ new_value) & WIN_B_H_INITIAL_DDA_UNDEFMASK)
            return true;
        break;
    case WIN_B_V_INITIAL_DDA_OFFSET:
        if ((value ^ new_value) & WIN_B_V_INITIAL_DDA_UNDEFMASK)
            return true;
        break;
    case WIN_B_DDA_INCREMENT_OFFSET:
        if ((value ^ new_value) & WIN_B_DDA_INCREMENT_UNDEFMASK)
            return true;
        break;
    case WIN_B_LINE_STRIDE_OFFSET:
        if ((value ^ new_value) & WIN_B_LINE_STRIDE_UNDEFMASK)
            return true;
        break;
    case WIN_B_BUF_STRIDE_OFFSET:
        if ((value ^ new_value) & WIN_B_BUF_STRIDE_UNDEFMASK)
            return true;
        break;
    case WIN_B_UV_BUF_STRIDE_OFFSET:
        if ((value ^ new_value) & WIN_B_UV_BUF_STRIDE_UNDEFMASK)
            return true;
        break;
    case WIN_B_BUFFER_ADDR_MODE_OFFSET:
        if ((value ^ new_value) & WIN_B_BUFFER_ADDR_MODE_UNDEFMASK)
            return true;
        break;
    case WIN_B_DV_CONTROL_OFFSET:
        if ((value ^ new_value) & WIN_B_DV_CONTROL_UNDEFMASK)
            return true;
        break;
    case WIN_B_BLEND_NOKEY_OFFSET:
        if ((value ^ new_value) & WIN_B_BLEND_NOKEY_UNDEFMASK)
            return true;
        break;
    case WIN_B_BLEND_1WIN_OFFSET:
        if ((value ^ new_value) & WIN_B_BLEND_1WIN_UNDEFMASK)
            return true;
        break;
    case WIN_B_BLEND_2WIN_A_OFFSET:
        if ((value ^ new_value) & WIN_B_BLEND_2WIN_A_UNDEFMASK)
            return true;
        break;
    case WIN_B_BLEND_2WIN_C_OFFSET:
        if ((value ^ new_value) & WIN_B_BLEND_2WIN_C_UNDEFMASK)
            return true;
        break;
    case WIN_B_BLEND_3WIN_AC_OFFSET:
        if ((value ^ new_value) & WIN_B_BLEND_3WIN_AC_UNDEFMASK)
            return true;
        break;
    case WIN_B_HP_FETCH_CONTROL_OFFSET:
        if ((value ^ new_value) & WIN_B_HP_FETCH_CONTROL_UNDEFMASK)
            return true;
        break;
    case WINBUF_B_START_ADDR_OFFSET:
        if ((value ^ new_value) & WINBUF_B_START_ADDR_UNDEFMASK)
            return true;
        break;
    case WINBUF_B_START_ADDR_NS_OFFSET:
        if ((value ^ new_value) & WINBUF_B_START_ADDR_NS_UNDEFMASK)
            return true;
        break;
    case WINBUF_B_START_ADDR_U_OFFSET:
        if ((value ^ new_value) & WINBUF_B_START_ADDR_U_UNDEFMASK)
            return true;
        break;
    case WINBUF_B_START_ADDR_U_NS_OFFSET:
        if ((value ^ new_value) & WINBUF_B_START_ADDR_U_NS_UNDEFMASK)
            return true;
        break;
    case WINBUF_B_START_ADDR_V_OFFSET:
        if ((value ^ new_value) & WINBUF_B_START_ADDR_V_UNDEFMASK)
            return true;
        break;
    case WINBUF_B_START_ADDR_V_NS_OFFSET:
        if ((value ^ new_value) & WINBUF_B_START_ADDR_V_NS_UNDEFMASK)
            return true;
        break;
    case WINBUF_B_ADDR_H_OFFSET_OFFSET:
        if ((value ^ new_value) & WINBUF_B_ADDR_H_OFFSET_UNDEFMASK)
            return true;
        break;
    case WINBUF_B_ADDR_H_OFFSET_NS_OFFSET:
        if ((value ^ new_value) & WINBUF_B_ADDR_H_OFFSET_NS_UNDEFMASK)
            return true;
        break;
    case WINBUF_B_ADDR_V_OFFSET_OFFSET:
        if ((value ^ new_value) & WINBUF_B_ADDR_V_OFFSET_UNDEFMASK)
            return true;
        break;
    case WINBUF_B_ADDR_V_OFFSET_NS_OFFSET:
        if ((value ^ new_value) & WINBUF_B_ADDR_V_OFFSET_NS_UNDEFMASK)
            return true;
        break;
    case WINBUF_B_UFLOW_STATUS_OFFSET:
        if ((value ^ new_value) & WINBUF_B_UFLOW_STATUS_UNDEFMASK)
            return true;
        break;
    case WINC_C_COLOR_PALETTE_OFFSET:
        if ((value ^ new_value) & WINC_C_COLOR_PALETTE_UNDEFMASK)
            return true;
        break;
    case WINC_C_PALETTE_COLOR_EXT_OFFSET:
        if ((value ^ new_value) & WINC_C_PALETTE_COLOR_EXT_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P00_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P00_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P01_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P01_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P02_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P02_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P03_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P03_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P04_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P04_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P05_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P05_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P06_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P06_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P07_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P07_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P08_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P08_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P09_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P09_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P0A_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P0A_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P0B_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P0B_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P0C_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P0C_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P0D_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P0D_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P0E_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P0E_UNDEFMASK)
            return true;
        break;
    case WINC_C_H_FILTER_P0F_OFFSET:
        if ((value ^ new_value) & WINC_C_H_FILTER_P0F_UNDEFMASK)
            return true;
        break;
    case WINC_C_CSC_YOF_OFFSET:
        if ((value ^ new_value) & WINC_C_CSC_YOF_UNDEFMASK)
            return true;
        break;
    case WINC_C_CSC_KYRGB_OFFSET:
        if ((value ^ new_value) & WINC_C_CSC_KYRGB_UNDEFMASK)
            return true;
        break;
    case WINC_C_CSC_KUR_OFFSET:
        if ((value ^ new_value) & WINC_C_CSC_KUR_UNDEFMASK)
            return true;
        break;
    case WINC_C_CSC_KVR_OFFSET:
        if ((value ^ new_value) & WINC_C_CSC_KVR_UNDEFMASK)
            return true;
        break;
    case WINC_C_CSC_KUG_OFFSET:
        if ((value ^ new_value) & WINC_C_CSC_KUG_UNDEFMASK)
            return true;
        break;
    case WINC_C_CSC_KVG_OFFSET:
        if ((value ^ new_value) & WINC_C_CSC_KVG_UNDEFMASK)
            return true;
        break;
    case WINC_C_CSC_KUB_OFFSET:
        if ((value ^ new_value) & WINC_C_CSC_KUB_UNDEFMASK)
            return true;
        break;
    case WINC_C_CSC_KVB_OFFSET:
        if ((value ^ new_value) & WINC_C_CSC_KVB_UNDEFMASK)
            return true;
        break;
    case WIN_C_WIN_OPTIONS_OFFSET:
        if ((value ^ new_value) & WIN_C_WIN_OPTIONS_UNDEFMASK)
            return true;
        break;
    case WIN_C_BYTE_SWAP_OFFSET:
        if ((value ^ new_value) & WIN_C_BYTE_SWAP_UNDEFMASK)
            return true;
        break;
    case WIN_C_BUFFER_CONTROL_OFFSET:
        if ((value ^ new_value) & WIN_C_BUFFER_CONTROL_UNDEFMASK)
            return true;
        break;
    case WIN_C_COLOR_DEPTH_OFFSET:
        if ((value ^ new_value) & WIN_C_COLOR_DEPTH_UNDEFMASK)
            return true;
        break;
    case WIN_C_POSITION_OFFSET:
        if ((value ^ new_value) & WIN_C_POSITION_UNDEFMASK)
            return true;
        break;
    case WIN_C_SIZE_OFFSET:
        if ((value ^ new_value) & WIN_C_SIZE_UNDEFMASK)
            return true;
        break;
    case WIN_C_PRESCALED_SIZE_OFFSET:
        if ((value ^ new_value) & WIN_C_PRESCALED_SIZE_UNDEFMASK)
            return true;
        break;
    case WIN_C_H_INITIAL_DDA_OFFSET:
        if ((value ^ new_value) & WIN_C_H_INITIAL_DDA_UNDEFMASK)
            return true;
        break;
    case WIN_C_V_INITIAL_DDA_OFFSET:
        if ((value ^ new_value) & WIN_C_V_INITIAL_DDA_UNDEFMASK)
            return true;
        break;
    case WIN_C_DDA_INCREMENT_OFFSET:
        if ((value ^ new_value) & WIN_C_DDA_INCREMENT_UNDEFMASK)
            return true;
        break;
    case WIN_C_LINE_STRIDE_OFFSET:
        if ((value ^ new_value) & WIN_C_LINE_STRIDE_UNDEFMASK)
            return true;
        break;
    case WIN_C_BUF_STRIDE_OFFSET:
        if ((value ^ new_value) & WIN_C_BUF_STRIDE_UNDEFMASK)
            return true;
        break;
    case WIN_C_UV_BUF_STRIDE_OFFSET:
        if ((value ^ new_value) & WIN_C_UV_BUF_STRIDE_UNDEFMASK)
            return true;
        break;
    case WIN_C_BUFFER_ADDR_MODE_OFFSET:
        if ((value ^ new_value) & WIN_C_BUFFER_ADDR_MODE_UNDEFMASK)
            return true;
        break;
    case WIN_C_DV_CONTROL_OFFSET:
        if ((value ^ new_value) & WIN_C_DV_CONTROL_UNDEFMASK)
            return true;
        break;
    case WIN_C_BLEND_NOKEY_OFFSET:
        if ((value ^ new_value) & WIN_C_BLEND_NOKEY_UNDEFMASK)
            return true;
        break;
    case WIN_C_BLEND_1WIN_OFFSET:
        if ((value ^ new_value) & WIN_C_BLEND_1WIN_UNDEFMASK)
            return true;
        break;
    case WIN_C_BLEND_2WIN_A_OFFSET:
        if ((value ^ new_value) & WIN_C_BLEND_2WIN_A_UNDEFMASK)
            return true;
        break;
    case WIN_C_BLEND_2WIN_B_OFFSET:
        if ((value ^ new_value) & WIN_C_BLEND_2WIN_B_UNDEFMASK)
            return true;
        break;
    case WIN_C_BLEND_3WIN_AB_OFFSET:
        if ((value ^ new_value) & WIN_C_BLEND_3WIN_AB_UNDEFMASK)
            return true;
        break;
    case WIN_C_HP_FETCH_CONTROL_OFFSET:
        if ((value ^ new_value) & WIN_C_HP_FETCH_CONTROL_UNDEFMASK)
            return true;
        break;
    case WINBUF_C_START_ADDR_OFFSET:
        if ((value ^ new_value) & WINBUF_C_START_ADDR_UNDEFMASK)
            return true;
        break;
    case WINBUF_C_START_ADDR_NS_OFFSET:
        if ((value ^ new_value) & WINBUF_C_START_ADDR_NS_UNDEFMASK)
            return true;
        break;
    case WINBUF_C_START_ADDR_U_OFFSET:
        if ((value ^ new_value) & WINBUF_C_START_ADDR_U_UNDEFMASK)
            return true;
        break;
    case WINBUF_C_START_ADDR_U_NS_OFFSET:
        if ((value ^ new_value) & WINBUF_C_START_ADDR_U_NS_UNDEFMASK)
            return true;
        break;
    case WINBUF_C_START_ADDR_V_OFFSET:
        if ((value ^ new_value) & WINBUF_C_START_ADDR_V_UNDEFMASK)
            return true;
        break;
    case WINBUF_C_START_ADDR_V_NS_OFFSET:
        if ((value ^ new_value) & WINBUF_C_START_ADDR_V_NS_UNDEFMASK)
            return true;
        break;
    case WINBUF_C_ADDR_H_OFFSET_OFFSET:
        if ((value ^ new_value) & WINBUF_C_ADDR_H_OFFSET_UNDEFMASK)
            return true;
        break;
    case WINBUF_C_ADDR_H_OFFSET_NS_OFFSET:
        if ((value ^ new_value) & WINBUF_C_ADDR_H_OFFSET_NS_UNDEFMASK)
            return true;
        break;
    case WINBUF_C_ADDR_V_OFFSET_OFFSET:
        if ((value ^ new_value) & WINBUF_C_ADDR_V_OFFSET_UNDEFMASK)
            return true;
        break;
    case WINBUF_C_ADDR_V_OFFSET_NS_OFFSET:
        if ((value ^ new_value) & WINBUF_C_ADDR_V_OFFSET_NS_UNDEFMASK)
            return true;
        break;
    case WINBUF_C_UFLOW_STATUS_OFFSET:
        if ((value ^ new_value) & WINBUF_C_UFLOW_STATUS_UNDEFMASK)
            return true;
        break;
    case DISP_SD_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_SD_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_SD_CSC_COEFF_OFFSET:
        if ((value ^ new_value) & DISP_SD_CSC_COEFF_UNDEFMASK)
            return true;
        break;
    case DISP_SD_LUT_OFFSET:
        if ((value ^ new_value) & DISP_SD_LUT_UNDEFMASK)
            return true;
        break;
    case DISP_SD_LUT_1_OFFSET:
        if ((value ^ new_value) & DISP_SD_LUT_1_UNDEFMASK)
            return true;
        break;
    case DISP_SD_LUT_2_OFFSET:
        if ((value ^ new_value) & DISP_SD_LUT_2_UNDEFMASK)
            return true;
        break;
    case DISP_SD_LUT_3_OFFSET:
        if ((value ^ new_value) & DISP_SD_LUT_3_UNDEFMASK)
            return true;
        break;
    case DISP_SD_LUT_4_OFFSET:
        if ((value ^ new_value) & DISP_SD_LUT_4_UNDEFMASK)
            return true;
        break;
    case DISP_SD_LUT_5_OFFSET:
        if ((value ^ new_value) & DISP_SD_LUT_5_UNDEFMASK)
            return true;
        break;
    case DISP_SD_LUT_6_OFFSET:
        if ((value ^ new_value) & DISP_SD_LUT_6_UNDEFMASK)
            return true;
        break;
    case DISP_SD_LUT_7_OFFSET:
        if ((value ^ new_value) & DISP_SD_LUT_7_UNDEFMASK)
            return true;
        break;
    case DISP_SD_LUT_8_OFFSET:
        if ((value ^ new_value) & DISP_SD_LUT_8_UNDEFMASK)
            return true;
        break;
    case DISP_SD_FLICKER_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_SD_FLICKER_CONTROL_UNDEFMASK)
            return true;
        break;
    case DISP_SD_PIXEL_COUNT_OFFSET:
        if ((value ^ new_value) & DISP_SD_PIXEL_COUNT_UNDEFMASK)
            return true;
        break;
    case DISP_SD_HISTOGRAM_OFFSET:
        if ((value ^ new_value) & DISP_SD_HISTOGRAM_UNDEFMASK)
            return true;
        break;
    case DISP_SD_HISTOGRAM_1_OFFSET:
        if ((value ^ new_value) & DISP_SD_HISTOGRAM_1_UNDEFMASK)
            return true;
        break;
    case DISP_SD_HISTOGRAM_2_OFFSET:
        if ((value ^ new_value) & DISP_SD_HISTOGRAM_2_UNDEFMASK)
            return true;
        break;
    case DISP_SD_HISTOGRAM_3_OFFSET:
        if ((value ^ new_value) & DISP_SD_HISTOGRAM_3_UNDEFMASK)
            return true;
        break;
    case DISP_SD_HISTOGRAM_4_OFFSET:
        if ((value ^ new_value) & DISP_SD_HISTOGRAM_4_UNDEFMASK)
            return true;
        break;
    case DISP_SD_HISTOGRAM_5_OFFSET:
        if ((value ^ new_value) & DISP_SD_HISTOGRAM_5_UNDEFMASK)
            return true;
        break;
    case DISP_SD_HISTOGRAM_6_OFFSET:
        if ((value ^ new_value) & DISP_SD_HISTOGRAM_6_UNDEFMASK)
            return true;
        break;
    case DISP_SD_HISTOGRAM_7_OFFSET:
        if ((value ^ new_value) & DISP_SD_HISTOGRAM_7_UNDEFMASK)
            return true;
        break;
    case DISP_SD_BL_PARAMETERS_OFFSET:
        if ((value ^ new_value) & DISP_SD_BL_PARAMETERS_UNDEFMASK)
            return true;
        break;
    case DISP_SD_BL_TF_OFFSET:
        if ((value ^ new_value) & DISP_SD_BL_TF_UNDEFMASK)
            return true;
        break;
    case DISP_SD_BL_TF_1_OFFSET:
        if ((value ^ new_value) & DISP_SD_BL_TF_1_UNDEFMASK)
            return true;
        break;
    case DISP_SD_BL_TF_2_OFFSET:
        if ((value ^ new_value) & DISP_SD_BL_TF_2_UNDEFMASK)
            return true;
        break;
    case DISP_SD_BL_TF_3_OFFSET:
        if ((value ^ new_value) & DISP_SD_BL_TF_3_UNDEFMASK)
            return true;
        break;
    case DISP_SD_BL_CONTROL_OFFSET:
        if ((value ^ new_value) & DISP_SD_BL_CONTROL_UNDEFMASK)
            return true;
        break;
    case WINC_B_COLOR_PALETTE_1_OFFSET:
        if ((value ^ new_value) & WINC_B_COLOR_PALETTE_1_UNDEFMASK)
            return true;
        break;
    case WINC_B_COLOR_PALETTE_2_OFFSET:
        if ((value ^ new_value) & WINC_B_COLOR_PALETTE_2_UNDEFMASK)
            return true;
        break;
    case WINC_B_COLOR_PALETTE_3_OFFSET:
        if ((value ^ new_value) & WINC_B_COLOR_PALETTE_3_UNDEFMASK)
            return true;
        break;
    case WINC_B_COLOR_PALETTE_4_OFFSET:
        if ((value ^ new_value) & WINC_B_COLOR_PALETTE_4_UNDEFMASK)
            return true;
        break;
    case WINC_B_COLOR_PALETTE_5_OFFSET:
        if ((value ^ new_value) & WINC_B_COLOR_PALETTE_5_UNDEFMASK)
            return true;
        break;
    case WINC_B_COLOR_PALETTE_6_OFFSET:
        if ((value ^ new_value) & WINC_B_COLOR_PALETTE_6_UNDEFMASK)
            return true;
        break;
    case WINC_B_COLOR_PALETTE_7_OFFSET:
        if ((value ^ new_value) & WINC_B_COLOR_PALETTE_7_UNDEFMASK)
            return true;
        break;
    case WINC_B_COLOR_PALETTE_8_OFFSET:
        if ((value ^ new_value) & WINC_B_COLOR_PALETTE_8_UNDEFMASK)
            return true;
        break;
    case WINC_B_COLOR_PALETTE_9_OFFSET:
        if ((value ^ new_value) & WINC_B_COLOR_PALETTE_9_UNDEFMASK)
            return true;
        break;

    default:
        break;
    }

    return false;
}

QString DcDev::get_register_name(const log_entry &entry) const
{
    switch (entry.offset) {
    case CMD_GENERAL_INCR_SYNCPT_OFFSET:
        return QString("CMD_GENERAL_INCR_SYNCPT");
    case CMD_GENERAL_INCR_SYNCPT_CNTRL_OFFSET:
        return QString("CMD_GENERAL_INCR_SYNCPT_CNTRL");
    case CMD_GENERAL_INCR_SYNCPT_ERROR_OFFSET:
        return QString("CMD_GENERAL_INCR_SYNCPT_ERROR");
    case CMD_WIN_A_INCR_SYNCPT_OFFSET:
        return QString("CMD_WIN_A_INCR_SYNCPT");
    case CMD_WIN_A_INCR_SYNCPT_CNTRL_OFFSET:
        return QString("CMD_WIN_A_INCR_SYNCPT_CNTRL");
    case CMD_WIN_A_INCR_SYNCPT_ERROR_OFFSET:
        return QString("CMD_WIN_A_INCR_SYNCPT_ERROR");
    case CMD_WIN_B_INCR_SYNCPT_OFFSET:
        return QString("CMD_WIN_B_INCR_SYNCPT");
    case CMD_WIN_B_INCR_SYNCPT_CNTRL_OFFSET:
        return QString("CMD_WIN_B_INCR_SYNCPT_CNTRL");
    case CMD_WIN_B_INCR_SYNCPT_ERROR_OFFSET:
        return QString("CMD_WIN_B_INCR_SYNCPT_ERROR");
    case CMD_WIN_C_INCR_SYNCPT_OFFSET:
        return QString("CMD_WIN_C_INCR_SYNCPT");
    case CMD_WIN_C_INCR_SYNCPT_CNTRL_OFFSET:
        return QString("CMD_WIN_C_INCR_SYNCPT_CNTRL");
    case CMD_WIN_C_INCR_SYNCPT_ERROR_OFFSET:
        return QString("CMD_WIN_C_INCR_SYNCPT_ERROR");
    case CMD_CONT_SYNCPT_VSYNC_OFFSET:
        return QString("CMD_CONT_SYNCPT_VSYNC");
    case CMD_CTXSW_OFFSET:
        return QString("CMD_CTXSW");
    case CMD_DISPLAY_COMMAND_OPTION0_OFFSET:
        return QString("CMD_DISPLAY_COMMAND_OPTION0");
    case CMD_DISPLAY_COMMAND_OFFSET:
        return QString("CMD_DISPLAY_COMMAND");
    case CMD_SIGNAL_RAISE_OFFSET:
        return QString("CMD_SIGNAL_RAISE");
    case CMD_DISPLAY_POWER_CONTROL_OFFSET:
        return QString("CMD_DISPLAY_POWER_CONTROL");
    case CMD_INT_STATUS_OFFSET:
        return QString("CMD_INT_STATUS");
    case CMD_INT_MASK_OFFSET:
        return QString("CMD_INT_MASK");
    case CMD_INT_ENABLE_OFFSET:
        return QString("CMD_INT_ENABLE");
    case CMD_INT_TYPE_OFFSET:
        return QString("CMD_INT_TYPE");
    case CMD_INT_POLARITY_OFFSET:
        return QString("CMD_INT_POLARITY");
    case CMD_SIGNAL_RAISE1_OFFSET:
        return QString("CMD_SIGNAL_RAISE1");
    case CMD_SIGNAL_RAISE2_OFFSET:
        return QString("CMD_SIGNAL_RAISE2");
    case CMD_SIGNAL_RAISE3_OFFSET:
        return QString("CMD_SIGNAL_RAISE3");
    case CMD_STATE_ACCESS_OFFSET:
        return QString("CMD_STATE_ACCESS");
    case CMD_STATE_CONTROL_OFFSET:
        return QString("CMD_STATE_CONTROL");
    case CMD_DISPLAY_WINDOW_HEADER_OFFSET:
        return QString("CMD_DISPLAY_WINDOW_HEADER");
    case CMD_REG_ACT_CONTROL_OFFSET:
        return QString("CMD_REG_ACT_CONTROL");
    case COM_CRC_CONTROL_OFFSET:
        return QString("COM_CRC_CONTROL");
    case COM_CRC_CHECKSUM_OFFSET:
        return QString("COM_CRC_CHECKSUM");
    case COM_PIN_OUTPUT_ENABLE0_OFFSET:
        return QString("COM_PIN_OUTPUT_ENABLE0");
    case COM_PIN_OUTPUT_ENABLE1_OFFSET:
        return QString("COM_PIN_OUTPUT_ENABLE1");
    case COM_PIN_OUTPUT_ENABLE2_OFFSET:
        return QString("COM_PIN_OUTPUT_ENABLE2");
    case COM_PIN_OUTPUT_ENABLE3_OFFSET:
        return QString("COM_PIN_OUTPUT_ENABLE3");
    case COM_PIN_OUTPUT_POLARITY0_OFFSET:
        return QString("COM_PIN_OUTPUT_POLARITY0");
    case COM_PIN_OUTPUT_POLARITY1_OFFSET:
        return QString("COM_PIN_OUTPUT_POLARITY1");
    case COM_PIN_OUTPUT_POLARITY2_OFFSET:
        return QString("COM_PIN_OUTPUT_POLARITY2");
    case COM_PIN_OUTPUT_POLARITY3_OFFSET:
        return QString("COM_PIN_OUTPUT_POLARITY3");
    case COM_PIN_OUTPUT_DATA0_OFFSET:
        return QString("COM_PIN_OUTPUT_DATA0");
    case COM_PIN_OUTPUT_DATA1_OFFSET:
        return QString("COM_PIN_OUTPUT_DATA1");
    case COM_PIN_OUTPUT_DATA2_OFFSET:
        return QString("COM_PIN_OUTPUT_DATA2");
    case COM_PIN_OUTPUT_DATA3_OFFSET:
        return QString("COM_PIN_OUTPUT_DATA3");
    case COM_PIN_INPUT_ENABLE0_OFFSET:
        return QString("COM_PIN_INPUT_ENABLE0");
    case COM_PIN_INPUT_ENABLE1_OFFSET:
        return QString("COM_PIN_INPUT_ENABLE1");
    case COM_PIN_INPUT_ENABLE2_OFFSET:
        return QString("COM_PIN_INPUT_ENABLE2");
    case COM_PIN_INPUT_ENABLE3_OFFSET:
        return QString("COM_PIN_INPUT_ENABLE3");
    case COM_PIN_INPUT_DATA0_OFFSET:
        return QString("COM_PIN_INPUT_DATA0");
    case COM_PIN_INPUT_DATA1_OFFSET:
        return QString("COM_PIN_INPUT_DATA1");
    case COM_PIN_OUTPUT_SELECT0_OFFSET:
        return QString("COM_PIN_OUTPUT_SELECT0");
    case COM_PIN_OUTPUT_SELECT1_OFFSET:
        return QString("COM_PIN_OUTPUT_SELECT1");
    case COM_PIN_OUTPUT_SELECT2_OFFSET:
        return QString("COM_PIN_OUTPUT_SELECT2");
    case COM_PIN_OUTPUT_SELECT3_OFFSET:
        return QString("COM_PIN_OUTPUT_SELECT3");
    case COM_PIN_OUTPUT_SELECT4_OFFSET:
        return QString("COM_PIN_OUTPUT_SELECT4");
    case COM_PIN_OUTPUT_SELECT5_OFFSET:
        return QString("COM_PIN_OUTPUT_SELECT5");
    case COM_PIN_OUTPUT_SELECT6_OFFSET:
        return QString("COM_PIN_OUTPUT_SELECT6");
    case COM_PIN_MISC_CONTROL_OFFSET:
        return QString("COM_PIN_MISC_CONTROL");
    case COM_PM0_CONTROL_OFFSET:
        return QString("COM_PM0_CONTROL");
    case COM_PM0_DUTY_CYCLE_OFFSET:
        return QString("COM_PM0_DUTY_CYCLE");
    case COM_PM1_CONTROL_OFFSET:
        return QString("COM_PM1_CONTROL");
    case COM_PM1_DUTY_CYCLE_OFFSET:
        return QString("COM_PM1_DUTY_CYCLE");
    case COM_SPI_CONTROL_OFFSET:
        return QString("COM_SPI_CONTROL");
    case COM_SPI_START_BYTE_OFFSET:
        return QString("COM_SPI_START_BYTE");
    case COM_HSPI_WRITE_DATA_AB_OFFSET:
        return QString("COM_HSPI_WRITE_DATA_AB");
    case COM_HSPI_WRITE_DATA_CD_OFFSET:
        return QString("COM_HSPI_WRITE_DATA_CD");
    case COM_HSPI_CS_DC_OFFSET:
        return QString("COM_HSPI_CS_DC");
    case COM_SCRATCH_REGISTER_A_OFFSET:
        return QString("COM_SCRATCH_REGISTER_A");
    case COM_SCRATCH_REGISTER_B_OFFSET:
        return QString("COM_SCRATCH_REGISTER_B");
    case COM_GPIO_CTRL_OFFSET:
        return QString("COM_GPIO_CTRL");
    case COM_GPIO_DEBOUNCE_COUNTER_OFFSET:
        return QString("COM_GPIO_DEBOUNCE_COUNTER");
    case COM_CRC_CHECKSUM_LATCHED_OFFSET:
        return QString("COM_CRC_CHECKSUM_LATCHED");
    case DISP_DISP_SIGNAL_OPTIONS0_OFFSET:
        return QString("DISP_DISP_SIGNAL_OPTIONS0");
    case DISP_DISP_SIGNAL_OPTIONS1_OFFSET:
        return QString("DISP_DISP_SIGNAL_OPTIONS1");
    case DISP_DISP_WIN_OPTIONS_OFFSET:
        return QString("DISP_DISP_WIN_OPTIONS");
    case DISP_MEM_HIGH_PRIORITY_OFFSET:
        return QString("DISP_MEM_HIGH_PRIORITY");
    case DISP_MEM_HIGH_PRIORITY_TIMER_OFFSET:
        return QString("DISP_MEM_HIGH_PRIORITY_TIMER");
    case DISP_DISP_TIMING_OPTIONS_OFFSET:
        return QString("DISP_DISP_TIMING_OPTIONS");
    case DISP_REF_TO_SYNC_OFFSET:
        return QString("DISP_REF_TO_SYNC");
    case DISP_SYNC_WIDTH_OFFSET:
        return QString("DISP_SYNC_WIDTH");
    case DISP_BACK_PORCH_OFFSET:
        return QString("DISP_BACK_PORCH");
    case DISP_DISP_ACTIVE_OFFSET:
        return QString("DISP_DISP_ACTIVE");
    case DISP_FRONT_PORCH_OFFSET:
        return QString("DISP_FRONT_PORCH");
    case DISP_H_PULSE0_CONTROL_OFFSET:
        return QString("DISP_H_PULSE0_CONTROL");
    case DISP_H_PULSE0_POSITION_A_OFFSET:
        return QString("DISP_H_PULSE0_POSITION_A");
    case DISP_H_PULSE0_POSITION_B_OFFSET:
        return QString("DISP_H_PULSE0_POSITION_B");
    case DISP_H_PULSE0_POSITION_C_OFFSET:
        return QString("DISP_H_PULSE0_POSITION_C");
    case DISP_H_PULSE0_POSITION_D_OFFSET:
        return QString("DISP_H_PULSE0_POSITION_D");
    case DISP_H_PULSE1_CONTROL_OFFSET:
        return QString("DISP_H_PULSE1_CONTROL");
    case DISP_H_PULSE1_POSITION_A_OFFSET:
        return QString("DISP_H_PULSE1_POSITION_A");
    case DISP_H_PULSE1_POSITION_B_OFFSET:
        return QString("DISP_H_PULSE1_POSITION_B");
    case DISP_H_PULSE1_POSITION_C_OFFSET:
        return QString("DISP_H_PULSE1_POSITION_C");
    case DISP_H_PULSE1_POSITION_D_OFFSET:
        return QString("DISP_H_PULSE1_POSITION_D");
    case DISP_H_PULSE2_CONTROL_OFFSET:
        return QString("DISP_H_PULSE2_CONTROL");
    case DISP_H_PULSE2_POSITION_A_OFFSET:
        return QString("DISP_H_PULSE2_POSITION_A");
    case DISP_H_PULSE2_POSITION_B_OFFSET:
        return QString("DISP_H_PULSE2_POSITION_B");
    case DISP_H_PULSE2_POSITION_C_OFFSET:
        return QString("DISP_H_PULSE2_POSITION_C");
    case DISP_H_PULSE2_POSITION_D_OFFSET:
        return QString("DISP_H_PULSE2_POSITION_D");
    case DISP_V_PULSE0_CONTROL_OFFSET:
        return QString("DISP_V_PULSE0_CONTROL");
    case DISP_V_PULSE0_POSITION_A_OFFSET:
        return QString("DISP_V_PULSE0_POSITION_A");
    case DISP_V_PULSE0_POSITION_B_OFFSET:
        return QString("DISP_V_PULSE0_POSITION_B");
    case DISP_V_PULSE0_POSITION_C_OFFSET:
        return QString("DISP_V_PULSE0_POSITION_C");
    case DISP_V_PULSE1_CONTROL_OFFSET:
        return QString("DISP_V_PULSE1_CONTROL");
    case DISP_V_PULSE1_POSITION_A_OFFSET:
        return QString("DISP_V_PULSE1_POSITION_A");
    case DISP_V_PULSE1_POSITION_B_OFFSET:
        return QString("DISP_V_PULSE1_POSITION_B");
    case DISP_V_PULSE1_POSITION_C_OFFSET:
        return QString("DISP_V_PULSE1_POSITION_C");
    case DISP_V_PULSE2_CONTROL_OFFSET:
        return QString("DISP_V_PULSE2_CONTROL");
    case DISP_V_PULSE2_POSITION_A_OFFSET:
        return QString("DISP_V_PULSE2_POSITION_A");
    case DISP_V_PULSE3_CONTROL_OFFSET:
        return QString("DISP_V_PULSE3_CONTROL");
    case DISP_V_PULSE3_POSITION_A_OFFSET:
        return QString("DISP_V_PULSE3_POSITION_A");
    case DISP_M0_CONTROL_OFFSET:
        return QString("DISP_M0_CONTROL");
    case DISP_M1_CONTROL_OFFSET:
        return QString("DISP_M1_CONTROL");
    case DISP_DI_CONTROL_OFFSET:
        return QString("DISP_DI_CONTROL");
    case DISP_PP_CONTROL_OFFSET:
        return QString("DISP_PP_CONTROL");
    case DISP_PP_SELECT_A_OFFSET:
        return QString("DISP_PP_SELECT_A");
    case DISP_PP_SELECT_B_OFFSET:
        return QString("DISP_PP_SELECT_B");
    case DISP_PP_SELECT_C_OFFSET:
        return QString("DISP_PP_SELECT_C");
    case DISP_PP_SELECT_D_OFFSET:
        return QString("DISP_PP_SELECT_D");
    case DISP_DISP_CLOCK_CONTROL_OFFSET:
        return QString("DISP_DISP_CLOCK_CONTROL");
    case DISP_DISP_INTERFACE_CONTROL_OFFSET:
        return QString("DISP_DISP_INTERFACE_CONTROL");
    case DISP_DISP_COLOR_CONTROL_OFFSET:
        return QString("DISP_DISP_COLOR_CONTROL");
    case DISP_SHIFT_CLOCK_OPTIONS_OFFSET:
        return QString("DISP_SHIFT_CLOCK_OPTIONS");
    case DISP_DATA_ENABLE_OPTIONS_OFFSET:
        return QString("DISP_DATA_ENABLE_OPTIONS");
    case DISP_SERIAL_INTERFACE_OPTIONS_OFFSET:
        return QString("DISP_SERIAL_INTERFACE_OPTIONS");
    case DISP_LCD_SPI_OPTIONS_OFFSET:
        return QString("DISP_LCD_SPI_OPTIONS");
    case DISP_BORDER_COLOR_OFFSET:
        return QString("DISP_BORDER_COLOR");
    case DISP_COLOR_KEY0_LOWER_OFFSET:
        return QString("DISP_COLOR_KEY0_LOWER");
    case DISP_COLOR_KEY0_UPPER_OFFSET:
        return QString("DISP_COLOR_KEY0_UPPER");
    case DISP_COLOR_KEY1_LOWER_OFFSET:
        return QString("DISP_COLOR_KEY1_LOWER");
    case DISP_COLOR_KEY1_UPPER_OFFSET:
        return QString("DISP_COLOR_KEY1_UPPER");
    case DISP_CURSOR_FOREGROUND_OFFSET:
        return QString("DISP_CURSOR_FOREGROUND");
    case DISP_CURSOR_BACKGROUND_OFFSET:
        return QString("DISP_CURSOR_BACKGROUND");
    case DISP_CURSOR_START_ADDR_OFFSET:
        return QString("DISP_CURSOR_START_ADDR");
    case DISP_CURSOR_START_ADDR_NS_OFFSET:
        return QString("DISP_CURSOR_START_ADDR_NS");
    case DISP_CURSOR_POSITION_OFFSET:
        return QString("DISP_CURSOR_POSITION");
    case DISP_CURSOR_POSITION_NS_OFFSET:
        return QString("DISP_CURSOR_POSITION_NS");
    case DISP_INIT_SEQ_CONTROL_OFFSET:
        return QString("DISP_INIT_SEQ_CONTROL");
    case DISP_SPI_INIT_SEQ_DATA_A_OFFSET:
        return QString("DISP_SPI_INIT_SEQ_DATA_A");
    case DISP_SPI_INIT_SEQ_DATA_B_OFFSET:
        return QString("DISP_SPI_INIT_SEQ_DATA_B");
    case DISP_SPI_INIT_SEQ_DATA_C_OFFSET:
        return QString("DISP_SPI_INIT_SEQ_DATA_C");
    case DISP_SPI_INIT_SEQ_DATA_D_OFFSET:
        return QString("DISP_SPI_INIT_SEQ_DATA_D");
    case DISP_DC_MCCIF_FIFOCTRL_OFFSET:
        return QString("DISP_DC_MCCIF_FIFOCTRL");
    case DISP_MCCIF_DISPLAY0A_HYST_OFFSET:
        return QString("DISP_MCCIF_DISPLAY0A_HYST");
    case DISP_MCCIF_DISPLAY0B_HYST_OFFSET:
        return QString("DISP_MCCIF_DISPLAY0B_HYST");
    case DISP_MCCIF_DISPLAY0C_HYST_OFFSET:
        return QString("DISP_MCCIF_DISPLAY0C_HYST");
    case DISP_MCCIF_DISPLAY1B_HYST_OFFSET:
        return QString("DISP_MCCIF_DISPLAY1B_HYST");
    case DISP_DAC_CRT_CTRL_OFFSET:
        return QString("DISP_DAC_CRT_CTRL");
    case DISP_DISP_MISC_CONTROL_OFFSET:
        return QString("DISP_DISP_MISC_CONTROL");
    case WINC_A_COLOR_PALETTE_OFFSET:
        return QString("WINC_A_COLOR_PALETTE");
    case WINC_A_PALETTE_COLOR_EXT_OFFSET:
        return QString("WINC_A_PALETTE_COLOR_EXT");
    case WIN_A_WIN_OPTIONS_OFFSET:
        return QString("WIN_A_WIN_OPTIONS");
    case WIN_A_BYTE_SWAP_OFFSET:
        return QString("WIN_A_BYTE_SWAP");
    case WIN_A_BUFFER_CONTROL_OFFSET:
        return QString("WIN_A_BUFFER_CONTROL");
    case WIN_A_COLOR_DEPTH_OFFSET:
        return QString("WIN_A_COLOR_DEPTH");
    case WIN_A_POSITION_OFFSET:
        return QString("WIN_A_POSITION");
    case WIN_A_SIZE_OFFSET:
        return QString("WIN_A_SIZE");
    case WIN_A_PRESCALED_SIZE_OFFSET:
        return QString("WIN_A_PRESCALED_SIZE");
    case WIN_A_H_INITIAL_DDA_OFFSET:
        return QString("WIN_A_H_INITIAL_DDA");
    case WIN_A_V_INITIAL_DDA_OFFSET:
        return QString("WIN_A_V_INITIAL_DDA");
    case WIN_A_DDA_INCREMENT_OFFSET:
        return QString("WIN_A_DDA_INCREMENT");
    case WIN_A_LINE_STRIDE_OFFSET:
        return QString("WIN_A_LINE_STRIDE");
    case WIN_A_BUF_STRIDE_OFFSET:
        return QString("WIN_A_BUF_STRIDE");
    case WIN_A_BUFFER_ADDR_MODE_OFFSET:
        return QString("WIN_A_BUFFER_ADDR_MODE");
    case WIN_A_DV_CONTROL_OFFSET:
        return QString("WIN_A_DV_CONTROL");
    case WIN_A_BLEND_NOKEY_OFFSET:
        return QString("WIN_A_BLEND_NOKEY");
    case WIN_A_BLEND_1WIN_OFFSET:
        return QString("WIN_A_BLEND_1WIN");
    case WIN_A_BLEND_2WIN_B_OFFSET:
        return QString("WIN_A_BLEND_2WIN_B");
    case WIN_A_BLEND_2WIN_C_OFFSET:
        return QString("WIN_A_BLEND_2WIN_C");
    case WIN_A_BLEND_3WIN_BC_OFFSET:
        return QString("WIN_A_BLEND_3WIN_BC");
    case WIN_A_HP_FETCH_CONTROL_OFFSET:
        return QString("WIN_A_HP_FETCH_CONTROL");
    case WINBUF_A_START_ADDR_OFFSET:
        return QString("WINBUF_A_START_ADDR");
    case WINBUF_A_START_ADDR_NS_OFFSET:
        return QString("WINBUF_A_START_ADDR_NS");
    case WINBUF_A_ADDR_H_OFFSET_OFFSET:
        return QString("WINBUF_A_ADDR_H_OFFSET");
    case WINBUF_A_ADDR_H_OFFSET_NS_OFFSET:
        return QString("WINBUF_A_ADDR_H_OFFSET_NS");
    case WINBUF_A_ADDR_V_OFFSET_OFFSET:
        return QString("WINBUF_A_ADDR_V_OFFSET");
    case WINBUF_A_ADDR_V_OFFSET_NS_OFFSET:
        return QString("WINBUF_A_ADDR_V_OFFSET_NS");
    case WINBUF_A_UFLOW_STATUS_OFFSET:
        return QString("WINBUF_A_UFLOW_STATUS");
    case WINC_B_COLOR_PALETTE_OFFSET:
        return QString("WINC_B_COLOR_PALETTE");
    case WINC_B_PALETTE_COLOR_EXT_OFFSET:
        return QString("WINC_B_PALETTE_COLOR_EXT");
    case WINC_B_H_FILTER_P00_OFFSET:
        return QString("WINC_B_H_FILTER_P00");
    case WINC_B_H_FILTER_P01_OFFSET:
        return QString("WINC_B_H_FILTER_P01");
    case WINC_B_H_FILTER_P02_OFFSET:
        return QString("WINC_B_H_FILTER_P02");
    case WINC_B_H_FILTER_P03_OFFSET:
        return QString("WINC_B_H_FILTER_P03");
    case WINC_B_H_FILTER_P04_OFFSET:
        return QString("WINC_B_H_FILTER_P04");
    case WINC_B_H_FILTER_P05_OFFSET:
        return QString("WINC_B_H_FILTER_P05");
    case WINC_B_H_FILTER_P06_OFFSET:
        return QString("WINC_B_H_FILTER_P06");
    case WINC_B_H_FILTER_P07_OFFSET:
        return QString("WINC_B_H_FILTER_P07");
    case WINC_B_H_FILTER_P08_OFFSET:
        return QString("WINC_B_H_FILTER_P08");
    case WINC_B_H_FILTER_P09_OFFSET:
        return QString("WINC_B_H_FILTER_P09");
    case WINC_B_H_FILTER_P0A_OFFSET:
        return QString("WINC_B_H_FILTER_P0A");
    case WINC_B_H_FILTER_P0B_OFFSET:
        return QString("WINC_B_H_FILTER_P0B");
    case WINC_B_H_FILTER_P0C_OFFSET:
        return QString("WINC_B_H_FILTER_P0C");
    case WINC_B_H_FILTER_P0D_OFFSET:
        return QString("WINC_B_H_FILTER_P0D");
    case WINC_B_H_FILTER_P0E_OFFSET:
        return QString("WINC_B_H_FILTER_P0E");
    case WINC_B_H_FILTER_P0F_OFFSET:
        return QString("WINC_B_H_FILTER_P0F");
    case WINC_B_CSC_YOF_OFFSET:
        return QString("WINC_B_CSC_YOF");
    case WINC_B_CSC_KYRGB_OFFSET:
        return QString("WINC_B_CSC_KYRGB");
    case WINC_B_CSC_KUR_OFFSET:
        return QString("WINC_B_CSC_KUR");
    case WINC_B_CSC_KVR_OFFSET:
        return QString("WINC_B_CSC_KVR");
    case WINC_B_CSC_KUG_OFFSET:
        return QString("WINC_B_CSC_KUG");
    case WINC_B_CSC_KVG_OFFSET:
        return QString("WINC_B_CSC_KVG");
    case WINC_B_CSC_KUB_OFFSET:
        return QString("WINC_B_CSC_KUB");
    case WINC_B_CSC_KVB_OFFSET:
        return QString("WINC_B_CSC_KVB");
    case WINC_B_V_FILTER_P00_OFFSET:
        return QString("WINC_B_V_FILTER_P00");
    case WINC_B_V_FILTER_P01_OFFSET:
        return QString("WINC_B_V_FILTER_P01");
    case WINC_B_V_FILTER_P02_OFFSET:
        return QString("WINC_B_V_FILTER_P02");
    case WINC_B_V_FILTER_P03_OFFSET:
        return QString("WINC_B_V_FILTER_P03");
    case WINC_B_V_FILTER_P04_OFFSET:
        return QString("WINC_B_V_FILTER_P04");
    case WINC_B_V_FILTER_P05_OFFSET:
        return QString("WINC_B_V_FILTER_P05");
    case WINC_B_V_FILTER_P06_OFFSET:
        return QString("WINC_B_V_FILTER_P06");
    case WINC_B_V_FILTER_P07_OFFSET:
        return QString("WINC_B_V_FILTER_P07");
    case WINC_B_V_FILTER_P08_OFFSET:
        return QString("WINC_B_V_FILTER_P08");
    case WINC_B_V_FILTER_P09_OFFSET:
        return QString("WINC_B_V_FILTER_P09");
    case WINC_B_V_FILTER_P0A_OFFSET:
        return QString("WINC_B_V_FILTER_P0A");
    case WINC_B_V_FILTER_P0B_OFFSET:
        return QString("WINC_B_V_FILTER_P0B");
    case WINC_B_V_FILTER_P0C_OFFSET:
        return QString("WINC_B_V_FILTER_P0C");
    case WINC_B_V_FILTER_P0D_OFFSET:
        return QString("WINC_B_V_FILTER_P0D");
    case WINC_B_V_FILTER_P0E_OFFSET:
        return QString("WINC_B_V_FILTER_P0E");
    case WINC_B_V_FILTER_P0F_OFFSET:
        return QString("WINC_B_V_FILTER_P0F");
    case WIN_B_WIN_OPTIONS_OFFSET:
        return QString("WIN_B_WIN_OPTIONS");
    case WIN_B_BYTE_SWAP_OFFSET:
        return QString("WIN_B_BYTE_SWAP");
    case WIN_B_BUFFER_CONTROL_OFFSET:
        return QString("WIN_B_BUFFER_CONTROL");
    case WIN_B_COLOR_DEPTH_OFFSET:
        return QString("WIN_B_COLOR_DEPTH");
    case WIN_B_POSITION_OFFSET:
        return QString("WIN_B_POSITION");
    case WIN_B_SIZE_OFFSET:
        return QString("WIN_B_SIZE");
    case WIN_B_PRESCALED_SIZE_OFFSET:
        return QString("WIN_B_PRESCALED_SIZE");
    case WIN_B_H_INITIAL_DDA_OFFSET:
        return QString("WIN_B_H_INITIAL_DDA");
    case WIN_B_V_INITIAL_DDA_OFFSET:
        return QString("WIN_B_V_INITIAL_DDA");
    case WIN_B_DDA_INCREMENT_OFFSET:
        return QString("WIN_B_DDA_INCREMENT");
    case WIN_B_LINE_STRIDE_OFFSET:
        return QString("WIN_B_LINE_STRIDE");
    case WIN_B_BUF_STRIDE_OFFSET:
        return QString("WIN_B_BUF_STRIDE");
    case WIN_B_UV_BUF_STRIDE_OFFSET:
        return QString("WIN_B_UV_BUF_STRIDE");
    case WIN_B_BUFFER_ADDR_MODE_OFFSET:
        return QString("WIN_B_BUFFER_ADDR_MODE");
    case WIN_B_DV_CONTROL_OFFSET:
        return QString("WIN_B_DV_CONTROL");
    case WIN_B_BLEND_NOKEY_OFFSET:
        return QString("WIN_B_BLEND_NOKEY");
    case WIN_B_BLEND_1WIN_OFFSET:
        return QString("WIN_B_BLEND_1WIN");
    case WIN_B_BLEND_2WIN_A_OFFSET:
        return QString("WIN_B_BLEND_2WIN_A");
    case WIN_B_BLEND_2WIN_C_OFFSET:
        return QString("WIN_B_BLEND_2WIN_C");
    case WIN_B_BLEND_3WIN_AC_OFFSET:
        return QString("WIN_B_BLEND_3WIN_AC");
    case WIN_B_HP_FETCH_CONTROL_OFFSET:
        return QString("WIN_B_HP_FETCH_CONTROL");
    case WINBUF_B_START_ADDR_OFFSET:
        return QString("WINBUF_B_START_ADDR");
    case WINBUF_B_START_ADDR_NS_OFFSET:
        return QString("WINBUF_B_START_ADDR_NS");
    case WINBUF_B_START_ADDR_U_OFFSET:
        return QString("WINBUF_B_START_ADDR_U");
    case WINBUF_B_START_ADDR_U_NS_OFFSET:
        return QString("WINBUF_B_START_ADDR_U_NS");
    case WINBUF_B_START_ADDR_V_OFFSET:
        return QString("WINBUF_B_START_ADDR_V");
    case WINBUF_B_START_ADDR_V_NS_OFFSET:
        return QString("WINBUF_B_START_ADDR_V_NS");
    case WINBUF_B_ADDR_H_OFFSET_OFFSET:
        return QString("WINBUF_B_ADDR_H_OFFSET");
    case WINBUF_B_ADDR_H_OFFSET_NS_OFFSET:
        return QString("WINBUF_B_ADDR_H_OFFSET_NS");
    case WINBUF_B_ADDR_V_OFFSET_OFFSET:
        return QString("WINBUF_B_ADDR_V_OFFSET");
    case WINBUF_B_ADDR_V_OFFSET_NS_OFFSET:
        return QString("WINBUF_B_ADDR_V_OFFSET_NS");
    case WINBUF_B_UFLOW_STATUS_OFFSET:
        return QString("WINBUF_B_UFLOW_STATUS");
    case WINC_C_COLOR_PALETTE_OFFSET:
        return QString("WINC_C_COLOR_PALETTE");
    case WINC_C_PALETTE_COLOR_EXT_OFFSET:
        return QString("WINC_C_PALETTE_COLOR_EXT");
    case WINC_C_H_FILTER_P00_OFFSET:
        return QString("WINC_C_H_FILTER_P00");
    case WINC_C_H_FILTER_P01_OFFSET:
        return QString("WINC_C_H_FILTER_P01");
    case WINC_C_H_FILTER_P02_OFFSET:
        return QString("WINC_C_H_FILTER_P02");
    case WINC_C_H_FILTER_P03_OFFSET:
        return QString("WINC_C_H_FILTER_P03");
    case WINC_C_H_FILTER_P04_OFFSET:
        return QString("WINC_C_H_FILTER_P04");
    case WINC_C_H_FILTER_P05_OFFSET:
        return QString("WINC_C_H_FILTER_P05");
    case WINC_C_H_FILTER_P06_OFFSET:
        return QString("WINC_C_H_FILTER_P06");
    case WINC_C_H_FILTER_P07_OFFSET:
        return QString("WINC_C_H_FILTER_P07");
    case WINC_C_H_FILTER_P08_OFFSET:
        return QString("WINC_C_H_FILTER_P08");
    case WINC_C_H_FILTER_P09_OFFSET:
        return QString("WINC_C_H_FILTER_P09");
    case WINC_C_H_FILTER_P0A_OFFSET:
        return QString("WINC_C_H_FILTER_P0A");
    case WINC_C_H_FILTER_P0B_OFFSET:
        return QString("WINC_C_H_FILTER_P0B");
    case WINC_C_H_FILTER_P0C_OFFSET:
        return QString("WINC_C_H_FILTER_P0C");
    case WINC_C_H_FILTER_P0D_OFFSET:
        return QString("WINC_C_H_FILTER_P0D");
    case WINC_C_H_FILTER_P0E_OFFSET:
        return QString("WINC_C_H_FILTER_P0E");
    case WINC_C_H_FILTER_P0F_OFFSET:
        return QString("WINC_C_H_FILTER_P0F");
    case WINC_C_CSC_YOF_OFFSET:
        return QString("WINC_C_CSC_YOF");
    case WINC_C_CSC_KYRGB_OFFSET:
        return QString("WINC_C_CSC_KYRGB");
    case WINC_C_CSC_KUR_OFFSET:
        return QString("WINC_C_CSC_KUR");
    case WINC_C_CSC_KVR_OFFSET:
        return QString("WINC_C_CSC_KVR");
    case WINC_C_CSC_KUG_OFFSET:
        return QString("WINC_C_CSC_KUG");
    case WINC_C_CSC_KVG_OFFSET:
        return QString("WINC_C_CSC_KVG");
    case WINC_C_CSC_KUB_OFFSET:
        return QString("WINC_C_CSC_KUB");
    case WINC_C_CSC_KVB_OFFSET:
        return QString("WINC_C_CSC_KVB");
    case WIN_C_WIN_OPTIONS_OFFSET:
        return QString("WIN_C_WIN_OPTIONS");
    case WIN_C_BYTE_SWAP_OFFSET:
        return QString("WIN_C_BYTE_SWAP");
    case WIN_C_BUFFER_CONTROL_OFFSET:
        return QString("WIN_C_BUFFER_CONTROL");
    case WIN_C_COLOR_DEPTH_OFFSET:
        return QString("WIN_C_COLOR_DEPTH");
    case WIN_C_POSITION_OFFSET:
        return QString("WIN_C_POSITION");
    case WIN_C_SIZE_OFFSET:
        return QString("WIN_C_SIZE");
    case WIN_C_PRESCALED_SIZE_OFFSET:
        return QString("WIN_C_PRESCALED_SIZE");
    case WIN_C_H_INITIAL_DDA_OFFSET:
        return QString("WIN_C_H_INITIAL_DDA");
    case WIN_C_V_INITIAL_DDA_OFFSET:
        return QString("WIN_C_V_INITIAL_DDA");
    case WIN_C_DDA_INCREMENT_OFFSET:
        return QString("WIN_C_DDA_INCREMENT");
    case WIN_C_LINE_STRIDE_OFFSET:
        return QString("WIN_C_LINE_STRIDE");
    case WIN_C_BUF_STRIDE_OFFSET:
        return QString("WIN_C_BUF_STRIDE");
    case WIN_C_UV_BUF_STRIDE_OFFSET:
        return QString("WIN_C_UV_BUF_STRIDE");
    case WIN_C_BUFFER_ADDR_MODE_OFFSET:
        return QString("WIN_C_BUFFER_ADDR_MODE");
    case WIN_C_DV_CONTROL_OFFSET:
        return QString("WIN_C_DV_CONTROL");
    case WIN_C_BLEND_NOKEY_OFFSET:
        return QString("WIN_C_BLEND_NOKEY");
    case WIN_C_BLEND_1WIN_OFFSET:
        return QString("WIN_C_BLEND_1WIN");
    case WIN_C_BLEND_2WIN_A_OFFSET:
        return QString("WIN_C_BLEND_2WIN_A");
    case WIN_C_BLEND_2WIN_B_OFFSET:
        return QString("WIN_C_BLEND_2WIN_B");
    case WIN_C_BLEND_3WIN_AB_OFFSET:
        return QString("WIN_C_BLEND_3WIN_AB");
    case WIN_C_HP_FETCH_CONTROL_OFFSET:
        return QString("WIN_C_HP_FETCH_CONTROL");
    case WINBUF_C_START_ADDR_OFFSET:
        return QString("WINBUF_C_START_ADDR");
    case WINBUF_C_START_ADDR_NS_OFFSET:
        return QString("WINBUF_C_START_ADDR_NS");
    case WINBUF_C_START_ADDR_U_OFFSET:
        return QString("WINBUF_C_START_ADDR_U");
    case WINBUF_C_START_ADDR_U_NS_OFFSET:
        return QString("WINBUF_C_START_ADDR_U_NS");
    case WINBUF_C_START_ADDR_V_OFFSET:
        return QString("WINBUF_C_START_ADDR_V");
    case WINBUF_C_START_ADDR_V_NS_OFFSET:
        return QString("WINBUF_C_START_ADDR_V_NS");
    case WINBUF_C_ADDR_H_OFFSET_OFFSET:
        return QString("WINBUF_C_ADDR_H_OFFSET");
    case WINBUF_C_ADDR_H_OFFSET_NS_OFFSET:
        return QString("WINBUF_C_ADDR_H_OFFSET_NS");
    case WINBUF_C_ADDR_V_OFFSET_OFFSET:
        return QString("WINBUF_C_ADDR_V_OFFSET");
    case WINBUF_C_ADDR_V_OFFSET_NS_OFFSET:
        return QString("WINBUF_C_ADDR_V_OFFSET_NS");
    case WINBUF_C_UFLOW_STATUS_OFFSET:
        return QString("WINBUF_C_UFLOW_STATUS");
    case DISP_SD_CONTROL_OFFSET:
        return QString("DISP_SD_CONTROL");
    case DISP_SD_CSC_COEFF_OFFSET:
        return QString("DISP_SD_CSC_COEFF");
    case DISP_SD_LUT_OFFSET:
        return QString("DISP_SD_LUT");
    case DISP_SD_LUT_1_OFFSET:
        return QString("DISP_SD_LUT_1");
    case DISP_SD_LUT_2_OFFSET:
        return QString("DISP_SD_LUT_2");
    case DISP_SD_LUT_3_OFFSET:
        return QString("DISP_SD_LUT_3");
    case DISP_SD_LUT_4_OFFSET:
        return QString("DISP_SD_LUT_4");
    case DISP_SD_LUT_5_OFFSET:
        return QString("DISP_SD_LUT_5");
    case DISP_SD_LUT_6_OFFSET:
        return QString("DISP_SD_LUT_6");
    case DISP_SD_LUT_7_OFFSET:
        return QString("DISP_SD_LUT_7");
    case DISP_SD_LUT_8_OFFSET:
        return QString("DISP_SD_LUT_8");
    case DISP_SD_FLICKER_CONTROL_OFFSET:
        return QString("DISP_SD_FLICKER_CONTROL");
    case DISP_SD_PIXEL_COUNT_OFFSET:
        return QString("DISP_SD_PIXEL_COUNT");
    case DISP_SD_HISTOGRAM_OFFSET:
        return QString("DISP_SD_HISTOGRAM");
    case DISP_SD_HISTOGRAM_1_OFFSET:
        return QString("DISP_SD_HISTOGRAM_1");
    case DISP_SD_HISTOGRAM_2_OFFSET:
        return QString("DISP_SD_HISTOGRAM_2");
    case DISP_SD_HISTOGRAM_3_OFFSET:
        return QString("DISP_SD_HISTOGRAM_3");
    case DISP_SD_HISTOGRAM_4_OFFSET:
        return QString("DISP_SD_HISTOGRAM_4");
    case DISP_SD_HISTOGRAM_5_OFFSET:
        return QString("DISP_SD_HISTOGRAM_5");
    case DISP_SD_HISTOGRAM_6_OFFSET:
        return QString("DISP_SD_HISTOGRAM_6");
    case DISP_SD_HISTOGRAM_7_OFFSET:
        return QString("DISP_SD_HISTOGRAM_7");
    case DISP_SD_BL_PARAMETERS_OFFSET:
        return QString("DISP_SD_BL_PARAMETERS");
    case DISP_SD_BL_TF_OFFSET:
        return QString("DISP_SD_BL_TF");
    case DISP_SD_BL_TF_1_OFFSET:
        return QString("DISP_SD_BL_TF_1");
    case DISP_SD_BL_TF_2_OFFSET:
        return QString("DISP_SD_BL_TF_2");
    case DISP_SD_BL_TF_3_OFFSET:
        return QString("DISP_SD_BL_TF_3");
    case DISP_SD_BL_CONTROL_OFFSET:
        return QString("DISP_SD_BL_CONTROL");
    case WINC_B_COLOR_PALETTE_1_OFFSET:
        return QString("WINC_B_COLOR_PALETTE_1");
    case WINC_B_COLOR_PALETTE_2_OFFSET:
        return QString("WINC_B_COLOR_PALETTE_2");
    case WINC_B_COLOR_PALETTE_3_OFFSET:
        return QString("WINC_B_COLOR_PALETTE_3");
    case WINC_B_COLOR_PALETTE_4_OFFSET:
        return QString("WINC_B_COLOR_PALETTE_4");
    case WINC_B_COLOR_PALETTE_5_OFFSET:
        return QString("WINC_B_COLOR_PALETTE_5");
    case WINC_B_COLOR_PALETTE_6_OFFSET:
        return QString("WINC_B_COLOR_PALETTE_6");
    case WINC_B_COLOR_PALETTE_7_OFFSET:
        return QString("WINC_B_COLOR_PALETTE_7");
    case WINC_B_COLOR_PALETTE_8_OFFSET:
        return QString("WINC_B_COLOR_PALETTE_8");
    case WINC_B_COLOR_PALETTE_9_OFFSET:
        return QString("WINC_B_COLOR_PALETTE_9");

    default:
        break;
    }

    qDebug() << QString().sprintf("DC: %s: Ooops... 0x%x", __func__, entry.offset);

    return QString().sprintf("Ooops... @0x%X", entry.offset);
}

void DcDev::fill_bits_details(const u_int32_t &offset,
                                      const u_int32_t &value, const u_int32_t &new_value)
{
    switch (offset) {
    case CMD_GENERAL_INCR_SYNCPT_OFFSET:
        fill_cmd_general_incr_syncpt_details(value, new_value);
        break;
    case CMD_GENERAL_INCR_SYNCPT_CNTRL_OFFSET:
        fill_cmd_general_incr_syncpt_cntrl_details(value, new_value);
        break;
    case CMD_GENERAL_INCR_SYNCPT_ERROR_OFFSET:
        fill_cmd_general_incr_syncpt_error_details(value, new_value);
        break;
    case CMD_WIN_A_INCR_SYNCPT_OFFSET:
        fill_cmd_win_a_incr_syncpt_details(value, new_value);
        break;
    case CMD_WIN_A_INCR_SYNCPT_CNTRL_OFFSET:
        fill_cmd_win_a_incr_syncpt_cntrl_details(value, new_value);
        break;
    case CMD_WIN_A_INCR_SYNCPT_ERROR_OFFSET:
        fill_cmd_win_a_incr_syncpt_error_details(value, new_value);
        break;
    case CMD_WIN_B_INCR_SYNCPT_OFFSET:
        fill_cmd_win_b_incr_syncpt_details(value, new_value);
        break;
    case CMD_WIN_B_INCR_SYNCPT_CNTRL_OFFSET:
        fill_cmd_win_b_incr_syncpt_cntrl_details(value, new_value);
        break;
    case CMD_WIN_B_INCR_SYNCPT_ERROR_OFFSET:
        fill_cmd_win_b_incr_syncpt_error_details(value, new_value);
        break;
    case CMD_WIN_C_INCR_SYNCPT_OFFSET:
        fill_cmd_win_c_incr_syncpt_details(value, new_value);
        break;
    case CMD_WIN_C_INCR_SYNCPT_CNTRL_OFFSET:
        fill_cmd_win_c_incr_syncpt_cntrl_details(value, new_value);
        break;
    case CMD_WIN_C_INCR_SYNCPT_ERROR_OFFSET:
        fill_cmd_win_c_incr_syncpt_error_details(value, new_value);
        break;
    case CMD_CONT_SYNCPT_VSYNC_OFFSET:
        fill_cmd_cont_syncpt_vsync_details(value, new_value);
        break;
    case CMD_CTXSW_OFFSET:
        fill_cmd_ctxsw_details(value, new_value);
        break;
    case CMD_DISPLAY_COMMAND_OPTION0_OFFSET:
        fill_cmd_display_command_option0_details(value, new_value);
        break;
    case CMD_DISPLAY_COMMAND_OFFSET:
        fill_cmd_display_command_details(value, new_value);
        break;
    case CMD_SIGNAL_RAISE_OFFSET:
        fill_cmd_signal_raise_details(value, new_value);
        break;
    case CMD_DISPLAY_POWER_CONTROL_OFFSET:
        fill_cmd_display_power_control_details(value, new_value);
        break;
    case CMD_INT_STATUS_OFFSET:
        fill_cmd_int_status_details(value, new_value);
        break;
    case CMD_INT_MASK_OFFSET:
        fill_cmd_int_mask_details(value, new_value);
        break;
    case CMD_INT_ENABLE_OFFSET:
        fill_cmd_int_enable_details(value, new_value);
        break;
    case CMD_INT_TYPE_OFFSET:
        fill_cmd_int_type_details(value, new_value);
        break;
    case CMD_INT_POLARITY_OFFSET:
        fill_cmd_int_polarity_details(value, new_value);
        break;
    case CMD_SIGNAL_RAISE1_OFFSET:
        fill_cmd_signal_raise1_details(value, new_value);
        break;
    case CMD_SIGNAL_RAISE2_OFFSET:
        fill_cmd_signal_raise2_details(value, new_value);
        break;
    case CMD_SIGNAL_RAISE3_OFFSET:
        fill_cmd_signal_raise3_details(value, new_value);
        break;
    case CMD_STATE_ACCESS_OFFSET:
        fill_cmd_state_access_details(value, new_value);
        break;
    case CMD_STATE_CONTROL_OFFSET:
        fill_cmd_state_control_details(value, new_value);
        break;
    case CMD_DISPLAY_WINDOW_HEADER_OFFSET:
        fill_cmd_display_window_header_details(value, new_value);
        break;
    case CMD_REG_ACT_CONTROL_OFFSET:
        fill_cmd_reg_act_control_details(value, new_value);
        break;
    case COM_CRC_CONTROL_OFFSET:
        fill_com_crc_control_details(value, new_value);
        break;
    case COM_CRC_CHECKSUM_OFFSET:
        fill_com_crc_checksum_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_ENABLE0_OFFSET:
        fill_com_pin_output_enable0_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_ENABLE1_OFFSET:
        fill_com_pin_output_enable1_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_ENABLE2_OFFSET:
        fill_com_pin_output_enable2_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_ENABLE3_OFFSET:
        fill_com_pin_output_enable3_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_POLARITY0_OFFSET:
        fill_com_pin_output_polarity0_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_POLARITY1_OFFSET:
        fill_com_pin_output_polarity1_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_POLARITY2_OFFSET:
        fill_com_pin_output_polarity2_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_POLARITY3_OFFSET:
        fill_com_pin_output_polarity3_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_DATA0_OFFSET:
        fill_com_pin_output_data0_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_DATA1_OFFSET:
        fill_com_pin_output_data1_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_DATA2_OFFSET:
        fill_com_pin_output_data2_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_DATA3_OFFSET:
        fill_com_pin_output_data3_details(value, new_value);
        break;
    case COM_PIN_INPUT_ENABLE0_OFFSET:
        fill_com_pin_input_enable0_details(value, new_value);
        break;
    case COM_PIN_INPUT_ENABLE1_OFFSET:
        fill_com_pin_input_enable1_details(value, new_value);
        break;
    case COM_PIN_INPUT_ENABLE2_OFFSET:
        fill_com_pin_input_enable2_details(value, new_value);
        break;
    case COM_PIN_INPUT_ENABLE3_OFFSET:
        fill_com_pin_input_enable3_details(value, new_value);
        break;
    case COM_PIN_INPUT_DATA0_OFFSET:
        fill_com_pin_input_data0_details(value, new_value);
        break;
    case COM_PIN_INPUT_DATA1_OFFSET:
        fill_com_pin_input_data1_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_SELECT0_OFFSET:
        fill_com_pin_output_select0_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_SELECT1_OFFSET:
        fill_com_pin_output_select1_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_SELECT2_OFFSET:
        fill_com_pin_output_select2_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_SELECT3_OFFSET:
        fill_com_pin_output_select3_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_SELECT4_OFFSET:
        fill_com_pin_output_select4_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_SELECT5_OFFSET:
        fill_com_pin_output_select5_details(value, new_value);
        break;
    case COM_PIN_OUTPUT_SELECT6_OFFSET:
        fill_com_pin_output_select6_details(value, new_value);
        break;
    case COM_PIN_MISC_CONTROL_OFFSET:
        fill_com_pin_misc_control_details(value, new_value);
        break;
    case COM_PM0_CONTROL_OFFSET:
        fill_com_pm0_control_details(value, new_value);
        break;
    case COM_PM0_DUTY_CYCLE_OFFSET:
        fill_com_pm0_duty_cycle_details(value, new_value);
        break;
    case COM_PM1_CONTROL_OFFSET:
        fill_com_pm1_control_details(value, new_value);
        break;
    case COM_PM1_DUTY_CYCLE_OFFSET:
        fill_com_pm1_duty_cycle_details(value, new_value);
        break;
    case COM_SPI_CONTROL_OFFSET:
        fill_com_spi_control_details(value, new_value);
        break;
    case COM_SPI_START_BYTE_OFFSET:
        fill_com_spi_start_byte_details(value, new_value);
        break;
    case COM_HSPI_WRITE_DATA_AB_OFFSET:
        fill_com_hspi_write_data_ab_details(value, new_value);
        break;
    case COM_HSPI_WRITE_DATA_CD_OFFSET:
        fill_com_hspi_write_data_cd_details(value, new_value);
        break;
    case COM_HSPI_CS_DC_OFFSET:
        fill_com_hspi_cs_dc_details(value, new_value);
        break;
    case COM_SCRATCH_REGISTER_A_OFFSET:
        fill_com_scratch_register_a_details(value, new_value);
        break;
    case COM_SCRATCH_REGISTER_B_OFFSET:
        fill_com_scratch_register_b_details(value, new_value);
        break;
    case COM_GPIO_CTRL_OFFSET:
        fill_com_gpio_ctrl_details(value, new_value);
        break;
    case COM_GPIO_DEBOUNCE_COUNTER_OFFSET:
        fill_com_gpio_debounce_counter_details(value, new_value);
        break;
    case COM_CRC_CHECKSUM_LATCHED_OFFSET:
        fill_com_crc_checksum_latched_details(value, new_value);
        break;
    case DISP_DISP_SIGNAL_OPTIONS0_OFFSET:
        fill_disp_disp_signal_options0_details(value, new_value);
        break;
    case DISP_DISP_SIGNAL_OPTIONS1_OFFSET:
        fill_disp_disp_signal_options1_details(value, new_value);
        break;
    case DISP_DISP_WIN_OPTIONS_OFFSET:
        fill_disp_disp_win_options_details(value, new_value);
        break;
    case DISP_MEM_HIGH_PRIORITY_OFFSET:
        fill_disp_mem_high_priority_details(value, new_value);
        break;
    case DISP_MEM_HIGH_PRIORITY_TIMER_OFFSET:
        fill_disp_mem_high_priority_timer_details(value, new_value);
        break;
    case DISP_DISP_TIMING_OPTIONS_OFFSET:
        fill_disp_disp_timing_options_details(value, new_value);
        break;
    case DISP_REF_TO_SYNC_OFFSET:
        fill_disp_ref_to_sync_details(value, new_value);
        break;
    case DISP_SYNC_WIDTH_OFFSET:
        fill_disp_sync_width_details(value, new_value);
        break;
    case DISP_BACK_PORCH_OFFSET:
        fill_disp_back_porch_details(value, new_value);
        break;
    case DISP_DISP_ACTIVE_OFFSET:
        fill_disp_disp_active_details(value, new_value);
        break;
    case DISP_FRONT_PORCH_OFFSET:
        fill_disp_front_porch_details(value, new_value);
        break;
    case DISP_H_PULSE0_CONTROL_OFFSET:
        fill_disp_h_pulse0_control_details(value, new_value);
        break;
    case DISP_H_PULSE0_POSITION_A_OFFSET:
        fill_disp_h_pulse0_position_a_details(value, new_value);
        break;
    case DISP_H_PULSE0_POSITION_B_OFFSET:
        fill_disp_h_pulse0_position_b_details(value, new_value);
        break;
    case DISP_H_PULSE0_POSITION_C_OFFSET:
        fill_disp_h_pulse0_position_c_details(value, new_value);
        break;
    case DISP_H_PULSE0_POSITION_D_OFFSET:
        fill_disp_h_pulse0_position_d_details(value, new_value);
        break;
    case DISP_H_PULSE1_CONTROL_OFFSET:
        fill_disp_h_pulse1_control_details(value, new_value);
        break;
    case DISP_H_PULSE1_POSITION_A_OFFSET:
        fill_disp_h_pulse1_position_a_details(value, new_value);
        break;
    case DISP_H_PULSE1_POSITION_B_OFFSET:
        fill_disp_h_pulse1_position_b_details(value, new_value);
        break;
    case DISP_H_PULSE1_POSITION_C_OFFSET:
        fill_disp_h_pulse1_position_c_details(value, new_value);
        break;
    case DISP_H_PULSE1_POSITION_D_OFFSET:
        fill_disp_h_pulse1_position_d_details(value, new_value);
        break;
    case DISP_H_PULSE2_CONTROL_OFFSET:
        fill_disp_h_pulse2_control_details(value, new_value);
        break;
    case DISP_H_PULSE2_POSITION_A_OFFSET:
        fill_disp_h_pulse2_position_a_details(value, new_value);
        break;
    case DISP_H_PULSE2_POSITION_B_OFFSET:
        fill_disp_h_pulse2_position_b_details(value, new_value);
        break;
    case DISP_H_PULSE2_POSITION_C_OFFSET:
        fill_disp_h_pulse2_position_c_details(value, new_value);
        break;
    case DISP_H_PULSE2_POSITION_D_OFFSET:
        fill_disp_h_pulse2_position_d_details(value, new_value);
        break;
    case DISP_V_PULSE0_CONTROL_OFFSET:
        fill_disp_v_pulse0_control_details(value, new_value);
        break;
    case DISP_V_PULSE0_POSITION_A_OFFSET:
        fill_disp_v_pulse0_position_a_details(value, new_value);
        break;
    case DISP_V_PULSE0_POSITION_B_OFFSET:
        fill_disp_v_pulse0_position_b_details(value, new_value);
        break;
    case DISP_V_PULSE0_POSITION_C_OFFSET:
        fill_disp_v_pulse0_position_c_details(value, new_value);
        break;
    case DISP_V_PULSE1_CONTROL_OFFSET:
        fill_disp_v_pulse1_control_details(value, new_value);
        break;
    case DISP_V_PULSE1_POSITION_A_OFFSET:
        fill_disp_v_pulse1_position_a_details(value, new_value);
        break;
    case DISP_V_PULSE1_POSITION_B_OFFSET:
        fill_disp_v_pulse1_position_b_details(value, new_value);
        break;
    case DISP_V_PULSE1_POSITION_C_OFFSET:
        fill_disp_v_pulse1_position_c_details(value, new_value);
        break;
    case DISP_V_PULSE2_CONTROL_OFFSET:
        fill_disp_v_pulse2_control_details(value, new_value);
        break;
    case DISP_V_PULSE2_POSITION_A_OFFSET:
        fill_disp_v_pulse2_position_a_details(value, new_value);
        break;
    case DISP_V_PULSE3_CONTROL_OFFSET:
        fill_disp_v_pulse3_control_details(value, new_value);
        break;
    case DISP_V_PULSE3_POSITION_A_OFFSET:
        fill_disp_v_pulse3_position_a_details(value, new_value);
        break;
    case DISP_M0_CONTROL_OFFSET:
        fill_disp_m0_control_details(value, new_value);
        break;
    case DISP_M1_CONTROL_OFFSET:
        fill_disp_m1_control_details(value, new_value);
        break;
    case DISP_DI_CONTROL_OFFSET:
        fill_disp_di_control_details(value, new_value);
        break;
    case DISP_PP_CONTROL_OFFSET:
        fill_disp_pp_control_details(value, new_value);
        break;
    case DISP_PP_SELECT_A_OFFSET:
        fill_disp_pp_select_a_details(value, new_value);
        break;
    case DISP_PP_SELECT_B_OFFSET:
        fill_disp_pp_select_b_details(value, new_value);
        break;
    case DISP_PP_SELECT_C_OFFSET:
        fill_disp_pp_select_c_details(value, new_value);
        break;
    case DISP_PP_SELECT_D_OFFSET:
        fill_disp_pp_select_d_details(value, new_value);
        break;
    case DISP_DISP_CLOCK_CONTROL_OFFSET:
        fill_disp_disp_clock_control_details(value, new_value);
        break;
    case DISP_DISP_INTERFACE_CONTROL_OFFSET:
        fill_disp_disp_interface_control_details(value, new_value);
        break;
    case DISP_DISP_COLOR_CONTROL_OFFSET:
        fill_disp_disp_color_control_details(value, new_value);
        break;
    case DISP_SHIFT_CLOCK_OPTIONS_OFFSET:
        fill_disp_shift_clock_options_details(value, new_value);
        break;
    case DISP_DATA_ENABLE_OPTIONS_OFFSET:
        fill_disp_data_enable_options_details(value, new_value);
        break;
    case DISP_SERIAL_INTERFACE_OPTIONS_OFFSET:
        fill_disp_serial_interface_options_details(value, new_value);
        break;
    case DISP_LCD_SPI_OPTIONS_OFFSET:
        fill_disp_lcd_spi_options_details(value, new_value);
        break;
    case DISP_BORDER_COLOR_OFFSET:
        fill_disp_border_color_details(value, new_value);
        break;
    case DISP_COLOR_KEY0_LOWER_OFFSET:
        fill_disp_color_key0_lower_details(value, new_value);
        break;
    case DISP_COLOR_KEY0_UPPER_OFFSET:
        fill_disp_color_key0_upper_details(value, new_value);
        break;
    case DISP_COLOR_KEY1_LOWER_OFFSET:
        fill_disp_color_key1_lower_details(value, new_value);
        break;
    case DISP_COLOR_KEY1_UPPER_OFFSET:
        fill_disp_color_key1_upper_details(value, new_value);
        break;
    case DISP_CURSOR_FOREGROUND_OFFSET:
        fill_disp_cursor_foreground_details(value, new_value);
        break;
    case DISP_CURSOR_BACKGROUND_OFFSET:
        fill_disp_cursor_background_details(value, new_value);
        break;
    case DISP_CURSOR_START_ADDR_OFFSET:
        fill_disp_cursor_start_addr_details(value, new_value);
        break;
    case DISP_CURSOR_START_ADDR_NS_OFFSET:
        fill_disp_cursor_start_addr_ns_details(value, new_value);
        break;
    case DISP_CURSOR_POSITION_OFFSET:
        fill_disp_cursor_position_details(value, new_value);
        break;
    case DISP_CURSOR_POSITION_NS_OFFSET:
        fill_disp_cursor_position_ns_details(value, new_value);
        break;
    case DISP_INIT_SEQ_CONTROL_OFFSET:
        fill_disp_init_seq_control_details(value, new_value);
        break;
    case DISP_SPI_INIT_SEQ_DATA_A_OFFSET:
        fill_disp_spi_init_seq_data_a_details(value, new_value);
        break;
    case DISP_SPI_INIT_SEQ_DATA_B_OFFSET:
        fill_disp_spi_init_seq_data_b_details(value, new_value);
        break;
    case DISP_SPI_INIT_SEQ_DATA_C_OFFSET:
        fill_disp_spi_init_seq_data_c_details(value, new_value);
        break;
    case DISP_SPI_INIT_SEQ_DATA_D_OFFSET:
        fill_disp_spi_init_seq_data_d_details(value, new_value);
        break;
    case DISP_DC_MCCIF_FIFOCTRL_OFFSET:
        fill_disp_dc_mccif_fifoctrl_details(value, new_value);
        break;
    case DISP_MCCIF_DISPLAY0A_HYST_OFFSET:
        fill_disp_mccif_display0a_hyst_details(value, new_value);
        break;
    case DISP_MCCIF_DISPLAY0B_HYST_OFFSET:
        fill_disp_mccif_display0b_hyst_details(value, new_value);
        break;
    case DISP_MCCIF_DISPLAY0C_HYST_OFFSET:
        fill_disp_mccif_display0c_hyst_details(value, new_value);
        break;
    case DISP_MCCIF_DISPLAY1B_HYST_OFFSET:
        fill_disp_mccif_display1b_hyst_details(value, new_value);
        break;
    case DISP_DAC_CRT_CTRL_OFFSET:
        fill_disp_dac_crt_ctrl_details(value, new_value);
        break;
    case DISP_DISP_MISC_CONTROL_OFFSET:
        fill_disp_disp_misc_control_details(value, new_value);
        break;
    case WINC_A_COLOR_PALETTE_OFFSET:
        fill_winc_a_color_palette_details(value, new_value);
        break;
    case WINC_A_PALETTE_COLOR_EXT_OFFSET:
        fill_winc_a_palette_color_ext_details(value, new_value);
        break;
    case WIN_A_WIN_OPTIONS_OFFSET:
        fill_win_a_win_options_details(value, new_value);
        break;
    case WIN_A_BYTE_SWAP_OFFSET:
        fill_win_a_byte_swap_details(value, new_value);
        break;
    case WIN_A_BUFFER_CONTROL_OFFSET:
        fill_win_a_buffer_control_details(value, new_value);
        break;
    case WIN_A_COLOR_DEPTH_OFFSET:
        fill_win_a_color_depth_details(value, new_value);
        break;
    case WIN_A_POSITION_OFFSET:
        fill_win_a_position_details(value, new_value);
        break;
    case WIN_A_SIZE_OFFSET:
        fill_win_a_size_details(value, new_value);
        break;
    case WIN_A_PRESCALED_SIZE_OFFSET:
        fill_win_a_prescaled_size_details(value, new_value);
        break;
    case WIN_A_H_INITIAL_DDA_OFFSET:
        fill_win_a_h_initial_dda_details(value, new_value);
        break;
    case WIN_A_V_INITIAL_DDA_OFFSET:
        fill_win_a_v_initial_dda_details(value, new_value);
        break;
    case WIN_A_DDA_INCREMENT_OFFSET:
        fill_win_a_dda_increment_details(value, new_value);
        break;
    case WIN_A_LINE_STRIDE_OFFSET:
        fill_win_a_line_stride_details(value, new_value);
        break;
    case WIN_A_BUF_STRIDE_OFFSET:
        fill_win_a_buf_stride_details(value, new_value);
        break;
    case WIN_A_BUFFER_ADDR_MODE_OFFSET:
        fill_win_a_buffer_addr_mode_details(value, new_value);
        break;
    case WIN_A_DV_CONTROL_OFFSET:
        fill_win_a_dv_control_details(value, new_value);
        break;
    case WIN_A_BLEND_NOKEY_OFFSET:
        fill_win_a_blend_nokey_details(value, new_value);
        break;
    case WIN_A_BLEND_1WIN_OFFSET:
        fill_win_a_blend_1win_details(value, new_value);
        break;
    case WIN_A_BLEND_2WIN_B_OFFSET:
        fill_win_a_blend_2win_b_details(value, new_value);
        break;
    case WIN_A_BLEND_2WIN_C_OFFSET:
        fill_win_a_blend_2win_c_details(value, new_value);
        break;
    case WIN_A_BLEND_3WIN_BC_OFFSET:
        fill_win_a_blend_3win_bc_details(value, new_value);
        break;
    case WIN_A_HP_FETCH_CONTROL_OFFSET:
        fill_win_a_hp_fetch_control_details(value, new_value);
        break;
    case WINBUF_A_START_ADDR_OFFSET:
        fill_winbuf_a_start_addr_details(value, new_value);
        break;
    case WINBUF_A_START_ADDR_NS_OFFSET:
        fill_winbuf_a_start_addr_ns_details(value, new_value);
        break;
    case WINBUF_A_ADDR_H_OFFSET_OFFSET:
        fill_winbuf_a_addr_h_offset_details(value, new_value);
        break;
    case WINBUF_A_ADDR_H_OFFSET_NS_OFFSET:
        fill_winbuf_a_addr_h_offset_ns_details(value, new_value);
        break;
    case WINBUF_A_ADDR_V_OFFSET_OFFSET:
        fill_winbuf_a_addr_v_offset_details(value, new_value);
        break;
    case WINBUF_A_ADDR_V_OFFSET_NS_OFFSET:
        fill_winbuf_a_addr_v_offset_ns_details(value, new_value);
        break;
    case WINBUF_A_UFLOW_STATUS_OFFSET:
        fill_winbuf_a_uflow_status_details(value, new_value);
        break;
    case WINC_B_COLOR_PALETTE_OFFSET:
        fill_winc_b_color_palette_details(value, new_value);
        break;
    case WINC_B_PALETTE_COLOR_EXT_OFFSET:
        fill_winc_b_palette_color_ext_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P00_OFFSET:
        fill_winc_b_h_filter_p00_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P01_OFFSET:
        fill_winc_b_h_filter_p01_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P02_OFFSET:
        fill_winc_b_h_filter_p02_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P03_OFFSET:
        fill_winc_b_h_filter_p03_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P04_OFFSET:
        fill_winc_b_h_filter_p04_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P05_OFFSET:
        fill_winc_b_h_filter_p05_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P06_OFFSET:
        fill_winc_b_h_filter_p06_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P07_OFFSET:
        fill_winc_b_h_filter_p07_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P08_OFFSET:
        fill_winc_b_h_filter_p08_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P09_OFFSET:
        fill_winc_b_h_filter_p09_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P0A_OFFSET:
        fill_winc_b_h_filter_p0a_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P0B_OFFSET:
        fill_winc_b_h_filter_p0b_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P0C_OFFSET:
        fill_winc_b_h_filter_p0c_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P0D_OFFSET:
        fill_winc_b_h_filter_p0d_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P0E_OFFSET:
        fill_winc_b_h_filter_p0e_details(value, new_value);
        break;
    case WINC_B_H_FILTER_P0F_OFFSET:
        fill_winc_b_h_filter_p0f_details(value, new_value);
        break;
    case WINC_B_CSC_YOF_OFFSET:
        fill_winc_b_csc_yof_details(value, new_value);
        break;
    case WINC_B_CSC_KYRGB_OFFSET:
        fill_winc_b_csc_kyrgb_details(value, new_value);
        break;
    case WINC_B_CSC_KUR_OFFSET:
        fill_winc_b_csc_kur_details(value, new_value);
        break;
    case WINC_B_CSC_KVR_OFFSET:
        fill_winc_b_csc_kvr_details(value, new_value);
        break;
    case WINC_B_CSC_KUG_OFFSET:
        fill_winc_b_csc_kug_details(value, new_value);
        break;
    case WINC_B_CSC_KVG_OFFSET:
        fill_winc_b_csc_kvg_details(value, new_value);
        break;
    case WINC_B_CSC_KUB_OFFSET:
        fill_winc_b_csc_kub_details(value, new_value);
        break;
    case WINC_B_CSC_KVB_OFFSET:
        fill_winc_b_csc_kvb_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P00_OFFSET:
        fill_winc_b_v_filter_p00_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P01_OFFSET:
        fill_winc_b_v_filter_p01_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P02_OFFSET:
        fill_winc_b_v_filter_p02_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P03_OFFSET:
        fill_winc_b_v_filter_p03_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P04_OFFSET:
        fill_winc_b_v_filter_p04_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P05_OFFSET:
        fill_winc_b_v_filter_p05_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P06_OFFSET:
        fill_winc_b_v_filter_p06_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P07_OFFSET:
        fill_winc_b_v_filter_p07_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P08_OFFSET:
        fill_winc_b_v_filter_p08_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P09_OFFSET:
        fill_winc_b_v_filter_p09_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P0A_OFFSET:
        fill_winc_b_v_filter_p0a_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P0B_OFFSET:
        fill_winc_b_v_filter_p0b_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P0C_OFFSET:
        fill_winc_b_v_filter_p0c_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P0D_OFFSET:
        fill_winc_b_v_filter_p0d_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P0E_OFFSET:
        fill_winc_b_v_filter_p0e_details(value, new_value);
        break;
    case WINC_B_V_FILTER_P0F_OFFSET:
        fill_winc_b_v_filter_p0f_details(value, new_value);
        break;
    case WIN_B_WIN_OPTIONS_OFFSET:
        fill_win_b_win_options_details(value, new_value);
        break;
    case WIN_B_BYTE_SWAP_OFFSET:
        fill_win_b_byte_swap_details(value, new_value);
        break;
    case WIN_B_BUFFER_CONTROL_OFFSET:
        fill_win_b_buffer_control_details(value, new_value);
        break;
    case WIN_B_COLOR_DEPTH_OFFSET:
        fill_win_b_color_depth_details(value, new_value);
        break;
    case WIN_B_POSITION_OFFSET:
        fill_win_b_position_details(value, new_value);
        break;
    case WIN_B_SIZE_OFFSET:
        fill_win_b_size_details(value, new_value);
        break;
    case WIN_B_PRESCALED_SIZE_OFFSET:
        fill_win_b_prescaled_size_details(value, new_value);
        break;
    case WIN_B_H_INITIAL_DDA_OFFSET:
        fill_win_b_h_initial_dda_details(value, new_value);
        break;
    case WIN_B_V_INITIAL_DDA_OFFSET:
        fill_win_b_v_initial_dda_details(value, new_value);
        break;
    case WIN_B_DDA_INCREMENT_OFFSET:
        fill_win_b_dda_increment_details(value, new_value);
        break;
    case WIN_B_LINE_STRIDE_OFFSET:
        fill_win_b_line_stride_details(value, new_value);
        break;
    case WIN_B_BUF_STRIDE_OFFSET:
        fill_win_b_buf_stride_details(value, new_value);
        break;
    case WIN_B_UV_BUF_STRIDE_OFFSET:
        fill_win_b_uv_buf_stride_details(value, new_value);
        break;
    case WIN_B_BUFFER_ADDR_MODE_OFFSET:
        fill_win_b_buffer_addr_mode_details(value, new_value);
        break;
    case WIN_B_DV_CONTROL_OFFSET:
        fill_win_b_dv_control_details(value, new_value);
        break;
    case WIN_B_BLEND_NOKEY_OFFSET:
        fill_win_b_blend_nokey_details(value, new_value);
        break;
    case WIN_B_BLEND_1WIN_OFFSET:
        fill_win_b_blend_1win_details(value, new_value);
        break;
    case WIN_B_BLEND_2WIN_A_OFFSET:
        fill_win_b_blend_2win_a_details(value, new_value);
        break;
    case WIN_B_BLEND_2WIN_C_OFFSET:
        fill_win_b_blend_2win_c_details(value, new_value);
        break;
    case WIN_B_BLEND_3WIN_AC_OFFSET:
        fill_win_b_blend_3win_ac_details(value, new_value);
        break;
    case WIN_B_HP_FETCH_CONTROL_OFFSET:
        fill_win_b_hp_fetch_control_details(value, new_value);
        break;
    case WINBUF_B_START_ADDR_OFFSET:
        fill_winbuf_b_start_addr_details(value, new_value);
        break;
    case WINBUF_B_START_ADDR_NS_OFFSET:
        fill_winbuf_b_start_addr_ns_details(value, new_value);
        break;
    case WINBUF_B_START_ADDR_U_OFFSET:
        fill_winbuf_b_start_addr_u_details(value, new_value);
        break;
    case WINBUF_B_START_ADDR_U_NS_OFFSET:
        fill_winbuf_b_start_addr_u_ns_details(value, new_value);
        break;
    case WINBUF_B_START_ADDR_V_OFFSET:
        fill_winbuf_b_start_addr_v_details(value, new_value);
        break;
    case WINBUF_B_START_ADDR_V_NS_OFFSET:
        fill_winbuf_b_start_addr_v_ns_details(value, new_value);
        break;
    case WINBUF_B_ADDR_H_OFFSET_OFFSET:
        fill_winbuf_b_addr_h_offset_details(value, new_value);
        break;
    case WINBUF_B_ADDR_H_OFFSET_NS_OFFSET:
        fill_winbuf_b_addr_h_offset_ns_details(value, new_value);
        break;
    case WINBUF_B_ADDR_V_OFFSET_OFFSET:
        fill_winbuf_b_addr_v_offset_details(value, new_value);
        break;
    case WINBUF_B_ADDR_V_OFFSET_NS_OFFSET:
        fill_winbuf_b_addr_v_offset_ns_details(value, new_value);
        break;
    case WINBUF_B_UFLOW_STATUS_OFFSET:
        fill_winbuf_b_uflow_status_details(value, new_value);
        break;
    case WINC_C_COLOR_PALETTE_OFFSET:
        fill_winc_c_color_palette_details(value, new_value);
        break;
    case WINC_C_PALETTE_COLOR_EXT_OFFSET:
        fill_winc_c_palette_color_ext_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P00_OFFSET:
        fill_winc_c_h_filter_p00_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P01_OFFSET:
        fill_winc_c_h_filter_p01_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P02_OFFSET:
        fill_winc_c_h_filter_p02_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P03_OFFSET:
        fill_winc_c_h_filter_p03_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P04_OFFSET:
        fill_winc_c_h_filter_p04_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P05_OFFSET:
        fill_winc_c_h_filter_p05_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P06_OFFSET:
        fill_winc_c_h_filter_p06_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P07_OFFSET:
        fill_winc_c_h_filter_p07_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P08_OFFSET:
        fill_winc_c_h_filter_p08_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P09_OFFSET:
        fill_winc_c_h_filter_p09_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P0A_OFFSET:
        fill_winc_c_h_filter_p0a_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P0B_OFFSET:
        fill_winc_c_h_filter_p0b_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P0C_OFFSET:
        fill_winc_c_h_filter_p0c_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P0D_OFFSET:
        fill_winc_c_h_filter_p0d_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P0E_OFFSET:
        fill_winc_c_h_filter_p0e_details(value, new_value);
        break;
    case WINC_C_H_FILTER_P0F_OFFSET:
        fill_winc_c_h_filter_p0f_details(value, new_value);
        break;
    case WINC_C_CSC_YOF_OFFSET:
        fill_winc_c_csc_yof_details(value, new_value);
        break;
    case WINC_C_CSC_KYRGB_OFFSET:
        fill_winc_c_csc_kyrgb_details(value, new_value);
        break;
    case WINC_C_CSC_KUR_OFFSET:
        fill_winc_c_csc_kur_details(value, new_value);
        break;
    case WINC_C_CSC_KVR_OFFSET:
        fill_winc_c_csc_kvr_details(value, new_value);
        break;
    case WINC_C_CSC_KUG_OFFSET:
        fill_winc_c_csc_kug_details(value, new_value);
        break;
    case WINC_C_CSC_KVG_OFFSET:
        fill_winc_c_csc_kvg_details(value, new_value);
        break;
    case WINC_C_CSC_KUB_OFFSET:
        fill_winc_c_csc_kub_details(value, new_value);
        break;
    case WINC_C_CSC_KVB_OFFSET:
        fill_winc_c_csc_kvb_details(value, new_value);
        break;
    case WIN_C_WIN_OPTIONS_OFFSET:
        fill_win_c_win_options_details(value, new_value);
        break;
    case WIN_C_BYTE_SWAP_OFFSET:
        fill_win_c_byte_swap_details(value, new_value);
        break;
    case WIN_C_BUFFER_CONTROL_OFFSET:
        fill_win_c_buffer_control_details(value, new_value);
        break;
    case WIN_C_COLOR_DEPTH_OFFSET:
        fill_win_c_color_depth_details(value, new_value);
        break;
    case WIN_C_POSITION_OFFSET:
        fill_win_c_position_details(value, new_value);
        break;
    case WIN_C_SIZE_OFFSET:
        fill_win_c_size_details(value, new_value);
        break;
    case WIN_C_PRESCALED_SIZE_OFFSET:
        fill_win_c_prescaled_size_details(value, new_value);
        break;
    case WIN_C_H_INITIAL_DDA_OFFSET:
        fill_win_c_h_initial_dda_details(value, new_value);
        break;
    case WIN_C_V_INITIAL_DDA_OFFSET:
        fill_win_c_v_initial_dda_details(value, new_value);
        break;
    case WIN_C_DDA_INCREMENT_OFFSET:
        fill_win_c_dda_increment_details(value, new_value);
        break;
    case WIN_C_LINE_STRIDE_OFFSET:
        fill_win_c_line_stride_details(value, new_value);
        break;
    case WIN_C_BUF_STRIDE_OFFSET:
        fill_win_c_buf_stride_details(value, new_value);
        break;
    case WIN_C_UV_BUF_STRIDE_OFFSET:
        fill_win_c_uv_buf_stride_details(value, new_value);
        break;
    case WIN_C_BUFFER_ADDR_MODE_OFFSET:
        fill_win_c_buffer_addr_mode_details(value, new_value);
        break;
    case WIN_C_DV_CONTROL_OFFSET:
        fill_win_c_dv_control_details(value, new_value);
        break;
    case WIN_C_BLEND_NOKEY_OFFSET:
        fill_win_c_blend_nokey_details(value, new_value);
        break;
    case WIN_C_BLEND_1WIN_OFFSET:
        fill_win_c_blend_1win_details(value, new_value);
        break;
    case WIN_C_BLEND_2WIN_A_OFFSET:
        fill_win_c_blend_2win_a_details(value, new_value);
        break;
    case WIN_C_BLEND_2WIN_B_OFFSET:
        fill_win_c_blend_2win_b_details(value, new_value);
        break;
    case WIN_C_BLEND_3WIN_AB_OFFSET:
        fill_win_c_blend_3win_ab_details(value, new_value);
        break;
    case WIN_C_HP_FETCH_CONTROL_OFFSET:
        fill_win_c_hp_fetch_control_details(value, new_value);
        break;
    case WINBUF_C_START_ADDR_OFFSET:
        fill_winbuf_c_start_addr_details(value, new_value);
        break;
    case WINBUF_C_START_ADDR_NS_OFFSET:
        fill_winbuf_c_start_addr_ns_details(value, new_value);
        break;
    case WINBUF_C_START_ADDR_U_OFFSET:
        fill_winbuf_c_start_addr_u_details(value, new_value);
        break;
    case WINBUF_C_START_ADDR_U_NS_OFFSET:
        fill_winbuf_c_start_addr_u_ns_details(value, new_value);
        break;
    case WINBUF_C_START_ADDR_V_OFFSET:
        fill_winbuf_c_start_addr_v_details(value, new_value);
        break;
    case WINBUF_C_START_ADDR_V_NS_OFFSET:
        fill_winbuf_c_start_addr_v_ns_details(value, new_value);
        break;
    case WINBUF_C_ADDR_H_OFFSET_OFFSET:
        fill_winbuf_c_addr_h_offset_details(value, new_value);
        break;
    case WINBUF_C_ADDR_H_OFFSET_NS_OFFSET:
        fill_winbuf_c_addr_h_offset_ns_details(value, new_value);
        break;
    case WINBUF_C_ADDR_V_OFFSET_OFFSET:
        fill_winbuf_c_addr_v_offset_details(value, new_value);
        break;
    case WINBUF_C_ADDR_V_OFFSET_NS_OFFSET:
        fill_winbuf_c_addr_v_offset_ns_details(value, new_value);
        break;
    case WINBUF_C_UFLOW_STATUS_OFFSET:
        fill_winbuf_c_uflow_status_details(value, new_value);
        break;
    case DISP_SD_CONTROL_OFFSET:
        fill_disp_sd_control_details(value, new_value);
        break;
    case DISP_SD_CSC_COEFF_OFFSET:
        fill_disp_sd_csc_coeff_details(value, new_value);
        break;
    case DISP_SD_LUT_OFFSET:
        fill_disp_sd_lut_details(value, new_value);
        break;
    case DISP_SD_LUT_1_OFFSET:
        fill_disp_sd_lut_1_details(value, new_value);
        break;
    case DISP_SD_LUT_2_OFFSET:
        fill_disp_sd_lut_2_details(value, new_value);
        break;
    case DISP_SD_LUT_3_OFFSET:
        fill_disp_sd_lut_3_details(value, new_value);
        break;
    case DISP_SD_LUT_4_OFFSET:
        fill_disp_sd_lut_4_details(value, new_value);
        break;
    case DISP_SD_LUT_5_OFFSET:
        fill_disp_sd_lut_5_details(value, new_value);
        break;
    case DISP_SD_LUT_6_OFFSET:
        fill_disp_sd_lut_6_details(value, new_value);
        break;
    case DISP_SD_LUT_7_OFFSET:
        fill_disp_sd_lut_7_details(value, new_value);
        break;
    case DISP_SD_LUT_8_OFFSET:
        fill_disp_sd_lut_8_details(value, new_value);
        break;
    case DISP_SD_FLICKER_CONTROL_OFFSET:
        fill_disp_sd_flicker_control_details(value, new_value);
        break;
    case DISP_SD_PIXEL_COUNT_OFFSET:
        fill_disp_sd_pixel_count_details(value, new_value);
        break;
    case DISP_SD_HISTOGRAM_OFFSET:
        fill_disp_sd_histogram_details(value, new_value);
        break;
    case DISP_SD_HISTOGRAM_1_OFFSET:
        fill_disp_sd_histogram_1_details(value, new_value);
        break;
    case DISP_SD_HISTOGRAM_2_OFFSET:
        fill_disp_sd_histogram_2_details(value, new_value);
        break;
    case DISP_SD_HISTOGRAM_3_OFFSET:
        fill_disp_sd_histogram_3_details(value, new_value);
        break;
    case DISP_SD_HISTOGRAM_4_OFFSET:
        fill_disp_sd_histogram_4_details(value, new_value);
        break;
    case DISP_SD_HISTOGRAM_5_OFFSET:
        fill_disp_sd_histogram_5_details(value, new_value);
        break;
    case DISP_SD_HISTOGRAM_6_OFFSET:
        fill_disp_sd_histogram_6_details(value, new_value);
        break;
    case DISP_SD_HISTOGRAM_7_OFFSET:
        fill_disp_sd_histogram_7_details(value, new_value);
        break;
    case DISP_SD_BL_PARAMETERS_OFFSET:
        fill_disp_sd_bl_parameters_details(value, new_value);
        break;
    case DISP_SD_BL_TF_OFFSET:
        fill_disp_sd_bl_tf_details(value, new_value);
        break;
    case DISP_SD_BL_TF_1_OFFSET:
        fill_disp_sd_bl_tf_1_details(value, new_value);
        break;
    case DISP_SD_BL_TF_2_OFFSET:
        fill_disp_sd_bl_tf_2_details(value, new_value);
        break;
    case DISP_SD_BL_TF_3_OFFSET:
        fill_disp_sd_bl_tf_3_details(value, new_value);
        break;
    case DISP_SD_BL_CONTROL_OFFSET:
        fill_disp_sd_bl_control_details(value, new_value);
        break;
    case WINC_B_COLOR_PALETTE_1_OFFSET:
        fill_winc_b_color_palette_1_details(value, new_value);
        break;
    case WINC_B_COLOR_PALETTE_2_OFFSET:
        fill_winc_b_color_palette_2_details(value, new_value);
        break;
    case WINC_B_COLOR_PALETTE_3_OFFSET:
        fill_winc_b_color_palette_3_details(value, new_value);
        break;
    case WINC_B_COLOR_PALETTE_4_OFFSET:
        fill_winc_b_color_palette_4_details(value, new_value);
        break;
    case WINC_B_COLOR_PALETTE_5_OFFSET:
        fill_winc_b_color_palette_5_details(value, new_value);
        break;
    case WINC_B_COLOR_PALETTE_6_OFFSET:
        fill_winc_b_color_palette_6_details(value, new_value);
        break;
    case WINC_B_COLOR_PALETTE_7_OFFSET:
        fill_winc_b_color_palette_7_details(value, new_value);
        break;
    case WINC_B_COLOR_PALETTE_8_OFFSET:
        fill_winc_b_color_palette_8_details(value, new_value);
        break;
    case WINC_B_COLOR_PALETTE_9_OFFSET:
        fill_winc_b_color_palette_9_details(value, new_value);
        break;

    default:
        m_bit_details_model.bits.clear();
        break;
    }
}
