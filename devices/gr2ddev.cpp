/*
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

#include "gr2ddev.h"

#include <QDebug>

Gr2dDev::Gr2dDev(QObject *parent) :
    Device(parent)
{
}

#define G2SB_INCR_SYNCPT_OFFSET 0x0
#define G2SB_INCR_SYNCPT_UNDEFMASK 0xFFFF0000
union g2sb_incr_syncpt_u {
    struct {
        unsigned int indx:8;                /* syncpt index value */
        unsigned int cond:8;                /* Condition mapped from raise/wait */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_incr_syncpt_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_incr_syncpt_u old_value_t = { .reg32 = value };
    const g2sb_incr_syncpt_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: indx:8",
              "syncpt index value",
              8, old_value_t.indx, new_value_t.indx };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cond:8",
              "Condition mapped from raise/wait",
              8, old_value_t.cond, new_value_t.cond };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_INCR_SYNCPT_CNTRL_OFFSET 0x1
#define G2SB_INCR_SYNCPT_CNTRL_UNDEFMASK 0xFFFFFEFE
union g2sb_incr_syncpt_cntrl_u {
    struct {
        unsigned int incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs. */
        unsigned int undefined_bits_1_7:7;
        unsigned int incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled. */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_incr_syncpt_cntrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_incr_syncpt_cntrl_u old_value_t = { .reg32 = value };
    const g2sb_incr_syncpt_cntrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: incr_syncpt_soft_reset:1",
              "If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs.",
              1, old_value_t.incr_syncpt_soft_reset, new_value_t.incr_syncpt_soft_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: incr_syncpt_no_stall:1",
              "If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled.",
              1, old_value_t.incr_syncpt_no_stall, new_value_t.incr_syncpt_no_stall };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_INCR_SYNCPT_ERROR_OFFSET 0x2
#define G2SB_INCR_SYNCPT_ERROR_UNDEFMASK 0x00000000
union g2sb_incr_syncpt_error_u {
    struct {
        unsigned int cond_status:32;        /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_incr_syncpt_error_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_incr_syncpt_error_u old_value_t = { .reg32 = value };
    const g2sb_incr_syncpt_error_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cond_status:32",
              "COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero",
              32, old_value_t.cond_status, new_value_t.cond_status };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CLASSCHANNEL_REGONLY_OFFSET 0x8
#define G2SB_G2CLASSCHANNEL_REGONLY_UNDEFMASK 0xFFE0FC00
union g2sb_g2classchannel_regonly_u {
    struct {
        unsigned int curr_class:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int curr_channel:4;
        unsigned int ctx_valid:1;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2classchannel_regonly_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2classchannel_regonly_u old_value_t = { .reg32 = value };
    const g2sb_g2classchannel_regonly_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: curr_class:10", "", 10, old_value_t.curr_class, new_value_t.curr_class };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_15:6", "", 6, old_value_t.undefined_bits_10_15, new_value_t.undefined_bits_10_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: curr_channel:4", "", 4, old_value_t.curr_channel, new_value_t.curr_channel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ctx_valid:1", "", 1, old_value_t.ctx_valid, new_value_t.ctx_valid };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2TRIGGER_OFFSET 0x9
#define G2SB_G2TRIGGER_UNDEFMASK 0xFFFF0000
union g2sb_g2trigger_u {
    struct {
        unsigned int trigger:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2trigger_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2trigger_u old_value_t = { .reg32 = value };
    const g2sb_g2trigger_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger:16", "", 16, old_value_t.trigger, new_value_t.trigger };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2TRIGGER1_OFFSET 0xA
#define G2SB_G2TRIGGER1_UNDEFMASK 0xFFFF0000
union g2sb_g2trigger1_u {
    struct {
        unsigned int trigger1:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2trigger1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2trigger1_u old_value_t = { .reg32 = value };
    const g2sb_g2trigger1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger1:16", "", 16, old_value_t.trigger1, new_value_t.trigger1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2TRIGGER2_OFFSET 0xB
#define G2SB_G2TRIGGER2_UNDEFMASK 0xFFFF0000
union g2sb_g2trigger2_u {
    struct {
        unsigned int trigger2:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2trigger2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2trigger2_u old_value_t = { .reg32 = value };
    const g2sb_g2trigger2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger2:16", "", 16, old_value_t.trigger2, new_value_t.trigger2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CMDSEL_OFFSET 0xC
#define G2SB_G2CMDSEL_UNDEFMASK 0xE000280E
union g2sb_g2cmdsel_u {
    struct {
        unsigned int sbor2d:1;
        unsigned int undefined_bits_1_3:3;
        unsigned int cbenable:1;            /* circular buffer feature enable    0= disable */
        unsigned int vitrigger:1;           /* VI trigger enable, can be circular buffer or full frame */
        unsigned int hosttrigger:1;         /* host trigger the command, host also need program cicular buffer related data */
        unsigned int cbsbdisable:1;
        unsigned int g2output:2;            /* 00: to memory 01: to EPP */
        unsigned int clip_source_top_bottom:1;/* Reserved for HW Test, SW should not use this bit. */
        unsigned int undefined_bit_11:1;
        unsigned int link_wait_buf_end:1;
        unsigned int undefined_bit_13:1;
        unsigned int frame_start:1;         /* host writes this bit to tell which buffer is ready */
        unsigned int frame_end:1;
        unsigned int buffer_index:8;
        unsigned int linken:1;              /* Test purpose */
        unsigned int linkval:3;
        unsigned int priority:1;            /* indicates priority of the context, note vi-triggered contexts take priority over HIGH */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2cmdsel_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2cmdsel_u old_value_t = { .reg32 = value };
    const g2sb_g2cmdsel_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sbor2d:1", "", 1, old_value_t.sbor2d, new_value_t.sbor2d };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: cbenable:1",
              "circular buffer feature enable   \n0= disable",
              1, old_value_t.cbenable, new_value_t.cbenable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: vitrigger:1",
              "VI trigger enable, can be circular buffer or full frame",
              1, old_value_t.vitrigger, new_value_t.vitrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "06: hosttrigger:1",
              "host trigger the command, host also need program cicular buffer related data",
              1, old_value_t.hosttrigger, new_value_t.hosttrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "07: cbsbdisable:1", "", 1, old_value_t.cbsbdisable, new_value_t.cbsbdisable };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g2output:2",
              "00: to memory 01: to EPP",
              2, old_value_t.g2output, new_value_t.g2output };
    m_bit_details_model.bits.append(entry);
    entry = { "10: clip_source_top_bottom:1",
              "Reserved for HW Test, SW should not use this bit.",
              1, old_value_t.clip_source_top_bottom, new_value_t.clip_source_top_bottom };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: link_wait_buf_end:1", "", 1, old_value_t.link_wait_buf_end, new_value_t.link_wait_buf_end };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: frame_start:1",
              "host writes this bit to tell which buffer is ready",
              1, old_value_t.frame_start, new_value_t.frame_start };
    m_bit_details_model.bits.append(entry);
    entry = { "15: frame_end:1", "", 1, old_value_t.frame_end, new_value_t.frame_end };
    m_bit_details_model.bits.append(entry);
    entry = { "16: buffer_index:8", "", 8, old_value_t.buffer_index, new_value_t.buffer_index };
    m_bit_details_model.bits.append(entry);
    entry = { "24: linken:1",
              "Test purpose",
              1, old_value_t.linken, new_value_t.linken };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linkval:3", "", 3, old_value_t.linkval, new_value_t.linkval };
    m_bit_details_model.bits.append(entry);
    entry = { "28: priority:1",
              "indicates priority of the context, note vi-triggered contexts take priority over HIGH",
              1, old_value_t.priority, new_value_t.priority };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2RAISE_OFFSET 0xD
#define G2SB_G2RAISE_UNDEFMASK 0xFFF0FFE0
union g2sb_g2raise_u {
    struct {
        unsigned int raise:5;               /* Push back to read fifo when all commands in the channel are done.           */
        unsigned int undefined_bits_5_15:11;
        unsigned int raisechannel:4;
        unsigned int undefined_bits_20_31:12;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2raise_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2raise_u old_value_t = { .reg32 = value };
    const g2sb_g2raise_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: raise:5",
              "Push back to read fifo when all commands in the channel are done.",
              5, old_value_t.raise, new_value_t.raise };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_15:11", "", 11, old_value_t.undefined_bits_5_15, new_value_t.undefined_bits_5_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisechannel:4", "", 4, old_value_t.raisechannel, new_value_t.raisechannel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_31:12", "", 12, old_value_t.undefined_bits_20_31, new_value_t.undefined_bits_20_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2HOSTSET_OFFSET 0xF
#define G2SB_G2HOSTSET_UNDEFMASK 0xFFFFFF00
union g2sb_g2hostset_u {
    struct {
        unsigned int hstlngap:4;            /*  specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte) */
        unsigned int hstfpxl:4;             /* specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2hostset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2hostset_u old_value_t = { .reg32 = value };
    const g2sb_g2hostset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hstlngap:4",
              " specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte)",
              4, old_value_t.hstlngap, new_value_t.hstlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: hstfpxl:4",
              "specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary",
              4, old_value_t.hstfpxl, new_value_t.hstfpxl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2HOSTFIFO_OFFSET 0x10
#define G2SB_G2HOSTFIFO_UNDEFMASK 0x00000000
union g2sb_g2hostfifo_u {
    struct {
        unsigned int hostfifodata:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2hostfifo_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2hostfifo_u old_value_t = { .reg32 = value };
    const g2sb_g2hostfifo_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hostfifodata:32", "", 32, old_value_t.hostfifodata, new_value_t.hostfifodata };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2VDDA_OFFSET 0x11
#define G2SB_G2VDDA_UNDEFMASK 0x00000000
union g2sb_g2vdda_u {
    struct {
        unsigned int vdstep:32;             /* Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2vdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2vdda_u old_value_t = { .reg32 = value };
    const g2sb_g2vdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdstep:32",
              "Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010.",
              32, old_value_t.vdstep, new_value_t.vdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2VDDAINI_OFFSET 0x12
#define G2SB_G2VDDAINI_UNDEFMASK 0xFFFF0000
union g2sb_g2vddaini_u {
    struct {
        unsigned int vdtini:8;              /* Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window. */
        unsigned int vdbini:8;              /* Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above) */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2vddaini_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2vddaini_u old_value_t = { .reg32 = value };
    const g2sb_g2vddaini_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdtini:8",
              "Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window.",
              8, old_value_t.vdtini, new_value_t.vdtini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: vdbini:8",
              "Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above)",
              8, old_value_t.vdbini, new_value_t.vdbini };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2HDDA_OFFSET 0x13
#define G2SB_G2HDDA_UNDEFMASK 0x00000000
union g2sb_g2hdda_u {
    struct {
        unsigned int hdstep:32;             /* Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2hdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2hdda_u old_value_t = { .reg32 = value };
    const g2sb_g2hdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdstep:32",
              "Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101.",
              32, old_value_t.hdstep, new_value_t.hdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2HDDAINILS_OFFSET 0x14
#define G2SB_G2HDDAINILS_UNDEFMASK 0xFFFFFF00
union g2sb_g2hddainils_u {
    struct {
        unsigned int hdini:8;               /* Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0. */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2hddainils_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2hddainils_u old_value_t = { .reg32 = value };
    const g2sb_g2hddainils_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdini:8",
              "Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0.",
              8, old_value_t.hdini, new_value_t.hdini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CSCFIRST_OFFSET 0x15
#define G2SB_G2CSCFIRST_UNDEFMASK 0x00C00C00
union g2sb_g2cscfirst_u {
    struct {
        unsigned int cub:10;                /* multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved  */
        unsigned int undefined_bits_10_11:2;
        unsigned int cvr:10;                /* multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved */
        unsigned int undefined_bits_22_23:2;
        unsigned int yos:8;                 /* Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2cscfirst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2cscfirst_u old_value_t = { .reg32 = value };
    const g2sb_g2cscfirst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cub:10",
              "multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved",
              10, old_value_t.cub, new_value_t.cub };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_11:2", "", 2, old_value_t.undefined_bits_10_11, new_value_t.undefined_bits_10_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cvr:10",
              "multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved",
              10, old_value_t.cvr, new_value_t.cvr };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: yos:8",
              "Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10",
              8, old_value_t.yos, new_value_t.yos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CSCSECOND_OFFSET 0x16
#define G2SB_G2CSCSECOND_UNDEFMASK 0x00C00E00
union g2sb_g2cscsecond_u {
    struct {
        unsigned int cug:9;                 /* multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved */
        unsigned int undefined_bits_9_11:3;
        unsigned int cur:10;                /* multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved  */
        unsigned int undefined_bits_22_23:2;
        unsigned int cyx:8;                 /* multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2cscsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2cscsecond_u old_value_t = { .reg32 = value };
    const g2sb_g2cscsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cug:9",
              "multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved",
              9, old_value_t.cug, new_value_t.cug };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cur:10",
              "multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved",
              10, old_value_t.cur, new_value_t.cur };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cyx:8",
              "multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041",
              8, old_value_t.cyx, new_value_t.cyx };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CSCTHIRD_OFFSET 0x17
#define G2SB_G2CSCTHIRD_UNDEFMASK 0xFC00FE00
union g2sb_g2cscthird_u {
    struct {
        unsigned int cvg:9;                 /* multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113 */
        unsigned int undefined_bits_9_15:7;
        unsigned int cvb:10;                /* multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021 */
        unsigned int undefined_bits_26_31:6;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2cscthird_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2cscthird_u old_value_t = { .reg32 = value };
    const g2sb_g2cscthird_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cvg:9",
              "multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113",
              9, old_value_t.cvg, new_value_t.cvg };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cvb:10",
              "multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021",
              10, old_value_t.cvb, new_value_t.cvb };
    m_bit_details_model.bits.append(entry);
    entry = { "26: undefined_bits_26_31:6", "", 6, old_value_t.undefined_bits_26_31, new_value_t.undefined_bits_26_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CMKEYL_OFFSET 0x18
#define G2SB_G2CMKEYL_UNDEFMASK 0xFF000000
union g2sb_g2cmkeyl_u {
    struct {
        unsigned int ckbl:8;                /* B or Y Color/Chroma Key Lower Limit (CKBL[7:0]) */
        unsigned int ckgl:8;                /* G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level. */
        unsigned int ckrl:8;                /* R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2cmkeyl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2cmkeyl_u old_value_t = { .reg32 = value };
    const g2sb_g2cmkeyl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbl:8",
              "B or Y Color/Chroma Key Lower Limit (CKBL[7:0])",
              8, old_value_t.ckbl, new_value_t.ckbl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgl:8",
              "G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgl, new_value_t.ckgl };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckrl:8",
              "R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved",
              8, old_value_t.ckrl, new_value_t.ckrl };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CMKEYU_OFFSET 0x19
#define G2SB_G2CMKEYU_UNDEFMASK 0xFF000000
union g2sb_g2cmkeyu_u {
    struct {
        unsigned int ckbu:8;                /* This is B or Y color/chroma key upper limit value. */
        unsigned int ckgu:8;                /* G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level. */
        unsigned int ckru:8;                /* R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2cmkeyu_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2cmkeyu_u old_value_t = { .reg32 = value };
    const g2sb_g2cmkeyu_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbu:8",
              "This is B or Y color/chroma key upper limit value.",
              8, old_value_t.ckbu, new_value_t.ckbu };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgu:8",
              "G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgu, new_value_t.ckgu };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckru:8",
              "R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved",
              8, old_value_t.ckru, new_value_t.ckru };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2UBA_A_OFFSET 0x1A
#define G2SB_G2UBA_A_UNDEFMASK 0x00000000
union g2sb_g2uba_a_u {
    struct {
        unsigned int su1sa:32;              /* Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2uba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2uba_a_u old_value_t = { .reg32 = value };
    const g2sb_g2uba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: su1sa:32",
              "Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.su1sa, new_value_t.su1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2VBA_A_OFFSET 0x1B
#define G2SB_G2VBA_A_UNDEFMASK 0x00000000
union g2sb_g2vba_a_u {
    struct {
        unsigned int sv1sa:32;              /* Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2vba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2vba_a_u old_value_t = { .reg32 = value };
    const g2sb_g2vba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sv1sa:32",
              "Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.sv1sa, new_value_t.sv1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2SBFORMAT_OFFSET 0x1C
#define G2SB_G2SBFORMAT_UNDEFMASK 0x000020E0
union g2sb_g2sbformat_u {
    struct {
        unsigned int sifmt:5;               /* This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV. */
        unsigned int undefined_bits_5_7:3;
        unsigned int difmt:5;               /* Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED */
        unsigned int undefined_bit_13:1;
        unsigned int raisebufferen:1;       /* ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.  */
        unsigned int raiseframeen:1;        /* ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.  */
        unsigned int raisebuffervalue:8;    /* Raise buffer vector value. */
        unsigned int raiseframevalue:8;     /* Raise Fram vector value. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2sbformat_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2sbformat_u old_value_t = { .reg32 = value };
    const g2sb_g2sbformat_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sifmt:5",
              "This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV.",
              5, old_value_t.sifmt, new_value_t.sifmt };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: difmt:5",
              "Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED",
              5, old_value_t.difmt, new_value_t.difmt };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: raisebufferen:1",
              "ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raisebufferen, new_value_t.raisebufferen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: raiseframeen:1",
              "ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raiseframeen, new_value_t.raiseframeen };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisebuffervalue:8",
              "Raise buffer vector value.",
              8, old_value_t.raisebuffervalue, new_value_t.raisebuffervalue };
    m_bit_details_model.bits.append(entry);
    entry = { "24: raiseframevalue:8",
              "Raise Fram vector value.",
              8, old_value_t.raiseframevalue, new_value_t.raiseframevalue };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CONTROLSB_OFFSET 0x1D
#define G2SB_G2CONTROLSB_UNDEFMASK 0x20005807
union g2sb_g2controlsb_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int yuv422rotation:1;      /* yuv422 plannar rotated */
        unsigned int yuv422planar:1;        /* source data is yuv422 planar valid when imode==PLANAR */
        unsigned int imode:1;               /* Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d. */
        unsigned int enavf:1;               /* enable alpha vertical filter     */
        unsigned int enahf:1;               /* enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format, */
        unsigned int uvst:2;                /*   00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.   11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride). */
        unsigned int sl:1;                  /* Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines. */
        unsigned int undefined_bits_11_12:2;
        unsigned int sisel:1;               /* StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved  */
        unsigned int undefined_bit_14:1;
        unsigned int sbltsrc:1;             /* StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator. */
        unsigned int vftype:2;              /* StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager. */
        unsigned int vfen:1;                /* StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled. */
        unsigned int discsc:1;              /* enabled color space converter by default */
        unsigned int hftype:3;              /* StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE. */
        unsigned int rangeredfrm:1;         /* In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.  */
        unsigned int sitype:1;              /* StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?. */
        unsigned int sbsel:1;               /* StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer. */
        unsigned int dbsel:1;               /* StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer. */
        unsigned int keyen:1;               /* Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled. */
        unsigned int kpol:1;                /* Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range. */
        unsigned int undefined_bit_29:1;
        unsigned int endith:1;              /* Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering */
        unsigned int disdw:1;               /* output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2controlsb_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2controlsb_u old_value_t = { .reg32 = value };
    const g2sb_g2controlsb_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_2:3", "", 3, old_value_t.undefined_bits_0_2, new_value_t.undefined_bits_0_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: yuv422rotation:1",
              "yuv422 plannar rotated",
              1, old_value_t.yuv422rotation, new_value_t.yuv422rotation };
    m_bit_details_model.bits.append(entry);
    entry = { "04: yuv422planar:1",
              "source data is yuv422 planar valid when imode==PLANAR",
              1, old_value_t.yuv422planar, new_value_t.yuv422planar };
    m_bit_details_model.bits.append(entry);
    entry = { "05: imode:1",
              "Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d.",
              1, old_value_t.imode, new_value_t.imode };
    m_bit_details_model.bits.append(entry);
    entry = { "06: enavf:1",
              "enable alpha vertical filter",
              1, old_value_t.enavf, new_value_t.enavf };
    m_bit_details_model.bits.append(entry);
    entry = { "07: enahf:1",
              "enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format,",
              1, old_value_t.enahf, new_value_t.enahf };
    m_bit_details_model.bits.append(entry);
    entry = { "08: uvst:2",
              " \n00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.\n11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride).",
              2, old_value_t.uvst, new_value_t.uvst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: sl:1",
              "Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines.",
              1, old_value_t.sl, new_value_t.sl };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_12:2", "", 2, old_value_t.undefined_bits_11_12, new_value_t.undefined_bits_11_12 };
    m_bit_details_model.bits.append(entry);
    entry = { "13: sisel:1",
              "StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved",
              1, old_value_t.sisel, new_value_t.sisel };
    m_bit_details_model.bits.append(entry);
    entry = { "14: undefined_bit_14:1", "", 1, old_value_t.undefined_bit_14, new_value_t.undefined_bit_14 };
    m_bit_details_model.bits.append(entry);
    entry = { "15: sbltsrc:1",
              "StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator.",
              1, old_value_t.sbltsrc, new_value_t.sbltsrc };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vftype:2",
              "StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager.",
              2, old_value_t.vftype, new_value_t.vftype };
    m_bit_details_model.bits.append(entry);
    entry = { "18: vfen:1",
              "StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled.",
              1, old_value_t.vfen, new_value_t.vfen };
    m_bit_details_model.bits.append(entry);
    entry = { "19: discsc:1",
              "enabled color space converter by default",
              1, old_value_t.discsc, new_value_t.discsc };
    m_bit_details_model.bits.append(entry);
    entry = { "20: hftype:3",
              "StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE.",
              3, old_value_t.hftype, new_value_t.hftype };
    m_bit_details_model.bits.append(entry);
    entry = { "23: rangeredfrm:1",
              "In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.",
              1, old_value_t.rangeredfrm, new_value_t.rangeredfrm };
    m_bit_details_model.bits.append(entry);
    entry = { "24: sitype:1",
              "StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?.",
              1, old_value_t.sitype, new_value_t.sitype };
    m_bit_details_model.bits.append(entry);
    entry = { "25: sbsel:1",
              "StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer.",
              1, old_value_t.sbsel, new_value_t.sbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "26: dbsel:1",
              "StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer.",
              1, old_value_t.dbsel, new_value_t.dbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "27: keyen:1",
              "Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled.",
              1, old_value_t.keyen, new_value_t.keyen };
    m_bit_details_model.bits.append(entry);
    entry = { "28: kpol:1",
              "Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range.",
              1, old_value_t.kpol, new_value_t.kpol };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: endith:1",
              "Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering",
              1, old_value_t.endith, new_value_t.endith };
    m_bit_details_model.bits.append(entry);
    entry = { "31: disdw:1",
              "output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place.",
              1, old_value_t.disdw, new_value_t.disdw };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CONTROLSECOND_OFFSET 0x1E
#define G2SB_G2CONTROLSECOND_UNDEFMASK 0xC08E3C01
union g2sb_g2controlsecond_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int bitswap:1;             /* Host port bit swap 1=enable   0= disable   1= enable */
        unsigned int bebswap:1;             /* Host port byte swap 1=enable   0= disable   1= enable */
        unsigned int bewswap:1;             /* Host port word swap 1=enable   0= disable */
        unsigned int alptype:5;             /* Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits. */
        unsigned int alpsrcordst:1;         /* 32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha */
        unsigned int undefined_bits_10_13:4;
        unsigned int pxlrep:1;              /* Pixel replication for Palm OS. */
        unsigned int swapblt:1;             /* Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area */
        unsigned int vcaa_safe_mode:1;      /* VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken. */
        unsigned int undefined_bits_17_19:3;
        unsigned int g2nostop:1;
        unsigned int clipc:2;               /* Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,  10=draw only inside clipping rectangle,  11=draw only outside clipping rectangle */
        unsigned int undefined_bit_23:1;
        unsigned int fr_mode:2;             /* Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice. 00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so! 01 = src/dst copy mode - two separate buffers 10 = square in place - one buffer 11 = blank */
        unsigned int fr_type:3;             /*  Fast Rotate type     000 = FLIP_X  001 = FLIP_Y  010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right) 011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left) 100 = ROT_90 (counter clock wise by 90 degrees) 101 = ROT_180  110 = ROT_270 (clock wise by 90 degrees) 111 = IDENTITY */
        unsigned int fr_readwait:1;         /*  Fast Rotate wait for read 0 = disable 1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only. */
        unsigned int undefined_bits_30_31:2;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2controlsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2controlsecond_u old_value_t = { .reg32 = value };
    const g2sb_g2controlsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bit_0:1", "", 1, old_value_t.undefined_bit_0, new_value_t.undefined_bit_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "01: bitswap:1",
              "Host port bit swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bitswap, new_value_t.bitswap };
    m_bit_details_model.bits.append(entry);
    entry = { "02: bebswap:1",
              "Host port byte swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bebswap, new_value_t.bebswap };
    m_bit_details_model.bits.append(entry);
    entry = { "03: bewswap:1",
              "Host port word swap\n1=enable  \n0= disable",
              1, old_value_t.bewswap, new_value_t.bewswap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: alptype:5",
              "Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits.",
              5, old_value_t.alptype, new_value_t.alptype };
    m_bit_details_model.bits.append(entry);
    entry = { "09: alpsrcordst:1",
              "32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha",
              1, old_value_t.alpsrcordst, new_value_t.alpsrcordst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_13:4", "", 4, old_value_t.undefined_bits_10_13, new_value_t.undefined_bits_10_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: pxlrep:1",
              "Pixel replication for Palm OS.",
              1, old_value_t.pxlrep, new_value_t.pxlrep };
    m_bit_details_model.bits.append(entry);
    entry = { "15: swapblt:1",
              "Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area",
              1, old_value_t.swapblt, new_value_t.swapblt };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vcaa_safe_mode:1",
              "VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken.",
              1, old_value_t.vcaa_safe_mode, new_value_t.vcaa_safe_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: g2nostop:1", "", 1, old_value_t.g2nostop, new_value_t.g2nostop };
    m_bit_details_model.bits.append(entry);
    entry = { "21: clipc:2",
              "Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,\n10=draw only inside clipping rectangle,\n11=draw only outside clipping rectangle",
              2, old_value_t.clipc, new_value_t.clipc };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fr_mode:2",
              "Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice.\n00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so!\n01 = src/dst copy mode - two separate buffers\n10 = square in place - one buffer\n11 = blank",
              2, old_value_t.fr_mode, new_value_t.fr_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "26: fr_type:3",
              " Fast Rotate type    \n000 = FLIP_X \n001 = FLIP_Y \n010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right)\n011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left)\n100 = ROT_90 (counter clock wise by 90 degrees)\n101 = ROT_180 \n110 = ROT_270 (clock wise by 90 degrees)\n111 = IDENTITY",
              3, old_value_t.fr_type, new_value_t.fr_type };
    m_bit_details_model.bits.append(entry);
    entry = { "29: fr_readwait:1",
              " Fast Rotate wait for read\n0 = disable\n1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only.",
              1, old_value_t.fr_readwait, new_value_t.fr_readwait };
    m_bit_details_model.bits.append(entry);
    entry = { "30: undefined_bits_30_31:2", "", 2, old_value_t.undefined_bits_30_31, new_value_t.undefined_bits_30_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CONTROLMAIN_OFFSET 0x1F
#define G2SB_G2CONTROLMAIN_UNDEFMASK 0x80000000
union g2sb_g2controlmain_u {
    struct {
        unsigned int cmdt:2;                /* Command Type:  00=BitBlt 01=Line Draw  10=VCAA 11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed) */
        unsigned int turbofill:1;           /* fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified. */
        unsigned int test0bit:1;            /* Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish. */
        unsigned int faden:1;               /* BitBlt Source Copy Fade enable, 1=enable (share with mltln), only support  16bpp mode */
        unsigned int alpen:1;               /* BitBlt Alpha Blending, 1=enable. 0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype */
        unsigned int srcsld:1;              /* BitBlt Solid Source Color Fill: 1=enable. FGC will be used as  the color value. */
        unsigned int patsld:1;              /* BitBlt Solid Pattern Fill: 1=enable. BGC will be used as  the color value. */
        unsigned int patfl:1;               /* When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+ */
        unsigned int xdir:1;                /*  0=incrementing, 1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0 */
        unsigned int ydir:1;                /*  0=incrementing, 1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0 */
        unsigned int xytdw:1;               /* xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination. */
        unsigned int srcpack:1;             /* Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled. */
        unsigned int patpack:1;             /* Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled. */
        unsigned int yflip:1;               /* flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination. */
        unsigned int srcsel:1;              /* Source Data Select: */
        unsigned int dstcd:2;               /* Destination color depth:   00=8-bpp, 01=16-bpp, 10=32-bpp. 11=reserved */
        unsigned int dstt:2;                /* Destination read transparency enable:   0x=destination read transparency disabled   10=color destination read transparency   11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately, 0=wait for launch write) */
        unsigned int srccd:1;               /* 0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0 */
        unsigned int hlmono:1;              /* Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit */
        unsigned int srct:2;                /* Source transparency enable: 0x=source transparency disabled,  10=mono source background transparency     or color source transparency,  11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied. */
        unsigned int srcbas:1;              /* Source base address select:   0=srcba, 1=dstba. This is not used for Line Draw and  if source data comes from host memory. */
        unsigned int gcsw:2;                /* Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used */
        unsigned int srcdir:1;              /* source direct addressing */
        unsigned int dstdir:1;              /* destination direct addressing */
        unsigned int dst_rd_wr_sep:1;       /* This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA */
        unsigned int patsel:1;              /* pattern Data Select: SRCSEL and PATSEL can't be both enabled. */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2controlmain_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2controlmain_u old_value_t = { .reg32 = value };
    const g2sb_g2controlmain_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cmdt:2",
              "Command Type: \n00=BitBlt\n01=Line Draw \n10=VCAA\n11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed)",
              2, old_value_t.cmdt, new_value_t.cmdt };
    m_bit_details_model.bits.append(entry);
    entry = { "02: turbofill:1",
              "fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified.",
              1, old_value_t.turbofill, new_value_t.turbofill };
    m_bit_details_model.bits.append(entry);
    entry = { "03: test0bit:1",
              "Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish.",
              1, old_value_t.test0bit, new_value_t.test0bit };
    m_bit_details_model.bits.append(entry);
    entry = { "04: faden:1",
              "BitBlt Source Copy Fade enable,\n1=enable (share with mltln), only support  16bpp mode",
              1, old_value_t.faden, new_value_t.faden };
    m_bit_details_model.bits.append(entry);
    entry = { "05: alpen:1",
              "BitBlt Alpha Blending,\n1=enable.\n0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype",
              1, old_value_t.alpen, new_value_t.alpen };
    m_bit_details_model.bits.append(entry);
    entry = { "06: srcsld:1",
              "BitBlt Solid Source Color Fill:\n1=enable. FGC will be used as  the color value.",
              1, old_value_t.srcsld, new_value_t.srcsld };
    m_bit_details_model.bits.append(entry);
    entry = { "07: patsld:1",
              "BitBlt Solid Pattern Fill:\n1=enable. BGC will be used as  the color value.",
              1, old_value_t.patsld, new_value_t.patsld };
    m_bit_details_model.bits.append(entry);
    entry = { "08: patfl:1",
              "When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+",
              1, old_value_t.patfl, new_value_t.patfl };
    m_bit_details_model.bits.append(entry);
    entry = { "09: xdir:1",
              "0=incrementing,\n1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0",
              1, old_value_t.xdir, new_value_t.xdir };
    m_bit_details_model.bits.append(entry);
    entry = { "10: ydir:1",
              "0=incrementing,\n1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0",
              1, old_value_t.ydir, new_value_t.ydir };
    m_bit_details_model.bits.append(entry);
    entry = { "11: xytdw:1",
              "xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination.",
              1, old_value_t.xytdw, new_value_t.xytdw };
    m_bit_details_model.bits.append(entry);
    entry = { "12: srcpack:1",
              "Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.srcpack, new_value_t.srcpack };
    m_bit_details_model.bits.append(entry);
    entry = { "13: patpack:1",
              "Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.patpack, new_value_t.patpack };
    m_bit_details_model.bits.append(entry);
    entry = { "14: yflip:1",
              "flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination.",
              1, old_value_t.yflip, new_value_t.yflip };
    m_bit_details_model.bits.append(entry);
    entry = { "15: srcsel:1",
              "Source Data Select:",
              1, old_value_t.srcsel, new_value_t.srcsel };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstcd:2",
              "Destination color depth:  \n00=8-bpp,\n01=16-bpp,\n10=32-bpp.\n11=reserved",
              2, old_value_t.dstcd, new_value_t.dstcd };
    m_bit_details_model.bits.append(entry);
    entry = { "18: dstt:2",
              "Destination read transparency enable:   0x=destination read transparency disabled  \n10=color destination read transparency  \n11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately,\n0=wait for launch write)",
              2, old_value_t.dstt, new_value_t.dstt };
    m_bit_details_model.bits.append(entry);
    entry = { "20: srccd:1",
              "0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0",
              1, old_value_t.srccd, new_value_t.srccd };
    m_bit_details_model.bits.append(entry);
    entry = { "21: hlmono:1",
              "Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit",
              1, old_value_t.hlmono, new_value_t.hlmono };
    m_bit_details_model.bits.append(entry);
    entry = { "22: srct:2",
              "Source transparency enable: 0x=source transparency disabled,\n10=mono source background transparency     or color source transparency,\n11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied.",
              2, old_value_t.srct, new_value_t.srct };
    m_bit_details_model.bits.append(entry);
    entry = { "24: srcbas:1",
              "Source base address select:  \n0=srcba,\n1=dstba. This is not used for Line Draw and  if source data comes from host memory.",
              1, old_value_t.srcbas, new_value_t.srcbas };
    m_bit_details_model.bits.append(entry);
    entry = { "25: gcsw:2",
              "Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used",
              2, old_value_t.gcsw, new_value_t.gcsw };
    m_bit_details_model.bits.append(entry);
    entry = { "27: srcdir:1",
              "source direct addressing",
              1, old_value_t.srcdir, new_value_t.srcdir };
    m_bit_details_model.bits.append(entry);
    entry = { "28: dstdir:1",
              "destination direct addressing",
              1, old_value_t.dstdir, new_value_t.dstdir };
    m_bit_details_model.bits.append(entry);
    entry = { "29: dst_rd_wr_sep:1",
              "This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA",
              1, old_value_t.dst_rd_wr_sep, new_value_t.dst_rd_wr_sep };
    m_bit_details_model.bits.append(entry);
    entry = { "30: patsel:1",
              "pattern Data Select: SRCSEL and PATSEL can't be both enabled.",
              1, old_value_t.patsel, new_value_t.patsel };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2ROPFADE_OFFSET 0x20
#define G2SB_G2ROPFADE_UNDEFMASK 0x0000FF00
union g2sb_g2ropfade_u {
    struct {
        unsigned int rop:8;                 /* If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out. */
        unsigned int undefined_bits_8_15:8;
        unsigned int fadcoe:8;
        unsigned int fadoff:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2ropfade_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2ropfade_u old_value_t = { .reg32 = value };
    const g2sb_g2ropfade_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: rop:8",
              "If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out.",
              8, old_value_t.rop, new_value_t.rop };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: fadcoe:8", "", 8, old_value_t.fadcoe, new_value_t.fadcoe };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fadoff:8", "", 8, old_value_t.fadoff, new_value_t.fadoff };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2ALPHABLEND_OFFSET 0x21
#define G2SB_G2ALPHABLEND_UNDEFMASK 0x0000FE00
union g2sb_g2alphablend_u {
    struct {
        unsigned int alpha:8;
        unsigned int alphainv:1;
        unsigned int undefined_bits_9_15:7;
        unsigned int alpha0v:8;
        unsigned int alpha1v:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2alphablend_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2alphablend_u old_value_t = { .reg32 = value };
    const g2sb_g2alphablend_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: alpha:8", "", 8, old_value_t.alpha, new_value_t.alpha };
    m_bit_details_model.bits.append(entry);
    entry = { "08: alphainv:1", "", 1, old_value_t.alphainv, new_value_t.alphainv };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: alpha0v:8", "", 8, old_value_t.alpha0v, new_value_t.alpha0v };
    m_bit_details_model.bits.append(entry);
    entry = { "24: alpha1v:8", "", 8, old_value_t.alpha1v, new_value_t.alpha1v };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CLIPLEFTTOP_OFFSET 0x22
#define G2SB_G2CLIPLEFTTOP_UNDEFMASK 0x80008000
union g2sb_g2cliplefttop_u {
    struct {
        unsigned int clipl:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipt:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2cliplefttop_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2cliplefttop_u old_value_t = { .reg32 = value };
    const g2sb_g2cliplefttop_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipl:15", "", 15, old_value_t.clipl, new_value_t.clipl };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipt:15", "", 15, old_value_t.clipt, new_value_t.clipt };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CLIPRIGHTBOT_OFFSET 0x23
#define G2SB_G2CLIPRIGHTBOT_UNDEFMASK 0x80008000
union g2sb_g2cliprightbot_u {
    struct {
        unsigned int clipr:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipb:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2cliprightbot_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2cliprightbot_u old_value_t = { .reg32 = value };
    const g2sb_g2cliprightbot_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipr:15", "", 15, old_value_t.clipr, new_value_t.clipr };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipb:15", "", 15, old_value_t.clipb, new_value_t.clipb };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2PATPACK_OFFSET 0x24
#define G2SB_G2PATPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_g2patpack_u {
    struct {
        unsigned int patlngap:4;            /* Packed mode, pattern data line gap. byte */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2patpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2patpack_u old_value_t = { .reg32 = value };
    const g2sb_g2patpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patlngap:4",
              "Packed mode, pattern data line gap. byte",
              4, old_value_t.patlngap, new_value_t.patlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2PATPACK_SIZE_OFFSET 0x25
#define G2SB_G2PATPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_g2patpack_size_u {
    struct {
        unsigned int patmonow:16;           /* Mono data width in packed mode, byte  */
        unsigned int patmonoh:16;           /*  Pattern mono data height in packed mode, byte  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2patpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2patpack_size_u old_value_t = { .reg32 = value };
    const g2sb_g2patpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patmonow:16",
              "Mono data width in packed mode, byte",
              16, old_value_t.patmonow, new_value_t.patmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patmonoh:16",
              " Pattern mono data height in packed mode, byte",
              16, old_value_t.patmonoh, new_value_t.patmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2PATBA_OFFSET 0x26
#define G2SB_G2PATBA_UNDEFMASK 0x00000000
union g2sb_g2patba_u {
    struct {
        unsigned int patba:32;              /* If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. } */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2patba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2patba_u old_value_t = { .reg32 = value };
    const g2sb_g2patba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patba:32",
              "If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. }",
              32, old_value_t.patba, new_value_t.patba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2PATOS_OFFSET 0x27
#define G2SB_G2PATOS_UNDEFMASK 0x009E0000
union g2sb_g2patos_u {
    struct {
        unsigned int patst:16;              /* stride */
        unsigned int patcd:1;               /* 0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0 */
        unsigned int undefined_bits_17_20:4;
        unsigned int patt:2;                /* Mono pattern transparency enable:  0x=pattern transparency disabled,  10=mono pattern background transparency    or color pattern transparency,  11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied. */
        unsigned int undefined_bit_23:1;
        unsigned int patxo:4;               /* x offset for mono tile pattern fill.  see PATFL */
        unsigned int patyo:4;               /* y offset for mono tile pattern fill.  see PATFL */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2patos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2patos_u old_value_t = { .reg32 = value };
    const g2sb_g2patos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patst:16",
              "stride",
              16, old_value_t.patst, new_value_t.patst };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patcd:1",
              "0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0",
              1, old_value_t.patcd, new_value_t.patcd };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_20:4", "", 4, old_value_t.undefined_bits_17_20, new_value_t.undefined_bits_17_20 };
    m_bit_details_model.bits.append(entry);
    entry = { "21: patt:2",
              "Mono pattern transparency enable:  0x=pattern transparency disabled,\n10=mono pattern background transparency    or color pattern transparency,\n11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied.",
              2, old_value_t.patt, new_value_t.patt };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: patxo:4",
              "x offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patxo, new_value_t.patxo };
    m_bit_details_model.bits.append(entry);
    entry = { "28: patyo:4",
              "y offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patyo, new_value_t.patyo };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2PATBGC_OFFSET 0x28
#define G2SB_G2PATBGC_UNDEFMASK 0x00000000
union g2sb_g2patbgc_u {
    struct {
        unsigned int patbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2patbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2patbgc_u old_value_t = { .reg32 = value };
    const g2sb_g2patbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patbgc:32", "", 32, old_value_t.patbgc, new_value_t.patbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2PATFGC_OFFSET 0x29
#define G2SB_G2PATFGC_UNDEFMASK 0x00000000
union g2sb_g2patfgc_u {
    struct {
        unsigned int patfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2patfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2patfgc_u old_value_t = { .reg32 = value };
    const g2sb_g2patfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patfgc:32", "", 32, old_value_t.patfgc, new_value_t.patfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2PATKEY_OFFSET 0x2A
#define G2SB_G2PATKEY_UNDEFMASK 0x00000000
union g2sb_g2patkey_u {
    struct {
        unsigned int patkey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2patkey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2patkey_u old_value_t = { .reg32 = value };
    const g2sb_g2patkey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patkey:32", "", 32, old_value_t.patkey, new_value_t.patkey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2DSTBA_OFFSET 0x2B
#define G2SB_G2DSTBA_UNDEFMASK 0x00000000
union g2sb_g2dstba_u {
    struct {
        unsigned int dstba:32;              /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2dstba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2dstba_u old_value_t = { .reg32 = value };
    const g2sb_g2dstba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba, new_value_t.dstba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2DSTBA_B_OFFSET 0x2C
#define G2SB_G2DSTBA_B_UNDEFMASK 0x00000000
union g2sb_g2dstba_b_u {
    struct {
        unsigned int dstba_b:32;            /* Destination base address (byte address) only usable in hardware trigger mode by enable gcsw */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2dstba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2dstba_b_u old_value_t = { .reg32 = value };
    const g2sb_g2dstba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_b:32",
              "Destination base address (byte address) only usable in hardware trigger mode by enable gcsw",
              32, old_value_t.dstba_b, new_value_t.dstba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2DSTBA_C_OFFSET 0x2D
#define G2SB_G2DSTBA_C_UNDEFMASK 0x00000000
union g2sb_g2dstba_c_u {
    struct {
        unsigned int dstba_c:32;            /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2dstba_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2dstba_c_u old_value_t = { .reg32 = value };
    const g2sb_g2dstba_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_c:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba_c, new_value_t.dstba_c };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2DSTST_OFFSET 0x2E
#define G2SB_G2DSTST_UNDEFMASK 0xFFFF0000
union g2sb_g2dstst_u {
    struct {
        unsigned int dsts:16;               /* Destination Stride coordinate(bytes) with respect to DSTBA. */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2dstst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2dstst_u old_value_t = { .reg32 = value };
    const g2sb_g2dstst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dsts:16",
              "Destination Stride coordinate(bytes) with respect to DSTBA.",
              16, old_value_t.dsts, new_value_t.dsts };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2SRCPACK_OFFSET 0x2F
#define G2SB_G2SRCPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_g2srcpack_u {
    struct {
        unsigned int srclngap:4;            /* Packed mode - source mono data line gap */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2srcpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2srcpack_u old_value_t = { .reg32 = value };
    const g2sb_g2srcpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srclngap:4",
              "Packed mode - source mono data line gap",
              4, old_value_t.srclngap, new_value_t.srclngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2SRCPACK_SIZE_OFFSET 0x30
#define G2SB_G2SRCPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_g2srcpack_size_u {
    struct {
        unsigned int srcmonow:16;           /* Packed mode - source mono data width in bytes */
        unsigned int srcmonoh:16;           /* Packed mode - source mono data height in bytes  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2srcpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2srcpack_size_u old_value_t = { .reg32 = value };
    const g2sb_g2srcpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcmonow:16",
              "Packed mode - source mono data width in bytes",
              16, old_value_t.srcmonow, new_value_t.srcmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcmonoh:16",
              "Packed mode - source mono data height in bytes",
              16, old_value_t.srcmonoh, new_value_t.srcmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2SRCBA_OFFSET 0x31
#define G2SB_G2SRCBA_UNDEFMASK 0x00000000
union g2sb_g2srcba_u {
    struct {
        unsigned int srcba:32;              /* Source base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2srcba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2srcba_u old_value_t = { .reg32 = value };
    const g2sb_g2srcba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba:32",
              "Source base address (byte address)",
              32, old_value_t.srcba, new_value_t.srcba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2SRCBA_B_OFFSET 0x32
#define G2SB_G2SRCBA_B_UNDEFMASK 0x00000000
union g2sb_g2srcba_b_u {
    struct {
        unsigned int srcba_b:32;            /* This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.) */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2srcba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2srcba_b_u old_value_t = { .reg32 = value };
    const g2sb_g2srcba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba_b:32",
              "This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.)",
              32, old_value_t.srcba_b, new_value_t.srcba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2SRCST_OFFSET 0x33
#define G2SB_G2SRCST_UNDEFMASK 0xFFFF0000
union g2sb_g2srcst_u {
    struct {
        unsigned int srcs:16;               /* Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.  */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2srcst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2srcst_u old_value_t = { .reg32 = value };
    const g2sb_g2srcst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs:16",
              "Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.",
              16, old_value_t.srcs, new_value_t.srcs };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2SRCBGC_OFFSET 0x34
#define G2SB_G2SRCBGC_UNDEFMASK 0x00000000
union g2sb_g2srcbgc_u {
    struct {
        unsigned int srcbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2srcbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2srcbgc_u old_value_t = { .reg32 = value };
    const g2sb_g2srcbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcbgc:32", "", 32, old_value_t.srcbgc, new_value_t.srcbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2SRCFGC_OFFSET 0x35
#define G2SB_G2SRCFGC_UNDEFMASK 0x00000000
union g2sb_g2srcfgc_u {
    struct {
        unsigned int srcfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2srcfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2srcfgc_u old_value_t = { .reg32 = value };
    const g2sb_g2srcfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcfgc:32", "", 32, old_value_t.srcfgc, new_value_t.srcfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2SRCKEY_OFFSET 0x36
#define G2SB_G2SRCKEY_UNDEFMASK 0x00000000
union g2sb_g2srckey_u {
    struct {
        unsigned int srckey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2srckey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2srckey_u old_value_t = { .reg32 = value };
    const g2sb_g2srckey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srckey:32", "", 32, old_value_t.srckey, new_value_t.srckey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2SRCSIZE_OFFSET 0x37
#define G2SB_G2SRCSIZE_UNDEFMASK 0x80008000
union g2sb_g2srcsize_u {
    struct {
        unsigned int srcwidth:15;
        unsigned int undefined_bit_15:1;
        unsigned int srcheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2srcsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2srcsize_u old_value_t = { .reg32 = value };
    const g2sb_g2srcsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcwidth:15", "", 15, old_value_t.srcwidth, new_value_t.srcwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.srcheight, new_value_t.srcheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2DSTSIZE_OFFSET 0x38
#define G2SB_G2DSTSIZE_UNDEFMASK 0x80008000
union g2sb_g2dstsize_u {
    struct {
        unsigned int dstwidth:15;           /* In 2D mode, the largest number can be programmed is 0x7fef */
        unsigned int undefined_bit_15:1;
        unsigned int dstheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2dstsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2dstsize_u old_value_t = { .reg32 = value };
    const g2sb_g2dstsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstwidth:15",
              "In 2D mode, the largest number can be programmed is 0x7fef",
              15, old_value_t.dstwidth, new_value_t.dstwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.dstheight, new_value_t.dstheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2SRCPS_OFFSET 0x39
#define G2SB_G2SRCPS_UNDEFMASK 0x00000000
union g2sb_g2srcps_u {
    struct {
        unsigned int srcx:16;               /* SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY   */
        unsigned int srcy:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2srcps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2srcps_u old_value_t = { .reg32 = value };
    const g2sb_g2srcps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcx:16",
              "SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY",
              16, old_value_t.srcx, new_value_t.srcx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcy:16", "", 16, old_value_t.srcy, new_value_t.srcy };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2DSTPS_OFFSET 0x3A
#define G2SB_G2DSTPS_UNDEFMASK 0x00000000
union g2sb_g2dstps_u {
    struct {
        unsigned int dstx:16;               /* NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 */
        unsigned int dsty:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2dstps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2dstps_u old_value_t = { .reg32 = value };
    const g2sb_g2dstps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstx:16",
              "NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489",
              16, old_value_t.dstx, new_value_t.dstx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dsty:16", "", 16, old_value_t.dsty, new_value_t.dsty };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CBDES_OFFSET 0x3B
#define G2SB_G2CBDES_UNDEFMASK 0x0000FF00
union g2sb_g2cbdes_u {
    struct {
        unsigned int cbcount:8;             /* This specifies the number of buffers incircular buffer feature                    */
        unsigned int undefined_bits_8_15:8;
        unsigned int cbline:15;             /* vertical line number in one buffer */
        unsigned int topclip:1;             /* top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2 0= disable  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2cbdes_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2cbdes_u old_value_t = { .reg32 = value };
    const g2sb_g2cbdes_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbcount:8",
              "This specifies the number of buffers incircular buffer feature",
              8, old_value_t.cbcount, new_value_t.cbcount };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbline:15",
              "vertical line number in one buffer",
              15, old_value_t.cbline, new_value_t.cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "31: topclip:1",
              "top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2\n0= disable",
              1, old_value_t.topclip, new_value_t.topclip };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CBSTRIDE_OFFSET 0x3C
#define G2SB_G2CBSTRIDE_UNDEFMASK 0x3F000000
union g2sb_g2cbstride_u {
    struct {
        unsigned int cbstride:24;           /* Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes) */
        unsigned int undefined_bits_24_29:6;
        unsigned int cbuvstride:2;          /* Chroma Buffer Stride default is half of luma   00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2cbstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2cbstride_u old_value_t = { .reg32 = value };
    const g2sb_g2cbstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbstride:24",
              "Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes)",
              24, old_value_t.cbstride, new_value_t.cbstride };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_29:6", "", 6, old_value_t.undefined_bits_24_29, new_value_t.undefined_bits_24_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: cbuvstride:2",
              "Chroma Buffer Stride default is half of luma  \n00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved",
              2, old_value_t.cbuvstride, new_value_t.cbuvstride };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2LINESETTING_OFFSET 0x3D
#define G2SB_G2LINESETTING_UNDEFMASK 0x00E00000
union g2sb_g2linesetting_u {
    struct {
        unsigned int gamma:21;
        unsigned int undefined_bits_21_23:3;
        unsigned int major:1;               /* 0:xmajor 1: y major */
        unsigned int linexdir:1;
        unsigned int lineydir:1;
        unsigned int droplastp:1;           /* draw last pixel or not */
        unsigned int lineuseoctant:1;       /* use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR */
        unsigned int octants:3;             /* 000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2linesetting_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2linesetting_u old_value_t = { .reg32 = value };
    const g2sb_g2linesetting_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: gamma:21", "", 21, old_value_t.gamma, new_value_t.gamma };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_23:3", "", 3, old_value_t.undefined_bits_21_23, new_value_t.undefined_bits_21_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: major:1",
              "0:xmajor 1: y major",
              1, old_value_t.major, new_value_t.major };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linexdir:1", "", 1, old_value_t.linexdir, new_value_t.linexdir };
    m_bit_details_model.bits.append(entry);
    entry = { "26: lineydir:1", "", 1, old_value_t.lineydir, new_value_t.lineydir };
    m_bit_details_model.bits.append(entry);
    entry = { "27: droplastp:1",
              "draw last pixel or not",
              1, old_value_t.droplastp, new_value_t.droplastp };
    m_bit_details_model.bits.append(entry);
    entry = { "28: lineuseoctant:1",
              "use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR",
              1, old_value_t.lineuseoctant, new_value_t.lineuseoctant };
    m_bit_details_model.bits.append(entry);
    entry = { "29: octants:3",
              "000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7",
              3, old_value_t.octants, new_value_t.octants };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2LINEDELTAN_OFFSET 0x3E
#define G2SB_G2LINEDELTAN_UNDEFMASK 0xFFE00000
union g2sb_g2linedeltan_u {
    struct {
        unsigned int deltan:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2linedeltan_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2linedeltan_u old_value_t = { .reg32 = value };
    const g2sb_g2linedeltan_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltan:21", "", 21, old_value_t.deltan, new_value_t.deltan };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2LINEDELTAM_OFFSET 0x3F
#define G2SB_G2LINEDELTAM_UNDEFMASK 0xFFE00000
union g2sb_g2linedeltam_u {
    struct {
        unsigned int deltam:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2linedeltam_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2linedeltam_u old_value_t = { .reg32 = value };
    const g2sb_g2linedeltam_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltam:21", "", 21, old_value_t.deltam, new_value_t.deltam };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2LINEPOS_OFFSET 0x40
#define G2SB_G2LINEPOS_UNDEFMASK 0x00000000
union g2sb_g2linepos_u {
    struct {
        unsigned int linexpos:16;
        unsigned int lineypos:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2linepos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2linepos_u old_value_t = { .reg32 = value };
    const g2sb_g2linepos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linexpos:16", "", 16, old_value_t.linexpos, new_value_t.linexpos };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lineypos:16", "", 16, old_value_t.lineypos, new_value_t.lineypos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2LINELEN_OFFSET 0x41
#define G2SB_G2LINELEN_UNDEFMASK 0xFFFF8000
union g2sb_g2linelen_u {
    struct {
        unsigned int linelen:15;
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2linelen_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2linelen_u old_value_t = { .reg32 = value };
    const g2sb_g2linelen_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linelen:15", "", 15, old_value_t.linelen, new_value_t.linelen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CSCFOURTH_OFFSET 0x42
#define G2SB_G2CSCFOURTH_UNDEFMASK 0xFE00FE00
union g2sb_g2cscfourth_u {
    struct {
        unsigned int g2u:9;                 /* multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored */
        unsigned int undefined_bits_9_15:7;
        unsigned int g2v:9;                 /* multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored */
        unsigned int undefined_bits_25_31:7;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2cscfourth_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2cscfourth_u old_value_t = { .reg32 = value };
    const g2sb_g2cscfourth_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: g2u:9",
              "multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored",
              9, old_value_t.g2u, new_value_t.g2u };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: g2v:9",
              "multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored",
              9, old_value_t.g2v, new_value_t.g2v };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bits_25_31:7", "", 7, old_value_t.undefined_bits_25_31, new_value_t.undefined_bits_25_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2SRCST_B_OFFSET 0x43
#define G2SB_G2SRCST_B_UNDEFMASK 0xFFFF0000
union g2sb_g2srcst_b_u {
    struct {
        unsigned int srcs_b:16;             /* Source Stride B */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2srcst_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2srcst_b_u old_value_t = { .reg32 = value };
    const g2sb_g2srcst_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs_b:16",
              "Source Stride B",
              16, old_value_t.srcs_b, new_value_t.srcs_b };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2UVSTRIDE_OFFSET 0x44
#define G2SB_G2UVSTRIDE_UNDEFMASK 0xFFFF0000
union g2sb_g2uvstride_u {
    struct {
        unsigned int uvstride:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2uvstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2uvstride_u old_value_t = { .reg32 = value };
    const g2sb_g2uvstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: uvstride:16", "", 16, old_value_t.uvstride, new_value_t.uvstride };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2CBDES2_OFFSET 0x45
#define G2SB_G2CBDES2_UNDEFMASK 0xFFFF8000
union g2sb_g2cbdes2_u {
    struct {
        unsigned int top_cbline:15;         /* Circular buffer top clipping enabled, the first buffer line num */
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2cbdes2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2cbdes2_u old_value_t = { .reg32 = value };
    const g2sb_g2cbdes2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: top_cbline:15",
              "Circular buffer top clipping enabled, the first buffer line num",
              15, old_value_t.top_cbline, new_value_t.top_cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2TILEMODE_OFFSET 0x46
#define G2SB_G2TILEMODE_UNDEFMASK 0xFFEEEEEE
union g2sb_g2tilemode_u {
    struct {
        unsigned int src_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_1_3:3;
        unsigned int src_uv_tile_mode:1;    /* UV surface, ignored in RGB mode */
        unsigned int undefined_bits_5_7:3;
        unsigned int pat_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_9_11:3;
        unsigned int pat_uv_tile_mode:1;    /* UNUSED */
        unsigned int undefined_bits_13_15:3;
        unsigned int dst_rd_tile_mode:1;    /* Same as destination write unless DST_RD_WR_SEP (not supported) */
        unsigned int undefined_bits_17_19:3;
        unsigned int dst_wr_tile_mode:1;    /* destination surface */
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2tilemode_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2tilemode_u old_value_t = { .reg32 = value };
    const g2sb_g2tilemode_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.src_y_tile_mode, new_value_t.src_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: src_uv_tile_mode:1",
              "UV surface, ignored in RGB mode",
              1, old_value_t.src_uv_tile_mode, new_value_t.src_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: pat_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.pat_y_tile_mode, new_value_t.pat_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: pat_uv_tile_mode:1",
              "UNUSED",
              1, old_value_t.pat_uv_tile_mode, new_value_t.pat_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dst_rd_tile_mode:1",
              "Same as destination write unless DST_RD_WR_SEP (not supported)",
              1, old_value_t.dst_rd_tile_mode, new_value_t.dst_rd_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: dst_wr_tile_mode:1",
              "destination surface",
              1, old_value_t.dst_wr_tile_mode, new_value_t.dst_wr_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2PATBASE_OFFSET 0x47
#define G2SB_G2PATBASE_UNDEFMASK 0x00000000
union g2sb_g2patbase_u {
    struct {
        unsigned int pat_base:32;           /* pattern base address in tile mode,  PATBA is the linear address where pixel start */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2patbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2patbase_u old_value_t = { .reg32 = value };
    const g2sb_g2patbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pat_base:32",
              "pattern base address in tile mode,  PATBA is the linear address where pixel start",
              32, old_value_t.pat_base, new_value_t.pat_base };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2SRCBA_SB_SURFBASE_OFFSET 0x48
#define G2SB_G2SRCBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_g2srcba_sb_surfbase_u {
    struct {
        unsigned int src_addr:32;           /* surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2srcba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2srcba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_g2srcba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_addr:32",
              "surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine",
              32, old_value_t.src_addr, new_value_t.src_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2DSTBA_SB_SURFBASE_OFFSET 0x49
#define G2SB_G2DSTBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_g2dstba_sb_surfbase_u {
    struct {
        unsigned int dst_addr:32;           /* surface address corresponding to G2DSTBA Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2dstba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2dstba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_g2dstba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_addr:32",
              "surface address corresponding to G2DSTBA Only used by the StretchBlit Engine",
              32, old_value_t.dst_addr, new_value_t.dst_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2DSTBA_B_SB_SURFBASE_OFFSET 0x4A
#define G2SB_G2DSTBA_B_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_g2dstba_b_sb_surfbase_u {
    struct {
        unsigned int dst_b_addr:32;         /* surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2dstba_b_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2dstba_b_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_g2dstba_b_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_b_addr:32",
              "surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled",
              32, old_value_t.dst_b_addr, new_value_t.dst_b_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2VBA_A_SB_SURFBASE_OFFSET 0x4B
#define G2SB_G2VBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_g2vba_a_sb_surfbase_u {
    struct {
        unsigned int v_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2vba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2vba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_g2vba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine",
              32, old_value_t.v_addr, new_value_t.v_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_G2UBA_A_SB_SURFBASE_OFFSET 0x4C
#define G2SB_G2UBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_g2uba_a_sb_surfbase_u {
    struct {
        unsigned int u_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_g2uba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_g2uba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_g2uba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: u_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine",
              32, old_value_t.u_addr, new_value_t.u_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_INCR_SYNCPT_OFFSET 0x4000
#define G2SB_CTX1_INCR_SYNCPT_UNDEFMASK 0xFFFF0000
union g2sb_ctx1_incr_syncpt_u {
    struct {
        unsigned int indx:8;                /* syncpt index value */
        unsigned int cond:8;                /* Condition mapped from raise/wait */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_incr_syncpt_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_incr_syncpt_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_incr_syncpt_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: indx:8",
              "syncpt index value",
              8, old_value_t.indx, new_value_t.indx };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cond:8",
              "Condition mapped from raise/wait",
              8, old_value_t.cond, new_value_t.cond };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_INCR_SYNCPT_CNTRL_OFFSET 0x4001
#define G2SB_CTX1_INCR_SYNCPT_CNTRL_UNDEFMASK 0xFFFFFEFE
union g2sb_ctx1_incr_syncpt_cntrl_u {
    struct {
        unsigned int incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs. */
        unsigned int undefined_bits_1_7:7;
        unsigned int incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled. */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_incr_syncpt_cntrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_incr_syncpt_cntrl_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_incr_syncpt_cntrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: incr_syncpt_soft_reset:1",
              "If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs.",
              1, old_value_t.incr_syncpt_soft_reset, new_value_t.incr_syncpt_soft_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: incr_syncpt_no_stall:1",
              "If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled.",
              1, old_value_t.incr_syncpt_no_stall, new_value_t.incr_syncpt_no_stall };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_INCR_SYNCPT_ERROR_OFFSET 0x4002
#define G2SB_CTX1_INCR_SYNCPT_ERROR_UNDEFMASK 0x00000000
union g2sb_ctx1_incr_syncpt_error_u {
    struct {
        unsigned int cond_status:32;        /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_incr_syncpt_error_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_incr_syncpt_error_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_incr_syncpt_error_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cond_status:32",
              "COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero",
              32, old_value_t.cond_status, new_value_t.cond_status };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CLASSCHANNEL_REGONLY_OFFSET 0x4008
#define G2SB_CTX1_G2CLASSCHANNEL_REGONLY_UNDEFMASK 0xFFE0FC00
union g2sb_ctx1_g2classchannel_regonly_u {
    struct {
        unsigned int curr_class:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int curr_channel:4;
        unsigned int ctx_valid:1;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2classchannel_regonly_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2classchannel_regonly_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2classchannel_regonly_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: curr_class:10", "", 10, old_value_t.curr_class, new_value_t.curr_class };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_15:6", "", 6, old_value_t.undefined_bits_10_15, new_value_t.undefined_bits_10_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: curr_channel:4", "", 4, old_value_t.curr_channel, new_value_t.curr_channel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ctx_valid:1", "", 1, old_value_t.ctx_valid, new_value_t.ctx_valid };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2TRIGGER_OFFSET 0x4009
#define G2SB_CTX1_G2TRIGGER_UNDEFMASK 0xFFFF0000
union g2sb_ctx1_g2trigger_u {
    struct {
        unsigned int trigger:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2trigger_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2trigger_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2trigger_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger:16", "", 16, old_value_t.trigger, new_value_t.trigger };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2TRIGGER1_OFFSET 0x400A
#define G2SB_CTX1_G2TRIGGER1_UNDEFMASK 0xFFFF0000
union g2sb_ctx1_g2trigger1_u {
    struct {
        unsigned int trigger1:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2trigger1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2trigger1_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2trigger1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger1:16", "", 16, old_value_t.trigger1, new_value_t.trigger1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2TRIGGER2_OFFSET 0x400B
#define G2SB_CTX1_G2TRIGGER2_UNDEFMASK 0xFFFF0000
union g2sb_ctx1_g2trigger2_u {
    struct {
        unsigned int trigger2:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2trigger2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2trigger2_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2trigger2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger2:16", "", 16, old_value_t.trigger2, new_value_t.trigger2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CMDSEL_OFFSET 0x400C
#define G2SB_CTX1_G2CMDSEL_UNDEFMASK 0xE000280E
union g2sb_ctx1_g2cmdsel_u {
    struct {
        unsigned int sbor2d:1;
        unsigned int undefined_bits_1_3:3;
        unsigned int cbenable:1;            /* circular buffer feature enable    0= disable */
        unsigned int vitrigger:1;           /* VI trigger enable, can be circular buffer or full frame */
        unsigned int hosttrigger:1;         /* host trigger the command, host also need program cicular buffer related data */
        unsigned int cbsbdisable:1;
        unsigned int g2output:2;            /* 00: to memory 01: to EPP */
        unsigned int clip_source_top_bottom:1;/* Reserved for HW Test, SW should not use this bit. */
        unsigned int undefined_bit_11:1;
        unsigned int link_wait_buf_end:1;
        unsigned int undefined_bit_13:1;
        unsigned int frame_start:1;         /* host writes this bit to tell which buffer is ready */
        unsigned int frame_end:1;
        unsigned int buffer_index:8;
        unsigned int linken:1;              /* Test purpose */
        unsigned int linkval:3;
        unsigned int priority:1;            /* indicates priority of the context, note vi-triggered contexts take priority over HIGH */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2cmdsel_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2cmdsel_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2cmdsel_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sbor2d:1", "", 1, old_value_t.sbor2d, new_value_t.sbor2d };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: cbenable:1",
              "circular buffer feature enable   \n0= disable",
              1, old_value_t.cbenable, new_value_t.cbenable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: vitrigger:1",
              "VI trigger enable, can be circular buffer or full frame",
              1, old_value_t.vitrigger, new_value_t.vitrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "06: hosttrigger:1",
              "host trigger the command, host also need program cicular buffer related data",
              1, old_value_t.hosttrigger, new_value_t.hosttrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "07: cbsbdisable:1", "", 1, old_value_t.cbsbdisable, new_value_t.cbsbdisable };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g2output:2",
              "00: to memory 01: to EPP",
              2, old_value_t.g2output, new_value_t.g2output };
    m_bit_details_model.bits.append(entry);
    entry = { "10: clip_source_top_bottom:1",
              "Reserved for HW Test, SW should not use this bit.",
              1, old_value_t.clip_source_top_bottom, new_value_t.clip_source_top_bottom };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: link_wait_buf_end:1", "", 1, old_value_t.link_wait_buf_end, new_value_t.link_wait_buf_end };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: frame_start:1",
              "host writes this bit to tell which buffer is ready",
              1, old_value_t.frame_start, new_value_t.frame_start };
    m_bit_details_model.bits.append(entry);
    entry = { "15: frame_end:1", "", 1, old_value_t.frame_end, new_value_t.frame_end };
    m_bit_details_model.bits.append(entry);
    entry = { "16: buffer_index:8", "", 8, old_value_t.buffer_index, new_value_t.buffer_index };
    m_bit_details_model.bits.append(entry);
    entry = { "24: linken:1",
              "Test purpose",
              1, old_value_t.linken, new_value_t.linken };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linkval:3", "", 3, old_value_t.linkval, new_value_t.linkval };
    m_bit_details_model.bits.append(entry);
    entry = { "28: priority:1",
              "indicates priority of the context, note vi-triggered contexts take priority over HIGH",
              1, old_value_t.priority, new_value_t.priority };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2RAISE_OFFSET 0x400D
#define G2SB_CTX1_G2RAISE_UNDEFMASK 0xFFF0FFE0
union g2sb_ctx1_g2raise_u {
    struct {
        unsigned int raise:5;               /* Push back to read fifo when all commands in the channel are done.           */
        unsigned int undefined_bits_5_15:11;
        unsigned int raisechannel:4;
        unsigned int undefined_bits_20_31:12;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2raise_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2raise_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2raise_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: raise:5",
              "Push back to read fifo when all commands in the channel are done.",
              5, old_value_t.raise, new_value_t.raise };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_15:11", "", 11, old_value_t.undefined_bits_5_15, new_value_t.undefined_bits_5_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisechannel:4", "", 4, old_value_t.raisechannel, new_value_t.raisechannel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_31:12", "", 12, old_value_t.undefined_bits_20_31, new_value_t.undefined_bits_20_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2HOSTSET_OFFSET 0x400F
#define G2SB_CTX1_G2HOSTSET_UNDEFMASK 0xFFFFFF00
union g2sb_ctx1_g2hostset_u {
    struct {
        unsigned int hstlngap:4;            /*  specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte) */
        unsigned int hstfpxl:4;             /* specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2hostset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2hostset_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2hostset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hstlngap:4",
              " specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte)",
              4, old_value_t.hstlngap, new_value_t.hstlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: hstfpxl:4",
              "specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary",
              4, old_value_t.hstfpxl, new_value_t.hstfpxl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2HOSTFIFO_OFFSET 0x4010
#define G2SB_CTX1_G2HOSTFIFO_UNDEFMASK 0x00000000
union g2sb_ctx1_g2hostfifo_u {
    struct {
        unsigned int hostfifodata:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2hostfifo_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2hostfifo_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2hostfifo_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hostfifodata:32", "", 32, old_value_t.hostfifodata, new_value_t.hostfifodata };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2VDDA_OFFSET 0x4011
#define G2SB_CTX1_G2VDDA_UNDEFMASK 0x00000000
union g2sb_ctx1_g2vdda_u {
    struct {
        unsigned int vdstep:32;             /* Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2vdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2vdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2vdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdstep:32",
              "Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010.",
              32, old_value_t.vdstep, new_value_t.vdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2VDDAINI_OFFSET 0x4012
#define G2SB_CTX1_G2VDDAINI_UNDEFMASK 0xFFFF0000
union g2sb_ctx1_g2vddaini_u {
    struct {
        unsigned int vdtini:8;              /* Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window. */
        unsigned int vdbini:8;              /* Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above) */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2vddaini_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2vddaini_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2vddaini_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdtini:8",
              "Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window.",
              8, old_value_t.vdtini, new_value_t.vdtini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: vdbini:8",
              "Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above)",
              8, old_value_t.vdbini, new_value_t.vdbini };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2HDDA_OFFSET 0x4013
#define G2SB_CTX1_G2HDDA_UNDEFMASK 0x00000000
union g2sb_ctx1_g2hdda_u {
    struct {
        unsigned int hdstep:32;             /* Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2hdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2hdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2hdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdstep:32",
              "Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101.",
              32, old_value_t.hdstep, new_value_t.hdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2HDDAINILS_OFFSET 0x4014
#define G2SB_CTX1_G2HDDAINILS_UNDEFMASK 0xFFFFFF00
union g2sb_ctx1_g2hddainils_u {
    struct {
        unsigned int hdini:8;               /* Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0. */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2hddainils_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2hddainils_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2hddainils_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdini:8",
              "Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0.",
              8, old_value_t.hdini, new_value_t.hdini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CSCFIRST_OFFSET 0x4015
#define G2SB_CTX1_G2CSCFIRST_UNDEFMASK 0x00C00C00
union g2sb_ctx1_g2cscfirst_u {
    struct {
        unsigned int cub:10;                /* multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved  */
        unsigned int undefined_bits_10_11:2;
        unsigned int cvr:10;                /* multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved */
        unsigned int undefined_bits_22_23:2;
        unsigned int yos:8;                 /* Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2cscfirst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2cscfirst_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2cscfirst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cub:10",
              "multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved",
              10, old_value_t.cub, new_value_t.cub };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_11:2", "", 2, old_value_t.undefined_bits_10_11, new_value_t.undefined_bits_10_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cvr:10",
              "multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved",
              10, old_value_t.cvr, new_value_t.cvr };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: yos:8",
              "Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10",
              8, old_value_t.yos, new_value_t.yos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CSCSECOND_OFFSET 0x4016
#define G2SB_CTX1_G2CSCSECOND_UNDEFMASK 0x00C00E00
union g2sb_ctx1_g2cscsecond_u {
    struct {
        unsigned int cug:9;                 /* multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved */
        unsigned int undefined_bits_9_11:3;
        unsigned int cur:10;                /* multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved  */
        unsigned int undefined_bits_22_23:2;
        unsigned int cyx:8;                 /* multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2cscsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2cscsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2cscsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cug:9",
              "multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved",
              9, old_value_t.cug, new_value_t.cug };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cur:10",
              "multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved",
              10, old_value_t.cur, new_value_t.cur };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cyx:8",
              "multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041",
              8, old_value_t.cyx, new_value_t.cyx };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CSCTHIRD_OFFSET 0x4017
#define G2SB_CTX1_G2CSCTHIRD_UNDEFMASK 0xFC00FE00
union g2sb_ctx1_g2cscthird_u {
    struct {
        unsigned int cvg:9;                 /* multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113 */
        unsigned int undefined_bits_9_15:7;
        unsigned int cvb:10;                /* multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021 */
        unsigned int undefined_bits_26_31:6;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2cscthird_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2cscthird_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2cscthird_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cvg:9",
              "multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113",
              9, old_value_t.cvg, new_value_t.cvg };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cvb:10",
              "multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021",
              10, old_value_t.cvb, new_value_t.cvb };
    m_bit_details_model.bits.append(entry);
    entry = { "26: undefined_bits_26_31:6", "", 6, old_value_t.undefined_bits_26_31, new_value_t.undefined_bits_26_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CMKEYL_OFFSET 0x4018
#define G2SB_CTX1_G2CMKEYL_UNDEFMASK 0xFF000000
union g2sb_ctx1_g2cmkeyl_u {
    struct {
        unsigned int ckbl:8;                /* B or Y Color/Chroma Key Lower Limit (CKBL[7:0]) */
        unsigned int ckgl:8;                /* G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level. */
        unsigned int ckrl:8;                /* R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2cmkeyl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2cmkeyl_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2cmkeyl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbl:8",
              "B or Y Color/Chroma Key Lower Limit (CKBL[7:0])",
              8, old_value_t.ckbl, new_value_t.ckbl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgl:8",
              "G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgl, new_value_t.ckgl };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckrl:8",
              "R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved",
              8, old_value_t.ckrl, new_value_t.ckrl };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CMKEYU_OFFSET 0x4019
#define G2SB_CTX1_G2CMKEYU_UNDEFMASK 0xFF000000
union g2sb_ctx1_g2cmkeyu_u {
    struct {
        unsigned int ckbu:8;                /* This is B or Y color/chroma key upper limit value. */
        unsigned int ckgu:8;                /* G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level. */
        unsigned int ckru:8;                /* R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2cmkeyu_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2cmkeyu_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2cmkeyu_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbu:8",
              "This is B or Y color/chroma key upper limit value.",
              8, old_value_t.ckbu, new_value_t.ckbu };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgu:8",
              "G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgu, new_value_t.ckgu };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckru:8",
              "R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved",
              8, old_value_t.ckru, new_value_t.ckru };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2UBA_A_OFFSET 0x401A
#define G2SB_CTX1_G2UBA_A_UNDEFMASK 0x00000000
union g2sb_ctx1_g2uba_a_u {
    struct {
        unsigned int su1sa:32;              /* Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2uba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2uba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2uba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: su1sa:32",
              "Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.su1sa, new_value_t.su1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2VBA_A_OFFSET 0x401B
#define G2SB_CTX1_G2VBA_A_UNDEFMASK 0x00000000
union g2sb_ctx1_g2vba_a_u {
    struct {
        unsigned int sv1sa:32;              /* Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2vba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2vba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2vba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sv1sa:32",
              "Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.sv1sa, new_value_t.sv1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2SBFORMAT_OFFSET 0x401C
#define G2SB_CTX1_G2SBFORMAT_UNDEFMASK 0x000020E0
union g2sb_ctx1_g2sbformat_u {
    struct {
        unsigned int sifmt:5;               /* This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV. */
        unsigned int undefined_bits_5_7:3;
        unsigned int difmt:5;               /* Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED */
        unsigned int undefined_bit_13:1;
        unsigned int raisebufferen:1;       /* ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.  */
        unsigned int raiseframeen:1;        /* ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.  */
        unsigned int raisebuffervalue:8;    /* Raise buffer vector value. */
        unsigned int raiseframevalue:8;     /* Raise Fram vector value. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2sbformat_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2sbformat_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2sbformat_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sifmt:5",
              "This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV.",
              5, old_value_t.sifmt, new_value_t.sifmt };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: difmt:5",
              "Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED",
              5, old_value_t.difmt, new_value_t.difmt };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: raisebufferen:1",
              "ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raisebufferen, new_value_t.raisebufferen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: raiseframeen:1",
              "ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raiseframeen, new_value_t.raiseframeen };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisebuffervalue:8",
              "Raise buffer vector value.",
              8, old_value_t.raisebuffervalue, new_value_t.raisebuffervalue };
    m_bit_details_model.bits.append(entry);
    entry = { "24: raiseframevalue:8",
              "Raise Fram vector value.",
              8, old_value_t.raiseframevalue, new_value_t.raiseframevalue };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CONTROLSB_OFFSET 0x401D
#define G2SB_CTX1_G2CONTROLSB_UNDEFMASK 0x20005807
union g2sb_ctx1_g2controlsb_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int yuv422rotation:1;      /* yuv422 plannar rotated */
        unsigned int yuv422planar:1;        /* source data is yuv422 planar valid when imode==PLANAR */
        unsigned int imode:1;               /* Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d. */
        unsigned int enavf:1;               /* enable alpha vertical filter     */
        unsigned int enahf:1;               /* enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format, */
        unsigned int uvst:2;                /*   00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.   11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride). */
        unsigned int sl:1;                  /* Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines. */
        unsigned int undefined_bits_11_12:2;
        unsigned int sisel:1;               /* StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved  */
        unsigned int undefined_bit_14:1;
        unsigned int sbltsrc:1;             /* StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator. */
        unsigned int vftype:2;              /* StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager. */
        unsigned int vfen:1;                /* StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled. */
        unsigned int discsc:1;              /* enabled color space converter by default */
        unsigned int hftype:3;              /* StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE. */
        unsigned int rangeredfrm:1;         /* In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.  */
        unsigned int sitype:1;              /* StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?. */
        unsigned int sbsel:1;               /* StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer. */
        unsigned int dbsel:1;               /* StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer. */
        unsigned int keyen:1;               /* Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled. */
        unsigned int kpol:1;                /* Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range. */
        unsigned int undefined_bit_29:1;
        unsigned int endith:1;              /* Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering */
        unsigned int disdw:1;               /* output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2controlsb_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2controlsb_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2controlsb_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_2:3", "", 3, old_value_t.undefined_bits_0_2, new_value_t.undefined_bits_0_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: yuv422rotation:1",
              "yuv422 plannar rotated",
              1, old_value_t.yuv422rotation, new_value_t.yuv422rotation };
    m_bit_details_model.bits.append(entry);
    entry = { "04: yuv422planar:1",
              "source data is yuv422 planar valid when imode==PLANAR",
              1, old_value_t.yuv422planar, new_value_t.yuv422planar };
    m_bit_details_model.bits.append(entry);
    entry = { "05: imode:1",
              "Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d.",
              1, old_value_t.imode, new_value_t.imode };
    m_bit_details_model.bits.append(entry);
    entry = { "06: enavf:1",
              "enable alpha vertical filter",
              1, old_value_t.enavf, new_value_t.enavf };
    m_bit_details_model.bits.append(entry);
    entry = { "07: enahf:1",
              "enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format,",
              1, old_value_t.enahf, new_value_t.enahf };
    m_bit_details_model.bits.append(entry);
    entry = { "08: uvst:2",
              " \n00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.\n11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride).",
              2, old_value_t.uvst, new_value_t.uvst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: sl:1",
              "Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines.",
              1, old_value_t.sl, new_value_t.sl };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_12:2", "", 2, old_value_t.undefined_bits_11_12, new_value_t.undefined_bits_11_12 };
    m_bit_details_model.bits.append(entry);
    entry = { "13: sisel:1",
              "StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved",
              1, old_value_t.sisel, new_value_t.sisel };
    m_bit_details_model.bits.append(entry);
    entry = { "14: undefined_bit_14:1", "", 1, old_value_t.undefined_bit_14, new_value_t.undefined_bit_14 };
    m_bit_details_model.bits.append(entry);
    entry = { "15: sbltsrc:1",
              "StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator.",
              1, old_value_t.sbltsrc, new_value_t.sbltsrc };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vftype:2",
              "StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager.",
              2, old_value_t.vftype, new_value_t.vftype };
    m_bit_details_model.bits.append(entry);
    entry = { "18: vfen:1",
              "StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled.",
              1, old_value_t.vfen, new_value_t.vfen };
    m_bit_details_model.bits.append(entry);
    entry = { "19: discsc:1",
              "enabled color space converter by default",
              1, old_value_t.discsc, new_value_t.discsc };
    m_bit_details_model.bits.append(entry);
    entry = { "20: hftype:3",
              "StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE.",
              3, old_value_t.hftype, new_value_t.hftype };
    m_bit_details_model.bits.append(entry);
    entry = { "23: rangeredfrm:1",
              "In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.",
              1, old_value_t.rangeredfrm, new_value_t.rangeredfrm };
    m_bit_details_model.bits.append(entry);
    entry = { "24: sitype:1",
              "StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?.",
              1, old_value_t.sitype, new_value_t.sitype };
    m_bit_details_model.bits.append(entry);
    entry = { "25: sbsel:1",
              "StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer.",
              1, old_value_t.sbsel, new_value_t.sbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "26: dbsel:1",
              "StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer.",
              1, old_value_t.dbsel, new_value_t.dbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "27: keyen:1",
              "Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled.",
              1, old_value_t.keyen, new_value_t.keyen };
    m_bit_details_model.bits.append(entry);
    entry = { "28: kpol:1",
              "Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range.",
              1, old_value_t.kpol, new_value_t.kpol };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: endith:1",
              "Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering",
              1, old_value_t.endith, new_value_t.endith };
    m_bit_details_model.bits.append(entry);
    entry = { "31: disdw:1",
              "output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place.",
              1, old_value_t.disdw, new_value_t.disdw };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CONTROLSECOND_OFFSET 0x401E
#define G2SB_CTX1_G2CONTROLSECOND_UNDEFMASK 0xC08E3C01
union g2sb_ctx1_g2controlsecond_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int bitswap:1;             /* Host port bit swap 1=enable   0= disable   1= enable */
        unsigned int bebswap:1;             /* Host port byte swap 1=enable   0= disable   1= enable */
        unsigned int bewswap:1;             /* Host port word swap 1=enable   0= disable */
        unsigned int alptype:5;             /* Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits. */
        unsigned int alpsrcordst:1;         /* 32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha */
        unsigned int undefined_bits_10_13:4;
        unsigned int pxlrep:1;              /* Pixel replication for Palm OS. */
        unsigned int swapblt:1;             /* Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area */
        unsigned int vcaa_safe_mode:1;      /* VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken. */
        unsigned int undefined_bits_17_19:3;
        unsigned int g2nostop:1;
        unsigned int clipc:2;               /* Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,  10=draw only inside clipping rectangle,  11=draw only outside clipping rectangle */
        unsigned int undefined_bit_23:1;
        unsigned int fr_mode:2;             /* Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice. 00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so! 01 = src/dst copy mode - two separate buffers 10 = square in place - one buffer 11 = blank */
        unsigned int fr_type:3;             /*  Fast Rotate type     000 = FLIP_X  001 = FLIP_Y  010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right) 011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left) 100 = ROT_90 (counter clock wise by 90 degrees) 101 = ROT_180  110 = ROT_270 (clock wise by 90 degrees) 111 = IDENTITY */
        unsigned int fr_readwait:1;         /*  Fast Rotate wait for read 0 = disable 1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only. */
        unsigned int undefined_bits_30_31:2;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2controlsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2controlsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2controlsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bit_0:1", "", 1, old_value_t.undefined_bit_0, new_value_t.undefined_bit_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "01: bitswap:1",
              "Host port bit swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bitswap, new_value_t.bitswap };
    m_bit_details_model.bits.append(entry);
    entry = { "02: bebswap:1",
              "Host port byte swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bebswap, new_value_t.bebswap };
    m_bit_details_model.bits.append(entry);
    entry = { "03: bewswap:1",
              "Host port word swap\n1=enable  \n0= disable",
              1, old_value_t.bewswap, new_value_t.bewswap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: alptype:5",
              "Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits.",
              5, old_value_t.alptype, new_value_t.alptype };
    m_bit_details_model.bits.append(entry);
    entry = { "09: alpsrcordst:1",
              "32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha",
              1, old_value_t.alpsrcordst, new_value_t.alpsrcordst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_13:4", "", 4, old_value_t.undefined_bits_10_13, new_value_t.undefined_bits_10_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: pxlrep:1",
              "Pixel replication for Palm OS.",
              1, old_value_t.pxlrep, new_value_t.pxlrep };
    m_bit_details_model.bits.append(entry);
    entry = { "15: swapblt:1",
              "Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area",
              1, old_value_t.swapblt, new_value_t.swapblt };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vcaa_safe_mode:1",
              "VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken.",
              1, old_value_t.vcaa_safe_mode, new_value_t.vcaa_safe_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: g2nostop:1", "", 1, old_value_t.g2nostop, new_value_t.g2nostop };
    m_bit_details_model.bits.append(entry);
    entry = { "21: clipc:2",
              "Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,\n10=draw only inside clipping rectangle,\n11=draw only outside clipping rectangle",
              2, old_value_t.clipc, new_value_t.clipc };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fr_mode:2",
              "Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice.\n00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so!\n01 = src/dst copy mode - two separate buffers\n10 = square in place - one buffer\n11 = blank",
              2, old_value_t.fr_mode, new_value_t.fr_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "26: fr_type:3",
              " Fast Rotate type    \n000 = FLIP_X \n001 = FLIP_Y \n010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right)\n011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left)\n100 = ROT_90 (counter clock wise by 90 degrees)\n101 = ROT_180 \n110 = ROT_270 (clock wise by 90 degrees)\n111 = IDENTITY",
              3, old_value_t.fr_type, new_value_t.fr_type };
    m_bit_details_model.bits.append(entry);
    entry = { "29: fr_readwait:1",
              " Fast Rotate wait for read\n0 = disable\n1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only.",
              1, old_value_t.fr_readwait, new_value_t.fr_readwait };
    m_bit_details_model.bits.append(entry);
    entry = { "30: undefined_bits_30_31:2", "", 2, old_value_t.undefined_bits_30_31, new_value_t.undefined_bits_30_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CONTROLMAIN_OFFSET 0x401F
#define G2SB_CTX1_G2CONTROLMAIN_UNDEFMASK 0x80000000
union g2sb_ctx1_g2controlmain_u {
    struct {
        unsigned int cmdt:2;                /* Command Type:  00=BitBlt 01=Line Draw  10=VCAA 11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed) */
        unsigned int turbofill:1;           /* fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified. */
        unsigned int test0bit:1;            /* Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish. */
        unsigned int faden:1;               /* BitBlt Source Copy Fade enable, 1=enable (share with mltln), only support  16bpp mode */
        unsigned int alpen:1;               /* BitBlt Alpha Blending, 1=enable. 0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype */
        unsigned int srcsld:1;              /* BitBlt Solid Source Color Fill: 1=enable. FGC will be used as  the color value. */
        unsigned int patsld:1;              /* BitBlt Solid Pattern Fill: 1=enable. BGC will be used as  the color value. */
        unsigned int patfl:1;               /* When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+ */
        unsigned int xdir:1;                /*  0=incrementing, 1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0 */
        unsigned int ydir:1;                /*  0=incrementing, 1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0 */
        unsigned int xytdw:1;               /* xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination. */
        unsigned int srcpack:1;             /* Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled. */
        unsigned int patpack:1;             /* Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled. */
        unsigned int yflip:1;               /* flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination. */
        unsigned int srcsel:1;              /* Source Data Select: */
        unsigned int dstcd:2;               /* Destination color depth:   00=8-bpp, 01=16-bpp, 10=32-bpp. 11=reserved */
        unsigned int dstt:2;                /* Destination read transparency enable:   0x=destination read transparency disabled   10=color destination read transparency   11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately, 0=wait for launch write) */
        unsigned int srccd:1;               /* 0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0 */
        unsigned int hlmono:1;              /* Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit */
        unsigned int srct:2;                /* Source transparency enable: 0x=source transparency disabled,  10=mono source background transparency     or color source transparency,  11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied. */
        unsigned int srcbas:1;              /* Source base address select:   0=srcba, 1=dstba. This is not used for Line Draw and  if source data comes from host memory. */
        unsigned int gcsw:2;                /* Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used */
        unsigned int srcdir:1;              /* source direct addressing */
        unsigned int dstdir:1;              /* destination direct addressing */
        unsigned int dst_rd_wr_sep:1;       /* This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA */
        unsigned int patsel:1;              /* pattern Data Select: SRCSEL and PATSEL can't be both enabled. */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2controlmain_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2controlmain_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2controlmain_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cmdt:2",
              "Command Type: \n00=BitBlt\n01=Line Draw \n10=VCAA\n11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed)",
              2, old_value_t.cmdt, new_value_t.cmdt };
    m_bit_details_model.bits.append(entry);
    entry = { "02: turbofill:1",
              "fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified.",
              1, old_value_t.turbofill, new_value_t.turbofill };
    m_bit_details_model.bits.append(entry);
    entry = { "03: test0bit:1",
              "Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish.",
              1, old_value_t.test0bit, new_value_t.test0bit };
    m_bit_details_model.bits.append(entry);
    entry = { "04: faden:1",
              "BitBlt Source Copy Fade enable,\n1=enable (share with mltln), only support  16bpp mode",
              1, old_value_t.faden, new_value_t.faden };
    m_bit_details_model.bits.append(entry);
    entry = { "05: alpen:1",
              "BitBlt Alpha Blending,\n1=enable.\n0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype",
              1, old_value_t.alpen, new_value_t.alpen };
    m_bit_details_model.bits.append(entry);
    entry = { "06: srcsld:1",
              "BitBlt Solid Source Color Fill:\n1=enable. FGC will be used as  the color value.",
              1, old_value_t.srcsld, new_value_t.srcsld };
    m_bit_details_model.bits.append(entry);
    entry = { "07: patsld:1",
              "BitBlt Solid Pattern Fill:\n1=enable. BGC will be used as  the color value.",
              1, old_value_t.patsld, new_value_t.patsld };
    m_bit_details_model.bits.append(entry);
    entry = { "08: patfl:1",
              "When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+",
              1, old_value_t.patfl, new_value_t.patfl };
    m_bit_details_model.bits.append(entry);
    entry = { "09: xdir:1",
              "0=incrementing,\n1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0",
              1, old_value_t.xdir, new_value_t.xdir };
    m_bit_details_model.bits.append(entry);
    entry = { "10: ydir:1",
              "0=incrementing,\n1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0",
              1, old_value_t.ydir, new_value_t.ydir };
    m_bit_details_model.bits.append(entry);
    entry = { "11: xytdw:1",
              "xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination.",
              1, old_value_t.xytdw, new_value_t.xytdw };
    m_bit_details_model.bits.append(entry);
    entry = { "12: srcpack:1",
              "Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.srcpack, new_value_t.srcpack };
    m_bit_details_model.bits.append(entry);
    entry = { "13: patpack:1",
              "Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.patpack, new_value_t.patpack };
    m_bit_details_model.bits.append(entry);
    entry = { "14: yflip:1",
              "flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination.",
              1, old_value_t.yflip, new_value_t.yflip };
    m_bit_details_model.bits.append(entry);
    entry = { "15: srcsel:1",
              "Source Data Select:",
              1, old_value_t.srcsel, new_value_t.srcsel };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstcd:2",
              "Destination color depth:  \n00=8-bpp,\n01=16-bpp,\n10=32-bpp.\n11=reserved",
              2, old_value_t.dstcd, new_value_t.dstcd };
    m_bit_details_model.bits.append(entry);
    entry = { "18: dstt:2",
              "Destination read transparency enable:   0x=destination read transparency disabled  \n10=color destination read transparency  \n11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately,\n0=wait for launch write)",
              2, old_value_t.dstt, new_value_t.dstt };
    m_bit_details_model.bits.append(entry);
    entry = { "20: srccd:1",
              "0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0",
              1, old_value_t.srccd, new_value_t.srccd };
    m_bit_details_model.bits.append(entry);
    entry = { "21: hlmono:1",
              "Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit",
              1, old_value_t.hlmono, new_value_t.hlmono };
    m_bit_details_model.bits.append(entry);
    entry = { "22: srct:2",
              "Source transparency enable: 0x=source transparency disabled,\n10=mono source background transparency     or color source transparency,\n11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied.",
              2, old_value_t.srct, new_value_t.srct };
    m_bit_details_model.bits.append(entry);
    entry = { "24: srcbas:1",
              "Source base address select:  \n0=srcba,\n1=dstba. This is not used for Line Draw and  if source data comes from host memory.",
              1, old_value_t.srcbas, new_value_t.srcbas };
    m_bit_details_model.bits.append(entry);
    entry = { "25: gcsw:2",
              "Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used",
              2, old_value_t.gcsw, new_value_t.gcsw };
    m_bit_details_model.bits.append(entry);
    entry = { "27: srcdir:1",
              "source direct addressing",
              1, old_value_t.srcdir, new_value_t.srcdir };
    m_bit_details_model.bits.append(entry);
    entry = { "28: dstdir:1",
              "destination direct addressing",
              1, old_value_t.dstdir, new_value_t.dstdir };
    m_bit_details_model.bits.append(entry);
    entry = { "29: dst_rd_wr_sep:1",
              "This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA",
              1, old_value_t.dst_rd_wr_sep, new_value_t.dst_rd_wr_sep };
    m_bit_details_model.bits.append(entry);
    entry = { "30: patsel:1",
              "pattern Data Select: SRCSEL and PATSEL can't be both enabled.",
              1, old_value_t.patsel, new_value_t.patsel };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2ROPFADE_OFFSET 0x4020
#define G2SB_CTX1_G2ROPFADE_UNDEFMASK 0x0000FF00
union g2sb_ctx1_g2ropfade_u {
    struct {
        unsigned int rop:8;                 /* If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out. */
        unsigned int undefined_bits_8_15:8;
        unsigned int fadcoe:8;
        unsigned int fadoff:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2ropfade_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2ropfade_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2ropfade_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: rop:8",
              "If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out.",
              8, old_value_t.rop, new_value_t.rop };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: fadcoe:8", "", 8, old_value_t.fadcoe, new_value_t.fadcoe };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fadoff:8", "", 8, old_value_t.fadoff, new_value_t.fadoff };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2ALPHABLEND_OFFSET 0x4021
#define G2SB_CTX1_G2ALPHABLEND_UNDEFMASK 0x0000FE00
union g2sb_ctx1_g2alphablend_u {
    struct {
        unsigned int alpha:8;
        unsigned int alphainv:1;
        unsigned int undefined_bits_9_15:7;
        unsigned int alpha0v:8;
        unsigned int alpha1v:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2alphablend_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2alphablend_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2alphablend_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: alpha:8", "", 8, old_value_t.alpha, new_value_t.alpha };
    m_bit_details_model.bits.append(entry);
    entry = { "08: alphainv:1", "", 1, old_value_t.alphainv, new_value_t.alphainv };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: alpha0v:8", "", 8, old_value_t.alpha0v, new_value_t.alpha0v };
    m_bit_details_model.bits.append(entry);
    entry = { "24: alpha1v:8", "", 8, old_value_t.alpha1v, new_value_t.alpha1v };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CLIPLEFTTOP_OFFSET 0x4022
#define G2SB_CTX1_G2CLIPLEFTTOP_UNDEFMASK 0x80008000
union g2sb_ctx1_g2cliplefttop_u {
    struct {
        unsigned int clipl:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipt:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2cliplefttop_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2cliplefttop_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2cliplefttop_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipl:15", "", 15, old_value_t.clipl, new_value_t.clipl };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipt:15", "", 15, old_value_t.clipt, new_value_t.clipt };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CLIPRIGHTBOT_OFFSET 0x4023
#define G2SB_CTX1_G2CLIPRIGHTBOT_UNDEFMASK 0x80008000
union g2sb_ctx1_g2cliprightbot_u {
    struct {
        unsigned int clipr:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipb:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2cliprightbot_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2cliprightbot_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2cliprightbot_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipr:15", "", 15, old_value_t.clipr, new_value_t.clipr };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipb:15", "", 15, old_value_t.clipb, new_value_t.clipb };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2PATPACK_OFFSET 0x4024
#define G2SB_CTX1_G2PATPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx1_g2patpack_u {
    struct {
        unsigned int patlngap:4;            /* Packed mode, pattern data line gap. byte */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2patpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2patpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2patpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patlngap:4",
              "Packed mode, pattern data line gap. byte",
              4, old_value_t.patlngap, new_value_t.patlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2PATPACK_SIZE_OFFSET 0x4025
#define G2SB_CTX1_G2PATPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx1_g2patpack_size_u {
    struct {
        unsigned int patmonow:16;           /* Mono data width in packed mode, byte  */
        unsigned int patmonoh:16;           /*  Pattern mono data height in packed mode, byte  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2patpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2patpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2patpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patmonow:16",
              "Mono data width in packed mode, byte",
              16, old_value_t.patmonow, new_value_t.patmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patmonoh:16",
              " Pattern mono data height in packed mode, byte",
              16, old_value_t.patmonoh, new_value_t.patmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2PATBA_OFFSET 0x4026
#define G2SB_CTX1_G2PATBA_UNDEFMASK 0x00000000
union g2sb_ctx1_g2patba_u {
    struct {
        unsigned int patba:32;              /* If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. } */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2patba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2patba_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2patba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patba:32",
              "If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. }",
              32, old_value_t.patba, new_value_t.patba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2PATOS_OFFSET 0x4027
#define G2SB_CTX1_G2PATOS_UNDEFMASK 0x009E0000
union g2sb_ctx1_g2patos_u {
    struct {
        unsigned int patst:16;              /* stride */
        unsigned int patcd:1;               /* 0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0 */
        unsigned int undefined_bits_17_20:4;
        unsigned int patt:2;                /* Mono pattern transparency enable:  0x=pattern transparency disabled,  10=mono pattern background transparency    or color pattern transparency,  11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied. */
        unsigned int undefined_bit_23:1;
        unsigned int patxo:4;               /* x offset for mono tile pattern fill.  see PATFL */
        unsigned int patyo:4;               /* y offset for mono tile pattern fill.  see PATFL */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2patos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2patos_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2patos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patst:16",
              "stride",
              16, old_value_t.patst, new_value_t.patst };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patcd:1",
              "0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0",
              1, old_value_t.patcd, new_value_t.patcd };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_20:4", "", 4, old_value_t.undefined_bits_17_20, new_value_t.undefined_bits_17_20 };
    m_bit_details_model.bits.append(entry);
    entry = { "21: patt:2",
              "Mono pattern transparency enable:  0x=pattern transparency disabled,\n10=mono pattern background transparency    or color pattern transparency,\n11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied.",
              2, old_value_t.patt, new_value_t.patt };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: patxo:4",
              "x offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patxo, new_value_t.patxo };
    m_bit_details_model.bits.append(entry);
    entry = { "28: patyo:4",
              "y offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patyo, new_value_t.patyo };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2PATBGC_OFFSET 0x4028
#define G2SB_CTX1_G2PATBGC_UNDEFMASK 0x00000000
union g2sb_ctx1_g2patbgc_u {
    struct {
        unsigned int patbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2patbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2patbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2patbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patbgc:32", "", 32, old_value_t.patbgc, new_value_t.patbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2PATFGC_OFFSET 0x4029
#define G2SB_CTX1_G2PATFGC_UNDEFMASK 0x00000000
union g2sb_ctx1_g2patfgc_u {
    struct {
        unsigned int patfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2patfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2patfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2patfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patfgc:32", "", 32, old_value_t.patfgc, new_value_t.patfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2PATKEY_OFFSET 0x402A
#define G2SB_CTX1_G2PATKEY_UNDEFMASK 0x00000000
union g2sb_ctx1_g2patkey_u {
    struct {
        unsigned int patkey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2patkey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2patkey_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2patkey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patkey:32", "", 32, old_value_t.patkey, new_value_t.patkey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2DSTBA_OFFSET 0x402B
#define G2SB_CTX1_G2DSTBA_UNDEFMASK 0x00000000
union g2sb_ctx1_g2dstba_u {
    struct {
        unsigned int dstba:32;              /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2dstba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2dstba_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2dstba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba, new_value_t.dstba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2DSTBA_B_OFFSET 0x402C
#define G2SB_CTX1_G2DSTBA_B_UNDEFMASK 0x00000000
union g2sb_ctx1_g2dstba_b_u {
    struct {
        unsigned int dstba_b:32;            /* Destination base address (byte address) only usable in hardware trigger mode by enable gcsw */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2dstba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2dstba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2dstba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_b:32",
              "Destination base address (byte address) only usable in hardware trigger mode by enable gcsw",
              32, old_value_t.dstba_b, new_value_t.dstba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2DSTBA_C_OFFSET 0x402D
#define G2SB_CTX1_G2DSTBA_C_UNDEFMASK 0x00000000
union g2sb_ctx1_g2dstba_c_u {
    struct {
        unsigned int dstba_c:32;            /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2dstba_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2dstba_c_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2dstba_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_c:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba_c, new_value_t.dstba_c };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2DSTST_OFFSET 0x402E
#define G2SB_CTX1_G2DSTST_UNDEFMASK 0xFFFF0000
union g2sb_ctx1_g2dstst_u {
    struct {
        unsigned int dsts:16;               /* Destination Stride coordinate(bytes) with respect to DSTBA. */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2dstst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2dstst_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2dstst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dsts:16",
              "Destination Stride coordinate(bytes) with respect to DSTBA.",
              16, old_value_t.dsts, new_value_t.dsts };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2SRCPACK_OFFSET 0x402F
#define G2SB_CTX1_G2SRCPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx1_g2srcpack_u {
    struct {
        unsigned int srclngap:4;            /* Packed mode - source mono data line gap */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2srcpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2srcpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2srcpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srclngap:4",
              "Packed mode - source mono data line gap",
              4, old_value_t.srclngap, new_value_t.srclngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2SRCPACK_SIZE_OFFSET 0x4030
#define G2SB_CTX1_G2SRCPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx1_g2srcpack_size_u {
    struct {
        unsigned int srcmonow:16;           /* Packed mode - source mono data width in bytes */
        unsigned int srcmonoh:16;           /* Packed mode - source mono data height in bytes  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2srcpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2srcpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2srcpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcmonow:16",
              "Packed mode - source mono data width in bytes",
              16, old_value_t.srcmonow, new_value_t.srcmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcmonoh:16",
              "Packed mode - source mono data height in bytes",
              16, old_value_t.srcmonoh, new_value_t.srcmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2SRCBA_OFFSET 0x4031
#define G2SB_CTX1_G2SRCBA_UNDEFMASK 0x00000000
union g2sb_ctx1_g2srcba_u {
    struct {
        unsigned int srcba:32;              /* Source base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2srcba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2srcba_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2srcba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba:32",
              "Source base address (byte address)",
              32, old_value_t.srcba, new_value_t.srcba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2SRCBA_B_OFFSET 0x4032
#define G2SB_CTX1_G2SRCBA_B_UNDEFMASK 0x00000000
union g2sb_ctx1_g2srcba_b_u {
    struct {
        unsigned int srcba_b:32;            /* This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.) */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2srcba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2srcba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2srcba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba_b:32",
              "This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.)",
              32, old_value_t.srcba_b, new_value_t.srcba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2SRCST_OFFSET 0x4033
#define G2SB_CTX1_G2SRCST_UNDEFMASK 0xFFFF0000
union g2sb_ctx1_g2srcst_u {
    struct {
        unsigned int srcs:16;               /* Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.  */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2srcst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2srcst_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2srcst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs:16",
              "Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.",
              16, old_value_t.srcs, new_value_t.srcs };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2SRCBGC_OFFSET 0x4034
#define G2SB_CTX1_G2SRCBGC_UNDEFMASK 0x00000000
union g2sb_ctx1_g2srcbgc_u {
    struct {
        unsigned int srcbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2srcbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2srcbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2srcbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcbgc:32", "", 32, old_value_t.srcbgc, new_value_t.srcbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2SRCFGC_OFFSET 0x4035
#define G2SB_CTX1_G2SRCFGC_UNDEFMASK 0x00000000
union g2sb_ctx1_g2srcfgc_u {
    struct {
        unsigned int srcfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2srcfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2srcfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2srcfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcfgc:32", "", 32, old_value_t.srcfgc, new_value_t.srcfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2SRCKEY_OFFSET 0x4036
#define G2SB_CTX1_G2SRCKEY_UNDEFMASK 0x00000000
union g2sb_ctx1_g2srckey_u {
    struct {
        unsigned int srckey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2srckey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2srckey_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2srckey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srckey:32", "", 32, old_value_t.srckey, new_value_t.srckey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2SRCSIZE_OFFSET 0x4037
#define G2SB_CTX1_G2SRCSIZE_UNDEFMASK 0x80008000
union g2sb_ctx1_g2srcsize_u {
    struct {
        unsigned int srcwidth:15;
        unsigned int undefined_bit_15:1;
        unsigned int srcheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2srcsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2srcsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2srcsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcwidth:15", "", 15, old_value_t.srcwidth, new_value_t.srcwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.srcheight, new_value_t.srcheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2DSTSIZE_OFFSET 0x4038
#define G2SB_CTX1_G2DSTSIZE_UNDEFMASK 0x80008000
union g2sb_ctx1_g2dstsize_u {
    struct {
        unsigned int dstwidth:15;           /* In 2D mode, the largest number can be programmed is 0x7fef */
        unsigned int undefined_bit_15:1;
        unsigned int dstheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2dstsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2dstsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2dstsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstwidth:15",
              "In 2D mode, the largest number can be programmed is 0x7fef",
              15, old_value_t.dstwidth, new_value_t.dstwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.dstheight, new_value_t.dstheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2SRCPS_OFFSET 0x4039
#define G2SB_CTX1_G2SRCPS_UNDEFMASK 0x00000000
union g2sb_ctx1_g2srcps_u {
    struct {
        unsigned int srcx:16;               /* SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY   */
        unsigned int srcy:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2srcps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2srcps_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2srcps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcx:16",
              "SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY",
              16, old_value_t.srcx, new_value_t.srcx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcy:16", "", 16, old_value_t.srcy, new_value_t.srcy };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2DSTPS_OFFSET 0x403A
#define G2SB_CTX1_G2DSTPS_UNDEFMASK 0x00000000
union g2sb_ctx1_g2dstps_u {
    struct {
        unsigned int dstx:16;               /* NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 */
        unsigned int dsty:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2dstps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2dstps_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2dstps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstx:16",
              "NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489",
              16, old_value_t.dstx, new_value_t.dstx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dsty:16", "", 16, old_value_t.dsty, new_value_t.dsty };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CBDES_OFFSET 0x403B
#define G2SB_CTX1_G2CBDES_UNDEFMASK 0x0000FF00
union g2sb_ctx1_g2cbdes_u {
    struct {
        unsigned int cbcount:8;             /* This specifies the number of buffers incircular buffer feature                    */
        unsigned int undefined_bits_8_15:8;
        unsigned int cbline:15;             /* vertical line number in one buffer */
        unsigned int topclip:1;             /* top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2 0= disable  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2cbdes_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2cbdes_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2cbdes_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbcount:8",
              "This specifies the number of buffers incircular buffer feature",
              8, old_value_t.cbcount, new_value_t.cbcount };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbline:15",
              "vertical line number in one buffer",
              15, old_value_t.cbline, new_value_t.cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "31: topclip:1",
              "top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2\n0= disable",
              1, old_value_t.topclip, new_value_t.topclip };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CBSTRIDE_OFFSET 0x403C
#define G2SB_CTX1_G2CBSTRIDE_UNDEFMASK 0x3F000000
union g2sb_ctx1_g2cbstride_u {
    struct {
        unsigned int cbstride:24;           /* Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes) */
        unsigned int undefined_bits_24_29:6;
        unsigned int cbuvstride:2;          /* Chroma Buffer Stride default is half of luma   00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2cbstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2cbstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2cbstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbstride:24",
              "Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes)",
              24, old_value_t.cbstride, new_value_t.cbstride };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_29:6", "", 6, old_value_t.undefined_bits_24_29, new_value_t.undefined_bits_24_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: cbuvstride:2",
              "Chroma Buffer Stride default is half of luma  \n00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved",
              2, old_value_t.cbuvstride, new_value_t.cbuvstride };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2LINESETTING_OFFSET 0x403D
#define G2SB_CTX1_G2LINESETTING_UNDEFMASK 0x00E00000
union g2sb_ctx1_g2linesetting_u {
    struct {
        unsigned int gamma:21;
        unsigned int undefined_bits_21_23:3;
        unsigned int major:1;               /* 0:xmajor 1: y major */
        unsigned int linexdir:1;
        unsigned int lineydir:1;
        unsigned int droplastp:1;           /* draw last pixel or not */
        unsigned int lineuseoctant:1;       /* use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR */
        unsigned int octants:3;             /* 000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2linesetting_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2linesetting_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2linesetting_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: gamma:21", "", 21, old_value_t.gamma, new_value_t.gamma };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_23:3", "", 3, old_value_t.undefined_bits_21_23, new_value_t.undefined_bits_21_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: major:1",
              "0:xmajor 1: y major",
              1, old_value_t.major, new_value_t.major };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linexdir:1", "", 1, old_value_t.linexdir, new_value_t.linexdir };
    m_bit_details_model.bits.append(entry);
    entry = { "26: lineydir:1", "", 1, old_value_t.lineydir, new_value_t.lineydir };
    m_bit_details_model.bits.append(entry);
    entry = { "27: droplastp:1",
              "draw last pixel or not",
              1, old_value_t.droplastp, new_value_t.droplastp };
    m_bit_details_model.bits.append(entry);
    entry = { "28: lineuseoctant:1",
              "use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR",
              1, old_value_t.lineuseoctant, new_value_t.lineuseoctant };
    m_bit_details_model.bits.append(entry);
    entry = { "29: octants:3",
              "000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7",
              3, old_value_t.octants, new_value_t.octants };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2LINEDELTAN_OFFSET 0x403E
#define G2SB_CTX1_G2LINEDELTAN_UNDEFMASK 0xFFE00000
union g2sb_ctx1_g2linedeltan_u {
    struct {
        unsigned int deltan:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2linedeltan_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2linedeltan_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2linedeltan_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltan:21", "", 21, old_value_t.deltan, new_value_t.deltan };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2LINEDELTAM_OFFSET 0x403F
#define G2SB_CTX1_G2LINEDELTAM_UNDEFMASK 0xFFE00000
union g2sb_ctx1_g2linedeltam_u {
    struct {
        unsigned int deltam:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2linedeltam_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2linedeltam_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2linedeltam_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltam:21", "", 21, old_value_t.deltam, new_value_t.deltam };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2LINEPOS_OFFSET 0x4040
#define G2SB_CTX1_G2LINEPOS_UNDEFMASK 0x00000000
union g2sb_ctx1_g2linepos_u {
    struct {
        unsigned int linexpos:16;
        unsigned int lineypos:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2linepos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2linepos_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2linepos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linexpos:16", "", 16, old_value_t.linexpos, new_value_t.linexpos };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lineypos:16", "", 16, old_value_t.lineypos, new_value_t.lineypos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2LINELEN_OFFSET 0x4041
#define G2SB_CTX1_G2LINELEN_UNDEFMASK 0xFFFF8000
union g2sb_ctx1_g2linelen_u {
    struct {
        unsigned int linelen:15;
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2linelen_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2linelen_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2linelen_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linelen:15", "", 15, old_value_t.linelen, new_value_t.linelen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CSCFOURTH_OFFSET 0x4042
#define G2SB_CTX1_G2CSCFOURTH_UNDEFMASK 0xFE00FE00
union g2sb_ctx1_g2cscfourth_u {
    struct {
        unsigned int g2u:9;                 /* multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored */
        unsigned int undefined_bits_9_15:7;
        unsigned int g2v:9;                 /* multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored */
        unsigned int undefined_bits_25_31:7;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2cscfourth_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2cscfourth_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2cscfourth_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: g2u:9",
              "multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored",
              9, old_value_t.g2u, new_value_t.g2u };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: g2v:9",
              "multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored",
              9, old_value_t.g2v, new_value_t.g2v };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bits_25_31:7", "", 7, old_value_t.undefined_bits_25_31, new_value_t.undefined_bits_25_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2SRCST_B_OFFSET 0x4043
#define G2SB_CTX1_G2SRCST_B_UNDEFMASK 0xFFFF0000
union g2sb_ctx1_g2srcst_b_u {
    struct {
        unsigned int srcs_b:16;             /* Source Stride B */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2srcst_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2srcst_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2srcst_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs_b:16",
              "Source Stride B",
              16, old_value_t.srcs_b, new_value_t.srcs_b };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2UVSTRIDE_OFFSET 0x4044
#define G2SB_CTX1_G2UVSTRIDE_UNDEFMASK 0xFFFF0000
union g2sb_ctx1_g2uvstride_u {
    struct {
        unsigned int uvstride:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2uvstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2uvstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2uvstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: uvstride:16", "", 16, old_value_t.uvstride, new_value_t.uvstride };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2CBDES2_OFFSET 0x4045
#define G2SB_CTX1_G2CBDES2_UNDEFMASK 0xFFFF8000
union g2sb_ctx1_g2cbdes2_u {
    struct {
        unsigned int top_cbline:15;         /* Circular buffer top clipping enabled, the first buffer line num */
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2cbdes2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2cbdes2_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2cbdes2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: top_cbline:15",
              "Circular buffer top clipping enabled, the first buffer line num",
              15, old_value_t.top_cbline, new_value_t.top_cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2TILEMODE_OFFSET 0x4046
#define G2SB_CTX1_G2TILEMODE_UNDEFMASK 0xFFEEEEEE
union g2sb_ctx1_g2tilemode_u {
    struct {
        unsigned int src_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_1_3:3;
        unsigned int src_uv_tile_mode:1;    /* UV surface, ignored in RGB mode */
        unsigned int undefined_bits_5_7:3;
        unsigned int pat_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_9_11:3;
        unsigned int pat_uv_tile_mode:1;    /* UNUSED */
        unsigned int undefined_bits_13_15:3;
        unsigned int dst_rd_tile_mode:1;    /* Same as destination write unless DST_RD_WR_SEP (not supported) */
        unsigned int undefined_bits_17_19:3;
        unsigned int dst_wr_tile_mode:1;    /* destination surface */
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2tilemode_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2tilemode_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2tilemode_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.src_y_tile_mode, new_value_t.src_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: src_uv_tile_mode:1",
              "UV surface, ignored in RGB mode",
              1, old_value_t.src_uv_tile_mode, new_value_t.src_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: pat_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.pat_y_tile_mode, new_value_t.pat_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: pat_uv_tile_mode:1",
              "UNUSED",
              1, old_value_t.pat_uv_tile_mode, new_value_t.pat_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dst_rd_tile_mode:1",
              "Same as destination write unless DST_RD_WR_SEP (not supported)",
              1, old_value_t.dst_rd_tile_mode, new_value_t.dst_rd_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: dst_wr_tile_mode:1",
              "destination surface",
              1, old_value_t.dst_wr_tile_mode, new_value_t.dst_wr_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2PATBASE_OFFSET 0x4047
#define G2SB_CTX1_G2PATBASE_UNDEFMASK 0x00000000
union g2sb_ctx1_g2patbase_u {
    struct {
        unsigned int pat_base:32;           /* pattern base address in tile mode,  PATBA is the linear address where pixel start */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2patbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2patbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2patbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pat_base:32",
              "pattern base address in tile mode,  PATBA is the linear address where pixel start",
              32, old_value_t.pat_base, new_value_t.pat_base };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2SRCBA_SB_SURFBASE_OFFSET 0x4048
#define G2SB_CTX1_G2SRCBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx1_g2srcba_sb_surfbase_u {
    struct {
        unsigned int src_addr:32;           /* surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2srcba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2srcba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2srcba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_addr:32",
              "surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine",
              32, old_value_t.src_addr, new_value_t.src_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2DSTBA_SB_SURFBASE_OFFSET 0x4049
#define G2SB_CTX1_G2DSTBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx1_g2dstba_sb_surfbase_u {
    struct {
        unsigned int dst_addr:32;           /* surface address corresponding to G2DSTBA Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2dstba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2dstba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2dstba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_addr:32",
              "surface address corresponding to G2DSTBA Only used by the StretchBlit Engine",
              32, old_value_t.dst_addr, new_value_t.dst_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2DSTBA_B_SB_SURFBASE_OFFSET 0x404A
#define G2SB_CTX1_G2DSTBA_B_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx1_g2dstba_b_sb_surfbase_u {
    struct {
        unsigned int dst_b_addr:32;         /* surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2dstba_b_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2dstba_b_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2dstba_b_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_b_addr:32",
              "surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled",
              32, old_value_t.dst_b_addr, new_value_t.dst_b_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2VBA_A_SB_SURFBASE_OFFSET 0x404B
#define G2SB_CTX1_G2VBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx1_g2vba_a_sb_surfbase_u {
    struct {
        unsigned int v_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2vba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2vba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2vba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine",
              32, old_value_t.v_addr, new_value_t.v_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX1_G2UBA_A_SB_SURFBASE_OFFSET 0x404C
#define G2SB_CTX1_G2UBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx1_g2uba_a_sb_surfbase_u {
    struct {
        unsigned int u_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx1_g2uba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx1_g2uba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx1_g2uba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: u_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine",
              32, old_value_t.u_addr, new_value_t.u_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_INCR_SYNCPT_OFFSET 0x8000
#define G2SB_CTX2_INCR_SYNCPT_UNDEFMASK 0xFFFF0000
union g2sb_ctx2_incr_syncpt_u {
    struct {
        unsigned int indx:8;                /* syncpt index value */
        unsigned int cond:8;                /* Condition mapped from raise/wait */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_incr_syncpt_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_incr_syncpt_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_incr_syncpt_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: indx:8",
              "syncpt index value",
              8, old_value_t.indx, new_value_t.indx };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cond:8",
              "Condition mapped from raise/wait",
              8, old_value_t.cond, new_value_t.cond };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_INCR_SYNCPT_CNTRL_OFFSET 0x8001
#define G2SB_CTX2_INCR_SYNCPT_CNTRL_UNDEFMASK 0xFFFFFEFE
union g2sb_ctx2_incr_syncpt_cntrl_u {
    struct {
        unsigned int incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs. */
        unsigned int undefined_bits_1_7:7;
        unsigned int incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled. */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_incr_syncpt_cntrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_incr_syncpt_cntrl_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_incr_syncpt_cntrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: incr_syncpt_soft_reset:1",
              "If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs.",
              1, old_value_t.incr_syncpt_soft_reset, new_value_t.incr_syncpt_soft_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: incr_syncpt_no_stall:1",
              "If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled.",
              1, old_value_t.incr_syncpt_no_stall, new_value_t.incr_syncpt_no_stall };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_INCR_SYNCPT_ERROR_OFFSET 0x8002
#define G2SB_CTX2_INCR_SYNCPT_ERROR_UNDEFMASK 0x00000000
union g2sb_ctx2_incr_syncpt_error_u {
    struct {
        unsigned int cond_status:32;        /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_incr_syncpt_error_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_incr_syncpt_error_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_incr_syncpt_error_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cond_status:32",
              "COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero",
              32, old_value_t.cond_status, new_value_t.cond_status };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CLASSCHANNEL_REGONLY_OFFSET 0x8008
#define G2SB_CTX2_G2CLASSCHANNEL_REGONLY_UNDEFMASK 0xFFE0FC00
union g2sb_ctx2_g2classchannel_regonly_u {
    struct {
        unsigned int curr_class:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int curr_channel:4;
        unsigned int ctx_valid:1;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2classchannel_regonly_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2classchannel_regonly_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2classchannel_regonly_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: curr_class:10", "", 10, old_value_t.curr_class, new_value_t.curr_class };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_15:6", "", 6, old_value_t.undefined_bits_10_15, new_value_t.undefined_bits_10_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: curr_channel:4", "", 4, old_value_t.curr_channel, new_value_t.curr_channel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ctx_valid:1", "", 1, old_value_t.ctx_valid, new_value_t.ctx_valid };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2TRIGGER_OFFSET 0x8009
#define G2SB_CTX2_G2TRIGGER_UNDEFMASK 0xFFFF0000
union g2sb_ctx2_g2trigger_u {
    struct {
        unsigned int trigger:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2trigger_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2trigger_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2trigger_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger:16", "", 16, old_value_t.trigger, new_value_t.trigger };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2TRIGGER1_OFFSET 0x800A
#define G2SB_CTX2_G2TRIGGER1_UNDEFMASK 0xFFFF0000
union g2sb_ctx2_g2trigger1_u {
    struct {
        unsigned int trigger1:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2trigger1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2trigger1_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2trigger1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger1:16", "", 16, old_value_t.trigger1, new_value_t.trigger1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2TRIGGER2_OFFSET 0x800B
#define G2SB_CTX2_G2TRIGGER2_UNDEFMASK 0xFFFF0000
union g2sb_ctx2_g2trigger2_u {
    struct {
        unsigned int trigger2:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2trigger2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2trigger2_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2trigger2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger2:16", "", 16, old_value_t.trigger2, new_value_t.trigger2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CMDSEL_OFFSET 0x800C
#define G2SB_CTX2_G2CMDSEL_UNDEFMASK 0xE000280E
union g2sb_ctx2_g2cmdsel_u {
    struct {
        unsigned int sbor2d:1;
        unsigned int undefined_bits_1_3:3;
        unsigned int cbenable:1;            /* circular buffer feature enable    0= disable */
        unsigned int vitrigger:1;           /* VI trigger enable, can be circular buffer or full frame */
        unsigned int hosttrigger:1;         /* host trigger the command, host also need program cicular buffer related data */
        unsigned int cbsbdisable:1;
        unsigned int g2output:2;            /* 00: to memory 01: to EPP */
        unsigned int clip_source_top_bottom:1;/* Reserved for HW Test, SW should not use this bit. */
        unsigned int undefined_bit_11:1;
        unsigned int link_wait_buf_end:1;
        unsigned int undefined_bit_13:1;
        unsigned int frame_start:1;         /* host writes this bit to tell which buffer is ready */
        unsigned int frame_end:1;
        unsigned int buffer_index:8;
        unsigned int linken:1;              /* Test purpose */
        unsigned int linkval:3;
        unsigned int priority:1;            /* indicates priority of the context, note vi-triggered contexts take priority over HIGH */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2cmdsel_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2cmdsel_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2cmdsel_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sbor2d:1", "", 1, old_value_t.sbor2d, new_value_t.sbor2d };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: cbenable:1",
              "circular buffer feature enable   \n0= disable",
              1, old_value_t.cbenable, new_value_t.cbenable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: vitrigger:1",
              "VI trigger enable, can be circular buffer or full frame",
              1, old_value_t.vitrigger, new_value_t.vitrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "06: hosttrigger:1",
              "host trigger the command, host also need program cicular buffer related data",
              1, old_value_t.hosttrigger, new_value_t.hosttrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "07: cbsbdisable:1", "", 1, old_value_t.cbsbdisable, new_value_t.cbsbdisable };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g2output:2",
              "00: to memory 01: to EPP",
              2, old_value_t.g2output, new_value_t.g2output };
    m_bit_details_model.bits.append(entry);
    entry = { "10: clip_source_top_bottom:1",
              "Reserved for HW Test, SW should not use this bit.",
              1, old_value_t.clip_source_top_bottom, new_value_t.clip_source_top_bottom };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: link_wait_buf_end:1", "", 1, old_value_t.link_wait_buf_end, new_value_t.link_wait_buf_end };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: frame_start:1",
              "host writes this bit to tell which buffer is ready",
              1, old_value_t.frame_start, new_value_t.frame_start };
    m_bit_details_model.bits.append(entry);
    entry = { "15: frame_end:1", "", 1, old_value_t.frame_end, new_value_t.frame_end };
    m_bit_details_model.bits.append(entry);
    entry = { "16: buffer_index:8", "", 8, old_value_t.buffer_index, new_value_t.buffer_index };
    m_bit_details_model.bits.append(entry);
    entry = { "24: linken:1",
              "Test purpose",
              1, old_value_t.linken, new_value_t.linken };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linkval:3", "", 3, old_value_t.linkval, new_value_t.linkval };
    m_bit_details_model.bits.append(entry);
    entry = { "28: priority:1",
              "indicates priority of the context, note vi-triggered contexts take priority over HIGH",
              1, old_value_t.priority, new_value_t.priority };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2RAISE_OFFSET 0x800D
#define G2SB_CTX2_G2RAISE_UNDEFMASK 0xFFF0FFE0
union g2sb_ctx2_g2raise_u {
    struct {
        unsigned int raise:5;               /* Push back to read fifo when all commands in the channel are done.           */
        unsigned int undefined_bits_5_15:11;
        unsigned int raisechannel:4;
        unsigned int undefined_bits_20_31:12;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2raise_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2raise_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2raise_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: raise:5",
              "Push back to read fifo when all commands in the channel are done.",
              5, old_value_t.raise, new_value_t.raise };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_15:11", "", 11, old_value_t.undefined_bits_5_15, new_value_t.undefined_bits_5_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisechannel:4", "", 4, old_value_t.raisechannel, new_value_t.raisechannel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_31:12", "", 12, old_value_t.undefined_bits_20_31, new_value_t.undefined_bits_20_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2HOSTSET_OFFSET 0x800F
#define G2SB_CTX2_G2HOSTSET_UNDEFMASK 0xFFFFFF00
union g2sb_ctx2_g2hostset_u {
    struct {
        unsigned int hstlngap:4;            /*  specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte) */
        unsigned int hstfpxl:4;             /* specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2hostset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2hostset_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2hostset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hstlngap:4",
              " specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte)",
              4, old_value_t.hstlngap, new_value_t.hstlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: hstfpxl:4",
              "specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary",
              4, old_value_t.hstfpxl, new_value_t.hstfpxl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2HOSTFIFO_OFFSET 0x8010
#define G2SB_CTX2_G2HOSTFIFO_UNDEFMASK 0x00000000
union g2sb_ctx2_g2hostfifo_u {
    struct {
        unsigned int hostfifodata:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2hostfifo_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2hostfifo_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2hostfifo_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hostfifodata:32", "", 32, old_value_t.hostfifodata, new_value_t.hostfifodata };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2VDDA_OFFSET 0x8011
#define G2SB_CTX2_G2VDDA_UNDEFMASK 0x00000000
union g2sb_ctx2_g2vdda_u {
    struct {
        unsigned int vdstep:32;             /* Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2vdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2vdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2vdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdstep:32",
              "Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010.",
              32, old_value_t.vdstep, new_value_t.vdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2VDDAINI_OFFSET 0x8012
#define G2SB_CTX2_G2VDDAINI_UNDEFMASK 0xFFFF0000
union g2sb_ctx2_g2vddaini_u {
    struct {
        unsigned int vdtini:8;              /* Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window. */
        unsigned int vdbini:8;              /* Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above) */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2vddaini_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2vddaini_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2vddaini_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdtini:8",
              "Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window.",
              8, old_value_t.vdtini, new_value_t.vdtini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: vdbini:8",
              "Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above)",
              8, old_value_t.vdbini, new_value_t.vdbini };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2HDDA_OFFSET 0x8013
#define G2SB_CTX2_G2HDDA_UNDEFMASK 0x00000000
union g2sb_ctx2_g2hdda_u {
    struct {
        unsigned int hdstep:32;             /* Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2hdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2hdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2hdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdstep:32",
              "Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101.",
              32, old_value_t.hdstep, new_value_t.hdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2HDDAINILS_OFFSET 0x8014
#define G2SB_CTX2_G2HDDAINILS_UNDEFMASK 0xFFFFFF00
union g2sb_ctx2_g2hddainils_u {
    struct {
        unsigned int hdini:8;               /* Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0. */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2hddainils_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2hddainils_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2hddainils_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdini:8",
              "Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0.",
              8, old_value_t.hdini, new_value_t.hdini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CSCFIRST_OFFSET 0x8015
#define G2SB_CTX2_G2CSCFIRST_UNDEFMASK 0x00C00C00
union g2sb_ctx2_g2cscfirst_u {
    struct {
        unsigned int cub:10;                /* multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved  */
        unsigned int undefined_bits_10_11:2;
        unsigned int cvr:10;                /* multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved */
        unsigned int undefined_bits_22_23:2;
        unsigned int yos:8;                 /* Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2cscfirst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2cscfirst_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2cscfirst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cub:10",
              "multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved",
              10, old_value_t.cub, new_value_t.cub };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_11:2", "", 2, old_value_t.undefined_bits_10_11, new_value_t.undefined_bits_10_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cvr:10",
              "multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved",
              10, old_value_t.cvr, new_value_t.cvr };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: yos:8",
              "Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10",
              8, old_value_t.yos, new_value_t.yos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CSCSECOND_OFFSET 0x8016
#define G2SB_CTX2_G2CSCSECOND_UNDEFMASK 0x00C00E00
union g2sb_ctx2_g2cscsecond_u {
    struct {
        unsigned int cug:9;                 /* multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved */
        unsigned int undefined_bits_9_11:3;
        unsigned int cur:10;                /* multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved  */
        unsigned int undefined_bits_22_23:2;
        unsigned int cyx:8;                 /* multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2cscsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2cscsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2cscsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cug:9",
              "multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved",
              9, old_value_t.cug, new_value_t.cug };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cur:10",
              "multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved",
              10, old_value_t.cur, new_value_t.cur };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cyx:8",
              "multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041",
              8, old_value_t.cyx, new_value_t.cyx };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CSCTHIRD_OFFSET 0x8017
#define G2SB_CTX2_G2CSCTHIRD_UNDEFMASK 0xFC00FE00
union g2sb_ctx2_g2cscthird_u {
    struct {
        unsigned int cvg:9;                 /* multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113 */
        unsigned int undefined_bits_9_15:7;
        unsigned int cvb:10;                /* multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021 */
        unsigned int undefined_bits_26_31:6;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2cscthird_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2cscthird_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2cscthird_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cvg:9",
              "multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113",
              9, old_value_t.cvg, new_value_t.cvg };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cvb:10",
              "multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021",
              10, old_value_t.cvb, new_value_t.cvb };
    m_bit_details_model.bits.append(entry);
    entry = { "26: undefined_bits_26_31:6", "", 6, old_value_t.undefined_bits_26_31, new_value_t.undefined_bits_26_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CMKEYL_OFFSET 0x8018
#define G2SB_CTX2_G2CMKEYL_UNDEFMASK 0xFF000000
union g2sb_ctx2_g2cmkeyl_u {
    struct {
        unsigned int ckbl:8;                /* B or Y Color/Chroma Key Lower Limit (CKBL[7:0]) */
        unsigned int ckgl:8;                /* G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level. */
        unsigned int ckrl:8;                /* R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2cmkeyl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2cmkeyl_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2cmkeyl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbl:8",
              "B or Y Color/Chroma Key Lower Limit (CKBL[7:0])",
              8, old_value_t.ckbl, new_value_t.ckbl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgl:8",
              "G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgl, new_value_t.ckgl };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckrl:8",
              "R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved",
              8, old_value_t.ckrl, new_value_t.ckrl };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CMKEYU_OFFSET 0x8019
#define G2SB_CTX2_G2CMKEYU_UNDEFMASK 0xFF000000
union g2sb_ctx2_g2cmkeyu_u {
    struct {
        unsigned int ckbu:8;                /* This is B or Y color/chroma key upper limit value. */
        unsigned int ckgu:8;                /* G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level. */
        unsigned int ckru:8;                /* R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2cmkeyu_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2cmkeyu_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2cmkeyu_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbu:8",
              "This is B or Y color/chroma key upper limit value.",
              8, old_value_t.ckbu, new_value_t.ckbu };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgu:8",
              "G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgu, new_value_t.ckgu };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckru:8",
              "R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved",
              8, old_value_t.ckru, new_value_t.ckru };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2UBA_A_OFFSET 0x801A
#define G2SB_CTX2_G2UBA_A_UNDEFMASK 0x00000000
union g2sb_ctx2_g2uba_a_u {
    struct {
        unsigned int su1sa:32;              /* Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2uba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2uba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2uba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: su1sa:32",
              "Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.su1sa, new_value_t.su1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2VBA_A_OFFSET 0x801B
#define G2SB_CTX2_G2VBA_A_UNDEFMASK 0x00000000
union g2sb_ctx2_g2vba_a_u {
    struct {
        unsigned int sv1sa:32;              /* Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2vba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2vba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2vba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sv1sa:32",
              "Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.sv1sa, new_value_t.sv1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2SBFORMAT_OFFSET 0x801C
#define G2SB_CTX2_G2SBFORMAT_UNDEFMASK 0x000020E0
union g2sb_ctx2_g2sbformat_u {
    struct {
        unsigned int sifmt:5;               /* This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV. */
        unsigned int undefined_bits_5_7:3;
        unsigned int difmt:5;               /* Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED */
        unsigned int undefined_bit_13:1;
        unsigned int raisebufferen:1;       /* ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.  */
        unsigned int raiseframeen:1;        /* ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.  */
        unsigned int raisebuffervalue:8;    /* Raise buffer vector value. */
        unsigned int raiseframevalue:8;     /* Raise Fram vector value. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2sbformat_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2sbformat_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2sbformat_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sifmt:5",
              "This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV.",
              5, old_value_t.sifmt, new_value_t.sifmt };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: difmt:5",
              "Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED",
              5, old_value_t.difmt, new_value_t.difmt };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: raisebufferen:1",
              "ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raisebufferen, new_value_t.raisebufferen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: raiseframeen:1",
              "ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raiseframeen, new_value_t.raiseframeen };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisebuffervalue:8",
              "Raise buffer vector value.",
              8, old_value_t.raisebuffervalue, new_value_t.raisebuffervalue };
    m_bit_details_model.bits.append(entry);
    entry = { "24: raiseframevalue:8",
              "Raise Fram vector value.",
              8, old_value_t.raiseframevalue, new_value_t.raiseframevalue };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CONTROLSB_OFFSET 0x801D
#define G2SB_CTX2_G2CONTROLSB_UNDEFMASK 0x20005807
union g2sb_ctx2_g2controlsb_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int yuv422rotation:1;      /* yuv422 plannar rotated */
        unsigned int yuv422planar:1;        /* source data is yuv422 planar valid when imode==PLANAR */
        unsigned int imode:1;               /* Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d. */
        unsigned int enavf:1;               /* enable alpha vertical filter     */
        unsigned int enahf:1;               /* enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format, */
        unsigned int uvst:2;                /*   00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.   11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride). */
        unsigned int sl:1;                  /* Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines. */
        unsigned int undefined_bits_11_12:2;
        unsigned int sisel:1;               /* StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved  */
        unsigned int undefined_bit_14:1;
        unsigned int sbltsrc:1;             /* StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator. */
        unsigned int vftype:2;              /* StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager. */
        unsigned int vfen:1;                /* StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled. */
        unsigned int discsc:1;              /* enabled color space converter by default */
        unsigned int hftype:3;              /* StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE. */
        unsigned int rangeredfrm:1;         /* In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.  */
        unsigned int sitype:1;              /* StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?. */
        unsigned int sbsel:1;               /* StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer. */
        unsigned int dbsel:1;               /* StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer. */
        unsigned int keyen:1;               /* Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled. */
        unsigned int kpol:1;                /* Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range. */
        unsigned int undefined_bit_29:1;
        unsigned int endith:1;              /* Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering */
        unsigned int disdw:1;               /* output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2controlsb_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2controlsb_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2controlsb_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_2:3", "", 3, old_value_t.undefined_bits_0_2, new_value_t.undefined_bits_0_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: yuv422rotation:1",
              "yuv422 plannar rotated",
              1, old_value_t.yuv422rotation, new_value_t.yuv422rotation };
    m_bit_details_model.bits.append(entry);
    entry = { "04: yuv422planar:1",
              "source data is yuv422 planar valid when imode==PLANAR",
              1, old_value_t.yuv422planar, new_value_t.yuv422planar };
    m_bit_details_model.bits.append(entry);
    entry = { "05: imode:1",
              "Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d.",
              1, old_value_t.imode, new_value_t.imode };
    m_bit_details_model.bits.append(entry);
    entry = { "06: enavf:1",
              "enable alpha vertical filter",
              1, old_value_t.enavf, new_value_t.enavf };
    m_bit_details_model.bits.append(entry);
    entry = { "07: enahf:1",
              "enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format,",
              1, old_value_t.enahf, new_value_t.enahf };
    m_bit_details_model.bits.append(entry);
    entry = { "08: uvst:2",
              " \n00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.\n11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride).",
              2, old_value_t.uvst, new_value_t.uvst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: sl:1",
              "Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines.",
              1, old_value_t.sl, new_value_t.sl };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_12:2", "", 2, old_value_t.undefined_bits_11_12, new_value_t.undefined_bits_11_12 };
    m_bit_details_model.bits.append(entry);
    entry = { "13: sisel:1",
              "StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved",
              1, old_value_t.sisel, new_value_t.sisel };
    m_bit_details_model.bits.append(entry);
    entry = { "14: undefined_bit_14:1", "", 1, old_value_t.undefined_bit_14, new_value_t.undefined_bit_14 };
    m_bit_details_model.bits.append(entry);
    entry = { "15: sbltsrc:1",
              "StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator.",
              1, old_value_t.sbltsrc, new_value_t.sbltsrc };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vftype:2",
              "StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager.",
              2, old_value_t.vftype, new_value_t.vftype };
    m_bit_details_model.bits.append(entry);
    entry = { "18: vfen:1",
              "StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled.",
              1, old_value_t.vfen, new_value_t.vfen };
    m_bit_details_model.bits.append(entry);
    entry = { "19: discsc:1",
              "enabled color space converter by default",
              1, old_value_t.discsc, new_value_t.discsc };
    m_bit_details_model.bits.append(entry);
    entry = { "20: hftype:3",
              "StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE.",
              3, old_value_t.hftype, new_value_t.hftype };
    m_bit_details_model.bits.append(entry);
    entry = { "23: rangeredfrm:1",
              "In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.",
              1, old_value_t.rangeredfrm, new_value_t.rangeredfrm };
    m_bit_details_model.bits.append(entry);
    entry = { "24: sitype:1",
              "StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?.",
              1, old_value_t.sitype, new_value_t.sitype };
    m_bit_details_model.bits.append(entry);
    entry = { "25: sbsel:1",
              "StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer.",
              1, old_value_t.sbsel, new_value_t.sbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "26: dbsel:1",
              "StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer.",
              1, old_value_t.dbsel, new_value_t.dbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "27: keyen:1",
              "Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled.",
              1, old_value_t.keyen, new_value_t.keyen };
    m_bit_details_model.bits.append(entry);
    entry = { "28: kpol:1",
              "Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range.",
              1, old_value_t.kpol, new_value_t.kpol };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: endith:1",
              "Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering",
              1, old_value_t.endith, new_value_t.endith };
    m_bit_details_model.bits.append(entry);
    entry = { "31: disdw:1",
              "output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place.",
              1, old_value_t.disdw, new_value_t.disdw };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CONTROLSECOND_OFFSET 0x801E
#define G2SB_CTX2_G2CONTROLSECOND_UNDEFMASK 0xC08E3C01
union g2sb_ctx2_g2controlsecond_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int bitswap:1;             /* Host port bit swap 1=enable   0= disable   1= enable */
        unsigned int bebswap:1;             /* Host port byte swap 1=enable   0= disable   1= enable */
        unsigned int bewswap:1;             /* Host port word swap 1=enable   0= disable */
        unsigned int alptype:5;             /* Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits. */
        unsigned int alpsrcordst:1;         /* 32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha */
        unsigned int undefined_bits_10_13:4;
        unsigned int pxlrep:1;              /* Pixel replication for Palm OS. */
        unsigned int swapblt:1;             /* Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area */
        unsigned int vcaa_safe_mode:1;      /* VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken. */
        unsigned int undefined_bits_17_19:3;
        unsigned int g2nostop:1;
        unsigned int clipc:2;               /* Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,  10=draw only inside clipping rectangle,  11=draw only outside clipping rectangle */
        unsigned int undefined_bit_23:1;
        unsigned int fr_mode:2;             /* Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice. 00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so! 01 = src/dst copy mode - two separate buffers 10 = square in place - one buffer 11 = blank */
        unsigned int fr_type:3;             /*  Fast Rotate type     000 = FLIP_X  001 = FLIP_Y  010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right) 011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left) 100 = ROT_90 (counter clock wise by 90 degrees) 101 = ROT_180  110 = ROT_270 (clock wise by 90 degrees) 111 = IDENTITY */
        unsigned int fr_readwait:1;         /*  Fast Rotate wait for read 0 = disable 1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only. */
        unsigned int undefined_bits_30_31:2;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2controlsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2controlsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2controlsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bit_0:1", "", 1, old_value_t.undefined_bit_0, new_value_t.undefined_bit_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "01: bitswap:1",
              "Host port bit swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bitswap, new_value_t.bitswap };
    m_bit_details_model.bits.append(entry);
    entry = { "02: bebswap:1",
              "Host port byte swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bebswap, new_value_t.bebswap };
    m_bit_details_model.bits.append(entry);
    entry = { "03: bewswap:1",
              "Host port word swap\n1=enable  \n0= disable",
              1, old_value_t.bewswap, new_value_t.bewswap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: alptype:5",
              "Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits.",
              5, old_value_t.alptype, new_value_t.alptype };
    m_bit_details_model.bits.append(entry);
    entry = { "09: alpsrcordst:1",
              "32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha",
              1, old_value_t.alpsrcordst, new_value_t.alpsrcordst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_13:4", "", 4, old_value_t.undefined_bits_10_13, new_value_t.undefined_bits_10_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: pxlrep:1",
              "Pixel replication for Palm OS.",
              1, old_value_t.pxlrep, new_value_t.pxlrep };
    m_bit_details_model.bits.append(entry);
    entry = { "15: swapblt:1",
              "Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area",
              1, old_value_t.swapblt, new_value_t.swapblt };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vcaa_safe_mode:1",
              "VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken.",
              1, old_value_t.vcaa_safe_mode, new_value_t.vcaa_safe_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: g2nostop:1", "", 1, old_value_t.g2nostop, new_value_t.g2nostop };
    m_bit_details_model.bits.append(entry);
    entry = { "21: clipc:2",
              "Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,\n10=draw only inside clipping rectangle,\n11=draw only outside clipping rectangle",
              2, old_value_t.clipc, new_value_t.clipc };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fr_mode:2",
              "Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice.\n00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so!\n01 = src/dst copy mode - two separate buffers\n10 = square in place - one buffer\n11 = blank",
              2, old_value_t.fr_mode, new_value_t.fr_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "26: fr_type:3",
              " Fast Rotate type    \n000 = FLIP_X \n001 = FLIP_Y \n010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right)\n011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left)\n100 = ROT_90 (counter clock wise by 90 degrees)\n101 = ROT_180 \n110 = ROT_270 (clock wise by 90 degrees)\n111 = IDENTITY",
              3, old_value_t.fr_type, new_value_t.fr_type };
    m_bit_details_model.bits.append(entry);
    entry = { "29: fr_readwait:1",
              " Fast Rotate wait for read\n0 = disable\n1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only.",
              1, old_value_t.fr_readwait, new_value_t.fr_readwait };
    m_bit_details_model.bits.append(entry);
    entry = { "30: undefined_bits_30_31:2", "", 2, old_value_t.undefined_bits_30_31, new_value_t.undefined_bits_30_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CONTROLMAIN_OFFSET 0x801F
#define G2SB_CTX2_G2CONTROLMAIN_UNDEFMASK 0x80000000
union g2sb_ctx2_g2controlmain_u {
    struct {
        unsigned int cmdt:2;                /* Command Type:  00=BitBlt 01=Line Draw  10=VCAA 11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed) */
        unsigned int turbofill:1;           /* fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified. */
        unsigned int test0bit:1;            /* Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish. */
        unsigned int faden:1;               /* BitBlt Source Copy Fade enable, 1=enable (share with mltln), only support  16bpp mode */
        unsigned int alpen:1;               /* BitBlt Alpha Blending, 1=enable. 0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype */
        unsigned int srcsld:1;              /* BitBlt Solid Source Color Fill: 1=enable. FGC will be used as  the color value. */
        unsigned int patsld:1;              /* BitBlt Solid Pattern Fill: 1=enable. BGC will be used as  the color value. */
        unsigned int patfl:1;               /* When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+ */
        unsigned int xdir:1;                /*  0=incrementing, 1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0 */
        unsigned int ydir:1;                /*  0=incrementing, 1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0 */
        unsigned int xytdw:1;               /* xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination. */
        unsigned int srcpack:1;             /* Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled. */
        unsigned int patpack:1;             /* Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled. */
        unsigned int yflip:1;               /* flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination. */
        unsigned int srcsel:1;              /* Source Data Select: */
        unsigned int dstcd:2;               /* Destination color depth:   00=8-bpp, 01=16-bpp, 10=32-bpp. 11=reserved */
        unsigned int dstt:2;                /* Destination read transparency enable:   0x=destination read transparency disabled   10=color destination read transparency   11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately, 0=wait for launch write) */
        unsigned int srccd:1;               /* 0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0 */
        unsigned int hlmono:1;              /* Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit */
        unsigned int srct:2;                /* Source transparency enable: 0x=source transparency disabled,  10=mono source background transparency     or color source transparency,  11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied. */
        unsigned int srcbas:1;              /* Source base address select:   0=srcba, 1=dstba. This is not used for Line Draw and  if source data comes from host memory. */
        unsigned int gcsw:2;                /* Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used */
        unsigned int srcdir:1;              /* source direct addressing */
        unsigned int dstdir:1;              /* destination direct addressing */
        unsigned int dst_rd_wr_sep:1;       /* This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA */
        unsigned int patsel:1;              /* pattern Data Select: SRCSEL and PATSEL can't be both enabled. */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2controlmain_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2controlmain_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2controlmain_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cmdt:2",
              "Command Type: \n00=BitBlt\n01=Line Draw \n10=VCAA\n11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed)",
              2, old_value_t.cmdt, new_value_t.cmdt };
    m_bit_details_model.bits.append(entry);
    entry = { "02: turbofill:1",
              "fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified.",
              1, old_value_t.turbofill, new_value_t.turbofill };
    m_bit_details_model.bits.append(entry);
    entry = { "03: test0bit:1",
              "Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish.",
              1, old_value_t.test0bit, new_value_t.test0bit };
    m_bit_details_model.bits.append(entry);
    entry = { "04: faden:1",
              "BitBlt Source Copy Fade enable,\n1=enable (share with mltln), only support  16bpp mode",
              1, old_value_t.faden, new_value_t.faden };
    m_bit_details_model.bits.append(entry);
    entry = { "05: alpen:1",
              "BitBlt Alpha Blending,\n1=enable.\n0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype",
              1, old_value_t.alpen, new_value_t.alpen };
    m_bit_details_model.bits.append(entry);
    entry = { "06: srcsld:1",
              "BitBlt Solid Source Color Fill:\n1=enable. FGC will be used as  the color value.",
              1, old_value_t.srcsld, new_value_t.srcsld };
    m_bit_details_model.bits.append(entry);
    entry = { "07: patsld:1",
              "BitBlt Solid Pattern Fill:\n1=enable. BGC will be used as  the color value.",
              1, old_value_t.patsld, new_value_t.patsld };
    m_bit_details_model.bits.append(entry);
    entry = { "08: patfl:1",
              "When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+",
              1, old_value_t.patfl, new_value_t.patfl };
    m_bit_details_model.bits.append(entry);
    entry = { "09: xdir:1",
              "0=incrementing,\n1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0",
              1, old_value_t.xdir, new_value_t.xdir };
    m_bit_details_model.bits.append(entry);
    entry = { "10: ydir:1",
              "0=incrementing,\n1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0",
              1, old_value_t.ydir, new_value_t.ydir };
    m_bit_details_model.bits.append(entry);
    entry = { "11: xytdw:1",
              "xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination.",
              1, old_value_t.xytdw, new_value_t.xytdw };
    m_bit_details_model.bits.append(entry);
    entry = { "12: srcpack:1",
              "Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.srcpack, new_value_t.srcpack };
    m_bit_details_model.bits.append(entry);
    entry = { "13: patpack:1",
              "Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.patpack, new_value_t.patpack };
    m_bit_details_model.bits.append(entry);
    entry = { "14: yflip:1",
              "flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination.",
              1, old_value_t.yflip, new_value_t.yflip };
    m_bit_details_model.bits.append(entry);
    entry = { "15: srcsel:1",
              "Source Data Select:",
              1, old_value_t.srcsel, new_value_t.srcsel };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstcd:2",
              "Destination color depth:  \n00=8-bpp,\n01=16-bpp,\n10=32-bpp.\n11=reserved",
              2, old_value_t.dstcd, new_value_t.dstcd };
    m_bit_details_model.bits.append(entry);
    entry = { "18: dstt:2",
              "Destination read transparency enable:   0x=destination read transparency disabled  \n10=color destination read transparency  \n11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately,\n0=wait for launch write)",
              2, old_value_t.dstt, new_value_t.dstt };
    m_bit_details_model.bits.append(entry);
    entry = { "20: srccd:1",
              "0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0",
              1, old_value_t.srccd, new_value_t.srccd };
    m_bit_details_model.bits.append(entry);
    entry = { "21: hlmono:1",
              "Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit",
              1, old_value_t.hlmono, new_value_t.hlmono };
    m_bit_details_model.bits.append(entry);
    entry = { "22: srct:2",
              "Source transparency enable: 0x=source transparency disabled,\n10=mono source background transparency     or color source transparency,\n11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied.",
              2, old_value_t.srct, new_value_t.srct };
    m_bit_details_model.bits.append(entry);
    entry = { "24: srcbas:1",
              "Source base address select:  \n0=srcba,\n1=dstba. This is not used for Line Draw and  if source data comes from host memory.",
              1, old_value_t.srcbas, new_value_t.srcbas };
    m_bit_details_model.bits.append(entry);
    entry = { "25: gcsw:2",
              "Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used",
              2, old_value_t.gcsw, new_value_t.gcsw };
    m_bit_details_model.bits.append(entry);
    entry = { "27: srcdir:1",
              "source direct addressing",
              1, old_value_t.srcdir, new_value_t.srcdir };
    m_bit_details_model.bits.append(entry);
    entry = { "28: dstdir:1",
              "destination direct addressing",
              1, old_value_t.dstdir, new_value_t.dstdir };
    m_bit_details_model.bits.append(entry);
    entry = { "29: dst_rd_wr_sep:1",
              "This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA",
              1, old_value_t.dst_rd_wr_sep, new_value_t.dst_rd_wr_sep };
    m_bit_details_model.bits.append(entry);
    entry = { "30: patsel:1",
              "pattern Data Select: SRCSEL and PATSEL can't be both enabled.",
              1, old_value_t.patsel, new_value_t.patsel };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2ROPFADE_OFFSET 0x8020
#define G2SB_CTX2_G2ROPFADE_UNDEFMASK 0x0000FF00
union g2sb_ctx2_g2ropfade_u {
    struct {
        unsigned int rop:8;                 /* If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out. */
        unsigned int undefined_bits_8_15:8;
        unsigned int fadcoe:8;
        unsigned int fadoff:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2ropfade_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2ropfade_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2ropfade_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: rop:8",
              "If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out.",
              8, old_value_t.rop, new_value_t.rop };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: fadcoe:8", "", 8, old_value_t.fadcoe, new_value_t.fadcoe };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fadoff:8", "", 8, old_value_t.fadoff, new_value_t.fadoff };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2ALPHABLEND_OFFSET 0x8021
#define G2SB_CTX2_G2ALPHABLEND_UNDEFMASK 0x0000FE00
union g2sb_ctx2_g2alphablend_u {
    struct {
        unsigned int alpha:8;
        unsigned int alphainv:1;
        unsigned int undefined_bits_9_15:7;
        unsigned int alpha0v:8;
        unsigned int alpha1v:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2alphablend_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2alphablend_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2alphablend_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: alpha:8", "", 8, old_value_t.alpha, new_value_t.alpha };
    m_bit_details_model.bits.append(entry);
    entry = { "08: alphainv:1", "", 1, old_value_t.alphainv, new_value_t.alphainv };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: alpha0v:8", "", 8, old_value_t.alpha0v, new_value_t.alpha0v };
    m_bit_details_model.bits.append(entry);
    entry = { "24: alpha1v:8", "", 8, old_value_t.alpha1v, new_value_t.alpha1v };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CLIPLEFTTOP_OFFSET 0x8022
#define G2SB_CTX2_G2CLIPLEFTTOP_UNDEFMASK 0x80008000
union g2sb_ctx2_g2cliplefttop_u {
    struct {
        unsigned int clipl:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipt:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2cliplefttop_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2cliplefttop_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2cliplefttop_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipl:15", "", 15, old_value_t.clipl, new_value_t.clipl };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipt:15", "", 15, old_value_t.clipt, new_value_t.clipt };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CLIPRIGHTBOT_OFFSET 0x8023
#define G2SB_CTX2_G2CLIPRIGHTBOT_UNDEFMASK 0x80008000
union g2sb_ctx2_g2cliprightbot_u {
    struct {
        unsigned int clipr:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipb:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2cliprightbot_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2cliprightbot_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2cliprightbot_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipr:15", "", 15, old_value_t.clipr, new_value_t.clipr };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipb:15", "", 15, old_value_t.clipb, new_value_t.clipb };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2PATPACK_OFFSET 0x8024
#define G2SB_CTX2_G2PATPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx2_g2patpack_u {
    struct {
        unsigned int patlngap:4;            /* Packed mode, pattern data line gap. byte */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2patpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2patpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2patpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patlngap:4",
              "Packed mode, pattern data line gap. byte",
              4, old_value_t.patlngap, new_value_t.patlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2PATPACK_SIZE_OFFSET 0x8025
#define G2SB_CTX2_G2PATPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx2_g2patpack_size_u {
    struct {
        unsigned int patmonow:16;           /* Mono data width in packed mode, byte  */
        unsigned int patmonoh:16;           /*  Pattern mono data height in packed mode, byte  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2patpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2patpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2patpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patmonow:16",
              "Mono data width in packed mode, byte",
              16, old_value_t.patmonow, new_value_t.patmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patmonoh:16",
              " Pattern mono data height in packed mode, byte",
              16, old_value_t.patmonoh, new_value_t.patmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2PATBA_OFFSET 0x8026
#define G2SB_CTX2_G2PATBA_UNDEFMASK 0x00000000
union g2sb_ctx2_g2patba_u {
    struct {
        unsigned int patba:32;              /* If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. } */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2patba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2patba_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2patba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patba:32",
              "If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. }",
              32, old_value_t.patba, new_value_t.patba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2PATOS_OFFSET 0x8027
#define G2SB_CTX2_G2PATOS_UNDEFMASK 0x009E0000
union g2sb_ctx2_g2patos_u {
    struct {
        unsigned int patst:16;              /* stride */
        unsigned int patcd:1;               /* 0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0 */
        unsigned int undefined_bits_17_20:4;
        unsigned int patt:2;                /* Mono pattern transparency enable:  0x=pattern transparency disabled,  10=mono pattern background transparency    or color pattern transparency,  11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied. */
        unsigned int undefined_bit_23:1;
        unsigned int patxo:4;               /* x offset for mono tile pattern fill.  see PATFL */
        unsigned int patyo:4;               /* y offset for mono tile pattern fill.  see PATFL */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2patos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2patos_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2patos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patst:16",
              "stride",
              16, old_value_t.patst, new_value_t.patst };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patcd:1",
              "0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0",
              1, old_value_t.patcd, new_value_t.patcd };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_20:4", "", 4, old_value_t.undefined_bits_17_20, new_value_t.undefined_bits_17_20 };
    m_bit_details_model.bits.append(entry);
    entry = { "21: patt:2",
              "Mono pattern transparency enable:  0x=pattern transparency disabled,\n10=mono pattern background transparency    or color pattern transparency,\n11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied.",
              2, old_value_t.patt, new_value_t.patt };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: patxo:4",
              "x offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patxo, new_value_t.patxo };
    m_bit_details_model.bits.append(entry);
    entry = { "28: patyo:4",
              "y offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patyo, new_value_t.patyo };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2PATBGC_OFFSET 0x8028
#define G2SB_CTX2_G2PATBGC_UNDEFMASK 0x00000000
union g2sb_ctx2_g2patbgc_u {
    struct {
        unsigned int patbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2patbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2patbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2patbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patbgc:32", "", 32, old_value_t.patbgc, new_value_t.patbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2PATFGC_OFFSET 0x8029
#define G2SB_CTX2_G2PATFGC_UNDEFMASK 0x00000000
union g2sb_ctx2_g2patfgc_u {
    struct {
        unsigned int patfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2patfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2patfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2patfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patfgc:32", "", 32, old_value_t.patfgc, new_value_t.patfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2PATKEY_OFFSET 0x802A
#define G2SB_CTX2_G2PATKEY_UNDEFMASK 0x00000000
union g2sb_ctx2_g2patkey_u {
    struct {
        unsigned int patkey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2patkey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2patkey_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2patkey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patkey:32", "", 32, old_value_t.patkey, new_value_t.patkey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2DSTBA_OFFSET 0x802B
#define G2SB_CTX2_G2DSTBA_UNDEFMASK 0x00000000
union g2sb_ctx2_g2dstba_u {
    struct {
        unsigned int dstba:32;              /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2dstba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2dstba_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2dstba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba, new_value_t.dstba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2DSTBA_B_OFFSET 0x802C
#define G2SB_CTX2_G2DSTBA_B_UNDEFMASK 0x00000000
union g2sb_ctx2_g2dstba_b_u {
    struct {
        unsigned int dstba_b:32;            /* Destination base address (byte address) only usable in hardware trigger mode by enable gcsw */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2dstba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2dstba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2dstba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_b:32",
              "Destination base address (byte address) only usable in hardware trigger mode by enable gcsw",
              32, old_value_t.dstba_b, new_value_t.dstba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2DSTBA_C_OFFSET 0x802D
#define G2SB_CTX2_G2DSTBA_C_UNDEFMASK 0x00000000
union g2sb_ctx2_g2dstba_c_u {
    struct {
        unsigned int dstba_c:32;            /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2dstba_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2dstba_c_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2dstba_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_c:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba_c, new_value_t.dstba_c };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2DSTST_OFFSET 0x802E
#define G2SB_CTX2_G2DSTST_UNDEFMASK 0xFFFF0000
union g2sb_ctx2_g2dstst_u {
    struct {
        unsigned int dsts:16;               /* Destination Stride coordinate(bytes) with respect to DSTBA. */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2dstst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2dstst_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2dstst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dsts:16",
              "Destination Stride coordinate(bytes) with respect to DSTBA.",
              16, old_value_t.dsts, new_value_t.dsts };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2SRCPACK_OFFSET 0x802F
#define G2SB_CTX2_G2SRCPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx2_g2srcpack_u {
    struct {
        unsigned int srclngap:4;            /* Packed mode - source mono data line gap */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2srcpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2srcpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2srcpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srclngap:4",
              "Packed mode - source mono data line gap",
              4, old_value_t.srclngap, new_value_t.srclngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2SRCPACK_SIZE_OFFSET 0x8030
#define G2SB_CTX2_G2SRCPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx2_g2srcpack_size_u {
    struct {
        unsigned int srcmonow:16;           /* Packed mode - source mono data width in bytes */
        unsigned int srcmonoh:16;           /* Packed mode - source mono data height in bytes  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2srcpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2srcpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2srcpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcmonow:16",
              "Packed mode - source mono data width in bytes",
              16, old_value_t.srcmonow, new_value_t.srcmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcmonoh:16",
              "Packed mode - source mono data height in bytes",
              16, old_value_t.srcmonoh, new_value_t.srcmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2SRCBA_OFFSET 0x8031
#define G2SB_CTX2_G2SRCBA_UNDEFMASK 0x00000000
union g2sb_ctx2_g2srcba_u {
    struct {
        unsigned int srcba:32;              /* Source base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2srcba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2srcba_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2srcba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba:32",
              "Source base address (byte address)",
              32, old_value_t.srcba, new_value_t.srcba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2SRCBA_B_OFFSET 0x8032
#define G2SB_CTX2_G2SRCBA_B_UNDEFMASK 0x00000000
union g2sb_ctx2_g2srcba_b_u {
    struct {
        unsigned int srcba_b:32;            /* This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.) */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2srcba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2srcba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2srcba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba_b:32",
              "This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.)",
              32, old_value_t.srcba_b, new_value_t.srcba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2SRCST_OFFSET 0x8033
#define G2SB_CTX2_G2SRCST_UNDEFMASK 0xFFFF0000
union g2sb_ctx2_g2srcst_u {
    struct {
        unsigned int srcs:16;               /* Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.  */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2srcst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2srcst_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2srcst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs:16",
              "Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.",
              16, old_value_t.srcs, new_value_t.srcs };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2SRCBGC_OFFSET 0x8034
#define G2SB_CTX2_G2SRCBGC_UNDEFMASK 0x00000000
union g2sb_ctx2_g2srcbgc_u {
    struct {
        unsigned int srcbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2srcbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2srcbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2srcbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcbgc:32", "", 32, old_value_t.srcbgc, new_value_t.srcbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2SRCFGC_OFFSET 0x8035
#define G2SB_CTX2_G2SRCFGC_UNDEFMASK 0x00000000
union g2sb_ctx2_g2srcfgc_u {
    struct {
        unsigned int srcfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2srcfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2srcfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2srcfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcfgc:32", "", 32, old_value_t.srcfgc, new_value_t.srcfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2SRCKEY_OFFSET 0x8036
#define G2SB_CTX2_G2SRCKEY_UNDEFMASK 0x00000000
union g2sb_ctx2_g2srckey_u {
    struct {
        unsigned int srckey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2srckey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2srckey_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2srckey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srckey:32", "", 32, old_value_t.srckey, new_value_t.srckey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2SRCSIZE_OFFSET 0x8037
#define G2SB_CTX2_G2SRCSIZE_UNDEFMASK 0x80008000
union g2sb_ctx2_g2srcsize_u {
    struct {
        unsigned int srcwidth:15;
        unsigned int undefined_bit_15:1;
        unsigned int srcheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2srcsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2srcsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2srcsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcwidth:15", "", 15, old_value_t.srcwidth, new_value_t.srcwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.srcheight, new_value_t.srcheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2DSTSIZE_OFFSET 0x8038
#define G2SB_CTX2_G2DSTSIZE_UNDEFMASK 0x80008000
union g2sb_ctx2_g2dstsize_u {
    struct {
        unsigned int dstwidth:15;           /* In 2D mode, the largest number can be programmed is 0x7fef */
        unsigned int undefined_bit_15:1;
        unsigned int dstheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2dstsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2dstsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2dstsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstwidth:15",
              "In 2D mode, the largest number can be programmed is 0x7fef",
              15, old_value_t.dstwidth, new_value_t.dstwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.dstheight, new_value_t.dstheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2SRCPS_OFFSET 0x8039
#define G2SB_CTX2_G2SRCPS_UNDEFMASK 0x00000000
union g2sb_ctx2_g2srcps_u {
    struct {
        unsigned int srcx:16;               /* SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY   */
        unsigned int srcy:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2srcps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2srcps_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2srcps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcx:16",
              "SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY",
              16, old_value_t.srcx, new_value_t.srcx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcy:16", "", 16, old_value_t.srcy, new_value_t.srcy };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2DSTPS_OFFSET 0x803A
#define G2SB_CTX2_G2DSTPS_UNDEFMASK 0x00000000
union g2sb_ctx2_g2dstps_u {
    struct {
        unsigned int dstx:16;               /* NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 */
        unsigned int dsty:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2dstps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2dstps_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2dstps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstx:16",
              "NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489",
              16, old_value_t.dstx, new_value_t.dstx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dsty:16", "", 16, old_value_t.dsty, new_value_t.dsty };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CBDES_OFFSET 0x803B
#define G2SB_CTX2_G2CBDES_UNDEFMASK 0x0000FF00
union g2sb_ctx2_g2cbdes_u {
    struct {
        unsigned int cbcount:8;             /* This specifies the number of buffers incircular buffer feature                    */
        unsigned int undefined_bits_8_15:8;
        unsigned int cbline:15;             /* vertical line number in one buffer */
        unsigned int topclip:1;             /* top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2 0= disable  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2cbdes_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2cbdes_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2cbdes_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbcount:8",
              "This specifies the number of buffers incircular buffer feature",
              8, old_value_t.cbcount, new_value_t.cbcount };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbline:15",
              "vertical line number in one buffer",
              15, old_value_t.cbline, new_value_t.cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "31: topclip:1",
              "top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2\n0= disable",
              1, old_value_t.topclip, new_value_t.topclip };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CBSTRIDE_OFFSET 0x803C
#define G2SB_CTX2_G2CBSTRIDE_UNDEFMASK 0x3F000000
union g2sb_ctx2_g2cbstride_u {
    struct {
        unsigned int cbstride:24;           /* Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes) */
        unsigned int undefined_bits_24_29:6;
        unsigned int cbuvstride:2;          /* Chroma Buffer Stride default is half of luma   00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2cbstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2cbstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2cbstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbstride:24",
              "Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes)",
              24, old_value_t.cbstride, new_value_t.cbstride };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_29:6", "", 6, old_value_t.undefined_bits_24_29, new_value_t.undefined_bits_24_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: cbuvstride:2",
              "Chroma Buffer Stride default is half of luma  \n00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved",
              2, old_value_t.cbuvstride, new_value_t.cbuvstride };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2LINESETTING_OFFSET 0x803D
#define G2SB_CTX2_G2LINESETTING_UNDEFMASK 0x00E00000
union g2sb_ctx2_g2linesetting_u {
    struct {
        unsigned int gamma:21;
        unsigned int undefined_bits_21_23:3;
        unsigned int major:1;               /* 0:xmajor 1: y major */
        unsigned int linexdir:1;
        unsigned int lineydir:1;
        unsigned int droplastp:1;           /* draw last pixel or not */
        unsigned int lineuseoctant:1;       /* use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR */
        unsigned int octants:3;             /* 000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2linesetting_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2linesetting_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2linesetting_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: gamma:21", "", 21, old_value_t.gamma, new_value_t.gamma };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_23:3", "", 3, old_value_t.undefined_bits_21_23, new_value_t.undefined_bits_21_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: major:1",
              "0:xmajor 1: y major",
              1, old_value_t.major, new_value_t.major };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linexdir:1", "", 1, old_value_t.linexdir, new_value_t.linexdir };
    m_bit_details_model.bits.append(entry);
    entry = { "26: lineydir:1", "", 1, old_value_t.lineydir, new_value_t.lineydir };
    m_bit_details_model.bits.append(entry);
    entry = { "27: droplastp:1",
              "draw last pixel or not",
              1, old_value_t.droplastp, new_value_t.droplastp };
    m_bit_details_model.bits.append(entry);
    entry = { "28: lineuseoctant:1",
              "use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR",
              1, old_value_t.lineuseoctant, new_value_t.lineuseoctant };
    m_bit_details_model.bits.append(entry);
    entry = { "29: octants:3",
              "000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7",
              3, old_value_t.octants, new_value_t.octants };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2LINEDELTAN_OFFSET 0x803E
#define G2SB_CTX2_G2LINEDELTAN_UNDEFMASK 0xFFE00000
union g2sb_ctx2_g2linedeltan_u {
    struct {
        unsigned int deltan:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2linedeltan_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2linedeltan_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2linedeltan_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltan:21", "", 21, old_value_t.deltan, new_value_t.deltan };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2LINEDELTAM_OFFSET 0x803F
#define G2SB_CTX2_G2LINEDELTAM_UNDEFMASK 0xFFE00000
union g2sb_ctx2_g2linedeltam_u {
    struct {
        unsigned int deltam:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2linedeltam_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2linedeltam_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2linedeltam_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltam:21", "", 21, old_value_t.deltam, new_value_t.deltam };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2LINEPOS_OFFSET 0x8040
#define G2SB_CTX2_G2LINEPOS_UNDEFMASK 0x00000000
union g2sb_ctx2_g2linepos_u {
    struct {
        unsigned int linexpos:16;
        unsigned int lineypos:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2linepos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2linepos_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2linepos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linexpos:16", "", 16, old_value_t.linexpos, new_value_t.linexpos };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lineypos:16", "", 16, old_value_t.lineypos, new_value_t.lineypos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2LINELEN_OFFSET 0x8041
#define G2SB_CTX2_G2LINELEN_UNDEFMASK 0xFFFF8000
union g2sb_ctx2_g2linelen_u {
    struct {
        unsigned int linelen:15;
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2linelen_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2linelen_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2linelen_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linelen:15", "", 15, old_value_t.linelen, new_value_t.linelen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CSCFOURTH_OFFSET 0x8042
#define G2SB_CTX2_G2CSCFOURTH_UNDEFMASK 0xFE00FE00
union g2sb_ctx2_g2cscfourth_u {
    struct {
        unsigned int g2u:9;                 /* multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored */
        unsigned int undefined_bits_9_15:7;
        unsigned int g2v:9;                 /* multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored */
        unsigned int undefined_bits_25_31:7;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2cscfourth_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2cscfourth_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2cscfourth_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: g2u:9",
              "multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored",
              9, old_value_t.g2u, new_value_t.g2u };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: g2v:9",
              "multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored",
              9, old_value_t.g2v, new_value_t.g2v };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bits_25_31:7", "", 7, old_value_t.undefined_bits_25_31, new_value_t.undefined_bits_25_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2SRCST_B_OFFSET 0x8043
#define G2SB_CTX2_G2SRCST_B_UNDEFMASK 0xFFFF0000
union g2sb_ctx2_g2srcst_b_u {
    struct {
        unsigned int srcs_b:16;             /* Source Stride B */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2srcst_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2srcst_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2srcst_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs_b:16",
              "Source Stride B",
              16, old_value_t.srcs_b, new_value_t.srcs_b };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2UVSTRIDE_OFFSET 0x8044
#define G2SB_CTX2_G2UVSTRIDE_UNDEFMASK 0xFFFF0000
union g2sb_ctx2_g2uvstride_u {
    struct {
        unsigned int uvstride:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2uvstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2uvstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2uvstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: uvstride:16", "", 16, old_value_t.uvstride, new_value_t.uvstride };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2CBDES2_OFFSET 0x8045
#define G2SB_CTX2_G2CBDES2_UNDEFMASK 0xFFFF8000
union g2sb_ctx2_g2cbdes2_u {
    struct {
        unsigned int top_cbline:15;         /* Circular buffer top clipping enabled, the first buffer line num */
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2cbdes2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2cbdes2_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2cbdes2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: top_cbline:15",
              "Circular buffer top clipping enabled, the first buffer line num",
              15, old_value_t.top_cbline, new_value_t.top_cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2TILEMODE_OFFSET 0x8046
#define G2SB_CTX2_G2TILEMODE_UNDEFMASK 0xFFEEEEEE
union g2sb_ctx2_g2tilemode_u {
    struct {
        unsigned int src_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_1_3:3;
        unsigned int src_uv_tile_mode:1;    /* UV surface, ignored in RGB mode */
        unsigned int undefined_bits_5_7:3;
        unsigned int pat_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_9_11:3;
        unsigned int pat_uv_tile_mode:1;    /* UNUSED */
        unsigned int undefined_bits_13_15:3;
        unsigned int dst_rd_tile_mode:1;    /* Same as destination write unless DST_RD_WR_SEP (not supported) */
        unsigned int undefined_bits_17_19:3;
        unsigned int dst_wr_tile_mode:1;    /* destination surface */
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2tilemode_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2tilemode_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2tilemode_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.src_y_tile_mode, new_value_t.src_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: src_uv_tile_mode:1",
              "UV surface, ignored in RGB mode",
              1, old_value_t.src_uv_tile_mode, new_value_t.src_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: pat_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.pat_y_tile_mode, new_value_t.pat_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: pat_uv_tile_mode:1",
              "UNUSED",
              1, old_value_t.pat_uv_tile_mode, new_value_t.pat_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dst_rd_tile_mode:1",
              "Same as destination write unless DST_RD_WR_SEP (not supported)",
              1, old_value_t.dst_rd_tile_mode, new_value_t.dst_rd_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: dst_wr_tile_mode:1",
              "destination surface",
              1, old_value_t.dst_wr_tile_mode, new_value_t.dst_wr_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2PATBASE_OFFSET 0x8047
#define G2SB_CTX2_G2PATBASE_UNDEFMASK 0x00000000
union g2sb_ctx2_g2patbase_u {
    struct {
        unsigned int pat_base:32;           /* pattern base address in tile mode,  PATBA is the linear address where pixel start */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2patbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2patbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2patbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pat_base:32",
              "pattern base address in tile mode,  PATBA is the linear address where pixel start",
              32, old_value_t.pat_base, new_value_t.pat_base };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2SRCBA_SB_SURFBASE_OFFSET 0x8048
#define G2SB_CTX2_G2SRCBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx2_g2srcba_sb_surfbase_u {
    struct {
        unsigned int src_addr:32;           /* surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2srcba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2srcba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2srcba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_addr:32",
              "surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine",
              32, old_value_t.src_addr, new_value_t.src_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2DSTBA_SB_SURFBASE_OFFSET 0x8049
#define G2SB_CTX2_G2DSTBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx2_g2dstba_sb_surfbase_u {
    struct {
        unsigned int dst_addr:32;           /* surface address corresponding to G2DSTBA Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2dstba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2dstba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2dstba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_addr:32",
              "surface address corresponding to G2DSTBA Only used by the StretchBlit Engine",
              32, old_value_t.dst_addr, new_value_t.dst_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2DSTBA_B_SB_SURFBASE_OFFSET 0x804A
#define G2SB_CTX2_G2DSTBA_B_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx2_g2dstba_b_sb_surfbase_u {
    struct {
        unsigned int dst_b_addr:32;         /* surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2dstba_b_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2dstba_b_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2dstba_b_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_b_addr:32",
              "surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled",
              32, old_value_t.dst_b_addr, new_value_t.dst_b_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2VBA_A_SB_SURFBASE_OFFSET 0x804B
#define G2SB_CTX2_G2VBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx2_g2vba_a_sb_surfbase_u {
    struct {
        unsigned int v_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2vba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2vba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2vba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine",
              32, old_value_t.v_addr, new_value_t.v_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX2_G2UBA_A_SB_SURFBASE_OFFSET 0x804C
#define G2SB_CTX2_G2UBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx2_g2uba_a_sb_surfbase_u {
    struct {
        unsigned int u_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx2_g2uba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx2_g2uba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx2_g2uba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: u_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine",
              32, old_value_t.u_addr, new_value_t.u_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_INCR_SYNCPT_OFFSET 0x1000
#define G2SB_CTX3_INCR_SYNCPT_UNDEFMASK 0xFFFF0000
union g2sb_ctx3_incr_syncpt_u {
    struct {
        unsigned int indx:8;                /* syncpt index value */
        unsigned int cond:8;                /* Condition mapped from raise/wait */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_incr_syncpt_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_incr_syncpt_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_incr_syncpt_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: indx:8",
              "syncpt index value",
              8, old_value_t.indx, new_value_t.indx };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cond:8",
              "Condition mapped from raise/wait",
              8, old_value_t.cond, new_value_t.cond };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_INCR_SYNCPT_CNTRL_OFFSET 0x1001
#define G2SB_CTX3_INCR_SYNCPT_CNTRL_UNDEFMASK 0xFFFFFEFE
union g2sb_ctx3_incr_syncpt_cntrl_u {
    struct {
        unsigned int incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs. */
        unsigned int undefined_bits_1_7:7;
        unsigned int incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled. */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_incr_syncpt_cntrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_incr_syncpt_cntrl_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_incr_syncpt_cntrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: incr_syncpt_soft_reset:1",
              "If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs.",
              1, old_value_t.incr_syncpt_soft_reset, new_value_t.incr_syncpt_soft_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: incr_syncpt_no_stall:1",
              "If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled.",
              1, old_value_t.incr_syncpt_no_stall, new_value_t.incr_syncpt_no_stall };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_INCR_SYNCPT_ERROR_OFFSET 0x1002
#define G2SB_CTX3_INCR_SYNCPT_ERROR_UNDEFMASK 0x00000000
union g2sb_ctx3_incr_syncpt_error_u {
    struct {
        unsigned int cond_status:32;        /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_incr_syncpt_error_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_incr_syncpt_error_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_incr_syncpt_error_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cond_status:32",
              "COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero",
              32, old_value_t.cond_status, new_value_t.cond_status };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CLASSCHANNEL_REGONLY_OFFSET 0x1008
#define G2SB_CTX3_G2CLASSCHANNEL_REGONLY_UNDEFMASK 0xFFE0FC00
union g2sb_ctx3_g2classchannel_regonly_u {
    struct {
        unsigned int curr_class:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int curr_channel:4;
        unsigned int ctx_valid:1;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2classchannel_regonly_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2classchannel_regonly_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2classchannel_regonly_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: curr_class:10", "", 10, old_value_t.curr_class, new_value_t.curr_class };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_15:6", "", 6, old_value_t.undefined_bits_10_15, new_value_t.undefined_bits_10_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: curr_channel:4", "", 4, old_value_t.curr_channel, new_value_t.curr_channel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ctx_valid:1", "", 1, old_value_t.ctx_valid, new_value_t.ctx_valid };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2TRIGGER_OFFSET 0x1009
#define G2SB_CTX3_G2TRIGGER_UNDEFMASK 0xFFFF0000
union g2sb_ctx3_g2trigger_u {
    struct {
        unsigned int trigger:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2trigger_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2trigger_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2trigger_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger:16", "", 16, old_value_t.trigger, new_value_t.trigger };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2TRIGGER1_OFFSET 0x100A
#define G2SB_CTX3_G2TRIGGER1_UNDEFMASK 0xFFFF0000
union g2sb_ctx3_g2trigger1_u {
    struct {
        unsigned int trigger1:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2trigger1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2trigger1_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2trigger1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger1:16", "", 16, old_value_t.trigger1, new_value_t.trigger1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2TRIGGER2_OFFSET 0x100B
#define G2SB_CTX3_G2TRIGGER2_UNDEFMASK 0xFFFF0000
union g2sb_ctx3_g2trigger2_u {
    struct {
        unsigned int trigger2:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2trigger2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2trigger2_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2trigger2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger2:16", "", 16, old_value_t.trigger2, new_value_t.trigger2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CMDSEL_OFFSET 0x100C
#define G2SB_CTX3_G2CMDSEL_UNDEFMASK 0xE000280E
union g2sb_ctx3_g2cmdsel_u {
    struct {
        unsigned int sbor2d:1;
        unsigned int undefined_bits_1_3:3;
        unsigned int cbenable:1;            /* circular buffer feature enable    0= disable */
        unsigned int vitrigger:1;           /* VI trigger enable, can be circular buffer or full frame */
        unsigned int hosttrigger:1;         /* host trigger the command, host also need program cicular buffer related data */
        unsigned int cbsbdisable:1;
        unsigned int g2output:2;            /* 00: to memory 01: to EPP */
        unsigned int clip_source_top_bottom:1;/* Reserved for HW Test, SW should not use this bit. */
        unsigned int undefined_bit_11:1;
        unsigned int link_wait_buf_end:1;
        unsigned int undefined_bit_13:1;
        unsigned int frame_start:1;         /* host writes this bit to tell which buffer is ready */
        unsigned int frame_end:1;
        unsigned int buffer_index:8;
        unsigned int linken:1;              /* Test purpose */
        unsigned int linkval:3;
        unsigned int priority:1;            /* indicates priority of the context, note vi-triggered contexts take priority over HIGH */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2cmdsel_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2cmdsel_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2cmdsel_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sbor2d:1", "", 1, old_value_t.sbor2d, new_value_t.sbor2d };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: cbenable:1",
              "circular buffer feature enable   \n0= disable",
              1, old_value_t.cbenable, new_value_t.cbenable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: vitrigger:1",
              "VI trigger enable, can be circular buffer or full frame",
              1, old_value_t.vitrigger, new_value_t.vitrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "06: hosttrigger:1",
              "host trigger the command, host also need program cicular buffer related data",
              1, old_value_t.hosttrigger, new_value_t.hosttrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "07: cbsbdisable:1", "", 1, old_value_t.cbsbdisable, new_value_t.cbsbdisable };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g2output:2",
              "00: to memory 01: to EPP",
              2, old_value_t.g2output, new_value_t.g2output };
    m_bit_details_model.bits.append(entry);
    entry = { "10: clip_source_top_bottom:1",
              "Reserved for HW Test, SW should not use this bit.",
              1, old_value_t.clip_source_top_bottom, new_value_t.clip_source_top_bottom };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: link_wait_buf_end:1", "", 1, old_value_t.link_wait_buf_end, new_value_t.link_wait_buf_end };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: frame_start:1",
              "host writes this bit to tell which buffer is ready",
              1, old_value_t.frame_start, new_value_t.frame_start };
    m_bit_details_model.bits.append(entry);
    entry = { "15: frame_end:1", "", 1, old_value_t.frame_end, new_value_t.frame_end };
    m_bit_details_model.bits.append(entry);
    entry = { "16: buffer_index:8", "", 8, old_value_t.buffer_index, new_value_t.buffer_index };
    m_bit_details_model.bits.append(entry);
    entry = { "24: linken:1",
              "Test purpose",
              1, old_value_t.linken, new_value_t.linken };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linkval:3", "", 3, old_value_t.linkval, new_value_t.linkval };
    m_bit_details_model.bits.append(entry);
    entry = { "28: priority:1",
              "indicates priority of the context, note vi-triggered contexts take priority over HIGH",
              1, old_value_t.priority, new_value_t.priority };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2RAISE_OFFSET 0x100D
#define G2SB_CTX3_G2RAISE_UNDEFMASK 0xFFF0FFE0
union g2sb_ctx3_g2raise_u {
    struct {
        unsigned int raise:5;               /* Push back to read fifo when all commands in the channel are done.           */
        unsigned int undefined_bits_5_15:11;
        unsigned int raisechannel:4;
        unsigned int undefined_bits_20_31:12;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2raise_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2raise_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2raise_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: raise:5",
              "Push back to read fifo when all commands in the channel are done.",
              5, old_value_t.raise, new_value_t.raise };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_15:11", "", 11, old_value_t.undefined_bits_5_15, new_value_t.undefined_bits_5_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisechannel:4", "", 4, old_value_t.raisechannel, new_value_t.raisechannel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_31:12", "", 12, old_value_t.undefined_bits_20_31, new_value_t.undefined_bits_20_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2HOSTSET_OFFSET 0x100F
#define G2SB_CTX3_G2HOSTSET_UNDEFMASK 0xFFFFFF00
union g2sb_ctx3_g2hostset_u {
    struct {
        unsigned int hstlngap:4;            /*  specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte) */
        unsigned int hstfpxl:4;             /* specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2hostset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2hostset_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2hostset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hstlngap:4",
              " specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte)",
              4, old_value_t.hstlngap, new_value_t.hstlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: hstfpxl:4",
              "specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary",
              4, old_value_t.hstfpxl, new_value_t.hstfpxl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2HOSTFIFO_OFFSET 0x1010
#define G2SB_CTX3_G2HOSTFIFO_UNDEFMASK 0x00000000
union g2sb_ctx3_g2hostfifo_u {
    struct {
        unsigned int hostfifodata:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2hostfifo_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2hostfifo_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2hostfifo_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hostfifodata:32", "", 32, old_value_t.hostfifodata, new_value_t.hostfifodata };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2VDDA_OFFSET 0x1011
#define G2SB_CTX3_G2VDDA_UNDEFMASK 0x00000000
union g2sb_ctx3_g2vdda_u {
    struct {
        unsigned int vdstep:32;             /* Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2vdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2vdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2vdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdstep:32",
              "Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010.",
              32, old_value_t.vdstep, new_value_t.vdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2VDDAINI_OFFSET 0x1012
#define G2SB_CTX3_G2VDDAINI_UNDEFMASK 0xFFFF0000
union g2sb_ctx3_g2vddaini_u {
    struct {
        unsigned int vdtini:8;              /* Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window. */
        unsigned int vdbini:8;              /* Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above) */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2vddaini_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2vddaini_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2vddaini_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdtini:8",
              "Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window.",
              8, old_value_t.vdtini, new_value_t.vdtini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: vdbini:8",
              "Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above)",
              8, old_value_t.vdbini, new_value_t.vdbini };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2HDDA_OFFSET 0x1013
#define G2SB_CTX3_G2HDDA_UNDEFMASK 0x00000000
union g2sb_ctx3_g2hdda_u {
    struct {
        unsigned int hdstep:32;             /* Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2hdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2hdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2hdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdstep:32",
              "Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101.",
              32, old_value_t.hdstep, new_value_t.hdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2HDDAINILS_OFFSET 0x1014
#define G2SB_CTX3_G2HDDAINILS_UNDEFMASK 0xFFFFFF00
union g2sb_ctx3_g2hddainils_u {
    struct {
        unsigned int hdini:8;               /* Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0. */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2hddainils_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2hddainils_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2hddainils_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdini:8",
              "Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0.",
              8, old_value_t.hdini, new_value_t.hdini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CSCFIRST_OFFSET 0x1015
#define G2SB_CTX3_G2CSCFIRST_UNDEFMASK 0x00C00C00
union g2sb_ctx3_g2cscfirst_u {
    struct {
        unsigned int cub:10;                /* multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved  */
        unsigned int undefined_bits_10_11:2;
        unsigned int cvr:10;                /* multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved */
        unsigned int undefined_bits_22_23:2;
        unsigned int yos:8;                 /* Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2cscfirst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2cscfirst_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2cscfirst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cub:10",
              "multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved",
              10, old_value_t.cub, new_value_t.cub };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_11:2", "", 2, old_value_t.undefined_bits_10_11, new_value_t.undefined_bits_10_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cvr:10",
              "multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved",
              10, old_value_t.cvr, new_value_t.cvr };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: yos:8",
              "Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10",
              8, old_value_t.yos, new_value_t.yos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CSCSECOND_OFFSET 0x1016
#define G2SB_CTX3_G2CSCSECOND_UNDEFMASK 0x00C00E00
union g2sb_ctx3_g2cscsecond_u {
    struct {
        unsigned int cug:9;                 /* multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved */
        unsigned int undefined_bits_9_11:3;
        unsigned int cur:10;                /* multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved  */
        unsigned int undefined_bits_22_23:2;
        unsigned int cyx:8;                 /* multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2cscsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2cscsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2cscsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cug:9",
              "multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved",
              9, old_value_t.cug, new_value_t.cug };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cur:10",
              "multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved",
              10, old_value_t.cur, new_value_t.cur };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cyx:8",
              "multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041",
              8, old_value_t.cyx, new_value_t.cyx };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CSCTHIRD_OFFSET 0x1017
#define G2SB_CTX3_G2CSCTHIRD_UNDEFMASK 0xFC00FE00
union g2sb_ctx3_g2cscthird_u {
    struct {
        unsigned int cvg:9;                 /* multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113 */
        unsigned int undefined_bits_9_15:7;
        unsigned int cvb:10;                /* multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021 */
        unsigned int undefined_bits_26_31:6;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2cscthird_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2cscthird_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2cscthird_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cvg:9",
              "multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113",
              9, old_value_t.cvg, new_value_t.cvg };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cvb:10",
              "multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021",
              10, old_value_t.cvb, new_value_t.cvb };
    m_bit_details_model.bits.append(entry);
    entry = { "26: undefined_bits_26_31:6", "", 6, old_value_t.undefined_bits_26_31, new_value_t.undefined_bits_26_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CMKEYL_OFFSET 0x1018
#define G2SB_CTX3_G2CMKEYL_UNDEFMASK 0xFF000000
union g2sb_ctx3_g2cmkeyl_u {
    struct {
        unsigned int ckbl:8;                /* B or Y Color/Chroma Key Lower Limit (CKBL[7:0]) */
        unsigned int ckgl:8;                /* G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level. */
        unsigned int ckrl:8;                /* R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2cmkeyl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2cmkeyl_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2cmkeyl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbl:8",
              "B or Y Color/Chroma Key Lower Limit (CKBL[7:0])",
              8, old_value_t.ckbl, new_value_t.ckbl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgl:8",
              "G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgl, new_value_t.ckgl };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckrl:8",
              "R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved",
              8, old_value_t.ckrl, new_value_t.ckrl };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CMKEYU_OFFSET 0x1019
#define G2SB_CTX3_G2CMKEYU_UNDEFMASK 0xFF000000
union g2sb_ctx3_g2cmkeyu_u {
    struct {
        unsigned int ckbu:8;                /* This is B or Y color/chroma key upper limit value. */
        unsigned int ckgu:8;                /* G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level. */
        unsigned int ckru:8;                /* R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2cmkeyu_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2cmkeyu_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2cmkeyu_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbu:8",
              "This is B or Y color/chroma key upper limit value.",
              8, old_value_t.ckbu, new_value_t.ckbu };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgu:8",
              "G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgu, new_value_t.ckgu };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckru:8",
              "R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved",
              8, old_value_t.ckru, new_value_t.ckru };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2UBA_A_OFFSET 0x101A
#define G2SB_CTX3_G2UBA_A_UNDEFMASK 0x00000000
union g2sb_ctx3_g2uba_a_u {
    struct {
        unsigned int su1sa:32;              /* Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2uba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2uba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2uba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: su1sa:32",
              "Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.su1sa, new_value_t.su1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2VBA_A_OFFSET 0x101B
#define G2SB_CTX3_G2VBA_A_UNDEFMASK 0x00000000
union g2sb_ctx3_g2vba_a_u {
    struct {
        unsigned int sv1sa:32;              /* Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2vba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2vba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2vba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sv1sa:32",
              "Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.sv1sa, new_value_t.sv1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2SBFORMAT_OFFSET 0x101C
#define G2SB_CTX3_G2SBFORMAT_UNDEFMASK 0x000020E0
union g2sb_ctx3_g2sbformat_u {
    struct {
        unsigned int sifmt:5;               /* This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV. */
        unsigned int undefined_bits_5_7:3;
        unsigned int difmt:5;               /* Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED */
        unsigned int undefined_bit_13:1;
        unsigned int raisebufferen:1;       /* ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.  */
        unsigned int raiseframeen:1;        /* ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.  */
        unsigned int raisebuffervalue:8;    /* Raise buffer vector value. */
        unsigned int raiseframevalue:8;     /* Raise Fram vector value. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2sbformat_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2sbformat_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2sbformat_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sifmt:5",
              "This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV.",
              5, old_value_t.sifmt, new_value_t.sifmt };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: difmt:5",
              "Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED",
              5, old_value_t.difmt, new_value_t.difmt };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: raisebufferen:1",
              "ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raisebufferen, new_value_t.raisebufferen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: raiseframeen:1",
              "ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raiseframeen, new_value_t.raiseframeen };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisebuffervalue:8",
              "Raise buffer vector value.",
              8, old_value_t.raisebuffervalue, new_value_t.raisebuffervalue };
    m_bit_details_model.bits.append(entry);
    entry = { "24: raiseframevalue:8",
              "Raise Fram vector value.",
              8, old_value_t.raiseframevalue, new_value_t.raiseframevalue };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CONTROLSB_OFFSET 0x101D
#define G2SB_CTX3_G2CONTROLSB_UNDEFMASK 0x20005807
union g2sb_ctx3_g2controlsb_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int yuv422rotation:1;      /* yuv422 plannar rotated */
        unsigned int yuv422planar:1;        /* source data is yuv422 planar valid when imode==PLANAR */
        unsigned int imode:1;               /* Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d. */
        unsigned int enavf:1;               /* enable alpha vertical filter     */
        unsigned int enahf:1;               /* enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format, */
        unsigned int uvst:2;                /*   00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.   11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride). */
        unsigned int sl:1;                  /* Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines. */
        unsigned int undefined_bits_11_12:2;
        unsigned int sisel:1;               /* StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved  */
        unsigned int undefined_bit_14:1;
        unsigned int sbltsrc:1;             /* StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator. */
        unsigned int vftype:2;              /* StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager. */
        unsigned int vfen:1;                /* StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled. */
        unsigned int discsc:1;              /* enabled color space converter by default */
        unsigned int hftype:3;              /* StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE. */
        unsigned int rangeredfrm:1;         /* In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.  */
        unsigned int sitype:1;              /* StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?. */
        unsigned int sbsel:1;               /* StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer. */
        unsigned int dbsel:1;               /* StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer. */
        unsigned int keyen:1;               /* Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled. */
        unsigned int kpol:1;                /* Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range. */
        unsigned int undefined_bit_29:1;
        unsigned int endith:1;              /* Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering */
        unsigned int disdw:1;               /* output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2controlsb_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2controlsb_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2controlsb_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_2:3", "", 3, old_value_t.undefined_bits_0_2, new_value_t.undefined_bits_0_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: yuv422rotation:1",
              "yuv422 plannar rotated",
              1, old_value_t.yuv422rotation, new_value_t.yuv422rotation };
    m_bit_details_model.bits.append(entry);
    entry = { "04: yuv422planar:1",
              "source data is yuv422 planar valid when imode==PLANAR",
              1, old_value_t.yuv422planar, new_value_t.yuv422planar };
    m_bit_details_model.bits.append(entry);
    entry = { "05: imode:1",
              "Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d.",
              1, old_value_t.imode, new_value_t.imode };
    m_bit_details_model.bits.append(entry);
    entry = { "06: enavf:1",
              "enable alpha vertical filter",
              1, old_value_t.enavf, new_value_t.enavf };
    m_bit_details_model.bits.append(entry);
    entry = { "07: enahf:1",
              "enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format,",
              1, old_value_t.enahf, new_value_t.enahf };
    m_bit_details_model.bits.append(entry);
    entry = { "08: uvst:2",
              " \n00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.\n11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride).",
              2, old_value_t.uvst, new_value_t.uvst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: sl:1",
              "Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines.",
              1, old_value_t.sl, new_value_t.sl };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_12:2", "", 2, old_value_t.undefined_bits_11_12, new_value_t.undefined_bits_11_12 };
    m_bit_details_model.bits.append(entry);
    entry = { "13: sisel:1",
              "StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved",
              1, old_value_t.sisel, new_value_t.sisel };
    m_bit_details_model.bits.append(entry);
    entry = { "14: undefined_bit_14:1", "", 1, old_value_t.undefined_bit_14, new_value_t.undefined_bit_14 };
    m_bit_details_model.bits.append(entry);
    entry = { "15: sbltsrc:1",
              "StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator.",
              1, old_value_t.sbltsrc, new_value_t.sbltsrc };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vftype:2",
              "StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager.",
              2, old_value_t.vftype, new_value_t.vftype };
    m_bit_details_model.bits.append(entry);
    entry = { "18: vfen:1",
              "StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled.",
              1, old_value_t.vfen, new_value_t.vfen };
    m_bit_details_model.bits.append(entry);
    entry = { "19: discsc:1",
              "enabled color space converter by default",
              1, old_value_t.discsc, new_value_t.discsc };
    m_bit_details_model.bits.append(entry);
    entry = { "20: hftype:3",
              "StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE.",
              3, old_value_t.hftype, new_value_t.hftype };
    m_bit_details_model.bits.append(entry);
    entry = { "23: rangeredfrm:1",
              "In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.",
              1, old_value_t.rangeredfrm, new_value_t.rangeredfrm };
    m_bit_details_model.bits.append(entry);
    entry = { "24: sitype:1",
              "StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?.",
              1, old_value_t.sitype, new_value_t.sitype };
    m_bit_details_model.bits.append(entry);
    entry = { "25: sbsel:1",
              "StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer.",
              1, old_value_t.sbsel, new_value_t.sbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "26: dbsel:1",
              "StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer.",
              1, old_value_t.dbsel, new_value_t.dbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "27: keyen:1",
              "Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled.",
              1, old_value_t.keyen, new_value_t.keyen };
    m_bit_details_model.bits.append(entry);
    entry = { "28: kpol:1",
              "Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range.",
              1, old_value_t.kpol, new_value_t.kpol };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: endith:1",
              "Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering",
              1, old_value_t.endith, new_value_t.endith };
    m_bit_details_model.bits.append(entry);
    entry = { "31: disdw:1",
              "output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place.",
              1, old_value_t.disdw, new_value_t.disdw };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CONTROLSECOND_OFFSET 0x101E
#define G2SB_CTX3_G2CONTROLSECOND_UNDEFMASK 0xC08E3C01
union g2sb_ctx3_g2controlsecond_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int bitswap:1;             /* Host port bit swap 1=enable   0= disable   1= enable */
        unsigned int bebswap:1;             /* Host port byte swap 1=enable   0= disable   1= enable */
        unsigned int bewswap:1;             /* Host port word swap 1=enable   0= disable */
        unsigned int alptype:5;             /* Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits. */
        unsigned int alpsrcordst:1;         /* 32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha */
        unsigned int undefined_bits_10_13:4;
        unsigned int pxlrep:1;              /* Pixel replication for Palm OS. */
        unsigned int swapblt:1;             /* Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area */
        unsigned int vcaa_safe_mode:1;      /* VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken. */
        unsigned int undefined_bits_17_19:3;
        unsigned int g2nostop:1;
        unsigned int clipc:2;               /* Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,  10=draw only inside clipping rectangle,  11=draw only outside clipping rectangle */
        unsigned int undefined_bit_23:1;
        unsigned int fr_mode:2;             /* Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice. 00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so! 01 = src/dst copy mode - two separate buffers 10 = square in place - one buffer 11 = blank */
        unsigned int fr_type:3;             /*  Fast Rotate type     000 = FLIP_X  001 = FLIP_Y  010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right) 011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left) 100 = ROT_90 (counter clock wise by 90 degrees) 101 = ROT_180  110 = ROT_270 (clock wise by 90 degrees) 111 = IDENTITY */
        unsigned int fr_readwait:1;         /*  Fast Rotate wait for read 0 = disable 1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only. */
        unsigned int undefined_bits_30_31:2;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2controlsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2controlsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2controlsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bit_0:1", "", 1, old_value_t.undefined_bit_0, new_value_t.undefined_bit_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "01: bitswap:1",
              "Host port bit swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bitswap, new_value_t.bitswap };
    m_bit_details_model.bits.append(entry);
    entry = { "02: bebswap:1",
              "Host port byte swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bebswap, new_value_t.bebswap };
    m_bit_details_model.bits.append(entry);
    entry = { "03: bewswap:1",
              "Host port word swap\n1=enable  \n0= disable",
              1, old_value_t.bewswap, new_value_t.bewswap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: alptype:5",
              "Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits.",
              5, old_value_t.alptype, new_value_t.alptype };
    m_bit_details_model.bits.append(entry);
    entry = { "09: alpsrcordst:1",
              "32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha",
              1, old_value_t.alpsrcordst, new_value_t.alpsrcordst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_13:4", "", 4, old_value_t.undefined_bits_10_13, new_value_t.undefined_bits_10_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: pxlrep:1",
              "Pixel replication for Palm OS.",
              1, old_value_t.pxlrep, new_value_t.pxlrep };
    m_bit_details_model.bits.append(entry);
    entry = { "15: swapblt:1",
              "Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area",
              1, old_value_t.swapblt, new_value_t.swapblt };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vcaa_safe_mode:1",
              "VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken.",
              1, old_value_t.vcaa_safe_mode, new_value_t.vcaa_safe_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: g2nostop:1", "", 1, old_value_t.g2nostop, new_value_t.g2nostop };
    m_bit_details_model.bits.append(entry);
    entry = { "21: clipc:2",
              "Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,\n10=draw only inside clipping rectangle,\n11=draw only outside clipping rectangle",
              2, old_value_t.clipc, new_value_t.clipc };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fr_mode:2",
              "Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice.\n00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so!\n01 = src/dst copy mode - two separate buffers\n10 = square in place - one buffer\n11 = blank",
              2, old_value_t.fr_mode, new_value_t.fr_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "26: fr_type:3",
              " Fast Rotate type    \n000 = FLIP_X \n001 = FLIP_Y \n010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right)\n011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left)\n100 = ROT_90 (counter clock wise by 90 degrees)\n101 = ROT_180 \n110 = ROT_270 (clock wise by 90 degrees)\n111 = IDENTITY",
              3, old_value_t.fr_type, new_value_t.fr_type };
    m_bit_details_model.bits.append(entry);
    entry = { "29: fr_readwait:1",
              " Fast Rotate wait for read\n0 = disable\n1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only.",
              1, old_value_t.fr_readwait, new_value_t.fr_readwait };
    m_bit_details_model.bits.append(entry);
    entry = { "30: undefined_bits_30_31:2", "", 2, old_value_t.undefined_bits_30_31, new_value_t.undefined_bits_30_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CONTROLMAIN_OFFSET 0x101F
#define G2SB_CTX3_G2CONTROLMAIN_UNDEFMASK 0x80000000
union g2sb_ctx3_g2controlmain_u {
    struct {
        unsigned int cmdt:2;                /* Command Type:  00=BitBlt 01=Line Draw  10=VCAA 11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed) */
        unsigned int turbofill:1;           /* fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified. */
        unsigned int test0bit:1;            /* Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish. */
        unsigned int faden:1;               /* BitBlt Source Copy Fade enable, 1=enable (share with mltln), only support  16bpp mode */
        unsigned int alpen:1;               /* BitBlt Alpha Blending, 1=enable. 0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype */
        unsigned int srcsld:1;              /* BitBlt Solid Source Color Fill: 1=enable. FGC will be used as  the color value. */
        unsigned int patsld:1;              /* BitBlt Solid Pattern Fill: 1=enable. BGC will be used as  the color value. */
        unsigned int patfl:1;               /* When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+ */
        unsigned int xdir:1;                /*  0=incrementing, 1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0 */
        unsigned int ydir:1;                /*  0=incrementing, 1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0 */
        unsigned int xytdw:1;               /* xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination. */
        unsigned int srcpack:1;             /* Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled. */
        unsigned int patpack:1;             /* Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled. */
        unsigned int yflip:1;               /* flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination. */
        unsigned int srcsel:1;              /* Source Data Select: */
        unsigned int dstcd:2;               /* Destination color depth:   00=8-bpp, 01=16-bpp, 10=32-bpp. 11=reserved */
        unsigned int dstt:2;                /* Destination read transparency enable:   0x=destination read transparency disabled   10=color destination read transparency   11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately, 0=wait for launch write) */
        unsigned int srccd:1;               /* 0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0 */
        unsigned int hlmono:1;              /* Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit */
        unsigned int srct:2;                /* Source transparency enable: 0x=source transparency disabled,  10=mono source background transparency     or color source transparency,  11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied. */
        unsigned int srcbas:1;              /* Source base address select:   0=srcba, 1=dstba. This is not used for Line Draw and  if source data comes from host memory. */
        unsigned int gcsw:2;                /* Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used */
        unsigned int srcdir:1;              /* source direct addressing */
        unsigned int dstdir:1;              /* destination direct addressing */
        unsigned int dst_rd_wr_sep:1;       /* This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA */
        unsigned int patsel:1;              /* pattern Data Select: SRCSEL and PATSEL can't be both enabled. */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2controlmain_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2controlmain_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2controlmain_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cmdt:2",
              "Command Type: \n00=BitBlt\n01=Line Draw \n10=VCAA\n11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed)",
              2, old_value_t.cmdt, new_value_t.cmdt };
    m_bit_details_model.bits.append(entry);
    entry = { "02: turbofill:1",
              "fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified.",
              1, old_value_t.turbofill, new_value_t.turbofill };
    m_bit_details_model.bits.append(entry);
    entry = { "03: test0bit:1",
              "Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish.",
              1, old_value_t.test0bit, new_value_t.test0bit };
    m_bit_details_model.bits.append(entry);
    entry = { "04: faden:1",
              "BitBlt Source Copy Fade enable,\n1=enable (share with mltln), only support  16bpp mode",
              1, old_value_t.faden, new_value_t.faden };
    m_bit_details_model.bits.append(entry);
    entry = { "05: alpen:1",
              "BitBlt Alpha Blending,\n1=enable.\n0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype",
              1, old_value_t.alpen, new_value_t.alpen };
    m_bit_details_model.bits.append(entry);
    entry = { "06: srcsld:1",
              "BitBlt Solid Source Color Fill:\n1=enable. FGC will be used as  the color value.",
              1, old_value_t.srcsld, new_value_t.srcsld };
    m_bit_details_model.bits.append(entry);
    entry = { "07: patsld:1",
              "BitBlt Solid Pattern Fill:\n1=enable. BGC will be used as  the color value.",
              1, old_value_t.patsld, new_value_t.patsld };
    m_bit_details_model.bits.append(entry);
    entry = { "08: patfl:1",
              "When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+",
              1, old_value_t.patfl, new_value_t.patfl };
    m_bit_details_model.bits.append(entry);
    entry = { "09: xdir:1",
              "0=incrementing,\n1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0",
              1, old_value_t.xdir, new_value_t.xdir };
    m_bit_details_model.bits.append(entry);
    entry = { "10: ydir:1",
              "0=incrementing,\n1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0",
              1, old_value_t.ydir, new_value_t.ydir };
    m_bit_details_model.bits.append(entry);
    entry = { "11: xytdw:1",
              "xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination.",
              1, old_value_t.xytdw, new_value_t.xytdw };
    m_bit_details_model.bits.append(entry);
    entry = { "12: srcpack:1",
              "Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.srcpack, new_value_t.srcpack };
    m_bit_details_model.bits.append(entry);
    entry = { "13: patpack:1",
              "Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.patpack, new_value_t.patpack };
    m_bit_details_model.bits.append(entry);
    entry = { "14: yflip:1",
              "flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination.",
              1, old_value_t.yflip, new_value_t.yflip };
    m_bit_details_model.bits.append(entry);
    entry = { "15: srcsel:1",
              "Source Data Select:",
              1, old_value_t.srcsel, new_value_t.srcsel };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstcd:2",
              "Destination color depth:  \n00=8-bpp,\n01=16-bpp,\n10=32-bpp.\n11=reserved",
              2, old_value_t.dstcd, new_value_t.dstcd };
    m_bit_details_model.bits.append(entry);
    entry = { "18: dstt:2",
              "Destination read transparency enable:   0x=destination read transparency disabled  \n10=color destination read transparency  \n11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately,\n0=wait for launch write)",
              2, old_value_t.dstt, new_value_t.dstt };
    m_bit_details_model.bits.append(entry);
    entry = { "20: srccd:1",
              "0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0",
              1, old_value_t.srccd, new_value_t.srccd };
    m_bit_details_model.bits.append(entry);
    entry = { "21: hlmono:1",
              "Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit",
              1, old_value_t.hlmono, new_value_t.hlmono };
    m_bit_details_model.bits.append(entry);
    entry = { "22: srct:2",
              "Source transparency enable: 0x=source transparency disabled,\n10=mono source background transparency     or color source transparency,\n11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied.",
              2, old_value_t.srct, new_value_t.srct };
    m_bit_details_model.bits.append(entry);
    entry = { "24: srcbas:1",
              "Source base address select:  \n0=srcba,\n1=dstba. This is not used for Line Draw and  if source data comes from host memory.",
              1, old_value_t.srcbas, new_value_t.srcbas };
    m_bit_details_model.bits.append(entry);
    entry = { "25: gcsw:2",
              "Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used",
              2, old_value_t.gcsw, new_value_t.gcsw };
    m_bit_details_model.bits.append(entry);
    entry = { "27: srcdir:1",
              "source direct addressing",
              1, old_value_t.srcdir, new_value_t.srcdir };
    m_bit_details_model.bits.append(entry);
    entry = { "28: dstdir:1",
              "destination direct addressing",
              1, old_value_t.dstdir, new_value_t.dstdir };
    m_bit_details_model.bits.append(entry);
    entry = { "29: dst_rd_wr_sep:1",
              "This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA",
              1, old_value_t.dst_rd_wr_sep, new_value_t.dst_rd_wr_sep };
    m_bit_details_model.bits.append(entry);
    entry = { "30: patsel:1",
              "pattern Data Select: SRCSEL and PATSEL can't be both enabled.",
              1, old_value_t.patsel, new_value_t.patsel };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2ROPFADE_OFFSET 0x1020
#define G2SB_CTX3_G2ROPFADE_UNDEFMASK 0x0000FF00
union g2sb_ctx3_g2ropfade_u {
    struct {
        unsigned int rop:8;                 /* If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out. */
        unsigned int undefined_bits_8_15:8;
        unsigned int fadcoe:8;
        unsigned int fadoff:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2ropfade_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2ropfade_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2ropfade_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: rop:8",
              "If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out.",
              8, old_value_t.rop, new_value_t.rop };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: fadcoe:8", "", 8, old_value_t.fadcoe, new_value_t.fadcoe };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fadoff:8", "", 8, old_value_t.fadoff, new_value_t.fadoff };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2ALPHABLEND_OFFSET 0x1021
#define G2SB_CTX3_G2ALPHABLEND_UNDEFMASK 0x0000FE00
union g2sb_ctx3_g2alphablend_u {
    struct {
        unsigned int alpha:8;
        unsigned int alphainv:1;
        unsigned int undefined_bits_9_15:7;
        unsigned int alpha0v:8;
        unsigned int alpha1v:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2alphablend_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2alphablend_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2alphablend_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: alpha:8", "", 8, old_value_t.alpha, new_value_t.alpha };
    m_bit_details_model.bits.append(entry);
    entry = { "08: alphainv:1", "", 1, old_value_t.alphainv, new_value_t.alphainv };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: alpha0v:8", "", 8, old_value_t.alpha0v, new_value_t.alpha0v };
    m_bit_details_model.bits.append(entry);
    entry = { "24: alpha1v:8", "", 8, old_value_t.alpha1v, new_value_t.alpha1v };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CLIPLEFTTOP_OFFSET 0x1022
#define G2SB_CTX3_G2CLIPLEFTTOP_UNDEFMASK 0x80008000
union g2sb_ctx3_g2cliplefttop_u {
    struct {
        unsigned int clipl:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipt:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2cliplefttop_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2cliplefttop_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2cliplefttop_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipl:15", "", 15, old_value_t.clipl, new_value_t.clipl };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipt:15", "", 15, old_value_t.clipt, new_value_t.clipt };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CLIPRIGHTBOT_OFFSET 0x1023
#define G2SB_CTX3_G2CLIPRIGHTBOT_UNDEFMASK 0x80008000
union g2sb_ctx3_g2cliprightbot_u {
    struct {
        unsigned int clipr:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipb:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2cliprightbot_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2cliprightbot_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2cliprightbot_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipr:15", "", 15, old_value_t.clipr, new_value_t.clipr };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipb:15", "", 15, old_value_t.clipb, new_value_t.clipb };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2PATPACK_OFFSET 0x1024
#define G2SB_CTX3_G2PATPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx3_g2patpack_u {
    struct {
        unsigned int patlngap:4;            /* Packed mode, pattern data line gap. byte */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2patpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2patpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2patpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patlngap:4",
              "Packed mode, pattern data line gap. byte",
              4, old_value_t.patlngap, new_value_t.patlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2PATPACK_SIZE_OFFSET 0x1025
#define G2SB_CTX3_G2PATPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx3_g2patpack_size_u {
    struct {
        unsigned int patmonow:16;           /* Mono data width in packed mode, byte  */
        unsigned int patmonoh:16;           /*  Pattern mono data height in packed mode, byte  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2patpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2patpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2patpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patmonow:16",
              "Mono data width in packed mode, byte",
              16, old_value_t.patmonow, new_value_t.patmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patmonoh:16",
              " Pattern mono data height in packed mode, byte",
              16, old_value_t.patmonoh, new_value_t.patmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2PATBA_OFFSET 0x1026
#define G2SB_CTX3_G2PATBA_UNDEFMASK 0x00000000
union g2sb_ctx3_g2patba_u {
    struct {
        unsigned int patba:32;              /* If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. } */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2patba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2patba_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2patba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patba:32",
              "If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. }",
              32, old_value_t.patba, new_value_t.patba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2PATOS_OFFSET 0x1027
#define G2SB_CTX3_G2PATOS_UNDEFMASK 0x009E0000
union g2sb_ctx3_g2patos_u {
    struct {
        unsigned int patst:16;              /* stride */
        unsigned int patcd:1;               /* 0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0 */
        unsigned int undefined_bits_17_20:4;
        unsigned int patt:2;                /* Mono pattern transparency enable:  0x=pattern transparency disabled,  10=mono pattern background transparency    or color pattern transparency,  11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied. */
        unsigned int undefined_bit_23:1;
        unsigned int patxo:4;               /* x offset for mono tile pattern fill.  see PATFL */
        unsigned int patyo:4;               /* y offset for mono tile pattern fill.  see PATFL */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2patos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2patos_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2patos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patst:16",
              "stride",
              16, old_value_t.patst, new_value_t.patst };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patcd:1",
              "0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0",
              1, old_value_t.patcd, new_value_t.patcd };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_20:4", "", 4, old_value_t.undefined_bits_17_20, new_value_t.undefined_bits_17_20 };
    m_bit_details_model.bits.append(entry);
    entry = { "21: patt:2",
              "Mono pattern transparency enable:  0x=pattern transparency disabled,\n10=mono pattern background transparency    or color pattern transparency,\n11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied.",
              2, old_value_t.patt, new_value_t.patt };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: patxo:4",
              "x offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patxo, new_value_t.patxo };
    m_bit_details_model.bits.append(entry);
    entry = { "28: patyo:4",
              "y offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patyo, new_value_t.patyo };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2PATBGC_OFFSET 0x1028
#define G2SB_CTX3_G2PATBGC_UNDEFMASK 0x00000000
union g2sb_ctx3_g2patbgc_u {
    struct {
        unsigned int patbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2patbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2patbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2patbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patbgc:32", "", 32, old_value_t.patbgc, new_value_t.patbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2PATFGC_OFFSET 0x1029
#define G2SB_CTX3_G2PATFGC_UNDEFMASK 0x00000000
union g2sb_ctx3_g2patfgc_u {
    struct {
        unsigned int patfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2patfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2patfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2patfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patfgc:32", "", 32, old_value_t.patfgc, new_value_t.patfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2PATKEY_OFFSET 0x102A
#define G2SB_CTX3_G2PATKEY_UNDEFMASK 0x00000000
union g2sb_ctx3_g2patkey_u {
    struct {
        unsigned int patkey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2patkey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2patkey_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2patkey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patkey:32", "", 32, old_value_t.patkey, new_value_t.patkey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2DSTBA_OFFSET 0x102B
#define G2SB_CTX3_G2DSTBA_UNDEFMASK 0x00000000
union g2sb_ctx3_g2dstba_u {
    struct {
        unsigned int dstba:32;              /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2dstba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2dstba_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2dstba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba, new_value_t.dstba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2DSTBA_B_OFFSET 0x102C
#define G2SB_CTX3_G2DSTBA_B_UNDEFMASK 0x00000000
union g2sb_ctx3_g2dstba_b_u {
    struct {
        unsigned int dstba_b:32;            /* Destination base address (byte address) only usable in hardware trigger mode by enable gcsw */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2dstba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2dstba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2dstba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_b:32",
              "Destination base address (byte address) only usable in hardware trigger mode by enable gcsw",
              32, old_value_t.dstba_b, new_value_t.dstba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2DSTBA_C_OFFSET 0x102D
#define G2SB_CTX3_G2DSTBA_C_UNDEFMASK 0x00000000
union g2sb_ctx3_g2dstba_c_u {
    struct {
        unsigned int dstba_c:32;            /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2dstba_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2dstba_c_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2dstba_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_c:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba_c, new_value_t.dstba_c };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2DSTST_OFFSET 0x102E
#define G2SB_CTX3_G2DSTST_UNDEFMASK 0xFFFF0000
union g2sb_ctx3_g2dstst_u {
    struct {
        unsigned int dsts:16;               /* Destination Stride coordinate(bytes) with respect to DSTBA. */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2dstst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2dstst_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2dstst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dsts:16",
              "Destination Stride coordinate(bytes) with respect to DSTBA.",
              16, old_value_t.dsts, new_value_t.dsts };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2SRCPACK_OFFSET 0x102F
#define G2SB_CTX3_G2SRCPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx3_g2srcpack_u {
    struct {
        unsigned int srclngap:4;            /* Packed mode - source mono data line gap */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2srcpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2srcpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2srcpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srclngap:4",
              "Packed mode - source mono data line gap",
              4, old_value_t.srclngap, new_value_t.srclngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2SRCPACK_SIZE_OFFSET 0x1030
#define G2SB_CTX3_G2SRCPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx3_g2srcpack_size_u {
    struct {
        unsigned int srcmonow:16;           /* Packed mode - source mono data width in bytes */
        unsigned int srcmonoh:16;           /* Packed mode - source mono data height in bytes  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2srcpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2srcpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2srcpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcmonow:16",
              "Packed mode - source mono data width in bytes",
              16, old_value_t.srcmonow, new_value_t.srcmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcmonoh:16",
              "Packed mode - source mono data height in bytes",
              16, old_value_t.srcmonoh, new_value_t.srcmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2SRCBA_OFFSET 0x1031
#define G2SB_CTX3_G2SRCBA_UNDEFMASK 0x00000000
union g2sb_ctx3_g2srcba_u {
    struct {
        unsigned int srcba:32;              /* Source base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2srcba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2srcba_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2srcba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba:32",
              "Source base address (byte address)",
              32, old_value_t.srcba, new_value_t.srcba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2SRCBA_B_OFFSET 0x1032
#define G2SB_CTX3_G2SRCBA_B_UNDEFMASK 0x00000000
union g2sb_ctx3_g2srcba_b_u {
    struct {
        unsigned int srcba_b:32;            /* This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.) */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2srcba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2srcba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2srcba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba_b:32",
              "This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.)",
              32, old_value_t.srcba_b, new_value_t.srcba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2SRCST_OFFSET 0x1033
#define G2SB_CTX3_G2SRCST_UNDEFMASK 0xFFFF0000
union g2sb_ctx3_g2srcst_u {
    struct {
        unsigned int srcs:16;               /* Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.  */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2srcst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2srcst_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2srcst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs:16",
              "Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.",
              16, old_value_t.srcs, new_value_t.srcs };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2SRCBGC_OFFSET 0x1034
#define G2SB_CTX3_G2SRCBGC_UNDEFMASK 0x00000000
union g2sb_ctx3_g2srcbgc_u {
    struct {
        unsigned int srcbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2srcbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2srcbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2srcbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcbgc:32", "", 32, old_value_t.srcbgc, new_value_t.srcbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2SRCFGC_OFFSET 0x1035
#define G2SB_CTX3_G2SRCFGC_UNDEFMASK 0x00000000
union g2sb_ctx3_g2srcfgc_u {
    struct {
        unsigned int srcfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2srcfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2srcfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2srcfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcfgc:32", "", 32, old_value_t.srcfgc, new_value_t.srcfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2SRCKEY_OFFSET 0x1036
#define G2SB_CTX3_G2SRCKEY_UNDEFMASK 0x00000000
union g2sb_ctx3_g2srckey_u {
    struct {
        unsigned int srckey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2srckey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2srckey_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2srckey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srckey:32", "", 32, old_value_t.srckey, new_value_t.srckey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2SRCSIZE_OFFSET 0x1037
#define G2SB_CTX3_G2SRCSIZE_UNDEFMASK 0x80008000
union g2sb_ctx3_g2srcsize_u {
    struct {
        unsigned int srcwidth:15;
        unsigned int undefined_bit_15:1;
        unsigned int srcheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2srcsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2srcsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2srcsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcwidth:15", "", 15, old_value_t.srcwidth, new_value_t.srcwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.srcheight, new_value_t.srcheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2DSTSIZE_OFFSET 0x1038
#define G2SB_CTX3_G2DSTSIZE_UNDEFMASK 0x80008000
union g2sb_ctx3_g2dstsize_u {
    struct {
        unsigned int dstwidth:15;           /* In 2D mode, the largest number can be programmed is 0x7fef */
        unsigned int undefined_bit_15:1;
        unsigned int dstheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2dstsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2dstsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2dstsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstwidth:15",
              "In 2D mode, the largest number can be programmed is 0x7fef",
              15, old_value_t.dstwidth, new_value_t.dstwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.dstheight, new_value_t.dstheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2SRCPS_OFFSET 0x1039
#define G2SB_CTX3_G2SRCPS_UNDEFMASK 0x00000000
union g2sb_ctx3_g2srcps_u {
    struct {
        unsigned int srcx:16;               /* SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY   */
        unsigned int srcy:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2srcps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2srcps_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2srcps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcx:16",
              "SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY",
              16, old_value_t.srcx, new_value_t.srcx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcy:16", "", 16, old_value_t.srcy, new_value_t.srcy };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2DSTPS_OFFSET 0x103A
#define G2SB_CTX3_G2DSTPS_UNDEFMASK 0x00000000
union g2sb_ctx3_g2dstps_u {
    struct {
        unsigned int dstx:16;               /* NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 */
        unsigned int dsty:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2dstps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2dstps_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2dstps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstx:16",
              "NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489",
              16, old_value_t.dstx, new_value_t.dstx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dsty:16", "", 16, old_value_t.dsty, new_value_t.dsty };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CBDES_OFFSET 0x103B
#define G2SB_CTX3_G2CBDES_UNDEFMASK 0x0000FF00
union g2sb_ctx3_g2cbdes_u {
    struct {
        unsigned int cbcount:8;             /* This specifies the number of buffers incircular buffer feature                    */
        unsigned int undefined_bits_8_15:8;
        unsigned int cbline:15;             /* vertical line number in one buffer */
        unsigned int topclip:1;             /* top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2 0= disable  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2cbdes_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2cbdes_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2cbdes_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbcount:8",
              "This specifies the number of buffers incircular buffer feature",
              8, old_value_t.cbcount, new_value_t.cbcount };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbline:15",
              "vertical line number in one buffer",
              15, old_value_t.cbline, new_value_t.cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "31: topclip:1",
              "top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2\n0= disable",
              1, old_value_t.topclip, new_value_t.topclip };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CBSTRIDE_OFFSET 0x103C
#define G2SB_CTX3_G2CBSTRIDE_UNDEFMASK 0x3F000000
union g2sb_ctx3_g2cbstride_u {
    struct {
        unsigned int cbstride:24;           /* Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes) */
        unsigned int undefined_bits_24_29:6;
        unsigned int cbuvstride:2;          /* Chroma Buffer Stride default is half of luma   00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2cbstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2cbstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2cbstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbstride:24",
              "Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes)",
              24, old_value_t.cbstride, new_value_t.cbstride };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_29:6", "", 6, old_value_t.undefined_bits_24_29, new_value_t.undefined_bits_24_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: cbuvstride:2",
              "Chroma Buffer Stride default is half of luma  \n00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved",
              2, old_value_t.cbuvstride, new_value_t.cbuvstride };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2LINESETTING_OFFSET 0x103D
#define G2SB_CTX3_G2LINESETTING_UNDEFMASK 0x00E00000
union g2sb_ctx3_g2linesetting_u {
    struct {
        unsigned int gamma:21;
        unsigned int undefined_bits_21_23:3;
        unsigned int major:1;               /* 0:xmajor 1: y major */
        unsigned int linexdir:1;
        unsigned int lineydir:1;
        unsigned int droplastp:1;           /* draw last pixel or not */
        unsigned int lineuseoctant:1;       /* use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR */
        unsigned int octants:3;             /* 000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2linesetting_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2linesetting_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2linesetting_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: gamma:21", "", 21, old_value_t.gamma, new_value_t.gamma };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_23:3", "", 3, old_value_t.undefined_bits_21_23, new_value_t.undefined_bits_21_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: major:1",
              "0:xmajor 1: y major",
              1, old_value_t.major, new_value_t.major };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linexdir:1", "", 1, old_value_t.linexdir, new_value_t.linexdir };
    m_bit_details_model.bits.append(entry);
    entry = { "26: lineydir:1", "", 1, old_value_t.lineydir, new_value_t.lineydir };
    m_bit_details_model.bits.append(entry);
    entry = { "27: droplastp:1",
              "draw last pixel or not",
              1, old_value_t.droplastp, new_value_t.droplastp };
    m_bit_details_model.bits.append(entry);
    entry = { "28: lineuseoctant:1",
              "use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR",
              1, old_value_t.lineuseoctant, new_value_t.lineuseoctant };
    m_bit_details_model.bits.append(entry);
    entry = { "29: octants:3",
              "000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7",
              3, old_value_t.octants, new_value_t.octants };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2LINEDELTAN_OFFSET 0x103E
#define G2SB_CTX3_G2LINEDELTAN_UNDEFMASK 0xFFE00000
union g2sb_ctx3_g2linedeltan_u {
    struct {
        unsigned int deltan:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2linedeltan_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2linedeltan_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2linedeltan_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltan:21", "", 21, old_value_t.deltan, new_value_t.deltan };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2LINEDELTAM_OFFSET 0x103F
#define G2SB_CTX3_G2LINEDELTAM_UNDEFMASK 0xFFE00000
union g2sb_ctx3_g2linedeltam_u {
    struct {
        unsigned int deltam:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2linedeltam_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2linedeltam_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2linedeltam_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltam:21", "", 21, old_value_t.deltam, new_value_t.deltam };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2LINEPOS_OFFSET 0x1040
#define G2SB_CTX3_G2LINEPOS_UNDEFMASK 0x00000000
union g2sb_ctx3_g2linepos_u {
    struct {
        unsigned int linexpos:16;
        unsigned int lineypos:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2linepos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2linepos_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2linepos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linexpos:16", "", 16, old_value_t.linexpos, new_value_t.linexpos };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lineypos:16", "", 16, old_value_t.lineypos, new_value_t.lineypos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2LINELEN_OFFSET 0x1041
#define G2SB_CTX3_G2LINELEN_UNDEFMASK 0xFFFF8000
union g2sb_ctx3_g2linelen_u {
    struct {
        unsigned int linelen:15;
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2linelen_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2linelen_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2linelen_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linelen:15", "", 15, old_value_t.linelen, new_value_t.linelen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CSCFOURTH_OFFSET 0x1042
#define G2SB_CTX3_G2CSCFOURTH_UNDEFMASK 0xFE00FE00
union g2sb_ctx3_g2cscfourth_u {
    struct {
        unsigned int g2u:9;                 /* multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored */
        unsigned int undefined_bits_9_15:7;
        unsigned int g2v:9;                 /* multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored */
        unsigned int undefined_bits_25_31:7;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2cscfourth_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2cscfourth_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2cscfourth_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: g2u:9",
              "multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored",
              9, old_value_t.g2u, new_value_t.g2u };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: g2v:9",
              "multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored",
              9, old_value_t.g2v, new_value_t.g2v };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bits_25_31:7", "", 7, old_value_t.undefined_bits_25_31, new_value_t.undefined_bits_25_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2SRCST_B_OFFSET 0x1043
#define G2SB_CTX3_G2SRCST_B_UNDEFMASK 0xFFFF0000
union g2sb_ctx3_g2srcst_b_u {
    struct {
        unsigned int srcs_b:16;             /* Source Stride B */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2srcst_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2srcst_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2srcst_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs_b:16",
              "Source Stride B",
              16, old_value_t.srcs_b, new_value_t.srcs_b };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2UVSTRIDE_OFFSET 0x1044
#define G2SB_CTX3_G2UVSTRIDE_UNDEFMASK 0xFFFF0000
union g2sb_ctx3_g2uvstride_u {
    struct {
        unsigned int uvstride:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2uvstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2uvstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2uvstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: uvstride:16", "", 16, old_value_t.uvstride, new_value_t.uvstride };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2CBDES2_OFFSET 0x1045
#define G2SB_CTX3_G2CBDES2_UNDEFMASK 0xFFFF8000
union g2sb_ctx3_g2cbdes2_u {
    struct {
        unsigned int top_cbline:15;         /* Circular buffer top clipping enabled, the first buffer line num */
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2cbdes2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2cbdes2_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2cbdes2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: top_cbline:15",
              "Circular buffer top clipping enabled, the first buffer line num",
              15, old_value_t.top_cbline, new_value_t.top_cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2TILEMODE_OFFSET 0x1046
#define G2SB_CTX3_G2TILEMODE_UNDEFMASK 0xFFEEEEEE
union g2sb_ctx3_g2tilemode_u {
    struct {
        unsigned int src_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_1_3:3;
        unsigned int src_uv_tile_mode:1;    /* UV surface, ignored in RGB mode */
        unsigned int undefined_bits_5_7:3;
        unsigned int pat_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_9_11:3;
        unsigned int pat_uv_tile_mode:1;    /* UNUSED */
        unsigned int undefined_bits_13_15:3;
        unsigned int dst_rd_tile_mode:1;    /* Same as destination write unless DST_RD_WR_SEP (not supported) */
        unsigned int undefined_bits_17_19:3;
        unsigned int dst_wr_tile_mode:1;    /* destination surface */
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2tilemode_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2tilemode_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2tilemode_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.src_y_tile_mode, new_value_t.src_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: src_uv_tile_mode:1",
              "UV surface, ignored in RGB mode",
              1, old_value_t.src_uv_tile_mode, new_value_t.src_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: pat_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.pat_y_tile_mode, new_value_t.pat_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: pat_uv_tile_mode:1",
              "UNUSED",
              1, old_value_t.pat_uv_tile_mode, new_value_t.pat_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dst_rd_tile_mode:1",
              "Same as destination write unless DST_RD_WR_SEP (not supported)",
              1, old_value_t.dst_rd_tile_mode, new_value_t.dst_rd_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: dst_wr_tile_mode:1",
              "destination surface",
              1, old_value_t.dst_wr_tile_mode, new_value_t.dst_wr_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2PATBASE_OFFSET 0x1047
#define G2SB_CTX3_G2PATBASE_UNDEFMASK 0x00000000
union g2sb_ctx3_g2patbase_u {
    struct {
        unsigned int pat_base:32;           /* pattern base address in tile mode,  PATBA is the linear address where pixel start */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2patbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2patbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2patbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pat_base:32",
              "pattern base address in tile mode,  PATBA is the linear address where pixel start",
              32, old_value_t.pat_base, new_value_t.pat_base };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2SRCBA_SB_SURFBASE_OFFSET 0x1048
#define G2SB_CTX3_G2SRCBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx3_g2srcba_sb_surfbase_u {
    struct {
        unsigned int src_addr:32;           /* surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2srcba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2srcba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2srcba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_addr:32",
              "surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine",
              32, old_value_t.src_addr, new_value_t.src_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2DSTBA_SB_SURFBASE_OFFSET 0x1049
#define G2SB_CTX3_G2DSTBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx3_g2dstba_sb_surfbase_u {
    struct {
        unsigned int dst_addr:32;           /* surface address corresponding to G2DSTBA Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2dstba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2dstba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2dstba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_addr:32",
              "surface address corresponding to G2DSTBA Only used by the StretchBlit Engine",
              32, old_value_t.dst_addr, new_value_t.dst_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2DSTBA_B_SB_SURFBASE_OFFSET 0x104A
#define G2SB_CTX3_G2DSTBA_B_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx3_g2dstba_b_sb_surfbase_u {
    struct {
        unsigned int dst_b_addr:32;         /* surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2dstba_b_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2dstba_b_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2dstba_b_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_b_addr:32",
              "surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled",
              32, old_value_t.dst_b_addr, new_value_t.dst_b_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2VBA_A_SB_SURFBASE_OFFSET 0x104B
#define G2SB_CTX3_G2VBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx3_g2vba_a_sb_surfbase_u {
    struct {
        unsigned int v_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2vba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2vba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2vba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine",
              32, old_value_t.v_addr, new_value_t.v_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX3_G2UBA_A_SB_SURFBASE_OFFSET 0x104C
#define G2SB_CTX3_G2UBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx3_g2uba_a_sb_surfbase_u {
    struct {
        unsigned int u_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx3_g2uba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx3_g2uba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx3_g2uba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: u_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine",
              32, old_value_t.u_addr, new_value_t.u_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_INCR_SYNCPT_OFFSET 0x5000
#define G2SB_CTX4_INCR_SYNCPT_UNDEFMASK 0xFFFF0000
union g2sb_ctx4_incr_syncpt_u {
    struct {
        unsigned int indx:8;                /* syncpt index value */
        unsigned int cond:8;                /* Condition mapped from raise/wait */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_incr_syncpt_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_incr_syncpt_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_incr_syncpt_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: indx:8",
              "syncpt index value",
              8, old_value_t.indx, new_value_t.indx };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cond:8",
              "Condition mapped from raise/wait",
              8, old_value_t.cond, new_value_t.cond };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_INCR_SYNCPT_CNTRL_OFFSET 0x5001
#define G2SB_CTX4_INCR_SYNCPT_CNTRL_UNDEFMASK 0xFFFFFEFE
union g2sb_ctx4_incr_syncpt_cntrl_u {
    struct {
        unsigned int incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs. */
        unsigned int undefined_bits_1_7:7;
        unsigned int incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled. */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_incr_syncpt_cntrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_incr_syncpt_cntrl_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_incr_syncpt_cntrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: incr_syncpt_soft_reset:1",
              "If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs.",
              1, old_value_t.incr_syncpt_soft_reset, new_value_t.incr_syncpt_soft_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: incr_syncpt_no_stall:1",
              "If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled.",
              1, old_value_t.incr_syncpt_no_stall, new_value_t.incr_syncpt_no_stall };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_INCR_SYNCPT_ERROR_OFFSET 0x5002
#define G2SB_CTX4_INCR_SYNCPT_ERROR_UNDEFMASK 0x00000000
union g2sb_ctx4_incr_syncpt_error_u {
    struct {
        unsigned int cond_status:32;        /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_incr_syncpt_error_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_incr_syncpt_error_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_incr_syncpt_error_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cond_status:32",
              "COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero",
              32, old_value_t.cond_status, new_value_t.cond_status };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CLASSCHANNEL_REGONLY_OFFSET 0x5008
#define G2SB_CTX4_G2CLASSCHANNEL_REGONLY_UNDEFMASK 0xFFE0FC00
union g2sb_ctx4_g2classchannel_regonly_u {
    struct {
        unsigned int curr_class:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int curr_channel:4;
        unsigned int ctx_valid:1;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2classchannel_regonly_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2classchannel_regonly_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2classchannel_regonly_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: curr_class:10", "", 10, old_value_t.curr_class, new_value_t.curr_class };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_15:6", "", 6, old_value_t.undefined_bits_10_15, new_value_t.undefined_bits_10_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: curr_channel:4", "", 4, old_value_t.curr_channel, new_value_t.curr_channel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ctx_valid:1", "", 1, old_value_t.ctx_valid, new_value_t.ctx_valid };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2TRIGGER_OFFSET 0x5009
#define G2SB_CTX4_G2TRIGGER_UNDEFMASK 0xFFFF0000
union g2sb_ctx4_g2trigger_u {
    struct {
        unsigned int trigger:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2trigger_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2trigger_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2trigger_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger:16", "", 16, old_value_t.trigger, new_value_t.trigger };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2TRIGGER1_OFFSET 0x500A
#define G2SB_CTX4_G2TRIGGER1_UNDEFMASK 0xFFFF0000
union g2sb_ctx4_g2trigger1_u {
    struct {
        unsigned int trigger1:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2trigger1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2trigger1_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2trigger1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger1:16", "", 16, old_value_t.trigger1, new_value_t.trigger1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2TRIGGER2_OFFSET 0x500B
#define G2SB_CTX4_G2TRIGGER2_UNDEFMASK 0xFFFF0000
union g2sb_ctx4_g2trigger2_u {
    struct {
        unsigned int trigger2:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2trigger2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2trigger2_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2trigger2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger2:16", "", 16, old_value_t.trigger2, new_value_t.trigger2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CMDSEL_OFFSET 0x500C
#define G2SB_CTX4_G2CMDSEL_UNDEFMASK 0xE000280E
union g2sb_ctx4_g2cmdsel_u {
    struct {
        unsigned int sbor2d:1;
        unsigned int undefined_bits_1_3:3;
        unsigned int cbenable:1;            /* circular buffer feature enable    0= disable */
        unsigned int vitrigger:1;           /* VI trigger enable, can be circular buffer or full frame */
        unsigned int hosttrigger:1;         /* host trigger the command, host also need program cicular buffer related data */
        unsigned int cbsbdisable:1;
        unsigned int g2output:2;            /* 00: to memory 01: to EPP */
        unsigned int clip_source_top_bottom:1;/* Reserved for HW Test, SW should not use this bit. */
        unsigned int undefined_bit_11:1;
        unsigned int link_wait_buf_end:1;
        unsigned int undefined_bit_13:1;
        unsigned int frame_start:1;         /* host writes this bit to tell which buffer is ready */
        unsigned int frame_end:1;
        unsigned int buffer_index:8;
        unsigned int linken:1;              /* Test purpose */
        unsigned int linkval:3;
        unsigned int priority:1;            /* indicates priority of the context, note vi-triggered contexts take priority over HIGH */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2cmdsel_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2cmdsel_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2cmdsel_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sbor2d:1", "", 1, old_value_t.sbor2d, new_value_t.sbor2d };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: cbenable:1",
              "circular buffer feature enable   \n0= disable",
              1, old_value_t.cbenable, new_value_t.cbenable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: vitrigger:1",
              "VI trigger enable, can be circular buffer or full frame",
              1, old_value_t.vitrigger, new_value_t.vitrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "06: hosttrigger:1",
              "host trigger the command, host also need program cicular buffer related data",
              1, old_value_t.hosttrigger, new_value_t.hosttrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "07: cbsbdisable:1", "", 1, old_value_t.cbsbdisable, new_value_t.cbsbdisable };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g2output:2",
              "00: to memory 01: to EPP",
              2, old_value_t.g2output, new_value_t.g2output };
    m_bit_details_model.bits.append(entry);
    entry = { "10: clip_source_top_bottom:1",
              "Reserved for HW Test, SW should not use this bit.",
              1, old_value_t.clip_source_top_bottom, new_value_t.clip_source_top_bottom };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: link_wait_buf_end:1", "", 1, old_value_t.link_wait_buf_end, new_value_t.link_wait_buf_end };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: frame_start:1",
              "host writes this bit to tell which buffer is ready",
              1, old_value_t.frame_start, new_value_t.frame_start };
    m_bit_details_model.bits.append(entry);
    entry = { "15: frame_end:1", "", 1, old_value_t.frame_end, new_value_t.frame_end };
    m_bit_details_model.bits.append(entry);
    entry = { "16: buffer_index:8", "", 8, old_value_t.buffer_index, new_value_t.buffer_index };
    m_bit_details_model.bits.append(entry);
    entry = { "24: linken:1",
              "Test purpose",
              1, old_value_t.linken, new_value_t.linken };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linkval:3", "", 3, old_value_t.linkval, new_value_t.linkval };
    m_bit_details_model.bits.append(entry);
    entry = { "28: priority:1",
              "indicates priority of the context, note vi-triggered contexts take priority over HIGH",
              1, old_value_t.priority, new_value_t.priority };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2RAISE_OFFSET 0x500D
#define G2SB_CTX4_G2RAISE_UNDEFMASK 0xFFF0FFE0
union g2sb_ctx4_g2raise_u {
    struct {
        unsigned int raise:5;               /* Push back to read fifo when all commands in the channel are done.           */
        unsigned int undefined_bits_5_15:11;
        unsigned int raisechannel:4;
        unsigned int undefined_bits_20_31:12;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2raise_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2raise_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2raise_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: raise:5",
              "Push back to read fifo when all commands in the channel are done.",
              5, old_value_t.raise, new_value_t.raise };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_15:11", "", 11, old_value_t.undefined_bits_5_15, new_value_t.undefined_bits_5_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisechannel:4", "", 4, old_value_t.raisechannel, new_value_t.raisechannel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_31:12", "", 12, old_value_t.undefined_bits_20_31, new_value_t.undefined_bits_20_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2HOSTSET_OFFSET 0x500F
#define G2SB_CTX4_G2HOSTSET_UNDEFMASK 0xFFFFFF00
union g2sb_ctx4_g2hostset_u {
    struct {
        unsigned int hstlngap:4;            /*  specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte) */
        unsigned int hstfpxl:4;             /* specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2hostset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2hostset_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2hostset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hstlngap:4",
              " specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte)",
              4, old_value_t.hstlngap, new_value_t.hstlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: hstfpxl:4",
              "specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary",
              4, old_value_t.hstfpxl, new_value_t.hstfpxl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2HOSTFIFO_OFFSET 0x5010
#define G2SB_CTX4_G2HOSTFIFO_UNDEFMASK 0x00000000
union g2sb_ctx4_g2hostfifo_u {
    struct {
        unsigned int hostfifodata:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2hostfifo_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2hostfifo_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2hostfifo_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hostfifodata:32", "", 32, old_value_t.hostfifodata, new_value_t.hostfifodata };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2VDDA_OFFSET 0x5011
#define G2SB_CTX4_G2VDDA_UNDEFMASK 0x00000000
union g2sb_ctx4_g2vdda_u {
    struct {
        unsigned int vdstep:32;             /* Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2vdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2vdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2vdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdstep:32",
              "Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010.",
              32, old_value_t.vdstep, new_value_t.vdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2VDDAINI_OFFSET 0x5012
#define G2SB_CTX4_G2VDDAINI_UNDEFMASK 0xFFFF0000
union g2sb_ctx4_g2vddaini_u {
    struct {
        unsigned int vdtini:8;              /* Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window. */
        unsigned int vdbini:8;              /* Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above) */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2vddaini_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2vddaini_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2vddaini_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdtini:8",
              "Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window.",
              8, old_value_t.vdtini, new_value_t.vdtini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: vdbini:8",
              "Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above)",
              8, old_value_t.vdbini, new_value_t.vdbini };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2HDDA_OFFSET 0x5013
#define G2SB_CTX4_G2HDDA_UNDEFMASK 0x00000000
union g2sb_ctx4_g2hdda_u {
    struct {
        unsigned int hdstep:32;             /* Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2hdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2hdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2hdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdstep:32",
              "Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101.",
              32, old_value_t.hdstep, new_value_t.hdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2HDDAINILS_OFFSET 0x5014
#define G2SB_CTX4_G2HDDAINILS_UNDEFMASK 0xFFFFFF00
union g2sb_ctx4_g2hddainils_u {
    struct {
        unsigned int hdini:8;               /* Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0. */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2hddainils_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2hddainils_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2hddainils_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdini:8",
              "Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0.",
              8, old_value_t.hdini, new_value_t.hdini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CSCFIRST_OFFSET 0x5015
#define G2SB_CTX4_G2CSCFIRST_UNDEFMASK 0x00C00C00
union g2sb_ctx4_g2cscfirst_u {
    struct {
        unsigned int cub:10;                /* multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved  */
        unsigned int undefined_bits_10_11:2;
        unsigned int cvr:10;                /* multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved */
        unsigned int undefined_bits_22_23:2;
        unsigned int yos:8;                 /* Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2cscfirst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2cscfirst_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2cscfirst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cub:10",
              "multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved",
              10, old_value_t.cub, new_value_t.cub };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_11:2", "", 2, old_value_t.undefined_bits_10_11, new_value_t.undefined_bits_10_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cvr:10",
              "multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved",
              10, old_value_t.cvr, new_value_t.cvr };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: yos:8",
              "Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10",
              8, old_value_t.yos, new_value_t.yos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CSCSECOND_OFFSET 0x5016
#define G2SB_CTX4_G2CSCSECOND_UNDEFMASK 0x00C00E00
union g2sb_ctx4_g2cscsecond_u {
    struct {
        unsigned int cug:9;                 /* multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved */
        unsigned int undefined_bits_9_11:3;
        unsigned int cur:10;                /* multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved  */
        unsigned int undefined_bits_22_23:2;
        unsigned int cyx:8;                 /* multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2cscsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2cscsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2cscsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cug:9",
              "multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved",
              9, old_value_t.cug, new_value_t.cug };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cur:10",
              "multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved",
              10, old_value_t.cur, new_value_t.cur };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cyx:8",
              "multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041",
              8, old_value_t.cyx, new_value_t.cyx };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CSCTHIRD_OFFSET 0x5017
#define G2SB_CTX4_G2CSCTHIRD_UNDEFMASK 0xFC00FE00
union g2sb_ctx4_g2cscthird_u {
    struct {
        unsigned int cvg:9;                 /* multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113 */
        unsigned int undefined_bits_9_15:7;
        unsigned int cvb:10;                /* multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021 */
        unsigned int undefined_bits_26_31:6;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2cscthird_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2cscthird_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2cscthird_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cvg:9",
              "multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113",
              9, old_value_t.cvg, new_value_t.cvg };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cvb:10",
              "multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021",
              10, old_value_t.cvb, new_value_t.cvb };
    m_bit_details_model.bits.append(entry);
    entry = { "26: undefined_bits_26_31:6", "", 6, old_value_t.undefined_bits_26_31, new_value_t.undefined_bits_26_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CMKEYL_OFFSET 0x5018
#define G2SB_CTX4_G2CMKEYL_UNDEFMASK 0xFF000000
union g2sb_ctx4_g2cmkeyl_u {
    struct {
        unsigned int ckbl:8;                /* B or Y Color/Chroma Key Lower Limit (CKBL[7:0]) */
        unsigned int ckgl:8;                /* G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level. */
        unsigned int ckrl:8;                /* R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2cmkeyl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2cmkeyl_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2cmkeyl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbl:8",
              "B or Y Color/Chroma Key Lower Limit (CKBL[7:0])",
              8, old_value_t.ckbl, new_value_t.ckbl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgl:8",
              "G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgl, new_value_t.ckgl };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckrl:8",
              "R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved",
              8, old_value_t.ckrl, new_value_t.ckrl };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CMKEYU_OFFSET 0x5019
#define G2SB_CTX4_G2CMKEYU_UNDEFMASK 0xFF000000
union g2sb_ctx4_g2cmkeyu_u {
    struct {
        unsigned int ckbu:8;                /* This is B or Y color/chroma key upper limit value. */
        unsigned int ckgu:8;                /* G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level. */
        unsigned int ckru:8;                /* R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2cmkeyu_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2cmkeyu_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2cmkeyu_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbu:8",
              "This is B or Y color/chroma key upper limit value.",
              8, old_value_t.ckbu, new_value_t.ckbu };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgu:8",
              "G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgu, new_value_t.ckgu };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckru:8",
              "R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved",
              8, old_value_t.ckru, new_value_t.ckru };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2UBA_A_OFFSET 0x501A
#define G2SB_CTX4_G2UBA_A_UNDEFMASK 0x00000000
union g2sb_ctx4_g2uba_a_u {
    struct {
        unsigned int su1sa:32;              /* Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2uba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2uba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2uba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: su1sa:32",
              "Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.su1sa, new_value_t.su1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2VBA_A_OFFSET 0x501B
#define G2SB_CTX4_G2VBA_A_UNDEFMASK 0x00000000
union g2sb_ctx4_g2vba_a_u {
    struct {
        unsigned int sv1sa:32;              /* Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2vba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2vba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2vba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sv1sa:32",
              "Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.sv1sa, new_value_t.sv1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2SBFORMAT_OFFSET 0x501C
#define G2SB_CTX4_G2SBFORMAT_UNDEFMASK 0x000020E0
union g2sb_ctx4_g2sbformat_u {
    struct {
        unsigned int sifmt:5;               /* This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV. */
        unsigned int undefined_bits_5_7:3;
        unsigned int difmt:5;               /* Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED */
        unsigned int undefined_bit_13:1;
        unsigned int raisebufferen:1;       /* ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.  */
        unsigned int raiseframeen:1;        /* ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.  */
        unsigned int raisebuffervalue:8;    /* Raise buffer vector value. */
        unsigned int raiseframevalue:8;     /* Raise Fram vector value. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2sbformat_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2sbformat_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2sbformat_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sifmt:5",
              "This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV.",
              5, old_value_t.sifmt, new_value_t.sifmt };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: difmt:5",
              "Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED",
              5, old_value_t.difmt, new_value_t.difmt };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: raisebufferen:1",
              "ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raisebufferen, new_value_t.raisebufferen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: raiseframeen:1",
              "ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raiseframeen, new_value_t.raiseframeen };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisebuffervalue:8",
              "Raise buffer vector value.",
              8, old_value_t.raisebuffervalue, new_value_t.raisebuffervalue };
    m_bit_details_model.bits.append(entry);
    entry = { "24: raiseframevalue:8",
              "Raise Fram vector value.",
              8, old_value_t.raiseframevalue, new_value_t.raiseframevalue };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CONTROLSB_OFFSET 0x501D
#define G2SB_CTX4_G2CONTROLSB_UNDEFMASK 0x20005807
union g2sb_ctx4_g2controlsb_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int yuv422rotation:1;      /* yuv422 plannar rotated */
        unsigned int yuv422planar:1;        /* source data is yuv422 planar valid when imode==PLANAR */
        unsigned int imode:1;               /* Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d. */
        unsigned int enavf:1;               /* enable alpha vertical filter     */
        unsigned int enahf:1;               /* enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format, */
        unsigned int uvst:2;                /*   00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.   11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride). */
        unsigned int sl:1;                  /* Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines. */
        unsigned int undefined_bits_11_12:2;
        unsigned int sisel:1;               /* StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved  */
        unsigned int undefined_bit_14:1;
        unsigned int sbltsrc:1;             /* StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator. */
        unsigned int vftype:2;              /* StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager. */
        unsigned int vfen:1;                /* StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled. */
        unsigned int discsc:1;              /* enabled color space converter by default */
        unsigned int hftype:3;              /* StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE. */
        unsigned int rangeredfrm:1;         /* In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.  */
        unsigned int sitype:1;              /* StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?. */
        unsigned int sbsel:1;               /* StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer. */
        unsigned int dbsel:1;               /* StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer. */
        unsigned int keyen:1;               /* Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled. */
        unsigned int kpol:1;                /* Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range. */
        unsigned int undefined_bit_29:1;
        unsigned int endith:1;              /* Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering */
        unsigned int disdw:1;               /* output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2controlsb_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2controlsb_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2controlsb_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_2:3", "", 3, old_value_t.undefined_bits_0_2, new_value_t.undefined_bits_0_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: yuv422rotation:1",
              "yuv422 plannar rotated",
              1, old_value_t.yuv422rotation, new_value_t.yuv422rotation };
    m_bit_details_model.bits.append(entry);
    entry = { "04: yuv422planar:1",
              "source data is yuv422 planar valid when imode==PLANAR",
              1, old_value_t.yuv422planar, new_value_t.yuv422planar };
    m_bit_details_model.bits.append(entry);
    entry = { "05: imode:1",
              "Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d.",
              1, old_value_t.imode, new_value_t.imode };
    m_bit_details_model.bits.append(entry);
    entry = { "06: enavf:1",
              "enable alpha vertical filter",
              1, old_value_t.enavf, new_value_t.enavf };
    m_bit_details_model.bits.append(entry);
    entry = { "07: enahf:1",
              "enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format,",
              1, old_value_t.enahf, new_value_t.enahf };
    m_bit_details_model.bits.append(entry);
    entry = { "08: uvst:2",
              " \n00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.\n11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride).",
              2, old_value_t.uvst, new_value_t.uvst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: sl:1",
              "Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines.",
              1, old_value_t.sl, new_value_t.sl };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_12:2", "", 2, old_value_t.undefined_bits_11_12, new_value_t.undefined_bits_11_12 };
    m_bit_details_model.bits.append(entry);
    entry = { "13: sisel:1",
              "StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved",
              1, old_value_t.sisel, new_value_t.sisel };
    m_bit_details_model.bits.append(entry);
    entry = { "14: undefined_bit_14:1", "", 1, old_value_t.undefined_bit_14, new_value_t.undefined_bit_14 };
    m_bit_details_model.bits.append(entry);
    entry = { "15: sbltsrc:1",
              "StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator.",
              1, old_value_t.sbltsrc, new_value_t.sbltsrc };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vftype:2",
              "StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager.",
              2, old_value_t.vftype, new_value_t.vftype };
    m_bit_details_model.bits.append(entry);
    entry = { "18: vfen:1",
              "StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled.",
              1, old_value_t.vfen, new_value_t.vfen };
    m_bit_details_model.bits.append(entry);
    entry = { "19: discsc:1",
              "enabled color space converter by default",
              1, old_value_t.discsc, new_value_t.discsc };
    m_bit_details_model.bits.append(entry);
    entry = { "20: hftype:3",
              "StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE.",
              3, old_value_t.hftype, new_value_t.hftype };
    m_bit_details_model.bits.append(entry);
    entry = { "23: rangeredfrm:1",
              "In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.",
              1, old_value_t.rangeredfrm, new_value_t.rangeredfrm };
    m_bit_details_model.bits.append(entry);
    entry = { "24: sitype:1",
              "StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?.",
              1, old_value_t.sitype, new_value_t.sitype };
    m_bit_details_model.bits.append(entry);
    entry = { "25: sbsel:1",
              "StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer.",
              1, old_value_t.sbsel, new_value_t.sbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "26: dbsel:1",
              "StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer.",
              1, old_value_t.dbsel, new_value_t.dbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "27: keyen:1",
              "Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled.",
              1, old_value_t.keyen, new_value_t.keyen };
    m_bit_details_model.bits.append(entry);
    entry = { "28: kpol:1",
              "Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range.",
              1, old_value_t.kpol, new_value_t.kpol };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: endith:1",
              "Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering",
              1, old_value_t.endith, new_value_t.endith };
    m_bit_details_model.bits.append(entry);
    entry = { "31: disdw:1",
              "output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place.",
              1, old_value_t.disdw, new_value_t.disdw };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CONTROLSECOND_OFFSET 0x501E
#define G2SB_CTX4_G2CONTROLSECOND_UNDEFMASK 0xC08E3C01
union g2sb_ctx4_g2controlsecond_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int bitswap:1;             /* Host port bit swap 1=enable   0= disable   1= enable */
        unsigned int bebswap:1;             /* Host port byte swap 1=enable   0= disable   1= enable */
        unsigned int bewswap:1;             /* Host port word swap 1=enable   0= disable */
        unsigned int alptype:5;             /* Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits. */
        unsigned int alpsrcordst:1;         /* 32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha */
        unsigned int undefined_bits_10_13:4;
        unsigned int pxlrep:1;              /* Pixel replication for Palm OS. */
        unsigned int swapblt:1;             /* Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area */
        unsigned int vcaa_safe_mode:1;      /* VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken. */
        unsigned int undefined_bits_17_19:3;
        unsigned int g2nostop:1;
        unsigned int clipc:2;               /* Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,  10=draw only inside clipping rectangle,  11=draw only outside clipping rectangle */
        unsigned int undefined_bit_23:1;
        unsigned int fr_mode:2;             /* Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice. 00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so! 01 = src/dst copy mode - two separate buffers 10 = square in place - one buffer 11 = blank */
        unsigned int fr_type:3;             /*  Fast Rotate type     000 = FLIP_X  001 = FLIP_Y  010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right) 011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left) 100 = ROT_90 (counter clock wise by 90 degrees) 101 = ROT_180  110 = ROT_270 (clock wise by 90 degrees) 111 = IDENTITY */
        unsigned int fr_readwait:1;         /*  Fast Rotate wait for read 0 = disable 1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only. */
        unsigned int undefined_bits_30_31:2;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2controlsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2controlsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2controlsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bit_0:1", "", 1, old_value_t.undefined_bit_0, new_value_t.undefined_bit_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "01: bitswap:1",
              "Host port bit swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bitswap, new_value_t.bitswap };
    m_bit_details_model.bits.append(entry);
    entry = { "02: bebswap:1",
              "Host port byte swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bebswap, new_value_t.bebswap };
    m_bit_details_model.bits.append(entry);
    entry = { "03: bewswap:1",
              "Host port word swap\n1=enable  \n0= disable",
              1, old_value_t.bewswap, new_value_t.bewswap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: alptype:5",
              "Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits.",
              5, old_value_t.alptype, new_value_t.alptype };
    m_bit_details_model.bits.append(entry);
    entry = { "09: alpsrcordst:1",
              "32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha",
              1, old_value_t.alpsrcordst, new_value_t.alpsrcordst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_13:4", "", 4, old_value_t.undefined_bits_10_13, new_value_t.undefined_bits_10_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: pxlrep:1",
              "Pixel replication for Palm OS.",
              1, old_value_t.pxlrep, new_value_t.pxlrep };
    m_bit_details_model.bits.append(entry);
    entry = { "15: swapblt:1",
              "Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area",
              1, old_value_t.swapblt, new_value_t.swapblt };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vcaa_safe_mode:1",
              "VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken.",
              1, old_value_t.vcaa_safe_mode, new_value_t.vcaa_safe_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: g2nostop:1", "", 1, old_value_t.g2nostop, new_value_t.g2nostop };
    m_bit_details_model.bits.append(entry);
    entry = { "21: clipc:2",
              "Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,\n10=draw only inside clipping rectangle,\n11=draw only outside clipping rectangle",
              2, old_value_t.clipc, new_value_t.clipc };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fr_mode:2",
              "Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice.\n00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so!\n01 = src/dst copy mode - two separate buffers\n10 = square in place - one buffer\n11 = blank",
              2, old_value_t.fr_mode, new_value_t.fr_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "26: fr_type:3",
              " Fast Rotate type    \n000 = FLIP_X \n001 = FLIP_Y \n010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right)\n011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left)\n100 = ROT_90 (counter clock wise by 90 degrees)\n101 = ROT_180 \n110 = ROT_270 (clock wise by 90 degrees)\n111 = IDENTITY",
              3, old_value_t.fr_type, new_value_t.fr_type };
    m_bit_details_model.bits.append(entry);
    entry = { "29: fr_readwait:1",
              " Fast Rotate wait for read\n0 = disable\n1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only.",
              1, old_value_t.fr_readwait, new_value_t.fr_readwait };
    m_bit_details_model.bits.append(entry);
    entry = { "30: undefined_bits_30_31:2", "", 2, old_value_t.undefined_bits_30_31, new_value_t.undefined_bits_30_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CONTROLMAIN_OFFSET 0x501F
#define G2SB_CTX4_G2CONTROLMAIN_UNDEFMASK 0x80000000
union g2sb_ctx4_g2controlmain_u {
    struct {
        unsigned int cmdt:2;                /* Command Type:  00=BitBlt 01=Line Draw  10=VCAA 11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed) */
        unsigned int turbofill:1;           /* fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified. */
        unsigned int test0bit:1;            /* Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish. */
        unsigned int faden:1;               /* BitBlt Source Copy Fade enable, 1=enable (share with mltln), only support  16bpp mode */
        unsigned int alpen:1;               /* BitBlt Alpha Blending, 1=enable. 0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype */
        unsigned int srcsld:1;              /* BitBlt Solid Source Color Fill: 1=enable. FGC will be used as  the color value. */
        unsigned int patsld:1;              /* BitBlt Solid Pattern Fill: 1=enable. BGC will be used as  the color value. */
        unsigned int patfl:1;               /* When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+ */
        unsigned int xdir:1;                /*  0=incrementing, 1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0 */
        unsigned int ydir:1;                /*  0=incrementing, 1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0 */
        unsigned int xytdw:1;               /* xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination. */
        unsigned int srcpack:1;             /* Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled. */
        unsigned int patpack:1;             /* Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled. */
        unsigned int yflip:1;               /* flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination. */
        unsigned int srcsel:1;              /* Source Data Select: */
        unsigned int dstcd:2;               /* Destination color depth:   00=8-bpp, 01=16-bpp, 10=32-bpp. 11=reserved */
        unsigned int dstt:2;                /* Destination read transparency enable:   0x=destination read transparency disabled   10=color destination read transparency   11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately, 0=wait for launch write) */
        unsigned int srccd:1;               /* 0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0 */
        unsigned int hlmono:1;              /* Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit */
        unsigned int srct:2;                /* Source transparency enable: 0x=source transparency disabled,  10=mono source background transparency     or color source transparency,  11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied. */
        unsigned int srcbas:1;              /* Source base address select:   0=srcba, 1=dstba. This is not used for Line Draw and  if source data comes from host memory. */
        unsigned int gcsw:2;                /* Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used */
        unsigned int srcdir:1;              /* source direct addressing */
        unsigned int dstdir:1;              /* destination direct addressing */
        unsigned int dst_rd_wr_sep:1;       /* This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA */
        unsigned int patsel:1;              /* pattern Data Select: SRCSEL and PATSEL can't be both enabled. */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2controlmain_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2controlmain_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2controlmain_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cmdt:2",
              "Command Type: \n00=BitBlt\n01=Line Draw \n10=VCAA\n11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed)",
              2, old_value_t.cmdt, new_value_t.cmdt };
    m_bit_details_model.bits.append(entry);
    entry = { "02: turbofill:1",
              "fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified.",
              1, old_value_t.turbofill, new_value_t.turbofill };
    m_bit_details_model.bits.append(entry);
    entry = { "03: test0bit:1",
              "Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish.",
              1, old_value_t.test0bit, new_value_t.test0bit };
    m_bit_details_model.bits.append(entry);
    entry = { "04: faden:1",
              "BitBlt Source Copy Fade enable,\n1=enable (share with mltln), only support  16bpp mode",
              1, old_value_t.faden, new_value_t.faden };
    m_bit_details_model.bits.append(entry);
    entry = { "05: alpen:1",
              "BitBlt Alpha Blending,\n1=enable.\n0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype",
              1, old_value_t.alpen, new_value_t.alpen };
    m_bit_details_model.bits.append(entry);
    entry = { "06: srcsld:1",
              "BitBlt Solid Source Color Fill:\n1=enable. FGC will be used as  the color value.",
              1, old_value_t.srcsld, new_value_t.srcsld };
    m_bit_details_model.bits.append(entry);
    entry = { "07: patsld:1",
              "BitBlt Solid Pattern Fill:\n1=enable. BGC will be used as  the color value.",
              1, old_value_t.patsld, new_value_t.patsld };
    m_bit_details_model.bits.append(entry);
    entry = { "08: patfl:1",
              "When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+",
              1, old_value_t.patfl, new_value_t.patfl };
    m_bit_details_model.bits.append(entry);
    entry = { "09: xdir:1",
              "0=incrementing,\n1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0",
              1, old_value_t.xdir, new_value_t.xdir };
    m_bit_details_model.bits.append(entry);
    entry = { "10: ydir:1",
              "0=incrementing,\n1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0",
              1, old_value_t.ydir, new_value_t.ydir };
    m_bit_details_model.bits.append(entry);
    entry = { "11: xytdw:1",
              "xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination.",
              1, old_value_t.xytdw, new_value_t.xytdw };
    m_bit_details_model.bits.append(entry);
    entry = { "12: srcpack:1",
              "Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.srcpack, new_value_t.srcpack };
    m_bit_details_model.bits.append(entry);
    entry = { "13: patpack:1",
              "Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.patpack, new_value_t.patpack };
    m_bit_details_model.bits.append(entry);
    entry = { "14: yflip:1",
              "flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination.",
              1, old_value_t.yflip, new_value_t.yflip };
    m_bit_details_model.bits.append(entry);
    entry = { "15: srcsel:1",
              "Source Data Select:",
              1, old_value_t.srcsel, new_value_t.srcsel };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstcd:2",
              "Destination color depth:  \n00=8-bpp,\n01=16-bpp,\n10=32-bpp.\n11=reserved",
              2, old_value_t.dstcd, new_value_t.dstcd };
    m_bit_details_model.bits.append(entry);
    entry = { "18: dstt:2",
              "Destination read transparency enable:   0x=destination read transparency disabled  \n10=color destination read transparency  \n11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately,\n0=wait for launch write)",
              2, old_value_t.dstt, new_value_t.dstt };
    m_bit_details_model.bits.append(entry);
    entry = { "20: srccd:1",
              "0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0",
              1, old_value_t.srccd, new_value_t.srccd };
    m_bit_details_model.bits.append(entry);
    entry = { "21: hlmono:1",
              "Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit",
              1, old_value_t.hlmono, new_value_t.hlmono };
    m_bit_details_model.bits.append(entry);
    entry = { "22: srct:2",
              "Source transparency enable: 0x=source transparency disabled,\n10=mono source background transparency     or color source transparency,\n11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied.",
              2, old_value_t.srct, new_value_t.srct };
    m_bit_details_model.bits.append(entry);
    entry = { "24: srcbas:1",
              "Source base address select:  \n0=srcba,\n1=dstba. This is not used for Line Draw and  if source data comes from host memory.",
              1, old_value_t.srcbas, new_value_t.srcbas };
    m_bit_details_model.bits.append(entry);
    entry = { "25: gcsw:2",
              "Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used",
              2, old_value_t.gcsw, new_value_t.gcsw };
    m_bit_details_model.bits.append(entry);
    entry = { "27: srcdir:1",
              "source direct addressing",
              1, old_value_t.srcdir, new_value_t.srcdir };
    m_bit_details_model.bits.append(entry);
    entry = { "28: dstdir:1",
              "destination direct addressing",
              1, old_value_t.dstdir, new_value_t.dstdir };
    m_bit_details_model.bits.append(entry);
    entry = { "29: dst_rd_wr_sep:1",
              "This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA",
              1, old_value_t.dst_rd_wr_sep, new_value_t.dst_rd_wr_sep };
    m_bit_details_model.bits.append(entry);
    entry = { "30: patsel:1",
              "pattern Data Select: SRCSEL and PATSEL can't be both enabled.",
              1, old_value_t.patsel, new_value_t.patsel };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2ROPFADE_OFFSET 0x5020
#define G2SB_CTX4_G2ROPFADE_UNDEFMASK 0x0000FF00
union g2sb_ctx4_g2ropfade_u {
    struct {
        unsigned int rop:8;                 /* If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out. */
        unsigned int undefined_bits_8_15:8;
        unsigned int fadcoe:8;
        unsigned int fadoff:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2ropfade_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2ropfade_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2ropfade_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: rop:8",
              "If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out.",
              8, old_value_t.rop, new_value_t.rop };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: fadcoe:8", "", 8, old_value_t.fadcoe, new_value_t.fadcoe };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fadoff:8", "", 8, old_value_t.fadoff, new_value_t.fadoff };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2ALPHABLEND_OFFSET 0x5021
#define G2SB_CTX4_G2ALPHABLEND_UNDEFMASK 0x0000FE00
union g2sb_ctx4_g2alphablend_u {
    struct {
        unsigned int alpha:8;
        unsigned int alphainv:1;
        unsigned int undefined_bits_9_15:7;
        unsigned int alpha0v:8;
        unsigned int alpha1v:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2alphablend_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2alphablend_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2alphablend_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: alpha:8", "", 8, old_value_t.alpha, new_value_t.alpha };
    m_bit_details_model.bits.append(entry);
    entry = { "08: alphainv:1", "", 1, old_value_t.alphainv, new_value_t.alphainv };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: alpha0v:8", "", 8, old_value_t.alpha0v, new_value_t.alpha0v };
    m_bit_details_model.bits.append(entry);
    entry = { "24: alpha1v:8", "", 8, old_value_t.alpha1v, new_value_t.alpha1v };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CLIPLEFTTOP_OFFSET 0x5022
#define G2SB_CTX4_G2CLIPLEFTTOP_UNDEFMASK 0x80008000
union g2sb_ctx4_g2cliplefttop_u {
    struct {
        unsigned int clipl:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipt:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2cliplefttop_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2cliplefttop_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2cliplefttop_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipl:15", "", 15, old_value_t.clipl, new_value_t.clipl };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipt:15", "", 15, old_value_t.clipt, new_value_t.clipt };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CLIPRIGHTBOT_OFFSET 0x5023
#define G2SB_CTX4_G2CLIPRIGHTBOT_UNDEFMASK 0x80008000
union g2sb_ctx4_g2cliprightbot_u {
    struct {
        unsigned int clipr:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipb:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2cliprightbot_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2cliprightbot_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2cliprightbot_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipr:15", "", 15, old_value_t.clipr, new_value_t.clipr };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipb:15", "", 15, old_value_t.clipb, new_value_t.clipb };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2PATPACK_OFFSET 0x5024
#define G2SB_CTX4_G2PATPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx4_g2patpack_u {
    struct {
        unsigned int patlngap:4;            /* Packed mode, pattern data line gap. byte */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2patpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2patpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2patpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patlngap:4",
              "Packed mode, pattern data line gap. byte",
              4, old_value_t.patlngap, new_value_t.patlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2PATPACK_SIZE_OFFSET 0x5025
#define G2SB_CTX4_G2PATPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx4_g2patpack_size_u {
    struct {
        unsigned int patmonow:16;           /* Mono data width in packed mode, byte  */
        unsigned int patmonoh:16;           /*  Pattern mono data height in packed mode, byte  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2patpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2patpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2patpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patmonow:16",
              "Mono data width in packed mode, byte",
              16, old_value_t.patmonow, new_value_t.patmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patmonoh:16",
              " Pattern mono data height in packed mode, byte",
              16, old_value_t.patmonoh, new_value_t.patmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2PATBA_OFFSET 0x5026
#define G2SB_CTX4_G2PATBA_UNDEFMASK 0x00000000
union g2sb_ctx4_g2patba_u {
    struct {
        unsigned int patba:32;              /* If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. } */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2patba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2patba_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2patba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patba:32",
              "If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. }",
              32, old_value_t.patba, new_value_t.patba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2PATOS_OFFSET 0x5027
#define G2SB_CTX4_G2PATOS_UNDEFMASK 0x009E0000
union g2sb_ctx4_g2patos_u {
    struct {
        unsigned int patst:16;              /* stride */
        unsigned int patcd:1;               /* 0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0 */
        unsigned int undefined_bits_17_20:4;
        unsigned int patt:2;                /* Mono pattern transparency enable:  0x=pattern transparency disabled,  10=mono pattern background transparency    or color pattern transparency,  11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied. */
        unsigned int undefined_bit_23:1;
        unsigned int patxo:4;               /* x offset for mono tile pattern fill.  see PATFL */
        unsigned int patyo:4;               /* y offset for mono tile pattern fill.  see PATFL */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2patos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2patos_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2patos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patst:16",
              "stride",
              16, old_value_t.patst, new_value_t.patst };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patcd:1",
              "0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0",
              1, old_value_t.patcd, new_value_t.patcd };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_20:4", "", 4, old_value_t.undefined_bits_17_20, new_value_t.undefined_bits_17_20 };
    m_bit_details_model.bits.append(entry);
    entry = { "21: patt:2",
              "Mono pattern transparency enable:  0x=pattern transparency disabled,\n10=mono pattern background transparency    or color pattern transparency,\n11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied.",
              2, old_value_t.patt, new_value_t.patt };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: patxo:4",
              "x offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patxo, new_value_t.patxo };
    m_bit_details_model.bits.append(entry);
    entry = { "28: patyo:4",
              "y offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patyo, new_value_t.patyo };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2PATBGC_OFFSET 0x5028
#define G2SB_CTX4_G2PATBGC_UNDEFMASK 0x00000000
union g2sb_ctx4_g2patbgc_u {
    struct {
        unsigned int patbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2patbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2patbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2patbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patbgc:32", "", 32, old_value_t.patbgc, new_value_t.patbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2PATFGC_OFFSET 0x5029
#define G2SB_CTX4_G2PATFGC_UNDEFMASK 0x00000000
union g2sb_ctx4_g2patfgc_u {
    struct {
        unsigned int patfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2patfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2patfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2patfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patfgc:32", "", 32, old_value_t.patfgc, new_value_t.patfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2PATKEY_OFFSET 0x502A
#define G2SB_CTX4_G2PATKEY_UNDEFMASK 0x00000000
union g2sb_ctx4_g2patkey_u {
    struct {
        unsigned int patkey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2patkey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2patkey_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2patkey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patkey:32", "", 32, old_value_t.patkey, new_value_t.patkey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2DSTBA_OFFSET 0x502B
#define G2SB_CTX4_G2DSTBA_UNDEFMASK 0x00000000
union g2sb_ctx4_g2dstba_u {
    struct {
        unsigned int dstba:32;              /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2dstba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2dstba_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2dstba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba, new_value_t.dstba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2DSTBA_B_OFFSET 0x502C
#define G2SB_CTX4_G2DSTBA_B_UNDEFMASK 0x00000000
union g2sb_ctx4_g2dstba_b_u {
    struct {
        unsigned int dstba_b:32;            /* Destination base address (byte address) only usable in hardware trigger mode by enable gcsw */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2dstba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2dstba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2dstba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_b:32",
              "Destination base address (byte address) only usable in hardware trigger mode by enable gcsw",
              32, old_value_t.dstba_b, new_value_t.dstba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2DSTBA_C_OFFSET 0x502D
#define G2SB_CTX4_G2DSTBA_C_UNDEFMASK 0x00000000
union g2sb_ctx4_g2dstba_c_u {
    struct {
        unsigned int dstba_c:32;            /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2dstba_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2dstba_c_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2dstba_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_c:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba_c, new_value_t.dstba_c };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2DSTST_OFFSET 0x502E
#define G2SB_CTX4_G2DSTST_UNDEFMASK 0xFFFF0000
union g2sb_ctx4_g2dstst_u {
    struct {
        unsigned int dsts:16;               /* Destination Stride coordinate(bytes) with respect to DSTBA. */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2dstst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2dstst_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2dstst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dsts:16",
              "Destination Stride coordinate(bytes) with respect to DSTBA.",
              16, old_value_t.dsts, new_value_t.dsts };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2SRCPACK_OFFSET 0x502F
#define G2SB_CTX4_G2SRCPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx4_g2srcpack_u {
    struct {
        unsigned int srclngap:4;            /* Packed mode - source mono data line gap */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2srcpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2srcpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2srcpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srclngap:4",
              "Packed mode - source mono data line gap",
              4, old_value_t.srclngap, new_value_t.srclngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2SRCPACK_SIZE_OFFSET 0x5030
#define G2SB_CTX4_G2SRCPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx4_g2srcpack_size_u {
    struct {
        unsigned int srcmonow:16;           /* Packed mode - source mono data width in bytes */
        unsigned int srcmonoh:16;           /* Packed mode - source mono data height in bytes  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2srcpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2srcpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2srcpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcmonow:16",
              "Packed mode - source mono data width in bytes",
              16, old_value_t.srcmonow, new_value_t.srcmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcmonoh:16",
              "Packed mode - source mono data height in bytes",
              16, old_value_t.srcmonoh, new_value_t.srcmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2SRCBA_OFFSET 0x5031
#define G2SB_CTX4_G2SRCBA_UNDEFMASK 0x00000000
union g2sb_ctx4_g2srcba_u {
    struct {
        unsigned int srcba:32;              /* Source base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2srcba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2srcba_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2srcba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba:32",
              "Source base address (byte address)",
              32, old_value_t.srcba, new_value_t.srcba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2SRCBA_B_OFFSET 0x5032
#define G2SB_CTX4_G2SRCBA_B_UNDEFMASK 0x00000000
union g2sb_ctx4_g2srcba_b_u {
    struct {
        unsigned int srcba_b:32;            /* This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.) */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2srcba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2srcba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2srcba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba_b:32",
              "This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.)",
              32, old_value_t.srcba_b, new_value_t.srcba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2SRCST_OFFSET 0x5033
#define G2SB_CTX4_G2SRCST_UNDEFMASK 0xFFFF0000
union g2sb_ctx4_g2srcst_u {
    struct {
        unsigned int srcs:16;               /* Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.  */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2srcst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2srcst_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2srcst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs:16",
              "Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.",
              16, old_value_t.srcs, new_value_t.srcs };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2SRCBGC_OFFSET 0x5034
#define G2SB_CTX4_G2SRCBGC_UNDEFMASK 0x00000000
union g2sb_ctx4_g2srcbgc_u {
    struct {
        unsigned int srcbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2srcbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2srcbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2srcbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcbgc:32", "", 32, old_value_t.srcbgc, new_value_t.srcbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2SRCFGC_OFFSET 0x5035
#define G2SB_CTX4_G2SRCFGC_UNDEFMASK 0x00000000
union g2sb_ctx4_g2srcfgc_u {
    struct {
        unsigned int srcfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2srcfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2srcfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2srcfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcfgc:32", "", 32, old_value_t.srcfgc, new_value_t.srcfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2SRCKEY_OFFSET 0x5036
#define G2SB_CTX4_G2SRCKEY_UNDEFMASK 0x00000000
union g2sb_ctx4_g2srckey_u {
    struct {
        unsigned int srckey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2srckey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2srckey_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2srckey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srckey:32", "", 32, old_value_t.srckey, new_value_t.srckey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2SRCSIZE_OFFSET 0x5037
#define G2SB_CTX4_G2SRCSIZE_UNDEFMASK 0x80008000
union g2sb_ctx4_g2srcsize_u {
    struct {
        unsigned int srcwidth:15;
        unsigned int undefined_bit_15:1;
        unsigned int srcheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2srcsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2srcsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2srcsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcwidth:15", "", 15, old_value_t.srcwidth, new_value_t.srcwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.srcheight, new_value_t.srcheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2DSTSIZE_OFFSET 0x5038
#define G2SB_CTX4_G2DSTSIZE_UNDEFMASK 0x80008000
union g2sb_ctx4_g2dstsize_u {
    struct {
        unsigned int dstwidth:15;           /* In 2D mode, the largest number can be programmed is 0x7fef */
        unsigned int undefined_bit_15:1;
        unsigned int dstheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2dstsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2dstsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2dstsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstwidth:15",
              "In 2D mode, the largest number can be programmed is 0x7fef",
              15, old_value_t.dstwidth, new_value_t.dstwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.dstheight, new_value_t.dstheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2SRCPS_OFFSET 0x5039
#define G2SB_CTX4_G2SRCPS_UNDEFMASK 0x00000000
union g2sb_ctx4_g2srcps_u {
    struct {
        unsigned int srcx:16;               /* SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY   */
        unsigned int srcy:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2srcps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2srcps_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2srcps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcx:16",
              "SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY",
              16, old_value_t.srcx, new_value_t.srcx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcy:16", "", 16, old_value_t.srcy, new_value_t.srcy };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2DSTPS_OFFSET 0x503A
#define G2SB_CTX4_G2DSTPS_UNDEFMASK 0x00000000
union g2sb_ctx4_g2dstps_u {
    struct {
        unsigned int dstx:16;               /* NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 */
        unsigned int dsty:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2dstps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2dstps_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2dstps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstx:16",
              "NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489",
              16, old_value_t.dstx, new_value_t.dstx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dsty:16", "", 16, old_value_t.dsty, new_value_t.dsty };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CBDES_OFFSET 0x503B
#define G2SB_CTX4_G2CBDES_UNDEFMASK 0x0000FF00
union g2sb_ctx4_g2cbdes_u {
    struct {
        unsigned int cbcount:8;             /* This specifies the number of buffers incircular buffer feature                    */
        unsigned int undefined_bits_8_15:8;
        unsigned int cbline:15;             /* vertical line number in one buffer */
        unsigned int topclip:1;             /* top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2 0= disable  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2cbdes_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2cbdes_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2cbdes_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbcount:8",
              "This specifies the number of buffers incircular buffer feature",
              8, old_value_t.cbcount, new_value_t.cbcount };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbline:15",
              "vertical line number in one buffer",
              15, old_value_t.cbline, new_value_t.cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "31: topclip:1",
              "top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2\n0= disable",
              1, old_value_t.topclip, new_value_t.topclip };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CBSTRIDE_OFFSET 0x503C
#define G2SB_CTX4_G2CBSTRIDE_UNDEFMASK 0x3F000000
union g2sb_ctx4_g2cbstride_u {
    struct {
        unsigned int cbstride:24;           /* Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes) */
        unsigned int undefined_bits_24_29:6;
        unsigned int cbuvstride:2;          /* Chroma Buffer Stride default is half of luma   00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2cbstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2cbstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2cbstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbstride:24",
              "Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes)",
              24, old_value_t.cbstride, new_value_t.cbstride };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_29:6", "", 6, old_value_t.undefined_bits_24_29, new_value_t.undefined_bits_24_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: cbuvstride:2",
              "Chroma Buffer Stride default is half of luma  \n00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved",
              2, old_value_t.cbuvstride, new_value_t.cbuvstride };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2LINESETTING_OFFSET 0x503D
#define G2SB_CTX4_G2LINESETTING_UNDEFMASK 0x00E00000
union g2sb_ctx4_g2linesetting_u {
    struct {
        unsigned int gamma:21;
        unsigned int undefined_bits_21_23:3;
        unsigned int major:1;               /* 0:xmajor 1: y major */
        unsigned int linexdir:1;
        unsigned int lineydir:1;
        unsigned int droplastp:1;           /* draw last pixel or not */
        unsigned int lineuseoctant:1;       /* use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR */
        unsigned int octants:3;             /* 000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2linesetting_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2linesetting_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2linesetting_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: gamma:21", "", 21, old_value_t.gamma, new_value_t.gamma };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_23:3", "", 3, old_value_t.undefined_bits_21_23, new_value_t.undefined_bits_21_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: major:1",
              "0:xmajor 1: y major",
              1, old_value_t.major, new_value_t.major };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linexdir:1", "", 1, old_value_t.linexdir, new_value_t.linexdir };
    m_bit_details_model.bits.append(entry);
    entry = { "26: lineydir:1", "", 1, old_value_t.lineydir, new_value_t.lineydir };
    m_bit_details_model.bits.append(entry);
    entry = { "27: droplastp:1",
              "draw last pixel or not",
              1, old_value_t.droplastp, new_value_t.droplastp };
    m_bit_details_model.bits.append(entry);
    entry = { "28: lineuseoctant:1",
              "use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR",
              1, old_value_t.lineuseoctant, new_value_t.lineuseoctant };
    m_bit_details_model.bits.append(entry);
    entry = { "29: octants:3",
              "000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7",
              3, old_value_t.octants, new_value_t.octants };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2LINEDELTAN_OFFSET 0x503E
#define G2SB_CTX4_G2LINEDELTAN_UNDEFMASK 0xFFE00000
union g2sb_ctx4_g2linedeltan_u {
    struct {
        unsigned int deltan:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2linedeltan_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2linedeltan_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2linedeltan_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltan:21", "", 21, old_value_t.deltan, new_value_t.deltan };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2LINEDELTAM_OFFSET 0x503F
#define G2SB_CTX4_G2LINEDELTAM_UNDEFMASK 0xFFE00000
union g2sb_ctx4_g2linedeltam_u {
    struct {
        unsigned int deltam:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2linedeltam_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2linedeltam_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2linedeltam_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltam:21", "", 21, old_value_t.deltam, new_value_t.deltam };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2LINEPOS_OFFSET 0x5040
#define G2SB_CTX4_G2LINEPOS_UNDEFMASK 0x00000000
union g2sb_ctx4_g2linepos_u {
    struct {
        unsigned int linexpos:16;
        unsigned int lineypos:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2linepos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2linepos_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2linepos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linexpos:16", "", 16, old_value_t.linexpos, new_value_t.linexpos };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lineypos:16", "", 16, old_value_t.lineypos, new_value_t.lineypos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2LINELEN_OFFSET 0x5041
#define G2SB_CTX4_G2LINELEN_UNDEFMASK 0xFFFF8000
union g2sb_ctx4_g2linelen_u {
    struct {
        unsigned int linelen:15;
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2linelen_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2linelen_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2linelen_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linelen:15", "", 15, old_value_t.linelen, new_value_t.linelen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CSCFOURTH_OFFSET 0x5042
#define G2SB_CTX4_G2CSCFOURTH_UNDEFMASK 0xFE00FE00
union g2sb_ctx4_g2cscfourth_u {
    struct {
        unsigned int g2u:9;                 /* multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored */
        unsigned int undefined_bits_9_15:7;
        unsigned int g2v:9;                 /* multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored */
        unsigned int undefined_bits_25_31:7;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2cscfourth_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2cscfourth_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2cscfourth_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: g2u:9",
              "multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored",
              9, old_value_t.g2u, new_value_t.g2u };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: g2v:9",
              "multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored",
              9, old_value_t.g2v, new_value_t.g2v };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bits_25_31:7", "", 7, old_value_t.undefined_bits_25_31, new_value_t.undefined_bits_25_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2SRCST_B_OFFSET 0x5043
#define G2SB_CTX4_G2SRCST_B_UNDEFMASK 0xFFFF0000
union g2sb_ctx4_g2srcst_b_u {
    struct {
        unsigned int srcs_b:16;             /* Source Stride B */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2srcst_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2srcst_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2srcst_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs_b:16",
              "Source Stride B",
              16, old_value_t.srcs_b, new_value_t.srcs_b };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2UVSTRIDE_OFFSET 0x5044
#define G2SB_CTX4_G2UVSTRIDE_UNDEFMASK 0xFFFF0000
union g2sb_ctx4_g2uvstride_u {
    struct {
        unsigned int uvstride:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2uvstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2uvstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2uvstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: uvstride:16", "", 16, old_value_t.uvstride, new_value_t.uvstride };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2CBDES2_OFFSET 0x5045
#define G2SB_CTX4_G2CBDES2_UNDEFMASK 0xFFFF8000
union g2sb_ctx4_g2cbdes2_u {
    struct {
        unsigned int top_cbline:15;         /* Circular buffer top clipping enabled, the first buffer line num */
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2cbdes2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2cbdes2_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2cbdes2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: top_cbline:15",
              "Circular buffer top clipping enabled, the first buffer line num",
              15, old_value_t.top_cbline, new_value_t.top_cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2TILEMODE_OFFSET 0x5046
#define G2SB_CTX4_G2TILEMODE_UNDEFMASK 0xFFEEEEEE
union g2sb_ctx4_g2tilemode_u {
    struct {
        unsigned int src_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_1_3:3;
        unsigned int src_uv_tile_mode:1;    /* UV surface, ignored in RGB mode */
        unsigned int undefined_bits_5_7:3;
        unsigned int pat_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_9_11:3;
        unsigned int pat_uv_tile_mode:1;    /* UNUSED */
        unsigned int undefined_bits_13_15:3;
        unsigned int dst_rd_tile_mode:1;    /* Same as destination write unless DST_RD_WR_SEP (not supported) */
        unsigned int undefined_bits_17_19:3;
        unsigned int dst_wr_tile_mode:1;    /* destination surface */
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2tilemode_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2tilemode_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2tilemode_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.src_y_tile_mode, new_value_t.src_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: src_uv_tile_mode:1",
              "UV surface, ignored in RGB mode",
              1, old_value_t.src_uv_tile_mode, new_value_t.src_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: pat_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.pat_y_tile_mode, new_value_t.pat_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: pat_uv_tile_mode:1",
              "UNUSED",
              1, old_value_t.pat_uv_tile_mode, new_value_t.pat_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dst_rd_tile_mode:1",
              "Same as destination write unless DST_RD_WR_SEP (not supported)",
              1, old_value_t.dst_rd_tile_mode, new_value_t.dst_rd_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: dst_wr_tile_mode:1",
              "destination surface",
              1, old_value_t.dst_wr_tile_mode, new_value_t.dst_wr_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2PATBASE_OFFSET 0x5047
#define G2SB_CTX4_G2PATBASE_UNDEFMASK 0x00000000
union g2sb_ctx4_g2patbase_u {
    struct {
        unsigned int pat_base:32;           /* pattern base address in tile mode,  PATBA is the linear address where pixel start */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2patbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2patbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2patbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pat_base:32",
              "pattern base address in tile mode,  PATBA is the linear address where pixel start",
              32, old_value_t.pat_base, new_value_t.pat_base };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2SRCBA_SB_SURFBASE_OFFSET 0x5048
#define G2SB_CTX4_G2SRCBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx4_g2srcba_sb_surfbase_u {
    struct {
        unsigned int src_addr:32;           /* surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2srcba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2srcba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2srcba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_addr:32",
              "surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine",
              32, old_value_t.src_addr, new_value_t.src_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2DSTBA_SB_SURFBASE_OFFSET 0x5049
#define G2SB_CTX4_G2DSTBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx4_g2dstba_sb_surfbase_u {
    struct {
        unsigned int dst_addr:32;           /* surface address corresponding to G2DSTBA Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2dstba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2dstba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2dstba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_addr:32",
              "surface address corresponding to G2DSTBA Only used by the StretchBlit Engine",
              32, old_value_t.dst_addr, new_value_t.dst_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2DSTBA_B_SB_SURFBASE_OFFSET 0x504A
#define G2SB_CTX4_G2DSTBA_B_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx4_g2dstba_b_sb_surfbase_u {
    struct {
        unsigned int dst_b_addr:32;         /* surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2dstba_b_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2dstba_b_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2dstba_b_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_b_addr:32",
              "surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled",
              32, old_value_t.dst_b_addr, new_value_t.dst_b_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2VBA_A_SB_SURFBASE_OFFSET 0x504B
#define G2SB_CTX4_G2VBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx4_g2vba_a_sb_surfbase_u {
    struct {
        unsigned int v_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2vba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2vba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2vba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine",
              32, old_value_t.v_addr, new_value_t.v_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX4_G2UBA_A_SB_SURFBASE_OFFSET 0x504C
#define G2SB_CTX4_G2UBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx4_g2uba_a_sb_surfbase_u {
    struct {
        unsigned int u_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx4_g2uba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx4_g2uba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx4_g2uba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: u_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine",
              32, old_value_t.u_addr, new_value_t.u_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_INCR_SYNCPT_OFFSET 0x2000
#define G2SB_CTX5_INCR_SYNCPT_UNDEFMASK 0xFFFF0000
union g2sb_ctx5_incr_syncpt_u {
    struct {
        unsigned int indx:8;                /* syncpt index value */
        unsigned int cond:8;                /* Condition mapped from raise/wait */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_incr_syncpt_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_incr_syncpt_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_incr_syncpt_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: indx:8",
              "syncpt index value",
              8, old_value_t.indx, new_value_t.indx };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cond:8",
              "Condition mapped from raise/wait",
              8, old_value_t.cond, new_value_t.cond };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_INCR_SYNCPT_CNTRL_OFFSET 0x2001
#define G2SB_CTX5_INCR_SYNCPT_CNTRL_UNDEFMASK 0xFFFFFEFE
union g2sb_ctx5_incr_syncpt_cntrl_u {
    struct {
        unsigned int incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs. */
        unsigned int undefined_bits_1_7:7;
        unsigned int incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled. */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_incr_syncpt_cntrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_incr_syncpt_cntrl_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_incr_syncpt_cntrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: incr_syncpt_soft_reset:1",
              "If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs.",
              1, old_value_t.incr_syncpt_soft_reset, new_value_t.incr_syncpt_soft_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: incr_syncpt_no_stall:1",
              "If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled.",
              1, old_value_t.incr_syncpt_no_stall, new_value_t.incr_syncpt_no_stall };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_INCR_SYNCPT_ERROR_OFFSET 0x2002
#define G2SB_CTX5_INCR_SYNCPT_ERROR_UNDEFMASK 0x00000000
union g2sb_ctx5_incr_syncpt_error_u {
    struct {
        unsigned int cond_status:32;        /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_incr_syncpt_error_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_incr_syncpt_error_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_incr_syncpt_error_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cond_status:32",
              "COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero",
              32, old_value_t.cond_status, new_value_t.cond_status };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CLASSCHANNEL_REGONLY_OFFSET 0x2008
#define G2SB_CTX5_G2CLASSCHANNEL_REGONLY_UNDEFMASK 0xFFE0FC00
union g2sb_ctx5_g2classchannel_regonly_u {
    struct {
        unsigned int curr_class:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int curr_channel:4;
        unsigned int ctx_valid:1;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2classchannel_regonly_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2classchannel_regonly_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2classchannel_regonly_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: curr_class:10", "", 10, old_value_t.curr_class, new_value_t.curr_class };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_15:6", "", 6, old_value_t.undefined_bits_10_15, new_value_t.undefined_bits_10_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: curr_channel:4", "", 4, old_value_t.curr_channel, new_value_t.curr_channel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ctx_valid:1", "", 1, old_value_t.ctx_valid, new_value_t.ctx_valid };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2TRIGGER_OFFSET 0x2009
#define G2SB_CTX5_G2TRIGGER_UNDEFMASK 0xFFFF0000
union g2sb_ctx5_g2trigger_u {
    struct {
        unsigned int trigger:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2trigger_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2trigger_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2trigger_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger:16", "", 16, old_value_t.trigger, new_value_t.trigger };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2TRIGGER1_OFFSET 0x200A
#define G2SB_CTX5_G2TRIGGER1_UNDEFMASK 0xFFFF0000
union g2sb_ctx5_g2trigger1_u {
    struct {
        unsigned int trigger1:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2trigger1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2trigger1_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2trigger1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger1:16", "", 16, old_value_t.trigger1, new_value_t.trigger1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2TRIGGER2_OFFSET 0x200B
#define G2SB_CTX5_G2TRIGGER2_UNDEFMASK 0xFFFF0000
union g2sb_ctx5_g2trigger2_u {
    struct {
        unsigned int trigger2:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2trigger2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2trigger2_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2trigger2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger2:16", "", 16, old_value_t.trigger2, new_value_t.trigger2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CMDSEL_OFFSET 0x200C
#define G2SB_CTX5_G2CMDSEL_UNDEFMASK 0xE000280E
union g2sb_ctx5_g2cmdsel_u {
    struct {
        unsigned int sbor2d:1;
        unsigned int undefined_bits_1_3:3;
        unsigned int cbenable:1;            /* circular buffer feature enable    0= disable */
        unsigned int vitrigger:1;           /* VI trigger enable, can be circular buffer or full frame */
        unsigned int hosttrigger:1;         /* host trigger the command, host also need program cicular buffer related data */
        unsigned int cbsbdisable:1;
        unsigned int g2output:2;            /* 00: to memory 01: to EPP */
        unsigned int clip_source_top_bottom:1;/* Reserved for HW Test, SW should not use this bit. */
        unsigned int undefined_bit_11:1;
        unsigned int link_wait_buf_end:1;
        unsigned int undefined_bit_13:1;
        unsigned int frame_start:1;         /* host writes this bit to tell which buffer is ready */
        unsigned int frame_end:1;
        unsigned int buffer_index:8;
        unsigned int linken:1;              /* Test purpose */
        unsigned int linkval:3;
        unsigned int priority:1;            /* indicates priority of the context, note vi-triggered contexts take priority over HIGH */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2cmdsel_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2cmdsel_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2cmdsel_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sbor2d:1", "", 1, old_value_t.sbor2d, new_value_t.sbor2d };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: cbenable:1",
              "circular buffer feature enable   \n0= disable",
              1, old_value_t.cbenable, new_value_t.cbenable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: vitrigger:1",
              "VI trigger enable, can be circular buffer or full frame",
              1, old_value_t.vitrigger, new_value_t.vitrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "06: hosttrigger:1",
              "host trigger the command, host also need program cicular buffer related data",
              1, old_value_t.hosttrigger, new_value_t.hosttrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "07: cbsbdisable:1", "", 1, old_value_t.cbsbdisable, new_value_t.cbsbdisable };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g2output:2",
              "00: to memory 01: to EPP",
              2, old_value_t.g2output, new_value_t.g2output };
    m_bit_details_model.bits.append(entry);
    entry = { "10: clip_source_top_bottom:1",
              "Reserved for HW Test, SW should not use this bit.",
              1, old_value_t.clip_source_top_bottom, new_value_t.clip_source_top_bottom };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: link_wait_buf_end:1", "", 1, old_value_t.link_wait_buf_end, new_value_t.link_wait_buf_end };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: frame_start:1",
              "host writes this bit to tell which buffer is ready",
              1, old_value_t.frame_start, new_value_t.frame_start };
    m_bit_details_model.bits.append(entry);
    entry = { "15: frame_end:1", "", 1, old_value_t.frame_end, new_value_t.frame_end };
    m_bit_details_model.bits.append(entry);
    entry = { "16: buffer_index:8", "", 8, old_value_t.buffer_index, new_value_t.buffer_index };
    m_bit_details_model.bits.append(entry);
    entry = { "24: linken:1",
              "Test purpose",
              1, old_value_t.linken, new_value_t.linken };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linkval:3", "", 3, old_value_t.linkval, new_value_t.linkval };
    m_bit_details_model.bits.append(entry);
    entry = { "28: priority:1",
              "indicates priority of the context, note vi-triggered contexts take priority over HIGH",
              1, old_value_t.priority, new_value_t.priority };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2RAISE_OFFSET 0x200D
#define G2SB_CTX5_G2RAISE_UNDEFMASK 0xFFF0FFE0
union g2sb_ctx5_g2raise_u {
    struct {
        unsigned int raise:5;               /* Push back to read fifo when all commands in the channel are done.           */
        unsigned int undefined_bits_5_15:11;
        unsigned int raisechannel:4;
        unsigned int undefined_bits_20_31:12;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2raise_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2raise_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2raise_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: raise:5",
              "Push back to read fifo when all commands in the channel are done.",
              5, old_value_t.raise, new_value_t.raise };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_15:11", "", 11, old_value_t.undefined_bits_5_15, new_value_t.undefined_bits_5_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisechannel:4", "", 4, old_value_t.raisechannel, new_value_t.raisechannel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_31:12", "", 12, old_value_t.undefined_bits_20_31, new_value_t.undefined_bits_20_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2HOSTSET_OFFSET 0x200F
#define G2SB_CTX5_G2HOSTSET_UNDEFMASK 0xFFFFFF00
union g2sb_ctx5_g2hostset_u {
    struct {
        unsigned int hstlngap:4;            /*  specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte) */
        unsigned int hstfpxl:4;             /* specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2hostset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2hostset_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2hostset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hstlngap:4",
              " specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte)",
              4, old_value_t.hstlngap, new_value_t.hstlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: hstfpxl:4",
              "specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary",
              4, old_value_t.hstfpxl, new_value_t.hstfpxl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2HOSTFIFO_OFFSET 0x2010
#define G2SB_CTX5_G2HOSTFIFO_UNDEFMASK 0x00000000
union g2sb_ctx5_g2hostfifo_u {
    struct {
        unsigned int hostfifodata:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2hostfifo_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2hostfifo_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2hostfifo_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hostfifodata:32", "", 32, old_value_t.hostfifodata, new_value_t.hostfifodata };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2VDDA_OFFSET 0x2011
#define G2SB_CTX5_G2VDDA_UNDEFMASK 0x00000000
union g2sb_ctx5_g2vdda_u {
    struct {
        unsigned int vdstep:32;             /* Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2vdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2vdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2vdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdstep:32",
              "Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010.",
              32, old_value_t.vdstep, new_value_t.vdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2VDDAINI_OFFSET 0x2012
#define G2SB_CTX5_G2VDDAINI_UNDEFMASK 0xFFFF0000
union g2sb_ctx5_g2vddaini_u {
    struct {
        unsigned int vdtini:8;              /* Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window. */
        unsigned int vdbini:8;              /* Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above) */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2vddaini_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2vddaini_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2vddaini_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdtini:8",
              "Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window.",
              8, old_value_t.vdtini, new_value_t.vdtini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: vdbini:8",
              "Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above)",
              8, old_value_t.vdbini, new_value_t.vdbini };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2HDDA_OFFSET 0x2013
#define G2SB_CTX5_G2HDDA_UNDEFMASK 0x00000000
union g2sb_ctx5_g2hdda_u {
    struct {
        unsigned int hdstep:32;             /* Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2hdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2hdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2hdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdstep:32",
              "Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101.",
              32, old_value_t.hdstep, new_value_t.hdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2HDDAINILS_OFFSET 0x2014
#define G2SB_CTX5_G2HDDAINILS_UNDEFMASK 0xFFFFFF00
union g2sb_ctx5_g2hddainils_u {
    struct {
        unsigned int hdini:8;               /* Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0. */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2hddainils_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2hddainils_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2hddainils_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdini:8",
              "Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0.",
              8, old_value_t.hdini, new_value_t.hdini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CSCFIRST_OFFSET 0x2015
#define G2SB_CTX5_G2CSCFIRST_UNDEFMASK 0x00C00C00
union g2sb_ctx5_g2cscfirst_u {
    struct {
        unsigned int cub:10;                /* multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved  */
        unsigned int undefined_bits_10_11:2;
        unsigned int cvr:10;                /* multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved */
        unsigned int undefined_bits_22_23:2;
        unsigned int yos:8;                 /* Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2cscfirst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2cscfirst_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2cscfirst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cub:10",
              "multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved",
              10, old_value_t.cub, new_value_t.cub };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_11:2", "", 2, old_value_t.undefined_bits_10_11, new_value_t.undefined_bits_10_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cvr:10",
              "multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved",
              10, old_value_t.cvr, new_value_t.cvr };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: yos:8",
              "Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10",
              8, old_value_t.yos, new_value_t.yos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CSCSECOND_OFFSET 0x2016
#define G2SB_CTX5_G2CSCSECOND_UNDEFMASK 0x00C00E00
union g2sb_ctx5_g2cscsecond_u {
    struct {
        unsigned int cug:9;                 /* multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved */
        unsigned int undefined_bits_9_11:3;
        unsigned int cur:10;                /* multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved  */
        unsigned int undefined_bits_22_23:2;
        unsigned int cyx:8;                 /* multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2cscsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2cscsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2cscsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cug:9",
              "multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved",
              9, old_value_t.cug, new_value_t.cug };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cur:10",
              "multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved",
              10, old_value_t.cur, new_value_t.cur };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cyx:8",
              "multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041",
              8, old_value_t.cyx, new_value_t.cyx };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CSCTHIRD_OFFSET 0x2017
#define G2SB_CTX5_G2CSCTHIRD_UNDEFMASK 0xFC00FE00
union g2sb_ctx5_g2cscthird_u {
    struct {
        unsigned int cvg:9;                 /* multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113 */
        unsigned int undefined_bits_9_15:7;
        unsigned int cvb:10;                /* multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021 */
        unsigned int undefined_bits_26_31:6;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2cscthird_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2cscthird_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2cscthird_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cvg:9",
              "multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113",
              9, old_value_t.cvg, new_value_t.cvg };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cvb:10",
              "multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021",
              10, old_value_t.cvb, new_value_t.cvb };
    m_bit_details_model.bits.append(entry);
    entry = { "26: undefined_bits_26_31:6", "", 6, old_value_t.undefined_bits_26_31, new_value_t.undefined_bits_26_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CMKEYL_OFFSET 0x2018
#define G2SB_CTX5_G2CMKEYL_UNDEFMASK 0xFF000000
union g2sb_ctx5_g2cmkeyl_u {
    struct {
        unsigned int ckbl:8;                /* B or Y Color/Chroma Key Lower Limit (CKBL[7:0]) */
        unsigned int ckgl:8;                /* G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level. */
        unsigned int ckrl:8;                /* R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2cmkeyl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2cmkeyl_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2cmkeyl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbl:8",
              "B or Y Color/Chroma Key Lower Limit (CKBL[7:0])",
              8, old_value_t.ckbl, new_value_t.ckbl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgl:8",
              "G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgl, new_value_t.ckgl };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckrl:8",
              "R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved",
              8, old_value_t.ckrl, new_value_t.ckrl };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CMKEYU_OFFSET 0x2019
#define G2SB_CTX5_G2CMKEYU_UNDEFMASK 0xFF000000
union g2sb_ctx5_g2cmkeyu_u {
    struct {
        unsigned int ckbu:8;                /* This is B or Y color/chroma key upper limit value. */
        unsigned int ckgu:8;                /* G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level. */
        unsigned int ckru:8;                /* R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2cmkeyu_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2cmkeyu_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2cmkeyu_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbu:8",
              "This is B or Y color/chroma key upper limit value.",
              8, old_value_t.ckbu, new_value_t.ckbu };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgu:8",
              "G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgu, new_value_t.ckgu };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckru:8",
              "R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved",
              8, old_value_t.ckru, new_value_t.ckru };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2UBA_A_OFFSET 0x201A
#define G2SB_CTX5_G2UBA_A_UNDEFMASK 0x00000000
union g2sb_ctx5_g2uba_a_u {
    struct {
        unsigned int su1sa:32;              /* Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2uba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2uba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2uba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: su1sa:32",
              "Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.su1sa, new_value_t.su1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2VBA_A_OFFSET 0x201B
#define G2SB_CTX5_G2VBA_A_UNDEFMASK 0x00000000
union g2sb_ctx5_g2vba_a_u {
    struct {
        unsigned int sv1sa:32;              /* Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2vba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2vba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2vba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sv1sa:32",
              "Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.sv1sa, new_value_t.sv1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2SBFORMAT_OFFSET 0x201C
#define G2SB_CTX5_G2SBFORMAT_UNDEFMASK 0x000020E0
union g2sb_ctx5_g2sbformat_u {
    struct {
        unsigned int sifmt:5;               /* This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV. */
        unsigned int undefined_bits_5_7:3;
        unsigned int difmt:5;               /* Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED */
        unsigned int undefined_bit_13:1;
        unsigned int raisebufferen:1;       /* ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.  */
        unsigned int raiseframeen:1;        /* ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.  */
        unsigned int raisebuffervalue:8;    /* Raise buffer vector value. */
        unsigned int raiseframevalue:8;     /* Raise Fram vector value. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2sbformat_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2sbformat_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2sbformat_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sifmt:5",
              "This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV.",
              5, old_value_t.sifmt, new_value_t.sifmt };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: difmt:5",
              "Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED",
              5, old_value_t.difmt, new_value_t.difmt };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: raisebufferen:1",
              "ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raisebufferen, new_value_t.raisebufferen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: raiseframeen:1",
              "ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raiseframeen, new_value_t.raiseframeen };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisebuffervalue:8",
              "Raise buffer vector value.",
              8, old_value_t.raisebuffervalue, new_value_t.raisebuffervalue };
    m_bit_details_model.bits.append(entry);
    entry = { "24: raiseframevalue:8",
              "Raise Fram vector value.",
              8, old_value_t.raiseframevalue, new_value_t.raiseframevalue };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CONTROLSB_OFFSET 0x201D
#define G2SB_CTX5_G2CONTROLSB_UNDEFMASK 0x20005807
union g2sb_ctx5_g2controlsb_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int yuv422rotation:1;      /* yuv422 plannar rotated */
        unsigned int yuv422planar:1;        /* source data is yuv422 planar valid when imode==PLANAR */
        unsigned int imode:1;               /* Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d. */
        unsigned int enavf:1;               /* enable alpha vertical filter     */
        unsigned int enahf:1;               /* enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format, */
        unsigned int uvst:2;                /*   00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.   11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride). */
        unsigned int sl:1;                  /* Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines. */
        unsigned int undefined_bits_11_12:2;
        unsigned int sisel:1;               /* StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved  */
        unsigned int undefined_bit_14:1;
        unsigned int sbltsrc:1;             /* StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator. */
        unsigned int vftype:2;              /* StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager. */
        unsigned int vfen:1;                /* StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled. */
        unsigned int discsc:1;              /* enabled color space converter by default */
        unsigned int hftype:3;              /* StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE. */
        unsigned int rangeredfrm:1;         /* In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.  */
        unsigned int sitype:1;              /* StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?. */
        unsigned int sbsel:1;               /* StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer. */
        unsigned int dbsel:1;               /* StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer. */
        unsigned int keyen:1;               /* Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled. */
        unsigned int kpol:1;                /* Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range. */
        unsigned int undefined_bit_29:1;
        unsigned int endith:1;              /* Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering */
        unsigned int disdw:1;               /* output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2controlsb_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2controlsb_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2controlsb_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_2:3", "", 3, old_value_t.undefined_bits_0_2, new_value_t.undefined_bits_0_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: yuv422rotation:1",
              "yuv422 plannar rotated",
              1, old_value_t.yuv422rotation, new_value_t.yuv422rotation };
    m_bit_details_model.bits.append(entry);
    entry = { "04: yuv422planar:1",
              "source data is yuv422 planar valid when imode==PLANAR",
              1, old_value_t.yuv422planar, new_value_t.yuv422planar };
    m_bit_details_model.bits.append(entry);
    entry = { "05: imode:1",
              "Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d.",
              1, old_value_t.imode, new_value_t.imode };
    m_bit_details_model.bits.append(entry);
    entry = { "06: enavf:1",
              "enable alpha vertical filter",
              1, old_value_t.enavf, new_value_t.enavf };
    m_bit_details_model.bits.append(entry);
    entry = { "07: enahf:1",
              "enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format,",
              1, old_value_t.enahf, new_value_t.enahf };
    m_bit_details_model.bits.append(entry);
    entry = { "08: uvst:2",
              " \n00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.\n11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride).",
              2, old_value_t.uvst, new_value_t.uvst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: sl:1",
              "Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines.",
              1, old_value_t.sl, new_value_t.sl };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_12:2", "", 2, old_value_t.undefined_bits_11_12, new_value_t.undefined_bits_11_12 };
    m_bit_details_model.bits.append(entry);
    entry = { "13: sisel:1",
              "StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved",
              1, old_value_t.sisel, new_value_t.sisel };
    m_bit_details_model.bits.append(entry);
    entry = { "14: undefined_bit_14:1", "", 1, old_value_t.undefined_bit_14, new_value_t.undefined_bit_14 };
    m_bit_details_model.bits.append(entry);
    entry = { "15: sbltsrc:1",
              "StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator.",
              1, old_value_t.sbltsrc, new_value_t.sbltsrc };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vftype:2",
              "StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager.",
              2, old_value_t.vftype, new_value_t.vftype };
    m_bit_details_model.bits.append(entry);
    entry = { "18: vfen:1",
              "StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled.",
              1, old_value_t.vfen, new_value_t.vfen };
    m_bit_details_model.bits.append(entry);
    entry = { "19: discsc:1",
              "enabled color space converter by default",
              1, old_value_t.discsc, new_value_t.discsc };
    m_bit_details_model.bits.append(entry);
    entry = { "20: hftype:3",
              "StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE.",
              3, old_value_t.hftype, new_value_t.hftype };
    m_bit_details_model.bits.append(entry);
    entry = { "23: rangeredfrm:1",
              "In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.",
              1, old_value_t.rangeredfrm, new_value_t.rangeredfrm };
    m_bit_details_model.bits.append(entry);
    entry = { "24: sitype:1",
              "StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?.",
              1, old_value_t.sitype, new_value_t.sitype };
    m_bit_details_model.bits.append(entry);
    entry = { "25: sbsel:1",
              "StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer.",
              1, old_value_t.sbsel, new_value_t.sbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "26: dbsel:1",
              "StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer.",
              1, old_value_t.dbsel, new_value_t.dbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "27: keyen:1",
              "Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled.",
              1, old_value_t.keyen, new_value_t.keyen };
    m_bit_details_model.bits.append(entry);
    entry = { "28: kpol:1",
              "Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range.",
              1, old_value_t.kpol, new_value_t.kpol };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: endith:1",
              "Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering",
              1, old_value_t.endith, new_value_t.endith };
    m_bit_details_model.bits.append(entry);
    entry = { "31: disdw:1",
              "output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place.",
              1, old_value_t.disdw, new_value_t.disdw };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CONTROLSECOND_OFFSET 0x201E
#define G2SB_CTX5_G2CONTROLSECOND_UNDEFMASK 0xC08E3C01
union g2sb_ctx5_g2controlsecond_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int bitswap:1;             /* Host port bit swap 1=enable   0= disable   1= enable */
        unsigned int bebswap:1;             /* Host port byte swap 1=enable   0= disable   1= enable */
        unsigned int bewswap:1;             /* Host port word swap 1=enable   0= disable */
        unsigned int alptype:5;             /* Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits. */
        unsigned int alpsrcordst:1;         /* 32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha */
        unsigned int undefined_bits_10_13:4;
        unsigned int pxlrep:1;              /* Pixel replication for Palm OS. */
        unsigned int swapblt:1;             /* Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area */
        unsigned int vcaa_safe_mode:1;      /* VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken. */
        unsigned int undefined_bits_17_19:3;
        unsigned int g2nostop:1;
        unsigned int clipc:2;               /* Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,  10=draw only inside clipping rectangle,  11=draw only outside clipping rectangle */
        unsigned int undefined_bit_23:1;
        unsigned int fr_mode:2;             /* Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice. 00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so! 01 = src/dst copy mode - two separate buffers 10 = square in place - one buffer 11 = blank */
        unsigned int fr_type:3;             /*  Fast Rotate type     000 = FLIP_X  001 = FLIP_Y  010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right) 011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left) 100 = ROT_90 (counter clock wise by 90 degrees) 101 = ROT_180  110 = ROT_270 (clock wise by 90 degrees) 111 = IDENTITY */
        unsigned int fr_readwait:1;         /*  Fast Rotate wait for read 0 = disable 1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only. */
        unsigned int undefined_bits_30_31:2;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2controlsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2controlsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2controlsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bit_0:1", "", 1, old_value_t.undefined_bit_0, new_value_t.undefined_bit_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "01: bitswap:1",
              "Host port bit swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bitswap, new_value_t.bitswap };
    m_bit_details_model.bits.append(entry);
    entry = { "02: bebswap:1",
              "Host port byte swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bebswap, new_value_t.bebswap };
    m_bit_details_model.bits.append(entry);
    entry = { "03: bewswap:1",
              "Host port word swap\n1=enable  \n0= disable",
              1, old_value_t.bewswap, new_value_t.bewswap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: alptype:5",
              "Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits.",
              5, old_value_t.alptype, new_value_t.alptype };
    m_bit_details_model.bits.append(entry);
    entry = { "09: alpsrcordst:1",
              "32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha",
              1, old_value_t.alpsrcordst, new_value_t.alpsrcordst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_13:4", "", 4, old_value_t.undefined_bits_10_13, new_value_t.undefined_bits_10_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: pxlrep:1",
              "Pixel replication for Palm OS.",
              1, old_value_t.pxlrep, new_value_t.pxlrep };
    m_bit_details_model.bits.append(entry);
    entry = { "15: swapblt:1",
              "Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area",
              1, old_value_t.swapblt, new_value_t.swapblt };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vcaa_safe_mode:1",
              "VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken.",
              1, old_value_t.vcaa_safe_mode, new_value_t.vcaa_safe_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: g2nostop:1", "", 1, old_value_t.g2nostop, new_value_t.g2nostop };
    m_bit_details_model.bits.append(entry);
    entry = { "21: clipc:2",
              "Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,\n10=draw only inside clipping rectangle,\n11=draw only outside clipping rectangle",
              2, old_value_t.clipc, new_value_t.clipc };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fr_mode:2",
              "Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice.\n00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so!\n01 = src/dst copy mode - two separate buffers\n10 = square in place - one buffer\n11 = blank",
              2, old_value_t.fr_mode, new_value_t.fr_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "26: fr_type:3",
              " Fast Rotate type    \n000 = FLIP_X \n001 = FLIP_Y \n010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right)\n011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left)\n100 = ROT_90 (counter clock wise by 90 degrees)\n101 = ROT_180 \n110 = ROT_270 (clock wise by 90 degrees)\n111 = IDENTITY",
              3, old_value_t.fr_type, new_value_t.fr_type };
    m_bit_details_model.bits.append(entry);
    entry = { "29: fr_readwait:1",
              " Fast Rotate wait for read\n0 = disable\n1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only.",
              1, old_value_t.fr_readwait, new_value_t.fr_readwait };
    m_bit_details_model.bits.append(entry);
    entry = { "30: undefined_bits_30_31:2", "", 2, old_value_t.undefined_bits_30_31, new_value_t.undefined_bits_30_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CONTROLMAIN_OFFSET 0x201F
#define G2SB_CTX5_G2CONTROLMAIN_UNDEFMASK 0x80000000
union g2sb_ctx5_g2controlmain_u {
    struct {
        unsigned int cmdt:2;                /* Command Type:  00=BitBlt 01=Line Draw  10=VCAA 11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed) */
        unsigned int turbofill:1;           /* fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified. */
        unsigned int test0bit:1;            /* Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish. */
        unsigned int faden:1;               /* BitBlt Source Copy Fade enable, 1=enable (share with mltln), only support  16bpp mode */
        unsigned int alpen:1;               /* BitBlt Alpha Blending, 1=enable. 0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype */
        unsigned int srcsld:1;              /* BitBlt Solid Source Color Fill: 1=enable. FGC will be used as  the color value. */
        unsigned int patsld:1;              /* BitBlt Solid Pattern Fill: 1=enable. BGC will be used as  the color value. */
        unsigned int patfl:1;               /* When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+ */
        unsigned int xdir:1;                /*  0=incrementing, 1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0 */
        unsigned int ydir:1;                /*  0=incrementing, 1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0 */
        unsigned int xytdw:1;               /* xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination. */
        unsigned int srcpack:1;             /* Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled. */
        unsigned int patpack:1;             /* Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled. */
        unsigned int yflip:1;               /* flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination. */
        unsigned int srcsel:1;              /* Source Data Select: */
        unsigned int dstcd:2;               /* Destination color depth:   00=8-bpp, 01=16-bpp, 10=32-bpp. 11=reserved */
        unsigned int dstt:2;                /* Destination read transparency enable:   0x=destination read transparency disabled   10=color destination read transparency   11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately, 0=wait for launch write) */
        unsigned int srccd:1;               /* 0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0 */
        unsigned int hlmono:1;              /* Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit */
        unsigned int srct:2;                /* Source transparency enable: 0x=source transparency disabled,  10=mono source background transparency     or color source transparency,  11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied. */
        unsigned int srcbas:1;              /* Source base address select:   0=srcba, 1=dstba. This is not used for Line Draw and  if source data comes from host memory. */
        unsigned int gcsw:2;                /* Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used */
        unsigned int srcdir:1;              /* source direct addressing */
        unsigned int dstdir:1;              /* destination direct addressing */
        unsigned int dst_rd_wr_sep:1;       /* This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA */
        unsigned int patsel:1;              /* pattern Data Select: SRCSEL and PATSEL can't be both enabled. */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2controlmain_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2controlmain_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2controlmain_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cmdt:2",
              "Command Type: \n00=BitBlt\n01=Line Draw \n10=VCAA\n11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed)",
              2, old_value_t.cmdt, new_value_t.cmdt };
    m_bit_details_model.bits.append(entry);
    entry = { "02: turbofill:1",
              "fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified.",
              1, old_value_t.turbofill, new_value_t.turbofill };
    m_bit_details_model.bits.append(entry);
    entry = { "03: test0bit:1",
              "Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish.",
              1, old_value_t.test0bit, new_value_t.test0bit };
    m_bit_details_model.bits.append(entry);
    entry = { "04: faden:1",
              "BitBlt Source Copy Fade enable,\n1=enable (share with mltln), only support  16bpp mode",
              1, old_value_t.faden, new_value_t.faden };
    m_bit_details_model.bits.append(entry);
    entry = { "05: alpen:1",
              "BitBlt Alpha Blending,\n1=enable.\n0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype",
              1, old_value_t.alpen, new_value_t.alpen };
    m_bit_details_model.bits.append(entry);
    entry = { "06: srcsld:1",
              "BitBlt Solid Source Color Fill:\n1=enable. FGC will be used as  the color value.",
              1, old_value_t.srcsld, new_value_t.srcsld };
    m_bit_details_model.bits.append(entry);
    entry = { "07: patsld:1",
              "BitBlt Solid Pattern Fill:\n1=enable. BGC will be used as  the color value.",
              1, old_value_t.patsld, new_value_t.patsld };
    m_bit_details_model.bits.append(entry);
    entry = { "08: patfl:1",
              "When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+",
              1, old_value_t.patfl, new_value_t.patfl };
    m_bit_details_model.bits.append(entry);
    entry = { "09: xdir:1",
              "0=incrementing,\n1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0",
              1, old_value_t.xdir, new_value_t.xdir };
    m_bit_details_model.bits.append(entry);
    entry = { "10: ydir:1",
              "0=incrementing,\n1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0",
              1, old_value_t.ydir, new_value_t.ydir };
    m_bit_details_model.bits.append(entry);
    entry = { "11: xytdw:1",
              "xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination.",
              1, old_value_t.xytdw, new_value_t.xytdw };
    m_bit_details_model.bits.append(entry);
    entry = { "12: srcpack:1",
              "Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.srcpack, new_value_t.srcpack };
    m_bit_details_model.bits.append(entry);
    entry = { "13: patpack:1",
              "Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.patpack, new_value_t.patpack };
    m_bit_details_model.bits.append(entry);
    entry = { "14: yflip:1",
              "flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination.",
              1, old_value_t.yflip, new_value_t.yflip };
    m_bit_details_model.bits.append(entry);
    entry = { "15: srcsel:1",
              "Source Data Select:",
              1, old_value_t.srcsel, new_value_t.srcsel };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstcd:2",
              "Destination color depth:  \n00=8-bpp,\n01=16-bpp,\n10=32-bpp.\n11=reserved",
              2, old_value_t.dstcd, new_value_t.dstcd };
    m_bit_details_model.bits.append(entry);
    entry = { "18: dstt:2",
              "Destination read transparency enable:   0x=destination read transparency disabled  \n10=color destination read transparency  \n11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately,\n0=wait for launch write)",
              2, old_value_t.dstt, new_value_t.dstt };
    m_bit_details_model.bits.append(entry);
    entry = { "20: srccd:1",
              "0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0",
              1, old_value_t.srccd, new_value_t.srccd };
    m_bit_details_model.bits.append(entry);
    entry = { "21: hlmono:1",
              "Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit",
              1, old_value_t.hlmono, new_value_t.hlmono };
    m_bit_details_model.bits.append(entry);
    entry = { "22: srct:2",
              "Source transparency enable: 0x=source transparency disabled,\n10=mono source background transparency     or color source transparency,\n11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied.",
              2, old_value_t.srct, new_value_t.srct };
    m_bit_details_model.bits.append(entry);
    entry = { "24: srcbas:1",
              "Source base address select:  \n0=srcba,\n1=dstba. This is not used for Line Draw and  if source data comes from host memory.",
              1, old_value_t.srcbas, new_value_t.srcbas };
    m_bit_details_model.bits.append(entry);
    entry = { "25: gcsw:2",
              "Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used",
              2, old_value_t.gcsw, new_value_t.gcsw };
    m_bit_details_model.bits.append(entry);
    entry = { "27: srcdir:1",
              "source direct addressing",
              1, old_value_t.srcdir, new_value_t.srcdir };
    m_bit_details_model.bits.append(entry);
    entry = { "28: dstdir:1",
              "destination direct addressing",
              1, old_value_t.dstdir, new_value_t.dstdir };
    m_bit_details_model.bits.append(entry);
    entry = { "29: dst_rd_wr_sep:1",
              "This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA",
              1, old_value_t.dst_rd_wr_sep, new_value_t.dst_rd_wr_sep };
    m_bit_details_model.bits.append(entry);
    entry = { "30: patsel:1",
              "pattern Data Select: SRCSEL and PATSEL can't be both enabled.",
              1, old_value_t.patsel, new_value_t.patsel };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2ROPFADE_OFFSET 0x2020
#define G2SB_CTX5_G2ROPFADE_UNDEFMASK 0x0000FF00
union g2sb_ctx5_g2ropfade_u {
    struct {
        unsigned int rop:8;                 /* If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out. */
        unsigned int undefined_bits_8_15:8;
        unsigned int fadcoe:8;
        unsigned int fadoff:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2ropfade_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2ropfade_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2ropfade_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: rop:8",
              "If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out.",
              8, old_value_t.rop, new_value_t.rop };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: fadcoe:8", "", 8, old_value_t.fadcoe, new_value_t.fadcoe };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fadoff:8", "", 8, old_value_t.fadoff, new_value_t.fadoff };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2ALPHABLEND_OFFSET 0x2021
#define G2SB_CTX5_G2ALPHABLEND_UNDEFMASK 0x0000FE00
union g2sb_ctx5_g2alphablend_u {
    struct {
        unsigned int alpha:8;
        unsigned int alphainv:1;
        unsigned int undefined_bits_9_15:7;
        unsigned int alpha0v:8;
        unsigned int alpha1v:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2alphablend_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2alphablend_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2alphablend_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: alpha:8", "", 8, old_value_t.alpha, new_value_t.alpha };
    m_bit_details_model.bits.append(entry);
    entry = { "08: alphainv:1", "", 1, old_value_t.alphainv, new_value_t.alphainv };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: alpha0v:8", "", 8, old_value_t.alpha0v, new_value_t.alpha0v };
    m_bit_details_model.bits.append(entry);
    entry = { "24: alpha1v:8", "", 8, old_value_t.alpha1v, new_value_t.alpha1v };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CLIPLEFTTOP_OFFSET 0x2022
#define G2SB_CTX5_G2CLIPLEFTTOP_UNDEFMASK 0x80008000
union g2sb_ctx5_g2cliplefttop_u {
    struct {
        unsigned int clipl:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipt:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2cliplefttop_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2cliplefttop_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2cliplefttop_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipl:15", "", 15, old_value_t.clipl, new_value_t.clipl };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipt:15", "", 15, old_value_t.clipt, new_value_t.clipt };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CLIPRIGHTBOT_OFFSET 0x2023
#define G2SB_CTX5_G2CLIPRIGHTBOT_UNDEFMASK 0x80008000
union g2sb_ctx5_g2cliprightbot_u {
    struct {
        unsigned int clipr:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipb:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2cliprightbot_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2cliprightbot_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2cliprightbot_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipr:15", "", 15, old_value_t.clipr, new_value_t.clipr };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipb:15", "", 15, old_value_t.clipb, new_value_t.clipb };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2PATPACK_OFFSET 0x2024
#define G2SB_CTX5_G2PATPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx5_g2patpack_u {
    struct {
        unsigned int patlngap:4;            /* Packed mode, pattern data line gap. byte */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2patpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2patpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2patpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patlngap:4",
              "Packed mode, pattern data line gap. byte",
              4, old_value_t.patlngap, new_value_t.patlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2PATPACK_SIZE_OFFSET 0x2025
#define G2SB_CTX5_G2PATPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx5_g2patpack_size_u {
    struct {
        unsigned int patmonow:16;           /* Mono data width in packed mode, byte  */
        unsigned int patmonoh:16;           /*  Pattern mono data height in packed mode, byte  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2patpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2patpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2patpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patmonow:16",
              "Mono data width in packed mode, byte",
              16, old_value_t.patmonow, new_value_t.patmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patmonoh:16",
              " Pattern mono data height in packed mode, byte",
              16, old_value_t.patmonoh, new_value_t.patmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2PATBA_OFFSET 0x2026
#define G2SB_CTX5_G2PATBA_UNDEFMASK 0x00000000
union g2sb_ctx5_g2patba_u {
    struct {
        unsigned int patba:32;              /* If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. } */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2patba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2patba_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2patba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patba:32",
              "If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. }",
              32, old_value_t.patba, new_value_t.patba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2PATOS_OFFSET 0x2027
#define G2SB_CTX5_G2PATOS_UNDEFMASK 0x009E0000
union g2sb_ctx5_g2patos_u {
    struct {
        unsigned int patst:16;              /* stride */
        unsigned int patcd:1;               /* 0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0 */
        unsigned int undefined_bits_17_20:4;
        unsigned int patt:2;                /* Mono pattern transparency enable:  0x=pattern transparency disabled,  10=mono pattern background transparency    or color pattern transparency,  11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied. */
        unsigned int undefined_bit_23:1;
        unsigned int patxo:4;               /* x offset for mono tile pattern fill.  see PATFL */
        unsigned int patyo:4;               /* y offset for mono tile pattern fill.  see PATFL */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2patos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2patos_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2patos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patst:16",
              "stride",
              16, old_value_t.patst, new_value_t.patst };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patcd:1",
              "0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0",
              1, old_value_t.patcd, new_value_t.patcd };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_20:4", "", 4, old_value_t.undefined_bits_17_20, new_value_t.undefined_bits_17_20 };
    m_bit_details_model.bits.append(entry);
    entry = { "21: patt:2",
              "Mono pattern transparency enable:  0x=pattern transparency disabled,\n10=mono pattern background transparency    or color pattern transparency,\n11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied.",
              2, old_value_t.patt, new_value_t.patt };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: patxo:4",
              "x offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patxo, new_value_t.patxo };
    m_bit_details_model.bits.append(entry);
    entry = { "28: patyo:4",
              "y offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patyo, new_value_t.patyo };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2PATBGC_OFFSET 0x2028
#define G2SB_CTX5_G2PATBGC_UNDEFMASK 0x00000000
union g2sb_ctx5_g2patbgc_u {
    struct {
        unsigned int patbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2patbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2patbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2patbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patbgc:32", "", 32, old_value_t.patbgc, new_value_t.patbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2PATFGC_OFFSET 0x2029
#define G2SB_CTX5_G2PATFGC_UNDEFMASK 0x00000000
union g2sb_ctx5_g2patfgc_u {
    struct {
        unsigned int patfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2patfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2patfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2patfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patfgc:32", "", 32, old_value_t.patfgc, new_value_t.patfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2PATKEY_OFFSET 0x202A
#define G2SB_CTX5_G2PATKEY_UNDEFMASK 0x00000000
union g2sb_ctx5_g2patkey_u {
    struct {
        unsigned int patkey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2patkey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2patkey_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2patkey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patkey:32", "", 32, old_value_t.patkey, new_value_t.patkey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2DSTBA_OFFSET 0x202B
#define G2SB_CTX5_G2DSTBA_UNDEFMASK 0x00000000
union g2sb_ctx5_g2dstba_u {
    struct {
        unsigned int dstba:32;              /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2dstba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2dstba_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2dstba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba, new_value_t.dstba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2DSTBA_B_OFFSET 0x202C
#define G2SB_CTX5_G2DSTBA_B_UNDEFMASK 0x00000000
union g2sb_ctx5_g2dstba_b_u {
    struct {
        unsigned int dstba_b:32;            /* Destination base address (byte address) only usable in hardware trigger mode by enable gcsw */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2dstba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2dstba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2dstba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_b:32",
              "Destination base address (byte address) only usable in hardware trigger mode by enable gcsw",
              32, old_value_t.dstba_b, new_value_t.dstba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2DSTBA_C_OFFSET 0x202D
#define G2SB_CTX5_G2DSTBA_C_UNDEFMASK 0x00000000
union g2sb_ctx5_g2dstba_c_u {
    struct {
        unsigned int dstba_c:32;            /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2dstba_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2dstba_c_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2dstba_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_c:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba_c, new_value_t.dstba_c };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2DSTST_OFFSET 0x202E
#define G2SB_CTX5_G2DSTST_UNDEFMASK 0xFFFF0000
union g2sb_ctx5_g2dstst_u {
    struct {
        unsigned int dsts:16;               /* Destination Stride coordinate(bytes) with respect to DSTBA. */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2dstst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2dstst_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2dstst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dsts:16",
              "Destination Stride coordinate(bytes) with respect to DSTBA.",
              16, old_value_t.dsts, new_value_t.dsts };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2SRCPACK_OFFSET 0x202F
#define G2SB_CTX5_G2SRCPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx5_g2srcpack_u {
    struct {
        unsigned int srclngap:4;            /* Packed mode - source mono data line gap */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2srcpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2srcpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2srcpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srclngap:4",
              "Packed mode - source mono data line gap",
              4, old_value_t.srclngap, new_value_t.srclngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2SRCPACK_SIZE_OFFSET 0x2030
#define G2SB_CTX5_G2SRCPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx5_g2srcpack_size_u {
    struct {
        unsigned int srcmonow:16;           /* Packed mode - source mono data width in bytes */
        unsigned int srcmonoh:16;           /* Packed mode - source mono data height in bytes  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2srcpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2srcpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2srcpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcmonow:16",
              "Packed mode - source mono data width in bytes",
              16, old_value_t.srcmonow, new_value_t.srcmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcmonoh:16",
              "Packed mode - source mono data height in bytes",
              16, old_value_t.srcmonoh, new_value_t.srcmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2SRCBA_OFFSET 0x2031
#define G2SB_CTX5_G2SRCBA_UNDEFMASK 0x00000000
union g2sb_ctx5_g2srcba_u {
    struct {
        unsigned int srcba:32;              /* Source base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2srcba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2srcba_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2srcba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba:32",
              "Source base address (byte address)",
              32, old_value_t.srcba, new_value_t.srcba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2SRCBA_B_OFFSET 0x2032
#define G2SB_CTX5_G2SRCBA_B_UNDEFMASK 0x00000000
union g2sb_ctx5_g2srcba_b_u {
    struct {
        unsigned int srcba_b:32;            /* This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.) */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2srcba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2srcba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2srcba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba_b:32",
              "This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.)",
              32, old_value_t.srcba_b, new_value_t.srcba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2SRCST_OFFSET 0x2033
#define G2SB_CTX5_G2SRCST_UNDEFMASK 0xFFFF0000
union g2sb_ctx5_g2srcst_u {
    struct {
        unsigned int srcs:16;               /* Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.  */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2srcst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2srcst_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2srcst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs:16",
              "Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.",
              16, old_value_t.srcs, new_value_t.srcs };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2SRCBGC_OFFSET 0x2034
#define G2SB_CTX5_G2SRCBGC_UNDEFMASK 0x00000000
union g2sb_ctx5_g2srcbgc_u {
    struct {
        unsigned int srcbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2srcbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2srcbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2srcbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcbgc:32", "", 32, old_value_t.srcbgc, new_value_t.srcbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2SRCFGC_OFFSET 0x2035
#define G2SB_CTX5_G2SRCFGC_UNDEFMASK 0x00000000
union g2sb_ctx5_g2srcfgc_u {
    struct {
        unsigned int srcfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2srcfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2srcfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2srcfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcfgc:32", "", 32, old_value_t.srcfgc, new_value_t.srcfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2SRCKEY_OFFSET 0x2036
#define G2SB_CTX5_G2SRCKEY_UNDEFMASK 0x00000000
union g2sb_ctx5_g2srckey_u {
    struct {
        unsigned int srckey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2srckey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2srckey_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2srckey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srckey:32", "", 32, old_value_t.srckey, new_value_t.srckey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2SRCSIZE_OFFSET 0x2037
#define G2SB_CTX5_G2SRCSIZE_UNDEFMASK 0x80008000
union g2sb_ctx5_g2srcsize_u {
    struct {
        unsigned int srcwidth:15;
        unsigned int undefined_bit_15:1;
        unsigned int srcheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2srcsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2srcsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2srcsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcwidth:15", "", 15, old_value_t.srcwidth, new_value_t.srcwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.srcheight, new_value_t.srcheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2DSTSIZE_OFFSET 0x2038
#define G2SB_CTX5_G2DSTSIZE_UNDEFMASK 0x80008000
union g2sb_ctx5_g2dstsize_u {
    struct {
        unsigned int dstwidth:15;           /* In 2D mode, the largest number can be programmed is 0x7fef */
        unsigned int undefined_bit_15:1;
        unsigned int dstheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2dstsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2dstsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2dstsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstwidth:15",
              "In 2D mode, the largest number can be programmed is 0x7fef",
              15, old_value_t.dstwidth, new_value_t.dstwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.dstheight, new_value_t.dstheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2SRCPS_OFFSET 0x2039
#define G2SB_CTX5_G2SRCPS_UNDEFMASK 0x00000000
union g2sb_ctx5_g2srcps_u {
    struct {
        unsigned int srcx:16;               /* SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY   */
        unsigned int srcy:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2srcps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2srcps_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2srcps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcx:16",
              "SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY",
              16, old_value_t.srcx, new_value_t.srcx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcy:16", "", 16, old_value_t.srcy, new_value_t.srcy };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2DSTPS_OFFSET 0x203A
#define G2SB_CTX5_G2DSTPS_UNDEFMASK 0x00000000
union g2sb_ctx5_g2dstps_u {
    struct {
        unsigned int dstx:16;               /* NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 */
        unsigned int dsty:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2dstps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2dstps_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2dstps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstx:16",
              "NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489",
              16, old_value_t.dstx, new_value_t.dstx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dsty:16", "", 16, old_value_t.dsty, new_value_t.dsty };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CBDES_OFFSET 0x203B
#define G2SB_CTX5_G2CBDES_UNDEFMASK 0x0000FF00
union g2sb_ctx5_g2cbdes_u {
    struct {
        unsigned int cbcount:8;             /* This specifies the number of buffers incircular buffer feature                    */
        unsigned int undefined_bits_8_15:8;
        unsigned int cbline:15;             /* vertical line number in one buffer */
        unsigned int topclip:1;             /* top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2 0= disable  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2cbdes_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2cbdes_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2cbdes_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbcount:8",
              "This specifies the number of buffers incircular buffer feature",
              8, old_value_t.cbcount, new_value_t.cbcount };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbline:15",
              "vertical line number in one buffer",
              15, old_value_t.cbline, new_value_t.cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "31: topclip:1",
              "top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2\n0= disable",
              1, old_value_t.topclip, new_value_t.topclip };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CBSTRIDE_OFFSET 0x203C
#define G2SB_CTX5_G2CBSTRIDE_UNDEFMASK 0x3F000000
union g2sb_ctx5_g2cbstride_u {
    struct {
        unsigned int cbstride:24;           /* Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes) */
        unsigned int undefined_bits_24_29:6;
        unsigned int cbuvstride:2;          /* Chroma Buffer Stride default is half of luma   00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2cbstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2cbstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2cbstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbstride:24",
              "Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes)",
              24, old_value_t.cbstride, new_value_t.cbstride };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_29:6", "", 6, old_value_t.undefined_bits_24_29, new_value_t.undefined_bits_24_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: cbuvstride:2",
              "Chroma Buffer Stride default is half of luma  \n00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved",
              2, old_value_t.cbuvstride, new_value_t.cbuvstride };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2LINESETTING_OFFSET 0x203D
#define G2SB_CTX5_G2LINESETTING_UNDEFMASK 0x00E00000
union g2sb_ctx5_g2linesetting_u {
    struct {
        unsigned int gamma:21;
        unsigned int undefined_bits_21_23:3;
        unsigned int major:1;               /* 0:xmajor 1: y major */
        unsigned int linexdir:1;
        unsigned int lineydir:1;
        unsigned int droplastp:1;           /* draw last pixel or not */
        unsigned int lineuseoctant:1;       /* use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR */
        unsigned int octants:3;             /* 000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2linesetting_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2linesetting_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2linesetting_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: gamma:21", "", 21, old_value_t.gamma, new_value_t.gamma };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_23:3", "", 3, old_value_t.undefined_bits_21_23, new_value_t.undefined_bits_21_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: major:1",
              "0:xmajor 1: y major",
              1, old_value_t.major, new_value_t.major };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linexdir:1", "", 1, old_value_t.linexdir, new_value_t.linexdir };
    m_bit_details_model.bits.append(entry);
    entry = { "26: lineydir:1", "", 1, old_value_t.lineydir, new_value_t.lineydir };
    m_bit_details_model.bits.append(entry);
    entry = { "27: droplastp:1",
              "draw last pixel or not",
              1, old_value_t.droplastp, new_value_t.droplastp };
    m_bit_details_model.bits.append(entry);
    entry = { "28: lineuseoctant:1",
              "use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR",
              1, old_value_t.lineuseoctant, new_value_t.lineuseoctant };
    m_bit_details_model.bits.append(entry);
    entry = { "29: octants:3",
              "000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7",
              3, old_value_t.octants, new_value_t.octants };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2LINEDELTAN_OFFSET 0x203E
#define G2SB_CTX5_G2LINEDELTAN_UNDEFMASK 0xFFE00000
union g2sb_ctx5_g2linedeltan_u {
    struct {
        unsigned int deltan:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2linedeltan_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2linedeltan_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2linedeltan_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltan:21", "", 21, old_value_t.deltan, new_value_t.deltan };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2LINEDELTAM_OFFSET 0x203F
#define G2SB_CTX5_G2LINEDELTAM_UNDEFMASK 0xFFE00000
union g2sb_ctx5_g2linedeltam_u {
    struct {
        unsigned int deltam:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2linedeltam_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2linedeltam_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2linedeltam_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltam:21", "", 21, old_value_t.deltam, new_value_t.deltam };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2LINEPOS_OFFSET 0x2040
#define G2SB_CTX5_G2LINEPOS_UNDEFMASK 0x00000000
union g2sb_ctx5_g2linepos_u {
    struct {
        unsigned int linexpos:16;
        unsigned int lineypos:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2linepos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2linepos_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2linepos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linexpos:16", "", 16, old_value_t.linexpos, new_value_t.linexpos };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lineypos:16", "", 16, old_value_t.lineypos, new_value_t.lineypos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2LINELEN_OFFSET 0x2041
#define G2SB_CTX5_G2LINELEN_UNDEFMASK 0xFFFF8000
union g2sb_ctx5_g2linelen_u {
    struct {
        unsigned int linelen:15;
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2linelen_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2linelen_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2linelen_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linelen:15", "", 15, old_value_t.linelen, new_value_t.linelen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CSCFOURTH_OFFSET 0x2042
#define G2SB_CTX5_G2CSCFOURTH_UNDEFMASK 0xFE00FE00
union g2sb_ctx5_g2cscfourth_u {
    struct {
        unsigned int g2u:9;                 /* multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored */
        unsigned int undefined_bits_9_15:7;
        unsigned int g2v:9;                 /* multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored */
        unsigned int undefined_bits_25_31:7;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2cscfourth_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2cscfourth_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2cscfourth_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: g2u:9",
              "multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored",
              9, old_value_t.g2u, new_value_t.g2u };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: g2v:9",
              "multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored",
              9, old_value_t.g2v, new_value_t.g2v };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bits_25_31:7", "", 7, old_value_t.undefined_bits_25_31, new_value_t.undefined_bits_25_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2SRCST_B_OFFSET 0x2043
#define G2SB_CTX5_G2SRCST_B_UNDEFMASK 0xFFFF0000
union g2sb_ctx5_g2srcst_b_u {
    struct {
        unsigned int srcs_b:16;             /* Source Stride B */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2srcst_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2srcst_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2srcst_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs_b:16",
              "Source Stride B",
              16, old_value_t.srcs_b, new_value_t.srcs_b };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2UVSTRIDE_OFFSET 0x2044
#define G2SB_CTX5_G2UVSTRIDE_UNDEFMASK 0xFFFF0000
union g2sb_ctx5_g2uvstride_u {
    struct {
        unsigned int uvstride:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2uvstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2uvstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2uvstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: uvstride:16", "", 16, old_value_t.uvstride, new_value_t.uvstride };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2CBDES2_OFFSET 0x2045
#define G2SB_CTX5_G2CBDES2_UNDEFMASK 0xFFFF8000
union g2sb_ctx5_g2cbdes2_u {
    struct {
        unsigned int top_cbline:15;         /* Circular buffer top clipping enabled, the first buffer line num */
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2cbdes2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2cbdes2_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2cbdes2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: top_cbline:15",
              "Circular buffer top clipping enabled, the first buffer line num",
              15, old_value_t.top_cbline, new_value_t.top_cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2TILEMODE_OFFSET 0x2046
#define G2SB_CTX5_G2TILEMODE_UNDEFMASK 0xFFEEEEEE
union g2sb_ctx5_g2tilemode_u {
    struct {
        unsigned int src_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_1_3:3;
        unsigned int src_uv_tile_mode:1;    /* UV surface, ignored in RGB mode */
        unsigned int undefined_bits_5_7:3;
        unsigned int pat_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_9_11:3;
        unsigned int pat_uv_tile_mode:1;    /* UNUSED */
        unsigned int undefined_bits_13_15:3;
        unsigned int dst_rd_tile_mode:1;    /* Same as destination write unless DST_RD_WR_SEP (not supported) */
        unsigned int undefined_bits_17_19:3;
        unsigned int dst_wr_tile_mode:1;    /* destination surface */
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2tilemode_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2tilemode_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2tilemode_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.src_y_tile_mode, new_value_t.src_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: src_uv_tile_mode:1",
              "UV surface, ignored in RGB mode",
              1, old_value_t.src_uv_tile_mode, new_value_t.src_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: pat_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.pat_y_tile_mode, new_value_t.pat_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: pat_uv_tile_mode:1",
              "UNUSED",
              1, old_value_t.pat_uv_tile_mode, new_value_t.pat_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dst_rd_tile_mode:1",
              "Same as destination write unless DST_RD_WR_SEP (not supported)",
              1, old_value_t.dst_rd_tile_mode, new_value_t.dst_rd_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: dst_wr_tile_mode:1",
              "destination surface",
              1, old_value_t.dst_wr_tile_mode, new_value_t.dst_wr_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2PATBASE_OFFSET 0x2047
#define G2SB_CTX5_G2PATBASE_UNDEFMASK 0x00000000
union g2sb_ctx5_g2patbase_u {
    struct {
        unsigned int pat_base:32;           /* pattern base address in tile mode,  PATBA is the linear address where pixel start */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2patbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2patbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2patbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pat_base:32",
              "pattern base address in tile mode,  PATBA is the linear address where pixel start",
              32, old_value_t.pat_base, new_value_t.pat_base };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2SRCBA_SB_SURFBASE_OFFSET 0x2048
#define G2SB_CTX5_G2SRCBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx5_g2srcba_sb_surfbase_u {
    struct {
        unsigned int src_addr:32;           /* surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2srcba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2srcba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2srcba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_addr:32",
              "surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine",
              32, old_value_t.src_addr, new_value_t.src_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2DSTBA_SB_SURFBASE_OFFSET 0x2049
#define G2SB_CTX5_G2DSTBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx5_g2dstba_sb_surfbase_u {
    struct {
        unsigned int dst_addr:32;           /* surface address corresponding to G2DSTBA Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2dstba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2dstba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2dstba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_addr:32",
              "surface address corresponding to G2DSTBA Only used by the StretchBlit Engine",
              32, old_value_t.dst_addr, new_value_t.dst_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2DSTBA_B_SB_SURFBASE_OFFSET 0x204A
#define G2SB_CTX5_G2DSTBA_B_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx5_g2dstba_b_sb_surfbase_u {
    struct {
        unsigned int dst_b_addr:32;         /* surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2dstba_b_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2dstba_b_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2dstba_b_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_b_addr:32",
              "surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled",
              32, old_value_t.dst_b_addr, new_value_t.dst_b_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2VBA_A_SB_SURFBASE_OFFSET 0x204B
#define G2SB_CTX5_G2VBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx5_g2vba_a_sb_surfbase_u {
    struct {
        unsigned int v_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2vba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2vba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2vba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine",
              32, old_value_t.v_addr, new_value_t.v_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX5_G2UBA_A_SB_SURFBASE_OFFSET 0x204C
#define G2SB_CTX5_G2UBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx5_g2uba_a_sb_surfbase_u {
    struct {
        unsigned int u_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx5_g2uba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx5_g2uba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx5_g2uba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: u_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine",
              32, old_value_t.u_addr, new_value_t.u_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_INCR_SYNCPT_OFFSET 0x6000
#define G2SB_CTX6_INCR_SYNCPT_UNDEFMASK 0xFFFF0000
union g2sb_ctx6_incr_syncpt_u {
    struct {
        unsigned int indx:8;                /* syncpt index value */
        unsigned int cond:8;                /* Condition mapped from raise/wait */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_incr_syncpt_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_incr_syncpt_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_incr_syncpt_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: indx:8",
              "syncpt index value",
              8, old_value_t.indx, new_value_t.indx };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cond:8",
              "Condition mapped from raise/wait",
              8, old_value_t.cond, new_value_t.cond };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_INCR_SYNCPT_CNTRL_OFFSET 0x6001
#define G2SB_CTX6_INCR_SYNCPT_CNTRL_UNDEFMASK 0xFFFFFEFE
union g2sb_ctx6_incr_syncpt_cntrl_u {
    struct {
        unsigned int incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs. */
        unsigned int undefined_bits_1_7:7;
        unsigned int incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled. */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_incr_syncpt_cntrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_incr_syncpt_cntrl_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_incr_syncpt_cntrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: incr_syncpt_soft_reset:1",
              "If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs.",
              1, old_value_t.incr_syncpt_soft_reset, new_value_t.incr_syncpt_soft_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: incr_syncpt_no_stall:1",
              "If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled.",
              1, old_value_t.incr_syncpt_no_stall, new_value_t.incr_syncpt_no_stall };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_INCR_SYNCPT_ERROR_OFFSET 0x6002
#define G2SB_CTX6_INCR_SYNCPT_ERROR_UNDEFMASK 0x00000000
union g2sb_ctx6_incr_syncpt_error_u {
    struct {
        unsigned int cond_status:32;        /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_incr_syncpt_error_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_incr_syncpt_error_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_incr_syncpt_error_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cond_status:32",
              "COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero",
              32, old_value_t.cond_status, new_value_t.cond_status };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CLASSCHANNEL_REGONLY_OFFSET 0x6008
#define G2SB_CTX6_G2CLASSCHANNEL_REGONLY_UNDEFMASK 0xFFE0FC00
union g2sb_ctx6_g2classchannel_regonly_u {
    struct {
        unsigned int curr_class:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int curr_channel:4;
        unsigned int ctx_valid:1;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2classchannel_regonly_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2classchannel_regonly_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2classchannel_regonly_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: curr_class:10", "", 10, old_value_t.curr_class, new_value_t.curr_class };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_15:6", "", 6, old_value_t.undefined_bits_10_15, new_value_t.undefined_bits_10_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: curr_channel:4", "", 4, old_value_t.curr_channel, new_value_t.curr_channel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ctx_valid:1", "", 1, old_value_t.ctx_valid, new_value_t.ctx_valid };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2TRIGGER_OFFSET 0x6009
#define G2SB_CTX6_G2TRIGGER_UNDEFMASK 0xFFFF0000
union g2sb_ctx6_g2trigger_u {
    struct {
        unsigned int trigger:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2trigger_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2trigger_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2trigger_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger:16", "", 16, old_value_t.trigger, new_value_t.trigger };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2TRIGGER1_OFFSET 0x600A
#define G2SB_CTX6_G2TRIGGER1_UNDEFMASK 0xFFFF0000
union g2sb_ctx6_g2trigger1_u {
    struct {
        unsigned int trigger1:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2trigger1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2trigger1_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2trigger1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger1:16", "", 16, old_value_t.trigger1, new_value_t.trigger1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2TRIGGER2_OFFSET 0x600B
#define G2SB_CTX6_G2TRIGGER2_UNDEFMASK 0xFFFF0000
union g2sb_ctx6_g2trigger2_u {
    struct {
        unsigned int trigger2:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2trigger2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2trigger2_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2trigger2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger2:16", "", 16, old_value_t.trigger2, new_value_t.trigger2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CMDSEL_OFFSET 0x600C
#define G2SB_CTX6_G2CMDSEL_UNDEFMASK 0xE000280E
union g2sb_ctx6_g2cmdsel_u {
    struct {
        unsigned int sbor2d:1;
        unsigned int undefined_bits_1_3:3;
        unsigned int cbenable:1;            /* circular buffer feature enable    0= disable */
        unsigned int vitrigger:1;           /* VI trigger enable, can be circular buffer or full frame */
        unsigned int hosttrigger:1;         /* host trigger the command, host also need program cicular buffer related data */
        unsigned int cbsbdisable:1;
        unsigned int g2output:2;            /* 00: to memory 01: to EPP */
        unsigned int clip_source_top_bottom:1;/* Reserved for HW Test, SW should not use this bit. */
        unsigned int undefined_bit_11:1;
        unsigned int link_wait_buf_end:1;
        unsigned int undefined_bit_13:1;
        unsigned int frame_start:1;         /* host writes this bit to tell which buffer is ready */
        unsigned int frame_end:1;
        unsigned int buffer_index:8;
        unsigned int linken:1;              /* Test purpose */
        unsigned int linkval:3;
        unsigned int priority:1;            /* indicates priority of the context, note vi-triggered contexts take priority over HIGH */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2cmdsel_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2cmdsel_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2cmdsel_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sbor2d:1", "", 1, old_value_t.sbor2d, new_value_t.sbor2d };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: cbenable:1",
              "circular buffer feature enable   \n0= disable",
              1, old_value_t.cbenable, new_value_t.cbenable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: vitrigger:1",
              "VI trigger enable, can be circular buffer or full frame",
              1, old_value_t.vitrigger, new_value_t.vitrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "06: hosttrigger:1",
              "host trigger the command, host also need program cicular buffer related data",
              1, old_value_t.hosttrigger, new_value_t.hosttrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "07: cbsbdisable:1", "", 1, old_value_t.cbsbdisable, new_value_t.cbsbdisable };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g2output:2",
              "00: to memory 01: to EPP",
              2, old_value_t.g2output, new_value_t.g2output };
    m_bit_details_model.bits.append(entry);
    entry = { "10: clip_source_top_bottom:1",
              "Reserved for HW Test, SW should not use this bit.",
              1, old_value_t.clip_source_top_bottom, new_value_t.clip_source_top_bottom };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: link_wait_buf_end:1", "", 1, old_value_t.link_wait_buf_end, new_value_t.link_wait_buf_end };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: frame_start:1",
              "host writes this bit to tell which buffer is ready",
              1, old_value_t.frame_start, new_value_t.frame_start };
    m_bit_details_model.bits.append(entry);
    entry = { "15: frame_end:1", "", 1, old_value_t.frame_end, new_value_t.frame_end };
    m_bit_details_model.bits.append(entry);
    entry = { "16: buffer_index:8", "", 8, old_value_t.buffer_index, new_value_t.buffer_index };
    m_bit_details_model.bits.append(entry);
    entry = { "24: linken:1",
              "Test purpose",
              1, old_value_t.linken, new_value_t.linken };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linkval:3", "", 3, old_value_t.linkval, new_value_t.linkval };
    m_bit_details_model.bits.append(entry);
    entry = { "28: priority:1",
              "indicates priority of the context, note vi-triggered contexts take priority over HIGH",
              1, old_value_t.priority, new_value_t.priority };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2RAISE_OFFSET 0x600D
#define G2SB_CTX6_G2RAISE_UNDEFMASK 0xFFF0FFE0
union g2sb_ctx6_g2raise_u {
    struct {
        unsigned int raise:5;               /* Push back to read fifo when all commands in the channel are done.           */
        unsigned int undefined_bits_5_15:11;
        unsigned int raisechannel:4;
        unsigned int undefined_bits_20_31:12;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2raise_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2raise_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2raise_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: raise:5",
              "Push back to read fifo when all commands in the channel are done.",
              5, old_value_t.raise, new_value_t.raise };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_15:11", "", 11, old_value_t.undefined_bits_5_15, new_value_t.undefined_bits_5_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisechannel:4", "", 4, old_value_t.raisechannel, new_value_t.raisechannel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_31:12", "", 12, old_value_t.undefined_bits_20_31, new_value_t.undefined_bits_20_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2HOSTSET_OFFSET 0x600F
#define G2SB_CTX6_G2HOSTSET_UNDEFMASK 0xFFFFFF00
union g2sb_ctx6_g2hostset_u {
    struct {
        unsigned int hstlngap:4;            /*  specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte) */
        unsigned int hstfpxl:4;             /* specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2hostset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2hostset_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2hostset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hstlngap:4",
              " specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte)",
              4, old_value_t.hstlngap, new_value_t.hstlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: hstfpxl:4",
              "specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary",
              4, old_value_t.hstfpxl, new_value_t.hstfpxl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2HOSTFIFO_OFFSET 0x6010
#define G2SB_CTX6_G2HOSTFIFO_UNDEFMASK 0x00000000
union g2sb_ctx6_g2hostfifo_u {
    struct {
        unsigned int hostfifodata:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2hostfifo_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2hostfifo_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2hostfifo_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hostfifodata:32", "", 32, old_value_t.hostfifodata, new_value_t.hostfifodata };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2VDDA_OFFSET 0x6011
#define G2SB_CTX6_G2VDDA_UNDEFMASK 0x00000000
union g2sb_ctx6_g2vdda_u {
    struct {
        unsigned int vdstep:32;             /* Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2vdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2vdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2vdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdstep:32",
              "Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010.",
              32, old_value_t.vdstep, new_value_t.vdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2VDDAINI_OFFSET 0x6012
#define G2SB_CTX6_G2VDDAINI_UNDEFMASK 0xFFFF0000
union g2sb_ctx6_g2vddaini_u {
    struct {
        unsigned int vdtini:8;              /* Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window. */
        unsigned int vdbini:8;              /* Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above) */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2vddaini_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2vddaini_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2vddaini_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdtini:8",
              "Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window.",
              8, old_value_t.vdtini, new_value_t.vdtini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: vdbini:8",
              "Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above)",
              8, old_value_t.vdbini, new_value_t.vdbini };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2HDDA_OFFSET 0x6013
#define G2SB_CTX6_G2HDDA_UNDEFMASK 0x00000000
union g2sb_ctx6_g2hdda_u {
    struct {
        unsigned int hdstep:32;             /* Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2hdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2hdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2hdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdstep:32",
              "Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101.",
              32, old_value_t.hdstep, new_value_t.hdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2HDDAINILS_OFFSET 0x6014
#define G2SB_CTX6_G2HDDAINILS_UNDEFMASK 0xFFFFFF00
union g2sb_ctx6_g2hddainils_u {
    struct {
        unsigned int hdini:8;               /* Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0. */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2hddainils_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2hddainils_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2hddainils_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdini:8",
              "Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0.",
              8, old_value_t.hdini, new_value_t.hdini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CSCFIRST_OFFSET 0x6015
#define G2SB_CTX6_G2CSCFIRST_UNDEFMASK 0x00C00C00
union g2sb_ctx6_g2cscfirst_u {
    struct {
        unsigned int cub:10;                /* multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved  */
        unsigned int undefined_bits_10_11:2;
        unsigned int cvr:10;                /* multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved */
        unsigned int undefined_bits_22_23:2;
        unsigned int yos:8;                 /* Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2cscfirst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2cscfirst_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2cscfirst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cub:10",
              "multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved",
              10, old_value_t.cub, new_value_t.cub };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_11:2", "", 2, old_value_t.undefined_bits_10_11, new_value_t.undefined_bits_10_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cvr:10",
              "multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved",
              10, old_value_t.cvr, new_value_t.cvr };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: yos:8",
              "Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10",
              8, old_value_t.yos, new_value_t.yos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CSCSECOND_OFFSET 0x6016
#define G2SB_CTX6_G2CSCSECOND_UNDEFMASK 0x00C00E00
union g2sb_ctx6_g2cscsecond_u {
    struct {
        unsigned int cug:9;                 /* multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved */
        unsigned int undefined_bits_9_11:3;
        unsigned int cur:10;                /* multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved  */
        unsigned int undefined_bits_22_23:2;
        unsigned int cyx:8;                 /* multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2cscsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2cscsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2cscsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cug:9",
              "multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved",
              9, old_value_t.cug, new_value_t.cug };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cur:10",
              "multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved",
              10, old_value_t.cur, new_value_t.cur };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cyx:8",
              "multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041",
              8, old_value_t.cyx, new_value_t.cyx };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CSCTHIRD_OFFSET 0x6017
#define G2SB_CTX6_G2CSCTHIRD_UNDEFMASK 0xFC00FE00
union g2sb_ctx6_g2cscthird_u {
    struct {
        unsigned int cvg:9;                 /* multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113 */
        unsigned int undefined_bits_9_15:7;
        unsigned int cvb:10;                /* multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021 */
        unsigned int undefined_bits_26_31:6;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2cscthird_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2cscthird_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2cscthird_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cvg:9",
              "multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113",
              9, old_value_t.cvg, new_value_t.cvg };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cvb:10",
              "multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021",
              10, old_value_t.cvb, new_value_t.cvb };
    m_bit_details_model.bits.append(entry);
    entry = { "26: undefined_bits_26_31:6", "", 6, old_value_t.undefined_bits_26_31, new_value_t.undefined_bits_26_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CMKEYL_OFFSET 0x6018
#define G2SB_CTX6_G2CMKEYL_UNDEFMASK 0xFF000000
union g2sb_ctx6_g2cmkeyl_u {
    struct {
        unsigned int ckbl:8;                /* B or Y Color/Chroma Key Lower Limit (CKBL[7:0]) */
        unsigned int ckgl:8;                /* G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level. */
        unsigned int ckrl:8;                /* R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2cmkeyl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2cmkeyl_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2cmkeyl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbl:8",
              "B or Y Color/Chroma Key Lower Limit (CKBL[7:0])",
              8, old_value_t.ckbl, new_value_t.ckbl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgl:8",
              "G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgl, new_value_t.ckgl };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckrl:8",
              "R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved",
              8, old_value_t.ckrl, new_value_t.ckrl };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CMKEYU_OFFSET 0x6019
#define G2SB_CTX6_G2CMKEYU_UNDEFMASK 0xFF000000
union g2sb_ctx6_g2cmkeyu_u {
    struct {
        unsigned int ckbu:8;                /* This is B or Y color/chroma key upper limit value. */
        unsigned int ckgu:8;                /* G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level. */
        unsigned int ckru:8;                /* R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2cmkeyu_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2cmkeyu_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2cmkeyu_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbu:8",
              "This is B or Y color/chroma key upper limit value.",
              8, old_value_t.ckbu, new_value_t.ckbu };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgu:8",
              "G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgu, new_value_t.ckgu };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckru:8",
              "R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved",
              8, old_value_t.ckru, new_value_t.ckru };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2UBA_A_OFFSET 0x601A
#define G2SB_CTX6_G2UBA_A_UNDEFMASK 0x00000000
union g2sb_ctx6_g2uba_a_u {
    struct {
        unsigned int su1sa:32;              /* Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2uba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2uba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2uba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: su1sa:32",
              "Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.su1sa, new_value_t.su1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2VBA_A_OFFSET 0x601B
#define G2SB_CTX6_G2VBA_A_UNDEFMASK 0x00000000
union g2sb_ctx6_g2vba_a_u {
    struct {
        unsigned int sv1sa:32;              /* Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2vba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2vba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2vba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sv1sa:32",
              "Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.sv1sa, new_value_t.sv1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2SBFORMAT_OFFSET 0x601C
#define G2SB_CTX6_G2SBFORMAT_UNDEFMASK 0x000020E0
union g2sb_ctx6_g2sbformat_u {
    struct {
        unsigned int sifmt:5;               /* This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV. */
        unsigned int undefined_bits_5_7:3;
        unsigned int difmt:5;               /* Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED */
        unsigned int undefined_bit_13:1;
        unsigned int raisebufferen:1;       /* ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.  */
        unsigned int raiseframeen:1;        /* ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.  */
        unsigned int raisebuffervalue:8;    /* Raise buffer vector value. */
        unsigned int raiseframevalue:8;     /* Raise Fram vector value. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2sbformat_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2sbformat_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2sbformat_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sifmt:5",
              "This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV.",
              5, old_value_t.sifmt, new_value_t.sifmt };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: difmt:5",
              "Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED",
              5, old_value_t.difmt, new_value_t.difmt };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: raisebufferen:1",
              "ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raisebufferen, new_value_t.raisebufferen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: raiseframeen:1",
              "ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raiseframeen, new_value_t.raiseframeen };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisebuffervalue:8",
              "Raise buffer vector value.",
              8, old_value_t.raisebuffervalue, new_value_t.raisebuffervalue };
    m_bit_details_model.bits.append(entry);
    entry = { "24: raiseframevalue:8",
              "Raise Fram vector value.",
              8, old_value_t.raiseframevalue, new_value_t.raiseframevalue };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CONTROLSB_OFFSET 0x601D
#define G2SB_CTX6_G2CONTROLSB_UNDEFMASK 0x20005807
union g2sb_ctx6_g2controlsb_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int yuv422rotation:1;      /* yuv422 plannar rotated */
        unsigned int yuv422planar:1;        /* source data is yuv422 planar valid when imode==PLANAR */
        unsigned int imode:1;               /* Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d. */
        unsigned int enavf:1;               /* enable alpha vertical filter     */
        unsigned int enahf:1;               /* enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format, */
        unsigned int uvst:2;                /*   00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.   11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride). */
        unsigned int sl:1;                  /* Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines. */
        unsigned int undefined_bits_11_12:2;
        unsigned int sisel:1;               /* StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved  */
        unsigned int undefined_bit_14:1;
        unsigned int sbltsrc:1;             /* StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator. */
        unsigned int vftype:2;              /* StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager. */
        unsigned int vfen:1;                /* StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled. */
        unsigned int discsc:1;              /* enabled color space converter by default */
        unsigned int hftype:3;              /* StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE. */
        unsigned int rangeredfrm:1;         /* In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.  */
        unsigned int sitype:1;              /* StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?. */
        unsigned int sbsel:1;               /* StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer. */
        unsigned int dbsel:1;               /* StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer. */
        unsigned int keyen:1;               /* Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled. */
        unsigned int kpol:1;                /* Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range. */
        unsigned int undefined_bit_29:1;
        unsigned int endith:1;              /* Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering */
        unsigned int disdw:1;               /* output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2controlsb_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2controlsb_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2controlsb_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_2:3", "", 3, old_value_t.undefined_bits_0_2, new_value_t.undefined_bits_0_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: yuv422rotation:1",
              "yuv422 plannar rotated",
              1, old_value_t.yuv422rotation, new_value_t.yuv422rotation };
    m_bit_details_model.bits.append(entry);
    entry = { "04: yuv422planar:1",
              "source data is yuv422 planar valid when imode==PLANAR",
              1, old_value_t.yuv422planar, new_value_t.yuv422planar };
    m_bit_details_model.bits.append(entry);
    entry = { "05: imode:1",
              "Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d.",
              1, old_value_t.imode, new_value_t.imode };
    m_bit_details_model.bits.append(entry);
    entry = { "06: enavf:1",
              "enable alpha vertical filter",
              1, old_value_t.enavf, new_value_t.enavf };
    m_bit_details_model.bits.append(entry);
    entry = { "07: enahf:1",
              "enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format,",
              1, old_value_t.enahf, new_value_t.enahf };
    m_bit_details_model.bits.append(entry);
    entry = { "08: uvst:2",
              " \n00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.\n11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride).",
              2, old_value_t.uvst, new_value_t.uvst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: sl:1",
              "Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines.",
              1, old_value_t.sl, new_value_t.sl };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_12:2", "", 2, old_value_t.undefined_bits_11_12, new_value_t.undefined_bits_11_12 };
    m_bit_details_model.bits.append(entry);
    entry = { "13: sisel:1",
              "StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved",
              1, old_value_t.sisel, new_value_t.sisel };
    m_bit_details_model.bits.append(entry);
    entry = { "14: undefined_bit_14:1", "", 1, old_value_t.undefined_bit_14, new_value_t.undefined_bit_14 };
    m_bit_details_model.bits.append(entry);
    entry = { "15: sbltsrc:1",
              "StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator.",
              1, old_value_t.sbltsrc, new_value_t.sbltsrc };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vftype:2",
              "StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager.",
              2, old_value_t.vftype, new_value_t.vftype };
    m_bit_details_model.bits.append(entry);
    entry = { "18: vfen:1",
              "StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled.",
              1, old_value_t.vfen, new_value_t.vfen };
    m_bit_details_model.bits.append(entry);
    entry = { "19: discsc:1",
              "enabled color space converter by default",
              1, old_value_t.discsc, new_value_t.discsc };
    m_bit_details_model.bits.append(entry);
    entry = { "20: hftype:3",
              "StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE.",
              3, old_value_t.hftype, new_value_t.hftype };
    m_bit_details_model.bits.append(entry);
    entry = { "23: rangeredfrm:1",
              "In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.",
              1, old_value_t.rangeredfrm, new_value_t.rangeredfrm };
    m_bit_details_model.bits.append(entry);
    entry = { "24: sitype:1",
              "StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?.",
              1, old_value_t.sitype, new_value_t.sitype };
    m_bit_details_model.bits.append(entry);
    entry = { "25: sbsel:1",
              "StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer.",
              1, old_value_t.sbsel, new_value_t.sbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "26: dbsel:1",
              "StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer.",
              1, old_value_t.dbsel, new_value_t.dbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "27: keyen:1",
              "Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled.",
              1, old_value_t.keyen, new_value_t.keyen };
    m_bit_details_model.bits.append(entry);
    entry = { "28: kpol:1",
              "Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range.",
              1, old_value_t.kpol, new_value_t.kpol };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: endith:1",
              "Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering",
              1, old_value_t.endith, new_value_t.endith };
    m_bit_details_model.bits.append(entry);
    entry = { "31: disdw:1",
              "output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place.",
              1, old_value_t.disdw, new_value_t.disdw };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CONTROLSECOND_OFFSET 0x601E
#define G2SB_CTX6_G2CONTROLSECOND_UNDEFMASK 0xC08E3C01
union g2sb_ctx6_g2controlsecond_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int bitswap:1;             /* Host port bit swap 1=enable   0= disable   1= enable */
        unsigned int bebswap:1;             /* Host port byte swap 1=enable   0= disable   1= enable */
        unsigned int bewswap:1;             /* Host port word swap 1=enable   0= disable */
        unsigned int alptype:5;             /* Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits. */
        unsigned int alpsrcordst:1;         /* 32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha */
        unsigned int undefined_bits_10_13:4;
        unsigned int pxlrep:1;              /* Pixel replication for Palm OS. */
        unsigned int swapblt:1;             /* Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area */
        unsigned int vcaa_safe_mode:1;      /* VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken. */
        unsigned int undefined_bits_17_19:3;
        unsigned int g2nostop:1;
        unsigned int clipc:2;               /* Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,  10=draw only inside clipping rectangle,  11=draw only outside clipping rectangle */
        unsigned int undefined_bit_23:1;
        unsigned int fr_mode:2;             /* Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice. 00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so! 01 = src/dst copy mode - two separate buffers 10 = square in place - one buffer 11 = blank */
        unsigned int fr_type:3;             /*  Fast Rotate type     000 = FLIP_X  001 = FLIP_Y  010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right) 011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left) 100 = ROT_90 (counter clock wise by 90 degrees) 101 = ROT_180  110 = ROT_270 (clock wise by 90 degrees) 111 = IDENTITY */
        unsigned int fr_readwait:1;         /*  Fast Rotate wait for read 0 = disable 1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only. */
        unsigned int undefined_bits_30_31:2;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2controlsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2controlsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2controlsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bit_0:1", "", 1, old_value_t.undefined_bit_0, new_value_t.undefined_bit_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "01: bitswap:1",
              "Host port bit swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bitswap, new_value_t.bitswap };
    m_bit_details_model.bits.append(entry);
    entry = { "02: bebswap:1",
              "Host port byte swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bebswap, new_value_t.bebswap };
    m_bit_details_model.bits.append(entry);
    entry = { "03: bewswap:1",
              "Host port word swap\n1=enable  \n0= disable",
              1, old_value_t.bewswap, new_value_t.bewswap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: alptype:5",
              "Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits.",
              5, old_value_t.alptype, new_value_t.alptype };
    m_bit_details_model.bits.append(entry);
    entry = { "09: alpsrcordst:1",
              "32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha",
              1, old_value_t.alpsrcordst, new_value_t.alpsrcordst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_13:4", "", 4, old_value_t.undefined_bits_10_13, new_value_t.undefined_bits_10_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: pxlrep:1",
              "Pixel replication for Palm OS.",
              1, old_value_t.pxlrep, new_value_t.pxlrep };
    m_bit_details_model.bits.append(entry);
    entry = { "15: swapblt:1",
              "Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area",
              1, old_value_t.swapblt, new_value_t.swapblt };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vcaa_safe_mode:1",
              "VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken.",
              1, old_value_t.vcaa_safe_mode, new_value_t.vcaa_safe_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: g2nostop:1", "", 1, old_value_t.g2nostop, new_value_t.g2nostop };
    m_bit_details_model.bits.append(entry);
    entry = { "21: clipc:2",
              "Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,\n10=draw only inside clipping rectangle,\n11=draw only outside clipping rectangle",
              2, old_value_t.clipc, new_value_t.clipc };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fr_mode:2",
              "Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice.\n00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so!\n01 = src/dst copy mode - two separate buffers\n10 = square in place - one buffer\n11 = blank",
              2, old_value_t.fr_mode, new_value_t.fr_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "26: fr_type:3",
              " Fast Rotate type    \n000 = FLIP_X \n001 = FLIP_Y \n010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right)\n011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left)\n100 = ROT_90 (counter clock wise by 90 degrees)\n101 = ROT_180 \n110 = ROT_270 (clock wise by 90 degrees)\n111 = IDENTITY",
              3, old_value_t.fr_type, new_value_t.fr_type };
    m_bit_details_model.bits.append(entry);
    entry = { "29: fr_readwait:1",
              " Fast Rotate wait for read\n0 = disable\n1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only.",
              1, old_value_t.fr_readwait, new_value_t.fr_readwait };
    m_bit_details_model.bits.append(entry);
    entry = { "30: undefined_bits_30_31:2", "", 2, old_value_t.undefined_bits_30_31, new_value_t.undefined_bits_30_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CONTROLMAIN_OFFSET 0x601F
#define G2SB_CTX6_G2CONTROLMAIN_UNDEFMASK 0x80000000
union g2sb_ctx6_g2controlmain_u {
    struct {
        unsigned int cmdt:2;                /* Command Type:  00=BitBlt 01=Line Draw  10=VCAA 11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed) */
        unsigned int turbofill:1;           /* fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified. */
        unsigned int test0bit:1;            /* Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish. */
        unsigned int faden:1;               /* BitBlt Source Copy Fade enable, 1=enable (share with mltln), only support  16bpp mode */
        unsigned int alpen:1;               /* BitBlt Alpha Blending, 1=enable. 0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype */
        unsigned int srcsld:1;              /* BitBlt Solid Source Color Fill: 1=enable. FGC will be used as  the color value. */
        unsigned int patsld:1;              /* BitBlt Solid Pattern Fill: 1=enable. BGC will be used as  the color value. */
        unsigned int patfl:1;               /* When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+ */
        unsigned int xdir:1;                /*  0=incrementing, 1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0 */
        unsigned int ydir:1;                /*  0=incrementing, 1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0 */
        unsigned int xytdw:1;               /* xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination. */
        unsigned int srcpack:1;             /* Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled. */
        unsigned int patpack:1;             /* Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled. */
        unsigned int yflip:1;               /* flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination. */
        unsigned int srcsel:1;              /* Source Data Select: */
        unsigned int dstcd:2;               /* Destination color depth:   00=8-bpp, 01=16-bpp, 10=32-bpp. 11=reserved */
        unsigned int dstt:2;                /* Destination read transparency enable:   0x=destination read transparency disabled   10=color destination read transparency   11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately, 0=wait for launch write) */
        unsigned int srccd:1;               /* 0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0 */
        unsigned int hlmono:1;              /* Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit */
        unsigned int srct:2;                /* Source transparency enable: 0x=source transparency disabled,  10=mono source background transparency     or color source transparency,  11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied. */
        unsigned int srcbas:1;              /* Source base address select:   0=srcba, 1=dstba. This is not used for Line Draw and  if source data comes from host memory. */
        unsigned int gcsw:2;                /* Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used */
        unsigned int srcdir:1;              /* source direct addressing */
        unsigned int dstdir:1;              /* destination direct addressing */
        unsigned int dst_rd_wr_sep:1;       /* This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA */
        unsigned int patsel:1;              /* pattern Data Select: SRCSEL and PATSEL can't be both enabled. */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2controlmain_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2controlmain_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2controlmain_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cmdt:2",
              "Command Type: \n00=BitBlt\n01=Line Draw \n10=VCAA\n11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed)",
              2, old_value_t.cmdt, new_value_t.cmdt };
    m_bit_details_model.bits.append(entry);
    entry = { "02: turbofill:1",
              "fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified.",
              1, old_value_t.turbofill, new_value_t.turbofill };
    m_bit_details_model.bits.append(entry);
    entry = { "03: test0bit:1",
              "Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish.",
              1, old_value_t.test0bit, new_value_t.test0bit };
    m_bit_details_model.bits.append(entry);
    entry = { "04: faden:1",
              "BitBlt Source Copy Fade enable,\n1=enable (share with mltln), only support  16bpp mode",
              1, old_value_t.faden, new_value_t.faden };
    m_bit_details_model.bits.append(entry);
    entry = { "05: alpen:1",
              "BitBlt Alpha Blending,\n1=enable.\n0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype",
              1, old_value_t.alpen, new_value_t.alpen };
    m_bit_details_model.bits.append(entry);
    entry = { "06: srcsld:1",
              "BitBlt Solid Source Color Fill:\n1=enable. FGC will be used as  the color value.",
              1, old_value_t.srcsld, new_value_t.srcsld };
    m_bit_details_model.bits.append(entry);
    entry = { "07: patsld:1",
              "BitBlt Solid Pattern Fill:\n1=enable. BGC will be used as  the color value.",
              1, old_value_t.patsld, new_value_t.patsld };
    m_bit_details_model.bits.append(entry);
    entry = { "08: patfl:1",
              "When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+",
              1, old_value_t.patfl, new_value_t.patfl };
    m_bit_details_model.bits.append(entry);
    entry = { "09: xdir:1",
              "0=incrementing,\n1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0",
              1, old_value_t.xdir, new_value_t.xdir };
    m_bit_details_model.bits.append(entry);
    entry = { "10: ydir:1",
              "0=incrementing,\n1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0",
              1, old_value_t.ydir, new_value_t.ydir };
    m_bit_details_model.bits.append(entry);
    entry = { "11: xytdw:1",
              "xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination.",
              1, old_value_t.xytdw, new_value_t.xytdw };
    m_bit_details_model.bits.append(entry);
    entry = { "12: srcpack:1",
              "Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.srcpack, new_value_t.srcpack };
    m_bit_details_model.bits.append(entry);
    entry = { "13: patpack:1",
              "Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.patpack, new_value_t.patpack };
    m_bit_details_model.bits.append(entry);
    entry = { "14: yflip:1",
              "flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination.",
              1, old_value_t.yflip, new_value_t.yflip };
    m_bit_details_model.bits.append(entry);
    entry = { "15: srcsel:1",
              "Source Data Select:",
              1, old_value_t.srcsel, new_value_t.srcsel };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstcd:2",
              "Destination color depth:  \n00=8-bpp,\n01=16-bpp,\n10=32-bpp.\n11=reserved",
              2, old_value_t.dstcd, new_value_t.dstcd };
    m_bit_details_model.bits.append(entry);
    entry = { "18: dstt:2",
              "Destination read transparency enable:   0x=destination read transparency disabled  \n10=color destination read transparency  \n11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately,\n0=wait for launch write)",
              2, old_value_t.dstt, new_value_t.dstt };
    m_bit_details_model.bits.append(entry);
    entry = { "20: srccd:1",
              "0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0",
              1, old_value_t.srccd, new_value_t.srccd };
    m_bit_details_model.bits.append(entry);
    entry = { "21: hlmono:1",
              "Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit",
              1, old_value_t.hlmono, new_value_t.hlmono };
    m_bit_details_model.bits.append(entry);
    entry = { "22: srct:2",
              "Source transparency enable: 0x=source transparency disabled,\n10=mono source background transparency     or color source transparency,\n11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied.",
              2, old_value_t.srct, new_value_t.srct };
    m_bit_details_model.bits.append(entry);
    entry = { "24: srcbas:1",
              "Source base address select:  \n0=srcba,\n1=dstba. This is not used for Line Draw and  if source data comes from host memory.",
              1, old_value_t.srcbas, new_value_t.srcbas };
    m_bit_details_model.bits.append(entry);
    entry = { "25: gcsw:2",
              "Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used",
              2, old_value_t.gcsw, new_value_t.gcsw };
    m_bit_details_model.bits.append(entry);
    entry = { "27: srcdir:1",
              "source direct addressing",
              1, old_value_t.srcdir, new_value_t.srcdir };
    m_bit_details_model.bits.append(entry);
    entry = { "28: dstdir:1",
              "destination direct addressing",
              1, old_value_t.dstdir, new_value_t.dstdir };
    m_bit_details_model.bits.append(entry);
    entry = { "29: dst_rd_wr_sep:1",
              "This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA",
              1, old_value_t.dst_rd_wr_sep, new_value_t.dst_rd_wr_sep };
    m_bit_details_model.bits.append(entry);
    entry = { "30: patsel:1",
              "pattern Data Select: SRCSEL and PATSEL can't be both enabled.",
              1, old_value_t.patsel, new_value_t.patsel };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2ROPFADE_OFFSET 0x6020
#define G2SB_CTX6_G2ROPFADE_UNDEFMASK 0x0000FF00
union g2sb_ctx6_g2ropfade_u {
    struct {
        unsigned int rop:8;                 /* If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out. */
        unsigned int undefined_bits_8_15:8;
        unsigned int fadcoe:8;
        unsigned int fadoff:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2ropfade_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2ropfade_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2ropfade_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: rop:8",
              "If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out.",
              8, old_value_t.rop, new_value_t.rop };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: fadcoe:8", "", 8, old_value_t.fadcoe, new_value_t.fadcoe };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fadoff:8", "", 8, old_value_t.fadoff, new_value_t.fadoff };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2ALPHABLEND_OFFSET 0x6021
#define G2SB_CTX6_G2ALPHABLEND_UNDEFMASK 0x0000FE00
union g2sb_ctx6_g2alphablend_u {
    struct {
        unsigned int alpha:8;
        unsigned int alphainv:1;
        unsigned int undefined_bits_9_15:7;
        unsigned int alpha0v:8;
        unsigned int alpha1v:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2alphablend_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2alphablend_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2alphablend_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: alpha:8", "", 8, old_value_t.alpha, new_value_t.alpha };
    m_bit_details_model.bits.append(entry);
    entry = { "08: alphainv:1", "", 1, old_value_t.alphainv, new_value_t.alphainv };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: alpha0v:8", "", 8, old_value_t.alpha0v, new_value_t.alpha0v };
    m_bit_details_model.bits.append(entry);
    entry = { "24: alpha1v:8", "", 8, old_value_t.alpha1v, new_value_t.alpha1v };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CLIPLEFTTOP_OFFSET 0x6022
#define G2SB_CTX6_G2CLIPLEFTTOP_UNDEFMASK 0x80008000
union g2sb_ctx6_g2cliplefttop_u {
    struct {
        unsigned int clipl:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipt:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2cliplefttop_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2cliplefttop_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2cliplefttop_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipl:15", "", 15, old_value_t.clipl, new_value_t.clipl };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipt:15", "", 15, old_value_t.clipt, new_value_t.clipt };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CLIPRIGHTBOT_OFFSET 0x6023
#define G2SB_CTX6_G2CLIPRIGHTBOT_UNDEFMASK 0x80008000
union g2sb_ctx6_g2cliprightbot_u {
    struct {
        unsigned int clipr:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipb:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2cliprightbot_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2cliprightbot_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2cliprightbot_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipr:15", "", 15, old_value_t.clipr, new_value_t.clipr };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipb:15", "", 15, old_value_t.clipb, new_value_t.clipb };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2PATPACK_OFFSET 0x6024
#define G2SB_CTX6_G2PATPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx6_g2patpack_u {
    struct {
        unsigned int patlngap:4;            /* Packed mode, pattern data line gap. byte */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2patpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2patpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2patpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patlngap:4",
              "Packed mode, pattern data line gap. byte",
              4, old_value_t.patlngap, new_value_t.patlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2PATPACK_SIZE_OFFSET 0x6025
#define G2SB_CTX6_G2PATPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx6_g2patpack_size_u {
    struct {
        unsigned int patmonow:16;           /* Mono data width in packed mode, byte  */
        unsigned int patmonoh:16;           /*  Pattern mono data height in packed mode, byte  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2patpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2patpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2patpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patmonow:16",
              "Mono data width in packed mode, byte",
              16, old_value_t.patmonow, new_value_t.patmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patmonoh:16",
              " Pattern mono data height in packed mode, byte",
              16, old_value_t.patmonoh, new_value_t.patmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2PATBA_OFFSET 0x6026
#define G2SB_CTX6_G2PATBA_UNDEFMASK 0x00000000
union g2sb_ctx6_g2patba_u {
    struct {
        unsigned int patba:32;              /* If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. } */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2patba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2patba_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2patba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patba:32",
              "If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. }",
              32, old_value_t.patba, new_value_t.patba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2PATOS_OFFSET 0x6027
#define G2SB_CTX6_G2PATOS_UNDEFMASK 0x009E0000
union g2sb_ctx6_g2patos_u {
    struct {
        unsigned int patst:16;              /* stride */
        unsigned int patcd:1;               /* 0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0 */
        unsigned int undefined_bits_17_20:4;
        unsigned int patt:2;                /* Mono pattern transparency enable:  0x=pattern transparency disabled,  10=mono pattern background transparency    or color pattern transparency,  11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied. */
        unsigned int undefined_bit_23:1;
        unsigned int patxo:4;               /* x offset for mono tile pattern fill.  see PATFL */
        unsigned int patyo:4;               /* y offset for mono tile pattern fill.  see PATFL */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2patos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2patos_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2patos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patst:16",
              "stride",
              16, old_value_t.patst, new_value_t.patst };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patcd:1",
              "0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0",
              1, old_value_t.patcd, new_value_t.patcd };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_20:4", "", 4, old_value_t.undefined_bits_17_20, new_value_t.undefined_bits_17_20 };
    m_bit_details_model.bits.append(entry);
    entry = { "21: patt:2",
              "Mono pattern transparency enable:  0x=pattern transparency disabled,\n10=mono pattern background transparency    or color pattern transparency,\n11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied.",
              2, old_value_t.patt, new_value_t.patt };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: patxo:4",
              "x offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patxo, new_value_t.patxo };
    m_bit_details_model.bits.append(entry);
    entry = { "28: patyo:4",
              "y offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patyo, new_value_t.patyo };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2PATBGC_OFFSET 0x6028
#define G2SB_CTX6_G2PATBGC_UNDEFMASK 0x00000000
union g2sb_ctx6_g2patbgc_u {
    struct {
        unsigned int patbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2patbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2patbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2patbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patbgc:32", "", 32, old_value_t.patbgc, new_value_t.patbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2PATFGC_OFFSET 0x6029
#define G2SB_CTX6_G2PATFGC_UNDEFMASK 0x00000000
union g2sb_ctx6_g2patfgc_u {
    struct {
        unsigned int patfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2patfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2patfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2patfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patfgc:32", "", 32, old_value_t.patfgc, new_value_t.patfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2PATKEY_OFFSET 0x602A
#define G2SB_CTX6_G2PATKEY_UNDEFMASK 0x00000000
union g2sb_ctx6_g2patkey_u {
    struct {
        unsigned int patkey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2patkey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2patkey_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2patkey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patkey:32", "", 32, old_value_t.patkey, new_value_t.patkey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2DSTBA_OFFSET 0x602B
#define G2SB_CTX6_G2DSTBA_UNDEFMASK 0x00000000
union g2sb_ctx6_g2dstba_u {
    struct {
        unsigned int dstba:32;              /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2dstba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2dstba_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2dstba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba, new_value_t.dstba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2DSTBA_B_OFFSET 0x602C
#define G2SB_CTX6_G2DSTBA_B_UNDEFMASK 0x00000000
union g2sb_ctx6_g2dstba_b_u {
    struct {
        unsigned int dstba_b:32;            /* Destination base address (byte address) only usable in hardware trigger mode by enable gcsw */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2dstba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2dstba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2dstba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_b:32",
              "Destination base address (byte address) only usable in hardware trigger mode by enable gcsw",
              32, old_value_t.dstba_b, new_value_t.dstba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2DSTBA_C_OFFSET 0x602D
#define G2SB_CTX6_G2DSTBA_C_UNDEFMASK 0x00000000
union g2sb_ctx6_g2dstba_c_u {
    struct {
        unsigned int dstba_c:32;            /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2dstba_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2dstba_c_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2dstba_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_c:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba_c, new_value_t.dstba_c };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2DSTST_OFFSET 0x602E
#define G2SB_CTX6_G2DSTST_UNDEFMASK 0xFFFF0000
union g2sb_ctx6_g2dstst_u {
    struct {
        unsigned int dsts:16;               /* Destination Stride coordinate(bytes) with respect to DSTBA. */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2dstst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2dstst_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2dstst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dsts:16",
              "Destination Stride coordinate(bytes) with respect to DSTBA.",
              16, old_value_t.dsts, new_value_t.dsts };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2SRCPACK_OFFSET 0x602F
#define G2SB_CTX6_G2SRCPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx6_g2srcpack_u {
    struct {
        unsigned int srclngap:4;            /* Packed mode - source mono data line gap */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2srcpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2srcpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2srcpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srclngap:4",
              "Packed mode - source mono data line gap",
              4, old_value_t.srclngap, new_value_t.srclngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2SRCPACK_SIZE_OFFSET 0x6030
#define G2SB_CTX6_G2SRCPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx6_g2srcpack_size_u {
    struct {
        unsigned int srcmonow:16;           /* Packed mode - source mono data width in bytes */
        unsigned int srcmonoh:16;           /* Packed mode - source mono data height in bytes  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2srcpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2srcpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2srcpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcmonow:16",
              "Packed mode - source mono data width in bytes",
              16, old_value_t.srcmonow, new_value_t.srcmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcmonoh:16",
              "Packed mode - source mono data height in bytes",
              16, old_value_t.srcmonoh, new_value_t.srcmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2SRCBA_OFFSET 0x6031
#define G2SB_CTX6_G2SRCBA_UNDEFMASK 0x00000000
union g2sb_ctx6_g2srcba_u {
    struct {
        unsigned int srcba:32;              /* Source base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2srcba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2srcba_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2srcba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba:32",
              "Source base address (byte address)",
              32, old_value_t.srcba, new_value_t.srcba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2SRCBA_B_OFFSET 0x6032
#define G2SB_CTX6_G2SRCBA_B_UNDEFMASK 0x00000000
union g2sb_ctx6_g2srcba_b_u {
    struct {
        unsigned int srcba_b:32;            /* This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.) */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2srcba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2srcba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2srcba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba_b:32",
              "This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.)",
              32, old_value_t.srcba_b, new_value_t.srcba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2SRCST_OFFSET 0x6033
#define G2SB_CTX6_G2SRCST_UNDEFMASK 0xFFFF0000
union g2sb_ctx6_g2srcst_u {
    struct {
        unsigned int srcs:16;               /* Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.  */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2srcst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2srcst_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2srcst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs:16",
              "Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.",
              16, old_value_t.srcs, new_value_t.srcs };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2SRCBGC_OFFSET 0x6034
#define G2SB_CTX6_G2SRCBGC_UNDEFMASK 0x00000000
union g2sb_ctx6_g2srcbgc_u {
    struct {
        unsigned int srcbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2srcbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2srcbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2srcbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcbgc:32", "", 32, old_value_t.srcbgc, new_value_t.srcbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2SRCFGC_OFFSET 0x6035
#define G2SB_CTX6_G2SRCFGC_UNDEFMASK 0x00000000
union g2sb_ctx6_g2srcfgc_u {
    struct {
        unsigned int srcfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2srcfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2srcfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2srcfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcfgc:32", "", 32, old_value_t.srcfgc, new_value_t.srcfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2SRCKEY_OFFSET 0x6036
#define G2SB_CTX6_G2SRCKEY_UNDEFMASK 0x00000000
union g2sb_ctx6_g2srckey_u {
    struct {
        unsigned int srckey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2srckey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2srckey_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2srckey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srckey:32", "", 32, old_value_t.srckey, new_value_t.srckey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2SRCSIZE_OFFSET 0x6037
#define G2SB_CTX6_G2SRCSIZE_UNDEFMASK 0x80008000
union g2sb_ctx6_g2srcsize_u {
    struct {
        unsigned int srcwidth:15;
        unsigned int undefined_bit_15:1;
        unsigned int srcheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2srcsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2srcsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2srcsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcwidth:15", "", 15, old_value_t.srcwidth, new_value_t.srcwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.srcheight, new_value_t.srcheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2DSTSIZE_OFFSET 0x6038
#define G2SB_CTX6_G2DSTSIZE_UNDEFMASK 0x80008000
union g2sb_ctx6_g2dstsize_u {
    struct {
        unsigned int dstwidth:15;           /* In 2D mode, the largest number can be programmed is 0x7fef */
        unsigned int undefined_bit_15:1;
        unsigned int dstheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2dstsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2dstsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2dstsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstwidth:15",
              "In 2D mode, the largest number can be programmed is 0x7fef",
              15, old_value_t.dstwidth, new_value_t.dstwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.dstheight, new_value_t.dstheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2SRCPS_OFFSET 0x6039
#define G2SB_CTX6_G2SRCPS_UNDEFMASK 0x00000000
union g2sb_ctx6_g2srcps_u {
    struct {
        unsigned int srcx:16;               /* SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY   */
        unsigned int srcy:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2srcps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2srcps_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2srcps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcx:16",
              "SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY",
              16, old_value_t.srcx, new_value_t.srcx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcy:16", "", 16, old_value_t.srcy, new_value_t.srcy };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2DSTPS_OFFSET 0x603A
#define G2SB_CTX6_G2DSTPS_UNDEFMASK 0x00000000
union g2sb_ctx6_g2dstps_u {
    struct {
        unsigned int dstx:16;               /* NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 */
        unsigned int dsty:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2dstps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2dstps_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2dstps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstx:16",
              "NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489",
              16, old_value_t.dstx, new_value_t.dstx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dsty:16", "", 16, old_value_t.dsty, new_value_t.dsty };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CBDES_OFFSET 0x603B
#define G2SB_CTX6_G2CBDES_UNDEFMASK 0x0000FF00
union g2sb_ctx6_g2cbdes_u {
    struct {
        unsigned int cbcount:8;             /* This specifies the number of buffers incircular buffer feature                    */
        unsigned int undefined_bits_8_15:8;
        unsigned int cbline:15;             /* vertical line number in one buffer */
        unsigned int topclip:1;             /* top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2 0= disable  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2cbdes_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2cbdes_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2cbdes_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbcount:8",
              "This specifies the number of buffers incircular buffer feature",
              8, old_value_t.cbcount, new_value_t.cbcount };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbline:15",
              "vertical line number in one buffer",
              15, old_value_t.cbline, new_value_t.cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "31: topclip:1",
              "top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2\n0= disable",
              1, old_value_t.topclip, new_value_t.topclip };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CBSTRIDE_OFFSET 0x603C
#define G2SB_CTX6_G2CBSTRIDE_UNDEFMASK 0x3F000000
union g2sb_ctx6_g2cbstride_u {
    struct {
        unsigned int cbstride:24;           /* Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes) */
        unsigned int undefined_bits_24_29:6;
        unsigned int cbuvstride:2;          /* Chroma Buffer Stride default is half of luma   00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2cbstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2cbstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2cbstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbstride:24",
              "Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes)",
              24, old_value_t.cbstride, new_value_t.cbstride };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_29:6", "", 6, old_value_t.undefined_bits_24_29, new_value_t.undefined_bits_24_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: cbuvstride:2",
              "Chroma Buffer Stride default is half of luma  \n00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved",
              2, old_value_t.cbuvstride, new_value_t.cbuvstride };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2LINESETTING_OFFSET 0x603D
#define G2SB_CTX6_G2LINESETTING_UNDEFMASK 0x00E00000
union g2sb_ctx6_g2linesetting_u {
    struct {
        unsigned int gamma:21;
        unsigned int undefined_bits_21_23:3;
        unsigned int major:1;               /* 0:xmajor 1: y major */
        unsigned int linexdir:1;
        unsigned int lineydir:1;
        unsigned int droplastp:1;           /* draw last pixel or not */
        unsigned int lineuseoctant:1;       /* use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR */
        unsigned int octants:3;             /* 000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2linesetting_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2linesetting_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2linesetting_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: gamma:21", "", 21, old_value_t.gamma, new_value_t.gamma };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_23:3", "", 3, old_value_t.undefined_bits_21_23, new_value_t.undefined_bits_21_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: major:1",
              "0:xmajor 1: y major",
              1, old_value_t.major, new_value_t.major };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linexdir:1", "", 1, old_value_t.linexdir, new_value_t.linexdir };
    m_bit_details_model.bits.append(entry);
    entry = { "26: lineydir:1", "", 1, old_value_t.lineydir, new_value_t.lineydir };
    m_bit_details_model.bits.append(entry);
    entry = { "27: droplastp:1",
              "draw last pixel or not",
              1, old_value_t.droplastp, new_value_t.droplastp };
    m_bit_details_model.bits.append(entry);
    entry = { "28: lineuseoctant:1",
              "use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR",
              1, old_value_t.lineuseoctant, new_value_t.lineuseoctant };
    m_bit_details_model.bits.append(entry);
    entry = { "29: octants:3",
              "000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7",
              3, old_value_t.octants, new_value_t.octants };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2LINEDELTAN_OFFSET 0x603E
#define G2SB_CTX6_G2LINEDELTAN_UNDEFMASK 0xFFE00000
union g2sb_ctx6_g2linedeltan_u {
    struct {
        unsigned int deltan:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2linedeltan_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2linedeltan_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2linedeltan_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltan:21", "", 21, old_value_t.deltan, new_value_t.deltan };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2LINEDELTAM_OFFSET 0x603F
#define G2SB_CTX6_G2LINEDELTAM_UNDEFMASK 0xFFE00000
union g2sb_ctx6_g2linedeltam_u {
    struct {
        unsigned int deltam:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2linedeltam_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2linedeltam_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2linedeltam_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltam:21", "", 21, old_value_t.deltam, new_value_t.deltam };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2LINEPOS_OFFSET 0x6040
#define G2SB_CTX6_G2LINEPOS_UNDEFMASK 0x00000000
union g2sb_ctx6_g2linepos_u {
    struct {
        unsigned int linexpos:16;
        unsigned int lineypos:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2linepos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2linepos_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2linepos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linexpos:16", "", 16, old_value_t.linexpos, new_value_t.linexpos };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lineypos:16", "", 16, old_value_t.lineypos, new_value_t.lineypos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2LINELEN_OFFSET 0x6041
#define G2SB_CTX6_G2LINELEN_UNDEFMASK 0xFFFF8000
union g2sb_ctx6_g2linelen_u {
    struct {
        unsigned int linelen:15;
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2linelen_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2linelen_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2linelen_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linelen:15", "", 15, old_value_t.linelen, new_value_t.linelen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CSCFOURTH_OFFSET 0x6042
#define G2SB_CTX6_G2CSCFOURTH_UNDEFMASK 0xFE00FE00
union g2sb_ctx6_g2cscfourth_u {
    struct {
        unsigned int g2u:9;                 /* multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored */
        unsigned int undefined_bits_9_15:7;
        unsigned int g2v:9;                 /* multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored */
        unsigned int undefined_bits_25_31:7;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2cscfourth_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2cscfourth_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2cscfourth_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: g2u:9",
              "multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored",
              9, old_value_t.g2u, new_value_t.g2u };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: g2v:9",
              "multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored",
              9, old_value_t.g2v, new_value_t.g2v };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bits_25_31:7", "", 7, old_value_t.undefined_bits_25_31, new_value_t.undefined_bits_25_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2SRCST_B_OFFSET 0x6043
#define G2SB_CTX6_G2SRCST_B_UNDEFMASK 0xFFFF0000
union g2sb_ctx6_g2srcst_b_u {
    struct {
        unsigned int srcs_b:16;             /* Source Stride B */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2srcst_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2srcst_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2srcst_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs_b:16",
              "Source Stride B",
              16, old_value_t.srcs_b, new_value_t.srcs_b };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2UVSTRIDE_OFFSET 0x6044
#define G2SB_CTX6_G2UVSTRIDE_UNDEFMASK 0xFFFF0000
union g2sb_ctx6_g2uvstride_u {
    struct {
        unsigned int uvstride:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2uvstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2uvstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2uvstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: uvstride:16", "", 16, old_value_t.uvstride, new_value_t.uvstride };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2CBDES2_OFFSET 0x6045
#define G2SB_CTX6_G2CBDES2_UNDEFMASK 0xFFFF8000
union g2sb_ctx6_g2cbdes2_u {
    struct {
        unsigned int top_cbline:15;         /* Circular buffer top clipping enabled, the first buffer line num */
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2cbdes2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2cbdes2_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2cbdes2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: top_cbline:15",
              "Circular buffer top clipping enabled, the first buffer line num",
              15, old_value_t.top_cbline, new_value_t.top_cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2TILEMODE_OFFSET 0x6046
#define G2SB_CTX6_G2TILEMODE_UNDEFMASK 0xFFEEEEEE
union g2sb_ctx6_g2tilemode_u {
    struct {
        unsigned int src_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_1_3:3;
        unsigned int src_uv_tile_mode:1;    /* UV surface, ignored in RGB mode */
        unsigned int undefined_bits_5_7:3;
        unsigned int pat_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_9_11:3;
        unsigned int pat_uv_tile_mode:1;    /* UNUSED */
        unsigned int undefined_bits_13_15:3;
        unsigned int dst_rd_tile_mode:1;    /* Same as destination write unless DST_RD_WR_SEP (not supported) */
        unsigned int undefined_bits_17_19:3;
        unsigned int dst_wr_tile_mode:1;    /* destination surface */
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2tilemode_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2tilemode_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2tilemode_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.src_y_tile_mode, new_value_t.src_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: src_uv_tile_mode:1",
              "UV surface, ignored in RGB mode",
              1, old_value_t.src_uv_tile_mode, new_value_t.src_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: pat_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.pat_y_tile_mode, new_value_t.pat_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: pat_uv_tile_mode:1",
              "UNUSED",
              1, old_value_t.pat_uv_tile_mode, new_value_t.pat_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dst_rd_tile_mode:1",
              "Same as destination write unless DST_RD_WR_SEP (not supported)",
              1, old_value_t.dst_rd_tile_mode, new_value_t.dst_rd_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: dst_wr_tile_mode:1",
              "destination surface",
              1, old_value_t.dst_wr_tile_mode, new_value_t.dst_wr_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2PATBASE_OFFSET 0x6047
#define G2SB_CTX6_G2PATBASE_UNDEFMASK 0x00000000
union g2sb_ctx6_g2patbase_u {
    struct {
        unsigned int pat_base:32;           /* pattern base address in tile mode,  PATBA is the linear address where pixel start */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2patbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2patbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2patbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pat_base:32",
              "pattern base address in tile mode,  PATBA is the linear address where pixel start",
              32, old_value_t.pat_base, new_value_t.pat_base };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2SRCBA_SB_SURFBASE_OFFSET 0x6048
#define G2SB_CTX6_G2SRCBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx6_g2srcba_sb_surfbase_u {
    struct {
        unsigned int src_addr:32;           /* surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2srcba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2srcba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2srcba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_addr:32",
              "surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine",
              32, old_value_t.src_addr, new_value_t.src_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2DSTBA_SB_SURFBASE_OFFSET 0x6049
#define G2SB_CTX6_G2DSTBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx6_g2dstba_sb_surfbase_u {
    struct {
        unsigned int dst_addr:32;           /* surface address corresponding to G2DSTBA Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2dstba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2dstba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2dstba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_addr:32",
              "surface address corresponding to G2DSTBA Only used by the StretchBlit Engine",
              32, old_value_t.dst_addr, new_value_t.dst_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2DSTBA_B_SB_SURFBASE_OFFSET 0x604A
#define G2SB_CTX6_G2DSTBA_B_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx6_g2dstba_b_sb_surfbase_u {
    struct {
        unsigned int dst_b_addr:32;         /* surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2dstba_b_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2dstba_b_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2dstba_b_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_b_addr:32",
              "surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled",
              32, old_value_t.dst_b_addr, new_value_t.dst_b_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2VBA_A_SB_SURFBASE_OFFSET 0x604B
#define G2SB_CTX6_G2VBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx6_g2vba_a_sb_surfbase_u {
    struct {
        unsigned int v_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2vba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2vba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2vba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine",
              32, old_value_t.v_addr, new_value_t.v_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX6_G2UBA_A_SB_SURFBASE_OFFSET 0x604C
#define G2SB_CTX6_G2UBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx6_g2uba_a_sb_surfbase_u {
    struct {
        unsigned int u_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx6_g2uba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx6_g2uba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx6_g2uba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: u_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine",
              32, old_value_t.u_addr, new_value_t.u_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_INCR_SYNCPT_OFFSET 0xA000
#define G2SB_CTX7_INCR_SYNCPT_UNDEFMASK 0xFFFF0000
union g2sb_ctx7_incr_syncpt_u {
    struct {
        unsigned int indx:8;                /* syncpt index value */
        unsigned int cond:8;                /* Condition mapped from raise/wait */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_incr_syncpt_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_incr_syncpt_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_incr_syncpt_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: indx:8",
              "syncpt index value",
              8, old_value_t.indx, new_value_t.indx };
    m_bit_details_model.bits.append(entry);
    entry = { "08: cond:8",
              "Condition mapped from raise/wait",
              8, old_value_t.cond, new_value_t.cond };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_INCR_SYNCPT_CNTRL_OFFSET 0xA001
#define G2SB_CTX7_INCR_SYNCPT_CNTRL_UNDEFMASK 0xFFFFFEFE
union g2sb_ctx7_incr_syncpt_cntrl_u {
    struct {
        unsigned int incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs. */
        unsigned int undefined_bits_1_7:7;
        unsigned int incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled. */
        unsigned int undefined_bits_9_31:23;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_incr_syncpt_cntrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_incr_syncpt_cntrl_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_incr_syncpt_cntrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: incr_syncpt_soft_reset:1",
              "If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs.",
              1, old_value_t.incr_syncpt_soft_reset, new_value_t.incr_syncpt_soft_reset };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_7:7", "", 7, old_value_t.undefined_bits_1_7, new_value_t.undefined_bits_1_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: incr_syncpt_no_stall:1",
              "If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled.",
              1, old_value_t.incr_syncpt_no_stall, new_value_t.incr_syncpt_no_stall };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_31:23", "", 23, old_value_t.undefined_bits_9_31, new_value_t.undefined_bits_9_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_INCR_SYNCPT_ERROR_OFFSET 0xA002
#define G2SB_CTX7_INCR_SYNCPT_ERROR_UNDEFMASK 0x00000000
union g2sb_ctx7_incr_syncpt_error_u {
    struct {
        unsigned int cond_status:32;        /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_incr_syncpt_error_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_incr_syncpt_error_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_incr_syncpt_error_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cond_status:32",
              "COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero",
              32, old_value_t.cond_status, new_value_t.cond_status };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CLASSCHANNEL_REGONLY_OFFSET 0xA008
#define G2SB_CTX7_G2CLASSCHANNEL_REGONLY_UNDEFMASK 0xFFE0FC00
union g2sb_ctx7_g2classchannel_regonly_u {
    struct {
        unsigned int curr_class:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int curr_channel:4;
        unsigned int ctx_valid:1;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2classchannel_regonly_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2classchannel_regonly_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2classchannel_regonly_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: curr_class:10", "", 10, old_value_t.curr_class, new_value_t.curr_class };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_15:6", "", 6, old_value_t.undefined_bits_10_15, new_value_t.undefined_bits_10_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: curr_channel:4", "", 4, old_value_t.curr_channel, new_value_t.curr_channel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: ctx_valid:1", "", 1, old_value_t.ctx_valid, new_value_t.ctx_valid };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2TRIGGER_OFFSET 0xA009
#define G2SB_CTX7_G2TRIGGER_UNDEFMASK 0xFFFF0000
union g2sb_ctx7_g2trigger_u {
    struct {
        unsigned int trigger:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2trigger_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2trigger_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2trigger_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger:16", "", 16, old_value_t.trigger, new_value_t.trigger };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2TRIGGER1_OFFSET 0xA00A
#define G2SB_CTX7_G2TRIGGER1_UNDEFMASK 0xFFFF0000
union g2sb_ctx7_g2trigger1_u {
    struct {
        unsigned int trigger1:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2trigger1_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2trigger1_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2trigger1_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger1:16", "", 16, old_value_t.trigger1, new_value_t.trigger1 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2TRIGGER2_OFFSET 0xA00B
#define G2SB_CTX7_G2TRIGGER2_UNDEFMASK 0xFFFF0000
union g2sb_ctx7_g2trigger2_u {
    struct {
        unsigned int trigger2:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2trigger2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2trigger2_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2trigger2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: trigger2:16", "", 16, old_value_t.trigger2, new_value_t.trigger2 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CMDSEL_OFFSET 0xA00C
#define G2SB_CTX7_G2CMDSEL_UNDEFMASK 0xE000280E
union g2sb_ctx7_g2cmdsel_u {
    struct {
        unsigned int sbor2d:1;
        unsigned int undefined_bits_1_3:3;
        unsigned int cbenable:1;            /* circular buffer feature enable    0= disable */
        unsigned int vitrigger:1;           /* VI trigger enable, can be circular buffer or full frame */
        unsigned int hosttrigger:1;         /* host trigger the command, host also need program cicular buffer related data */
        unsigned int cbsbdisable:1;
        unsigned int g2output:2;            /* 00: to memory 01: to EPP */
        unsigned int clip_source_top_bottom:1;/* Reserved for HW Test, SW should not use this bit. */
        unsigned int undefined_bit_11:1;
        unsigned int link_wait_buf_end:1;
        unsigned int undefined_bit_13:1;
        unsigned int frame_start:1;         /* host writes this bit to tell which buffer is ready */
        unsigned int frame_end:1;
        unsigned int buffer_index:8;
        unsigned int linken:1;              /* Test purpose */
        unsigned int linkval:3;
        unsigned int priority:1;            /* indicates priority of the context, note vi-triggered contexts take priority over HIGH */
        unsigned int undefined_bits_29_31:3;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2cmdsel_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2cmdsel_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2cmdsel_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sbor2d:1", "", 1, old_value_t.sbor2d, new_value_t.sbor2d };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: cbenable:1",
              "circular buffer feature enable   \n0= disable",
              1, old_value_t.cbenable, new_value_t.cbenable };
    m_bit_details_model.bits.append(entry);
    entry = { "05: vitrigger:1",
              "VI trigger enable, can be circular buffer or full frame",
              1, old_value_t.vitrigger, new_value_t.vitrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "06: hosttrigger:1",
              "host trigger the command, host also need program cicular buffer related data",
              1, old_value_t.hosttrigger, new_value_t.hosttrigger };
    m_bit_details_model.bits.append(entry);
    entry = { "07: cbsbdisable:1", "", 1, old_value_t.cbsbdisable, new_value_t.cbsbdisable };
    m_bit_details_model.bits.append(entry);
    entry = { "08: g2output:2",
              "00: to memory 01: to EPP",
              2, old_value_t.g2output, new_value_t.g2output };
    m_bit_details_model.bits.append(entry);
    entry = { "10: clip_source_top_bottom:1",
              "Reserved for HW Test, SW should not use this bit.",
              1, old_value_t.clip_source_top_bottom, new_value_t.clip_source_top_bottom };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bit_11:1", "", 1, old_value_t.undefined_bit_11, new_value_t.undefined_bit_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: link_wait_buf_end:1", "", 1, old_value_t.link_wait_buf_end, new_value_t.link_wait_buf_end };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: frame_start:1",
              "host writes this bit to tell which buffer is ready",
              1, old_value_t.frame_start, new_value_t.frame_start };
    m_bit_details_model.bits.append(entry);
    entry = { "15: frame_end:1", "", 1, old_value_t.frame_end, new_value_t.frame_end };
    m_bit_details_model.bits.append(entry);
    entry = { "16: buffer_index:8", "", 8, old_value_t.buffer_index, new_value_t.buffer_index };
    m_bit_details_model.bits.append(entry);
    entry = { "24: linken:1",
              "Test purpose",
              1, old_value_t.linken, new_value_t.linken };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linkval:3", "", 3, old_value_t.linkval, new_value_t.linkval };
    m_bit_details_model.bits.append(entry);
    entry = { "28: priority:1",
              "indicates priority of the context, note vi-triggered contexts take priority over HIGH",
              1, old_value_t.priority, new_value_t.priority };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bits_29_31:3", "", 3, old_value_t.undefined_bits_29_31, new_value_t.undefined_bits_29_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2RAISE_OFFSET 0xA00D
#define G2SB_CTX7_G2RAISE_UNDEFMASK 0xFFF0FFE0
union g2sb_ctx7_g2raise_u {
    struct {
        unsigned int raise:5;               /* Push back to read fifo when all commands in the channel are done.           */
        unsigned int undefined_bits_5_15:11;
        unsigned int raisechannel:4;
        unsigned int undefined_bits_20_31:12;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2raise_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2raise_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2raise_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: raise:5",
              "Push back to read fifo when all commands in the channel are done.",
              5, old_value_t.raise, new_value_t.raise };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_15:11", "", 11, old_value_t.undefined_bits_5_15, new_value_t.undefined_bits_5_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisechannel:4", "", 4, old_value_t.raisechannel, new_value_t.raisechannel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_31:12", "", 12, old_value_t.undefined_bits_20_31, new_value_t.undefined_bits_20_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2HOSTSET_OFFSET 0xA00F
#define G2SB_CTX7_G2HOSTSET_UNDEFMASK 0xFFFFFF00
union g2sb_ctx7_g2hostset_u {
    struct {
        unsigned int hstlngap:4;            /*  specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte) */
        unsigned int hstfpxl:4;             /* specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2hostset_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2hostset_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2hostset_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hstlngap:4",
              " specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte)",
              4, old_value_t.hstlngap, new_value_t.hstlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: hstfpxl:4",
              "specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary",
              4, old_value_t.hstfpxl, new_value_t.hstfpxl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2HOSTFIFO_OFFSET 0xA010
#define G2SB_CTX7_G2HOSTFIFO_UNDEFMASK 0x00000000
union g2sb_ctx7_g2hostfifo_u {
    struct {
        unsigned int hostfifodata:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2hostfifo_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2hostfifo_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2hostfifo_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hostfifodata:32", "", 32, old_value_t.hostfifodata, new_value_t.hostfifodata };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2VDDA_OFFSET 0xA011
#define G2SB_CTX7_G2VDDA_UNDEFMASK 0x00000000
union g2sb_ctx7_g2vdda_u {
    struct {
        unsigned int vdstep:32;             /* Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2vdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2vdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2vdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdstep:32",
              "Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010.",
              32, old_value_t.vdstep, new_value_t.vdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2VDDAINI_OFFSET 0xA012
#define G2SB_CTX7_G2VDDAINI_UNDEFMASK 0xFFFF0000
union g2sb_ctx7_g2vddaini_u {
    struct {
        unsigned int vdtini:8;              /* Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window. */
        unsigned int vdbini:8;              /* Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above) */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2vddaini_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2vddaini_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2vddaini_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: vdtini:8",
              "Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window.",
              8, old_value_t.vdtini, new_value_t.vdtini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: vdbini:8",
              "Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above)",
              8, old_value_t.vdbini, new_value_t.vdbini };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2HDDA_OFFSET 0xA013
#define G2SB_CTX7_G2HDDA_UNDEFMASK 0x00000000
union g2sb_ctx7_g2hdda_u {
    struct {
        unsigned int hdstep:32;             /* Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2hdda_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2hdda_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2hdda_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdstep:32",
              "Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101.",
              32, old_value_t.hdstep, new_value_t.hdstep };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2HDDAINILS_OFFSET 0xA014
#define G2SB_CTX7_G2HDDAINILS_UNDEFMASK 0xFFFFFF00
union g2sb_ctx7_g2hddainils_u {
    struct {
        unsigned int hdini:8;               /* Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0. */
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2hddainils_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2hddainils_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2hddainils_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: hdini:8",
              "Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0.",
              8, old_value_t.hdini, new_value_t.hdini };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CSCFIRST_OFFSET 0xA015
#define G2SB_CTX7_G2CSCFIRST_UNDEFMASK 0x00C00C00
union g2sb_ctx7_g2cscfirst_u {
    struct {
        unsigned int cub:10;                /* multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved  */
        unsigned int undefined_bits_10_11:2;
        unsigned int cvr:10;                /* multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved */
        unsigned int undefined_bits_22_23:2;
        unsigned int yos:8;                 /* Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2cscfirst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2cscfirst_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2cscfirst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cub:10",
              "multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved",
              10, old_value_t.cub, new_value_t.cub };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_11:2", "", 2, old_value_t.undefined_bits_10_11, new_value_t.undefined_bits_10_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cvr:10",
              "multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved",
              10, old_value_t.cvr, new_value_t.cvr };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: yos:8",
              "Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10",
              8, old_value_t.yos, new_value_t.yos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CSCSECOND_OFFSET 0xA016
#define G2SB_CTX7_G2CSCSECOND_UNDEFMASK 0x00C00E00
union g2sb_ctx7_g2cscsecond_u {
    struct {
        unsigned int cug:9;                 /* multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved */
        unsigned int undefined_bits_9_11:3;
        unsigned int cur:10;                /* multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved  */
        unsigned int undefined_bits_22_23:2;
        unsigned int cyx:8;                 /* multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2cscsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2cscsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2cscsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cug:9",
              "multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved",
              9, old_value_t.cug, new_value_t.cug };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: cur:10",
              "multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved",
              10, old_value_t.cur, new_value_t.cur };
    m_bit_details_model.bits.append(entry);
    entry = { "22: undefined_bits_22_23:2", "", 2, old_value_t.undefined_bits_22_23, new_value_t.undefined_bits_22_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: cyx:8",
              "multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041",
              8, old_value_t.cyx, new_value_t.cyx };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CSCTHIRD_OFFSET 0xA017
#define G2SB_CTX7_G2CSCTHIRD_UNDEFMASK 0xFC00FE00
union g2sb_ctx7_g2cscthird_u {
    struct {
        unsigned int cvg:9;                 /* multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113 */
        unsigned int undefined_bits_9_15:7;
        unsigned int cvb:10;                /* multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021 */
        unsigned int undefined_bits_26_31:6;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2cscthird_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2cscthird_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2cscthird_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cvg:9",
              "multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113",
              9, old_value_t.cvg, new_value_t.cvg };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cvb:10",
              "multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021",
              10, old_value_t.cvb, new_value_t.cvb };
    m_bit_details_model.bits.append(entry);
    entry = { "26: undefined_bits_26_31:6", "", 6, old_value_t.undefined_bits_26_31, new_value_t.undefined_bits_26_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CMKEYL_OFFSET 0xA018
#define G2SB_CTX7_G2CMKEYL_UNDEFMASK 0xFF000000
union g2sb_ctx7_g2cmkeyl_u {
    struct {
        unsigned int ckbl:8;                /* B or Y Color/Chroma Key Lower Limit (CKBL[7:0]) */
        unsigned int ckgl:8;                /* G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level. */
        unsigned int ckrl:8;                /* R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2cmkeyl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2cmkeyl_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2cmkeyl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbl:8",
              "B or Y Color/Chroma Key Lower Limit (CKBL[7:0])",
              8, old_value_t.ckbl, new_value_t.ckbl };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgl:8",
              "G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgl, new_value_t.ckgl };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckrl:8",
              "R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved",
              8, old_value_t.ckrl, new_value_t.ckrl };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CMKEYU_OFFSET 0xA019
#define G2SB_CTX7_G2CMKEYU_UNDEFMASK 0xFF000000
union g2sb_ctx7_g2cmkeyu_u {
    struct {
        unsigned int ckbu:8;                /* This is B or Y color/chroma key upper limit value. */
        unsigned int ckgu:8;                /* G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level. */
        unsigned int ckru:8;                /* R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2cmkeyu_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2cmkeyu_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2cmkeyu_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ckbu:8",
              "This is B or Y color/chroma key upper limit value.",
              8, old_value_t.ckbu, new_value_t.ckbu };
    m_bit_details_model.bits.append(entry);
    entry = { "08: ckgu:8",
              "G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level.",
              8, old_value_t.ckgu, new_value_t.ckgu };
    m_bit_details_model.bits.append(entry);
    entry = { "16: ckru:8",
              "R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved",
              8, old_value_t.ckru, new_value_t.ckru };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_31:8", "", 8, old_value_t.undefined_bits_24_31, new_value_t.undefined_bits_24_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2UBA_A_OFFSET 0xA01A
#define G2SB_CTX7_G2UBA_A_UNDEFMASK 0x00000000
union g2sb_ctx7_g2uba_a_u {
    struct {
        unsigned int su1sa:32;              /* Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2uba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2uba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2uba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: su1sa:32",
              "Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.su1sa, new_value_t.su1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2VBA_A_OFFSET 0xA01B
#define G2SB_CTX7_G2VBA_A_UNDEFMASK 0x00000000
union g2sb_ctx7_g2vba_a_u {
    struct {
        unsigned int sv1sa:32;              /* Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2vba_a_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2vba_a_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2vba_a_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sv1sa:32",
              "Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format.",
              32, old_value_t.sv1sa, new_value_t.sv1sa };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2SBFORMAT_OFFSET 0xA01C
#define G2SB_CTX7_G2SBFORMAT_UNDEFMASK 0x000020E0
union g2sb_ctx7_g2sbformat_u {
    struct {
        unsigned int sifmt:5;               /* This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV. */
        unsigned int undefined_bits_5_7:3;
        unsigned int difmt:5;               /* Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED */
        unsigned int undefined_bit_13:1;
        unsigned int raisebufferen:1;       /* ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.  */
        unsigned int raiseframeen:1;        /* ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.  */
        unsigned int raisebuffervalue:8;    /* Raise buffer vector value. */
        unsigned int raiseframevalue:8;     /* Raise Fram vector value. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2sbformat_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2sbformat_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2sbformat_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: sifmt:5",
              "This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for RGB->YUV.",
              5, old_value_t.sifmt, new_value_t.sifmt };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: difmt:5",
              "Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED",
              5, old_value_t.difmt, new_value_t.difmt };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bit_13:1", "", 1, old_value_t.undefined_bit_13, new_value_t.undefined_bit_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: raisebufferen:1",
              "ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raisebufferen, new_value_t.raisebufferen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: raiseframeen:1",
              "ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.",
              1, old_value_t.raiseframeen, new_value_t.raiseframeen };
    m_bit_details_model.bits.append(entry);
    entry = { "16: raisebuffervalue:8",
              "Raise buffer vector value.",
              8, old_value_t.raisebuffervalue, new_value_t.raisebuffervalue };
    m_bit_details_model.bits.append(entry);
    entry = { "24: raiseframevalue:8",
              "Raise Fram vector value.",
              8, old_value_t.raiseframevalue, new_value_t.raiseframevalue };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CONTROLSB_OFFSET 0xA01D
#define G2SB_CTX7_G2CONTROLSB_UNDEFMASK 0x20005807
union g2sb_ctx7_g2controlsb_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int yuv422rotation:1;      /* yuv422 plannar rotated */
        unsigned int yuv422planar:1;        /* source data is yuv422 planar valid when imode==PLANAR */
        unsigned int imode:1;               /* Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d. */
        unsigned int enavf:1;               /* enable alpha vertical filter     */
        unsigned int enahf:1;               /* enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format, */
        unsigned int uvst:2;                /*   00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.   11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride). */
        unsigned int sl:1;                  /* Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines. */
        unsigned int undefined_bits_11_12:2;
        unsigned int sisel:1;               /* StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved  */
        unsigned int undefined_bit_14:1;
        unsigned int sbltsrc:1;             /* StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator. */
        unsigned int vftype:2;              /* StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager. */
        unsigned int vfen:1;                /* StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled. */
        unsigned int discsc:1;              /* enabled color space converter by default */
        unsigned int hftype:3;              /* StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE. */
        unsigned int rangeredfrm:1;         /* In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.  */
        unsigned int sitype:1;              /* StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?. */
        unsigned int sbsel:1;               /* StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer. */
        unsigned int dbsel:1;               /* StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer. */
        unsigned int keyen:1;               /* Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled. */
        unsigned int kpol:1;                /* Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range. */
        unsigned int undefined_bit_29:1;
        unsigned int endith:1;              /* Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering */
        unsigned int disdw:1;               /* output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place. */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2controlsb_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2controlsb_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2controlsb_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bits_0_2:3", "", 3, old_value_t.undefined_bits_0_2, new_value_t.undefined_bits_0_2 };
    m_bit_details_model.bits.append(entry);
    entry = { "03: yuv422rotation:1",
              "yuv422 plannar rotated",
              1, old_value_t.yuv422rotation, new_value_t.yuv422rotation };
    m_bit_details_model.bits.append(entry);
    entry = { "04: yuv422planar:1",
              "source data is yuv422 planar valid when imode==PLANAR",
              1, old_value_t.yuv422planar, new_value_t.yuv422planar };
    m_bit_details_model.bits.append(entry);
    entry = { "05: imode:1",
              "Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d.",
              1, old_value_t.imode, new_value_t.imode };
    m_bit_details_model.bits.append(entry);
    entry = { "06: enavf:1",
              "enable alpha vertical filter",
              1, old_value_t.enavf, new_value_t.enavf };
    m_bit_details_model.bits.append(entry);
    entry = { "07: enahf:1",
              "enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format,",
              1, old_value_t.enahf, new_value_t.enahf };
    m_bit_details_model.bits.append(entry);
    entry = { "08: uvst:2",
              " \n00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.\n11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride).",
              2, old_value_t.uvst, new_value_t.uvst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: sl:1",
              "Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines.",
              1, old_value_t.sl, new_value_t.sl };
    m_bit_details_model.bits.append(entry);
    entry = { "11: undefined_bits_11_12:2", "", 2, old_value_t.undefined_bits_11_12, new_value_t.undefined_bits_11_12 };
    m_bit_details_model.bits.append(entry);
    entry = { "13: sisel:1",
              "StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved",
              1, old_value_t.sisel, new_value_t.sisel };
    m_bit_details_model.bits.append(entry);
    entry = { "14: undefined_bit_14:1", "", 1, old_value_t.undefined_bit_14, new_value_t.undefined_bit_14 };
    m_bit_details_model.bits.append(entry);
    entry = { "15: sbltsrc:1",
              "StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator.",
              1, old_value_t.sbltsrc, new_value_t.sbltsrc };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vftype:2",
              "StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager.",
              2, old_value_t.vftype, new_value_t.vftype };
    m_bit_details_model.bits.append(entry);
    entry = { "18: vfen:1",
              "StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled.",
              1, old_value_t.vfen, new_value_t.vfen };
    m_bit_details_model.bits.append(entry);
    entry = { "19: discsc:1",
              "enabled color space converter by default",
              1, old_value_t.discsc, new_value_t.discsc };
    m_bit_details_model.bits.append(entry);
    entry = { "20: hftype:3",
              "StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE.",
              3, old_value_t.hftype, new_value_t.hftype };
    m_bit_details_model.bits.append(entry);
    entry = { "23: rangeredfrm:1",
              "In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.",
              1, old_value_t.rangeredfrm, new_value_t.rangeredfrm };
    m_bit_details_model.bits.append(entry);
    entry = { "24: sitype:1",
              "StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?.",
              1, old_value_t.sitype, new_value_t.sitype };
    m_bit_details_model.bits.append(entry);
    entry = { "25: sbsel:1",
              "StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer.",
              1, old_value_t.sbsel, new_value_t.sbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "26: dbsel:1",
              "StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer.",
              1, old_value_t.dbsel, new_value_t.dbsel };
    m_bit_details_model.bits.append(entry);
    entry = { "27: keyen:1",
              "Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled.",
              1, old_value_t.keyen, new_value_t.keyen };
    m_bit_details_model.bits.append(entry);
    entry = { "28: kpol:1",
              "Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range.",
              1, old_value_t.kpol, new_value_t.kpol };
    m_bit_details_model.bits.append(entry);
    entry = { "29: undefined_bit_29:1", "", 1, old_value_t.undefined_bit_29, new_value_t.undefined_bit_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: endith:1",
              "Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering",
              1, old_value_t.endith, new_value_t.endith };
    m_bit_details_model.bits.append(entry);
    entry = { "31: disdw:1",
              "output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place.",
              1, old_value_t.disdw, new_value_t.disdw };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CONTROLSECOND_OFFSET 0xA01E
#define G2SB_CTX7_G2CONTROLSECOND_UNDEFMASK 0xC08E3C01
union g2sb_ctx7_g2controlsecond_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int bitswap:1;             /* Host port bit swap 1=enable   0= disable   1= enable */
        unsigned int bebswap:1;             /* Host port byte swap 1=enable   0= disable   1= enable */
        unsigned int bewswap:1;             /* Host port word swap 1=enable   0= disable */
        unsigned int alptype:5;             /* Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits. */
        unsigned int alpsrcordst:1;         /* 32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha */
        unsigned int undefined_bits_10_13:4;
        unsigned int pxlrep:1;              /* Pixel replication for Palm OS. */
        unsigned int swapblt:1;             /* Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area */
        unsigned int vcaa_safe_mode:1;      /* VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken. */
        unsigned int undefined_bits_17_19:3;
        unsigned int g2nostop:1;
        unsigned int clipc:2;               /* Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,  10=draw only inside clipping rectangle,  11=draw only outside clipping rectangle */
        unsigned int undefined_bit_23:1;
        unsigned int fr_mode:2;             /* Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice. 00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so! 01 = src/dst copy mode - two separate buffers 10 = square in place - one buffer 11 = blank */
        unsigned int fr_type:3;             /*  Fast Rotate type     000 = FLIP_X  001 = FLIP_Y  010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right) 011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left) 100 = ROT_90 (counter clock wise by 90 degrees) 101 = ROT_180  110 = ROT_270 (clock wise by 90 degrees) 111 = IDENTITY */
        unsigned int fr_readwait:1;         /*  Fast Rotate wait for read 0 = disable 1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only. */
        unsigned int undefined_bits_30_31:2;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2controlsecond_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2controlsecond_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2controlsecond_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: undefined_bit_0:1", "", 1, old_value_t.undefined_bit_0, new_value_t.undefined_bit_0 };
    m_bit_details_model.bits.append(entry);
    entry = { "01: bitswap:1",
              "Host port bit swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bitswap, new_value_t.bitswap };
    m_bit_details_model.bits.append(entry);
    entry = { "02: bebswap:1",
              "Host port byte swap\n1=enable  \n0= disable  \n1= enable",
              1, old_value_t.bebswap, new_value_t.bebswap };
    m_bit_details_model.bits.append(entry);
    entry = { "03: bewswap:1",
              "Host port word swap\n1=enable  \n0= disable",
              1, old_value_t.bewswap, new_value_t.bewswap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: alptype:5",
              "Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4, alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be multiple of 128bits.",
              5, old_value_t.alptype, new_value_t.alptype };
    m_bit_details_model.bits.append(entry);
    entry = { "09: alpsrcordst:1",
              "32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha",
              1, old_value_t.alpsrcordst, new_value_t.alpsrcordst };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_13:4", "", 4, old_value_t.undefined_bits_10_13, new_value_t.undefined_bits_10_13 };
    m_bit_details_model.bits.append(entry);
    entry = { "14: pxlrep:1",
              "Pixel replication for Palm OS.",
              1, old_value_t.pxlrep, new_value_t.pxlrep };
    m_bit_details_model.bits.append(entry);
    entry = { "15: swapblt:1",
              "Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area",
              1, old_value_t.swapblt, new_value_t.swapblt };
    m_bit_details_model.bits.append(entry);
    entry = { "16: vcaa_safe_mode:1",
              "VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken.",
              1, old_value_t.vcaa_safe_mode, new_value_t.vcaa_safe_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: g2nostop:1", "", 1, old_value_t.g2nostop, new_value_t.g2nostop };
    m_bit_details_model.bits.append(entry);
    entry = { "21: clipc:2",
              "Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,\n10=draw only inside clipping rectangle,\n11=draw only outside clipping rectangle",
              2, old_value_t.clipc, new_value_t.clipc };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fr_mode:2",
              "Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice.\n00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so!\n01 = src/dst copy mode - two separate buffers\n10 = square in place - one buffer\n11 = blank",
              2, old_value_t.fr_mode, new_value_t.fr_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "26: fr_type:3",
              " Fast Rotate type    \n000 = FLIP_X \n001 = FLIP_Y \n010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right)\n011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left)\n100 = ROT_90 (counter clock wise by 90 degrees)\n101 = ROT_180 \n110 = ROT_270 (clock wise by 90 degrees)\n111 = IDENTITY",
              3, old_value_t.fr_type, new_value_t.fr_type };
    m_bit_details_model.bits.append(entry);
    entry = { "29: fr_readwait:1",
              " Fast Rotate wait for read\n0 = disable\n1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only.",
              1, old_value_t.fr_readwait, new_value_t.fr_readwait };
    m_bit_details_model.bits.append(entry);
    entry = { "30: undefined_bits_30_31:2", "", 2, old_value_t.undefined_bits_30_31, new_value_t.undefined_bits_30_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CONTROLMAIN_OFFSET 0xA01F
#define G2SB_CTX7_G2CONTROLMAIN_UNDEFMASK 0x80000000
union g2sb_ctx7_g2controlmain_u {
    struct {
        unsigned int cmdt:2;                /* Command Type:  00=BitBlt 01=Line Draw  10=VCAA 11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed) */
        unsigned int turbofill:1;           /* fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified. */
        unsigned int test0bit:1;            /* Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish. */
        unsigned int faden:1;               /* BitBlt Source Copy Fade enable, 1=enable (share with mltln), only support  16bpp mode */
        unsigned int alpen:1;               /* BitBlt Alpha Blending, 1=enable. 0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype */
        unsigned int srcsld:1;              /* BitBlt Solid Source Color Fill: 1=enable. FGC will be used as  the color value. */
        unsigned int patsld:1;              /* BitBlt Solid Pattern Fill: 1=enable. BGC will be used as  the color value. */
        unsigned int patfl:1;               /* When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+ */
        unsigned int xdir:1;                /*  0=incrementing, 1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0 */
        unsigned int ydir:1;                /*  0=incrementing, 1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0 */
        unsigned int xytdw:1;               /* xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination. */
        unsigned int srcpack:1;             /* Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled. */
        unsigned int patpack:1;             /* Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled. */
        unsigned int yflip:1;               /* flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination. */
        unsigned int srcsel:1;              /* Source Data Select: */
        unsigned int dstcd:2;               /* Destination color depth:   00=8-bpp, 01=16-bpp, 10=32-bpp. 11=reserved */
        unsigned int dstt:2;                /* Destination read transparency enable:   0x=destination read transparency disabled   10=color destination read transparency   11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately, 0=wait for launch write) */
        unsigned int srccd:1;               /* 0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0 */
        unsigned int hlmono:1;              /* Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit */
        unsigned int srct:2;                /* Source transparency enable: 0x=source transparency disabled,  10=mono source background transparency     or color source transparency,  11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied. */
        unsigned int srcbas:1;              /* Source base address select:   0=srcba, 1=dstba. This is not used for Line Draw and  if source data comes from host memory. */
        unsigned int gcsw:2;                /* Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used */
        unsigned int srcdir:1;              /* source direct addressing */
        unsigned int dstdir:1;              /* destination direct addressing */
        unsigned int dst_rd_wr_sep:1;       /* This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA */
        unsigned int patsel:1;              /* pattern Data Select: SRCSEL and PATSEL can't be both enabled. */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2controlmain_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2controlmain_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2controlmain_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cmdt:2",
              "Command Type: \n00=BitBlt\n01=Line Draw \n10=VCAA\n11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed)",
              2, old_value_t.cmdt, new_value_t.cmdt };
    m_bit_details_model.bits.append(entry);
    entry = { "02: turbofill:1",
              "fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified.",
              1, old_value_t.turbofill, new_value_t.turbofill };
    m_bit_details_model.bits.append(entry);
    entry = { "03: test0bit:1",
              "Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish.",
              1, old_value_t.test0bit, new_value_t.test0bit };
    m_bit_details_model.bits.append(entry);
    entry = { "04: faden:1",
              "BitBlt Source Copy Fade enable,\n1=enable (share with mltln), only support  16bpp mode",
              1, old_value_t.faden, new_value_t.faden };
    m_bit_details_model.bits.append(entry);
    entry = { "05: alpen:1",
              "BitBlt Alpha Blending,\n1=enable.\n0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype",
              1, old_value_t.alpen, new_value_t.alpen };
    m_bit_details_model.bits.append(entry);
    entry = { "06: srcsld:1",
              "BitBlt Solid Source Color Fill:\n1=enable. FGC will be used as  the color value.",
              1, old_value_t.srcsld, new_value_t.srcsld };
    m_bit_details_model.bits.append(entry);
    entry = { "07: patsld:1",
              "BitBlt Solid Pattern Fill:\n1=enable. BGC will be used as  the color value.",
              1, old_value_t.patsld, new_value_t.patsld };
    m_bit_details_model.bits.append(entry);
    entry = { "08: patfl:1",
              "When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+",
              1, old_value_t.patfl, new_value_t.patfl };
    m_bit_details_model.bits.append(entry);
    entry = { "09: xdir:1",
              "0=incrementing,\n1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0",
              1, old_value_t.xdir, new_value_t.xdir };
    m_bit_details_model.bits.append(entry);
    entry = { "10: ydir:1",
              "0=incrementing,\n1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0",
              1, old_value_t.ydir, new_value_t.ydir };
    m_bit_details_model.bits.append(entry);
    entry = { "11: xytdw:1",
              "xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination.",
              1, old_value_t.xytdw, new_value_t.xytdw };
    m_bit_details_model.bits.append(entry);
    entry = { "12: srcpack:1",
              "Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.srcpack, new_value_t.srcpack };
    m_bit_details_model.bits.append(entry);
    entry = { "13: patpack:1",
              "Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled.",
              1, old_value_t.patpack, new_value_t.patpack };
    m_bit_details_model.bits.append(entry);
    entry = { "14: yflip:1",
              "flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination.",
              1, old_value_t.yflip, new_value_t.yflip };
    m_bit_details_model.bits.append(entry);
    entry = { "15: srcsel:1",
              "Source Data Select:",
              1, old_value_t.srcsel, new_value_t.srcsel };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstcd:2",
              "Destination color depth:  \n00=8-bpp,\n01=16-bpp,\n10=32-bpp.\n11=reserved",
              2, old_value_t.dstcd, new_value_t.dstcd };
    m_bit_details_model.bits.append(entry);
    entry = { "18: dstt:2",
              "Destination read transparency enable:   0x=destination read transparency disabled  \n10=color destination read transparency  \n11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately,\n0=wait for launch write)",
              2, old_value_t.dstt, new_value_t.dstt };
    m_bit_details_model.bits.append(entry);
    entry = { "20: srccd:1",
              "0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0",
              1, old_value_t.srccd, new_value_t.srccd };
    m_bit_details_model.bits.append(entry);
    entry = { "21: hlmono:1",
              "Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit",
              1, old_value_t.hlmono, new_value_t.hlmono };
    m_bit_details_model.bits.append(entry);
    entry = { "22: srct:2",
              "Source transparency enable: 0x=source transparency disabled,\n10=mono source background transparency     or color source transparency,\n11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied.",
              2, old_value_t.srct, new_value_t.srct };
    m_bit_details_model.bits.append(entry);
    entry = { "24: srcbas:1",
              "Source base address select:  \n0=srcba,\n1=dstba. This is not used for Line Draw and  if source data comes from host memory.",
              1, old_value_t.srcbas, new_value_t.srcbas };
    m_bit_details_model.bits.append(entry);
    entry = { "25: gcsw:2",
              "Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used",
              2, old_value_t.gcsw, new_value_t.gcsw };
    m_bit_details_model.bits.append(entry);
    entry = { "27: srcdir:1",
              "source direct addressing",
              1, old_value_t.srcdir, new_value_t.srcdir };
    m_bit_details_model.bits.append(entry);
    entry = { "28: dstdir:1",
              "destination direct addressing",
              1, old_value_t.dstdir, new_value_t.dstdir };
    m_bit_details_model.bits.append(entry);
    entry = { "29: dst_rd_wr_sep:1",
              "This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA",
              1, old_value_t.dst_rd_wr_sep, new_value_t.dst_rd_wr_sep };
    m_bit_details_model.bits.append(entry);
    entry = { "30: patsel:1",
              "pattern Data Select: SRCSEL and PATSEL can't be both enabled.",
              1, old_value_t.patsel, new_value_t.patsel };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2ROPFADE_OFFSET 0xA020
#define G2SB_CTX7_G2ROPFADE_UNDEFMASK 0x0000FF00
union g2sb_ctx7_g2ropfade_u {
    struct {
        unsigned int rop:8;                 /* If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out. */
        unsigned int undefined_bits_8_15:8;
        unsigned int fadcoe:8;
        unsigned int fadoff:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2ropfade_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2ropfade_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2ropfade_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: rop:8",
              "If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out.",
              8, old_value_t.rop, new_value_t.rop };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: fadcoe:8", "", 8, old_value_t.fadcoe, new_value_t.fadcoe };
    m_bit_details_model.bits.append(entry);
    entry = { "24: fadoff:8", "", 8, old_value_t.fadoff, new_value_t.fadoff };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2ALPHABLEND_OFFSET 0xA021
#define G2SB_CTX7_G2ALPHABLEND_UNDEFMASK 0x0000FE00
union g2sb_ctx7_g2alphablend_u {
    struct {
        unsigned int alpha:8;
        unsigned int alphainv:1;
        unsigned int undefined_bits_9_15:7;
        unsigned int alpha0v:8;
        unsigned int alpha1v:8;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2alphablend_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2alphablend_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2alphablend_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: alpha:8", "", 8, old_value_t.alpha, new_value_t.alpha };
    m_bit_details_model.bits.append(entry);
    entry = { "08: alphainv:1", "", 1, old_value_t.alphainv, new_value_t.alphainv };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: alpha0v:8", "", 8, old_value_t.alpha0v, new_value_t.alpha0v };
    m_bit_details_model.bits.append(entry);
    entry = { "24: alpha1v:8", "", 8, old_value_t.alpha1v, new_value_t.alpha1v };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CLIPLEFTTOP_OFFSET 0xA022
#define G2SB_CTX7_G2CLIPLEFTTOP_UNDEFMASK 0x80008000
union g2sb_ctx7_g2cliplefttop_u {
    struct {
        unsigned int clipl:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipt:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2cliplefttop_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2cliplefttop_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2cliplefttop_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipl:15", "", 15, old_value_t.clipl, new_value_t.clipl };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipt:15", "", 15, old_value_t.clipt, new_value_t.clipt };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CLIPRIGHTBOT_OFFSET 0xA023
#define G2SB_CTX7_G2CLIPRIGHTBOT_UNDEFMASK 0x80008000
union g2sb_ctx7_g2cliprightbot_u {
    struct {
        unsigned int clipr:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipb:15;
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2cliprightbot_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2cliprightbot_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2cliprightbot_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: clipr:15", "", 15, old_value_t.clipr, new_value_t.clipr };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: clipb:15", "", 15, old_value_t.clipb, new_value_t.clipb };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2PATPACK_OFFSET 0xA024
#define G2SB_CTX7_G2PATPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx7_g2patpack_u {
    struct {
        unsigned int patlngap:4;            /* Packed mode, pattern data line gap. byte */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2patpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2patpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2patpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patlngap:4",
              "Packed mode, pattern data line gap. byte",
              4, old_value_t.patlngap, new_value_t.patlngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2PATPACK_SIZE_OFFSET 0xA025
#define G2SB_CTX7_G2PATPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx7_g2patpack_size_u {
    struct {
        unsigned int patmonow:16;           /* Mono data width in packed mode, byte  */
        unsigned int patmonoh:16;           /*  Pattern mono data height in packed mode, byte  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2patpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2patpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2patpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patmonow:16",
              "Mono data width in packed mode, byte",
              16, old_value_t.patmonow, new_value_t.patmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patmonoh:16",
              " Pattern mono data height in packed mode, byte",
              16, old_value_t.patmonoh, new_value_t.patmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2PATBA_OFFSET 0xA026
#define G2SB_CTX7_G2PATBA_UNDEFMASK 0x00000000
union g2sb_ctx7_g2patba_u {
    struct {
        unsigned int patba:32;              /* If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. } */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2patba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2patba_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2patba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patba:32",
              "If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. }",
              32, old_value_t.patba, new_value_t.patba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2PATOS_OFFSET 0xA027
#define G2SB_CTX7_G2PATOS_UNDEFMASK 0x009E0000
union g2sb_ctx7_g2patos_u {
    struct {
        unsigned int patst:16;              /* stride */
        unsigned int patcd:1;               /* 0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0 */
        unsigned int undefined_bits_17_20:4;
        unsigned int patt:2;                /* Mono pattern transparency enable:  0x=pattern transparency disabled,  10=mono pattern background transparency    or color pattern transparency,  11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied. */
        unsigned int undefined_bit_23:1;
        unsigned int patxo:4;               /* x offset for mono tile pattern fill.  see PATFL */
        unsigned int patyo:4;               /* y offset for mono tile pattern fill.  see PATFL */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2patos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2patos_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2patos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patst:16",
              "stride",
              16, old_value_t.patst, new_value_t.patst };
    m_bit_details_model.bits.append(entry);
    entry = { "16: patcd:1",
              "0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0",
              1, old_value_t.patcd, new_value_t.patcd };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_20:4", "", 4, old_value_t.undefined_bits_17_20, new_value_t.undefined_bits_17_20 };
    m_bit_details_model.bits.append(entry);
    entry = { "21: patt:2",
              "Mono pattern transparency enable:  0x=pattern transparency disabled,\n10=mono pattern background transparency    or color pattern transparency,\n11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied.",
              2, old_value_t.patt, new_value_t.patt };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bit_23:1", "", 1, old_value_t.undefined_bit_23, new_value_t.undefined_bit_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: patxo:4",
              "x offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patxo, new_value_t.patxo };
    m_bit_details_model.bits.append(entry);
    entry = { "28: patyo:4",
              "y offset for mono tile pattern fill.  see PATFL",
              4, old_value_t.patyo, new_value_t.patyo };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2PATBGC_OFFSET 0xA028
#define G2SB_CTX7_G2PATBGC_UNDEFMASK 0x00000000
union g2sb_ctx7_g2patbgc_u {
    struct {
        unsigned int patbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2patbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2patbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2patbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patbgc:32", "", 32, old_value_t.patbgc, new_value_t.patbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2PATFGC_OFFSET 0xA029
#define G2SB_CTX7_G2PATFGC_UNDEFMASK 0x00000000
union g2sb_ctx7_g2patfgc_u {
    struct {
        unsigned int patfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2patfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2patfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2patfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patfgc:32", "", 32, old_value_t.patfgc, new_value_t.patfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2PATKEY_OFFSET 0xA02A
#define G2SB_CTX7_G2PATKEY_UNDEFMASK 0x00000000
union g2sb_ctx7_g2patkey_u {
    struct {
        unsigned int patkey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2patkey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2patkey_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2patkey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: patkey:32", "", 32, old_value_t.patkey, new_value_t.patkey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2DSTBA_OFFSET 0xA02B
#define G2SB_CTX7_G2DSTBA_UNDEFMASK 0x00000000
union g2sb_ctx7_g2dstba_u {
    struct {
        unsigned int dstba:32;              /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2dstba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2dstba_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2dstba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba, new_value_t.dstba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2DSTBA_B_OFFSET 0xA02C
#define G2SB_CTX7_G2DSTBA_B_UNDEFMASK 0x00000000
union g2sb_ctx7_g2dstba_b_u {
    struct {
        unsigned int dstba_b:32;            /* Destination base address (byte address) only usable in hardware trigger mode by enable gcsw */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2dstba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2dstba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2dstba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_b:32",
              "Destination base address (byte address) only usable in hardware trigger mode by enable gcsw",
              32, old_value_t.dstba_b, new_value_t.dstba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2DSTBA_C_OFFSET 0xA02D
#define G2SB_CTX7_G2DSTBA_C_UNDEFMASK 0x00000000
union g2sb_ctx7_g2dstba_c_u {
    struct {
        unsigned int dstba_c:32;            /* Destination base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2dstba_c_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2dstba_c_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2dstba_c_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstba_c:32",
              "Destination base address (byte address)",
              32, old_value_t.dstba_c, new_value_t.dstba_c };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2DSTST_OFFSET 0xA02E
#define G2SB_CTX7_G2DSTST_UNDEFMASK 0xFFFF0000
union g2sb_ctx7_g2dstst_u {
    struct {
        unsigned int dsts:16;               /* Destination Stride coordinate(bytes) with respect to DSTBA. */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2dstst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2dstst_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2dstst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dsts:16",
              "Destination Stride coordinate(bytes) with respect to DSTBA.",
              16, old_value_t.dsts, new_value_t.dsts };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2SRCPACK_OFFSET 0xA02F
#define G2SB_CTX7_G2SRCPACK_UNDEFMASK 0xFFFFFFF0
union g2sb_ctx7_g2srcpack_u {
    struct {
        unsigned int srclngap:4;            /* Packed mode - source mono data line gap */
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2srcpack_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2srcpack_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2srcpack_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srclngap:4",
              "Packed mode - source mono data line gap",
              4, old_value_t.srclngap, new_value_t.srclngap };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2SRCPACK_SIZE_OFFSET 0xA030
#define G2SB_CTX7_G2SRCPACK_SIZE_UNDEFMASK 0x00000000
union g2sb_ctx7_g2srcpack_size_u {
    struct {
        unsigned int srcmonow:16;           /* Packed mode - source mono data width in bytes */
        unsigned int srcmonoh:16;           /* Packed mode - source mono data height in bytes  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2srcpack_size_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2srcpack_size_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2srcpack_size_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcmonow:16",
              "Packed mode - source mono data width in bytes",
              16, old_value_t.srcmonow, new_value_t.srcmonow };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcmonoh:16",
              "Packed mode - source mono data height in bytes",
              16, old_value_t.srcmonoh, new_value_t.srcmonoh };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2SRCBA_OFFSET 0xA031
#define G2SB_CTX7_G2SRCBA_UNDEFMASK 0x00000000
union g2sb_ctx7_g2srcba_u {
    struct {
        unsigned int srcba:32;              /* Source base address (byte address)  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2srcba_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2srcba_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2srcba_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba:32",
              "Source base address (byte address)",
              32, old_value_t.srcba, new_value_t.srcba };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2SRCBA_B_OFFSET 0xA032
#define G2SB_CTX7_G2SRCBA_B_UNDEFMASK 0x00000000
union g2sb_ctx7_g2srcba_b_u {
    struct {
        unsigned int srcba_b:32;            /* This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.) */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2srcba_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2srcba_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2srcba_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcba_b:32",
              "This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.)",
              32, old_value_t.srcba_b, new_value_t.srcba_b };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2SRCST_OFFSET 0xA033
#define G2SB_CTX7_G2SRCST_UNDEFMASK 0xFFFF0000
union g2sb_ctx7_g2srcst_u {
    struct {
        unsigned int srcs:16;               /* Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.  */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2srcst_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2srcst_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2srcst_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs:16",
              "Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.",
              16, old_value_t.srcs, new_value_t.srcs };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2SRCBGC_OFFSET 0xA034
#define G2SB_CTX7_G2SRCBGC_UNDEFMASK 0x00000000
union g2sb_ctx7_g2srcbgc_u {
    struct {
        unsigned int srcbgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2srcbgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2srcbgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2srcbgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcbgc:32", "", 32, old_value_t.srcbgc, new_value_t.srcbgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2SRCFGC_OFFSET 0xA035
#define G2SB_CTX7_G2SRCFGC_UNDEFMASK 0x00000000
union g2sb_ctx7_g2srcfgc_u {
    struct {
        unsigned int srcfgc:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2srcfgc_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2srcfgc_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2srcfgc_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcfgc:32", "", 32, old_value_t.srcfgc, new_value_t.srcfgc };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2SRCKEY_OFFSET 0xA036
#define G2SB_CTX7_G2SRCKEY_UNDEFMASK 0x00000000
union g2sb_ctx7_g2srckey_u {
    struct {
        unsigned int srckey:32;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2srckey_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2srckey_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2srckey_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srckey:32", "", 32, old_value_t.srckey, new_value_t.srckey };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2SRCSIZE_OFFSET 0xA037
#define G2SB_CTX7_G2SRCSIZE_UNDEFMASK 0x80008000
union g2sb_ctx7_g2srcsize_u {
    struct {
        unsigned int srcwidth:15;
        unsigned int undefined_bit_15:1;
        unsigned int srcheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2srcsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2srcsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2srcsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcwidth:15", "", 15, old_value_t.srcwidth, new_value_t.srcwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.srcheight, new_value_t.srcheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2DSTSIZE_OFFSET 0xA038
#define G2SB_CTX7_G2DSTSIZE_UNDEFMASK 0x80008000
union g2sb_ctx7_g2dstsize_u {
    struct {
        unsigned int dstwidth:15;           /* In 2D mode, the largest number can be programmed is 0x7fef */
        unsigned int undefined_bit_15:1;
        unsigned int dstheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2dstsize_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2dstsize_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2dstsize_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstwidth:15",
              "In 2D mode, the largest number can be programmed is 0x7fef",
              15, old_value_t.dstwidth, new_value_t.dstwidth };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bit_15:1", "", 1, old_value_t.undefined_bit_15, new_value_t.undefined_bit_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dstheight:15",
              "In SB mode, number of lines - 1 In 2D mode, actual lines",
              15, old_value_t.dstheight, new_value_t.dstheight };
    m_bit_details_model.bits.append(entry);
    entry = { "31: undefined_bit_31:1", "", 1, old_value_t.undefined_bit_31, new_value_t.undefined_bit_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2SRCPS_OFFSET 0xA039
#define G2SB_CTX7_G2SRCPS_UNDEFMASK 0x00000000
union g2sb_ctx7_g2srcps_u {
    struct {
        unsigned int srcx:16;               /* SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY   */
        unsigned int srcy:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2srcps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2srcps_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2srcps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcx:16",
              "SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY",
              16, old_value_t.srcx, new_value_t.srcx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: srcy:16", "", 16, old_value_t.srcy, new_value_t.srcy };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2DSTPS_OFFSET 0xA03A
#define G2SB_CTX7_G2DSTPS_UNDEFMASK 0x00000000
union g2sb_ctx7_g2dstps_u {
    struct {
        unsigned int dstx:16;               /* NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 */
        unsigned int dsty:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2dstps_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2dstps_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2dstps_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dstx:16",
              "NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489",
              16, old_value_t.dstx, new_value_t.dstx };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dsty:16", "", 16, old_value_t.dsty, new_value_t.dsty };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CBDES_OFFSET 0xA03B
#define G2SB_CTX7_G2CBDES_UNDEFMASK 0x0000FF00
union g2sb_ctx7_g2cbdes_u {
    struct {
        unsigned int cbcount:8;             /* This specifies the number of buffers incircular buffer feature                    */
        unsigned int undefined_bits_8_15:8;
        unsigned int cbline:15;             /* vertical line number in one buffer */
        unsigned int topclip:1;             /* top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2 0= disable  */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2cbdes_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2cbdes_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2cbdes_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbcount:8",
              "This specifies the number of buffers incircular buffer feature",
              8, old_value_t.cbcount, new_value_t.cbcount };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_15:8", "", 8, old_value_t.undefined_bits_8_15, new_value_t.undefined_bits_8_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: cbline:15",
              "vertical line number in one buffer",
              15, old_value_t.cbline, new_value_t.cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "31: topclip:1",
              "top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2\n0= disable",
              1, old_value_t.topclip, new_value_t.topclip };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CBSTRIDE_OFFSET 0xA03C
#define G2SB_CTX7_G2CBSTRIDE_UNDEFMASK 0x3F000000
union g2sb_ctx7_g2cbstride_u {
    struct {
        unsigned int cbstride:24;           /* Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes) */
        unsigned int undefined_bits_24_29:6;
        unsigned int cbuvstride:2;          /* Chroma Buffer Stride default is half of luma   00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2cbstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2cbstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2cbstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: cbstride:24",
              "Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes)",
              24, old_value_t.cbstride, new_value_t.cbstride };
    m_bit_details_model.bits.append(entry);
    entry = { "24: undefined_bits_24_29:6", "", 6, old_value_t.undefined_bits_24_29, new_value_t.undefined_bits_24_29 };
    m_bit_details_model.bits.append(entry);
    entry = { "30: cbuvstride:2",
              "Chroma Buffer Stride default is half of luma  \n00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.\n01= Equal to Luma Buffer Stride  \n10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved",
              2, old_value_t.cbuvstride, new_value_t.cbuvstride };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2LINESETTING_OFFSET 0xA03D
#define G2SB_CTX7_G2LINESETTING_UNDEFMASK 0x00E00000
union g2sb_ctx7_g2linesetting_u {
    struct {
        unsigned int gamma:21;
        unsigned int undefined_bits_21_23:3;
        unsigned int major:1;               /* 0:xmajor 1: y major */
        unsigned int linexdir:1;
        unsigned int lineydir:1;
        unsigned int droplastp:1;           /* draw last pixel or not */
        unsigned int lineuseoctant:1;       /* use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR */
        unsigned int octants:3;             /* 000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7 */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2linesetting_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2linesetting_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2linesetting_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: gamma:21", "", 21, old_value_t.gamma, new_value_t.gamma };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_23:3", "", 3, old_value_t.undefined_bits_21_23, new_value_t.undefined_bits_21_23 };
    m_bit_details_model.bits.append(entry);
    entry = { "24: major:1",
              "0:xmajor 1: y major",
              1, old_value_t.major, new_value_t.major };
    m_bit_details_model.bits.append(entry);
    entry = { "25: linexdir:1", "", 1, old_value_t.linexdir, new_value_t.linexdir };
    m_bit_details_model.bits.append(entry);
    entry = { "26: lineydir:1", "", 1, old_value_t.lineydir, new_value_t.lineydir };
    m_bit_details_model.bits.append(entry);
    entry = { "27: droplastp:1",
              "draw last pixel or not",
              1, old_value_t.droplastp, new_value_t.droplastp };
    m_bit_details_model.bits.append(entry);
    entry = { "28: lineuseoctant:1",
              "use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR",
              1, old_value_t.lineuseoctant, new_value_t.lineuseoctant };
    m_bit_details_model.bits.append(entry);
    entry = { "29: octants:3",
              "000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7",
              3, old_value_t.octants, new_value_t.octants };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2LINEDELTAN_OFFSET 0xA03E
#define G2SB_CTX7_G2LINEDELTAN_UNDEFMASK 0xFFE00000
union g2sb_ctx7_g2linedeltan_u {
    struct {
        unsigned int deltan:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2linedeltan_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2linedeltan_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2linedeltan_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltan:21", "", 21, old_value_t.deltan, new_value_t.deltan };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2LINEDELTAM_OFFSET 0xA03F
#define G2SB_CTX7_G2LINEDELTAM_UNDEFMASK 0xFFE00000
union g2sb_ctx7_g2linedeltam_u {
    struct {
        unsigned int deltam:21;
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2linedeltam_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2linedeltam_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2linedeltam_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: deltam:21", "", 21, old_value_t.deltam, new_value_t.deltam };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2LINEPOS_OFFSET 0xA040
#define G2SB_CTX7_G2LINEPOS_UNDEFMASK 0x00000000
union g2sb_ctx7_g2linepos_u {
    struct {
        unsigned int linexpos:16;
        unsigned int lineypos:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2linepos_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2linepos_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2linepos_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linexpos:16", "", 16, old_value_t.linexpos, new_value_t.linexpos };
    m_bit_details_model.bits.append(entry);
    entry = { "16: lineypos:16", "", 16, old_value_t.lineypos, new_value_t.lineypos };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2LINELEN_OFFSET 0xA041
#define G2SB_CTX7_G2LINELEN_UNDEFMASK 0xFFFF8000
union g2sb_ctx7_g2linelen_u {
    struct {
        unsigned int linelen:15;
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2linelen_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2linelen_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2linelen_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: linelen:15", "", 15, old_value_t.linelen, new_value_t.linelen };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CSCFOURTH_OFFSET 0xA042
#define G2SB_CTX7_G2CSCFOURTH_UNDEFMASK 0xFE00FE00
union g2sb_ctx7_g2cscfourth_u {
    struct {
        unsigned int g2u:9;                 /* multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored */
        unsigned int undefined_bits_9_15:7;
        unsigned int g2v:9;                 /* multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored */
        unsigned int undefined_bits_25_31:7;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2cscfourth_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2cscfourth_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2cscfourth_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: g2u:9",
              "multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored",
              9, old_value_t.g2u, new_value_t.g2u };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_15:7", "", 7, old_value_t.undefined_bits_9_15, new_value_t.undefined_bits_9_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: g2v:9",
              "multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored",
              9, old_value_t.g2v, new_value_t.g2v };
    m_bit_details_model.bits.append(entry);
    entry = { "25: undefined_bits_25_31:7", "", 7, old_value_t.undefined_bits_25_31, new_value_t.undefined_bits_25_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2SRCST_B_OFFSET 0xA043
#define G2SB_CTX7_G2SRCST_B_UNDEFMASK 0xFFFF0000
union g2sb_ctx7_g2srcst_b_u {
    struct {
        unsigned int srcs_b:16;             /* Source Stride B */
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2srcst_b_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2srcst_b_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2srcst_b_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: srcs_b:16",
              "Source Stride B",
              16, old_value_t.srcs_b, new_value_t.srcs_b };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2UVSTRIDE_OFFSET 0xA044
#define G2SB_CTX7_G2UVSTRIDE_UNDEFMASK 0xFFFF0000
union g2sb_ctx7_g2uvstride_u {
    struct {
        unsigned int uvstride:16;
        unsigned int undefined_bits_16_31:16;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2uvstride_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2uvstride_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2uvstride_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: uvstride:16", "", 16, old_value_t.uvstride, new_value_t.uvstride };
    m_bit_details_model.bits.append(entry);
    entry = { "16: undefined_bits_16_31:16", "", 16, old_value_t.undefined_bits_16_31, new_value_t.undefined_bits_16_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2CBDES2_OFFSET 0xA045
#define G2SB_CTX7_G2CBDES2_UNDEFMASK 0xFFFF8000
union g2sb_ctx7_g2cbdes2_u {
    struct {
        unsigned int top_cbline:15;         /* Circular buffer top clipping enabled, the first buffer line num */
        unsigned int undefined_bits_15_31:17;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2cbdes2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2cbdes2_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2cbdes2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: top_cbline:15",
              "Circular buffer top clipping enabled, the first buffer line num",
              15, old_value_t.top_cbline, new_value_t.top_cbline };
    m_bit_details_model.bits.append(entry);
    entry = { "15: undefined_bits_15_31:17", "", 17, old_value_t.undefined_bits_15_31, new_value_t.undefined_bits_15_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2TILEMODE_OFFSET 0xA046
#define G2SB_CTX7_G2TILEMODE_UNDEFMASK 0xFFEEEEEE
union g2sb_ctx7_g2tilemode_u {
    struct {
        unsigned int src_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_1_3:3;
        unsigned int src_uv_tile_mode:1;    /* UV surface, ignored in RGB mode */
        unsigned int undefined_bits_5_7:3;
        unsigned int pat_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_9_11:3;
        unsigned int pat_uv_tile_mode:1;    /* UNUSED */
        unsigned int undefined_bits_13_15:3;
        unsigned int dst_rd_tile_mode:1;    /* Same as destination write unless DST_RD_WR_SEP (not supported) */
        unsigned int undefined_bits_17_19:3;
        unsigned int dst_wr_tile_mode:1;    /* destination surface */
        unsigned int undefined_bits_21_31:11;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2tilemode_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2tilemode_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2tilemode_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.src_y_tile_mode, new_value_t.src_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "01: undefined_bits_1_3:3", "", 3, old_value_t.undefined_bits_1_3, new_value_t.undefined_bits_1_3 };
    m_bit_details_model.bits.append(entry);
    entry = { "04: src_uv_tile_mode:1",
              "UV surface, ignored in RGB mode",
              1, old_value_t.src_uv_tile_mode, new_value_t.src_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "05: undefined_bits_5_7:3", "", 3, old_value_t.undefined_bits_5_7, new_value_t.undefined_bits_5_7 };
    m_bit_details_model.bits.append(entry);
    entry = { "08: pat_y_tile_mode:1",
              "Y or RGB surface",
              1, old_value_t.pat_y_tile_mode, new_value_t.pat_y_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "09: undefined_bits_9_11:3", "", 3, old_value_t.undefined_bits_9_11, new_value_t.undefined_bits_9_11 };
    m_bit_details_model.bits.append(entry);
    entry = { "12: pat_uv_tile_mode:1",
              "UNUSED",
              1, old_value_t.pat_uv_tile_mode, new_value_t.pat_uv_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "13: undefined_bits_13_15:3", "", 3, old_value_t.undefined_bits_13_15, new_value_t.undefined_bits_13_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: dst_rd_tile_mode:1",
              "Same as destination write unless DST_RD_WR_SEP (not supported)",
              1, old_value_t.dst_rd_tile_mode, new_value_t.dst_rd_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "17: undefined_bits_17_19:3", "", 3, old_value_t.undefined_bits_17_19, new_value_t.undefined_bits_17_19 };
    m_bit_details_model.bits.append(entry);
    entry = { "20: dst_wr_tile_mode:1",
              "destination surface",
              1, old_value_t.dst_wr_tile_mode, new_value_t.dst_wr_tile_mode };
    m_bit_details_model.bits.append(entry);
    entry = { "21: undefined_bits_21_31:11", "", 11, old_value_t.undefined_bits_21_31, new_value_t.undefined_bits_21_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2PATBASE_OFFSET 0xA047
#define G2SB_CTX7_G2PATBASE_UNDEFMASK 0x00000000
union g2sb_ctx7_g2patbase_u {
    struct {
        unsigned int pat_base:32;           /* pattern base address in tile mode,  PATBA is the linear address where pixel start */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2patbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2patbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2patbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: pat_base:32",
              "pattern base address in tile mode,  PATBA is the linear address where pixel start",
              32, old_value_t.pat_base, new_value_t.pat_base };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2SRCBA_SB_SURFBASE_OFFSET 0xA048
#define G2SB_CTX7_G2SRCBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx7_g2srcba_sb_surfbase_u {
    struct {
        unsigned int src_addr:32;           /* surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2srcba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2srcba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2srcba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: src_addr:32",
              "surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine",
              32, old_value_t.src_addr, new_value_t.src_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2DSTBA_SB_SURFBASE_OFFSET 0xA049
#define G2SB_CTX7_G2DSTBA_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx7_g2dstba_sb_surfbase_u {
    struct {
        unsigned int dst_addr:32;           /* surface address corresponding to G2DSTBA Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2dstba_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2dstba_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2dstba_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_addr:32",
              "surface address corresponding to G2DSTBA Only used by the StretchBlit Engine",
              32, old_value_t.dst_addr, new_value_t.dst_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2DSTBA_B_SB_SURFBASE_OFFSET 0xA04A
#define G2SB_CTX7_G2DSTBA_B_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx7_g2dstba_b_sb_surfbase_u {
    struct {
        unsigned int dst_b_addr:32;         /* surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2dstba_b_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2dstba_b_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2dstba_b_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_b_addr:32",
              "surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled",
              32, old_value_t.dst_b_addr, new_value_t.dst_b_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2VBA_A_SB_SURFBASE_OFFSET 0xA04B
#define G2SB_CTX7_G2VBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx7_g2vba_a_sb_surfbase_u {
    struct {
        unsigned int v_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2vba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2vba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2vba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: v_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine",
              32, old_value_t.v_addr, new_value_t.v_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_CTX7_G2UBA_A_SB_SURFBASE_OFFSET 0xA04C
#define G2SB_CTX7_G2UBA_A_SB_SURFBASE_UNDEFMASK 0x00000000
union g2sb_ctx7_g2uba_a_sb_surfbase_u {
    struct {
        unsigned int u_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine */
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_ctx7_g2uba_a_sb_surfbase_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_ctx7_g2uba_a_sb_surfbase_u old_value_t = { .reg32 = value };
    const g2sb_ctx7_g2uba_a_sb_surfbase_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: u_addr:32",
              "surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine",
              32, old_value_t.u_addr, new_value_t.u_addr };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_SWITCH_G2INTERRUPT_OFFSET 0xF000
#define G2SB_SWITCH_G2INTERRUPT_UNDEFMASK 0xFFFFFFF8
union g2sb_switch_g2interrupt_u {
    struct {
        unsigned int ctxsw_int:1;
        unsigned int vi_done:1;
        unsigned int gr2d_idle:1;
        unsigned int undefined_bits_3_31:29;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_switch_g2interrupt_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_switch_g2interrupt_u old_value_t = { .reg32 = value };
    const g2sb_switch_g2interrupt_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ctxsw_int:1", "", 1, old_value_t.ctxsw_int, new_value_t.ctxsw_int };
    m_bit_details_model.bits.append(entry);
    entry = { "01: vi_done:1", "", 1, old_value_t.vi_done, new_value_t.vi_done };
    m_bit_details_model.bits.append(entry);
    entry = { "02: gr2d_idle:1", "", 1, old_value_t.gr2d_idle, new_value_t.gr2d_idle };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_31:29", "", 29, old_value_t.undefined_bits_3_31, new_value_t.undefined_bits_3_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_SWITCH_G2INTENABLE_OFFSET 0xF001
#define G2SB_SWITCH_G2INTENABLE_UNDEFMASK 0xFFFFFFF8
union g2sb_switch_g2intenable_u {
    struct {
        unsigned int ctxsw_int_enable:1;
        unsigned int vi_done_enable:1;
        unsigned int gr2d_idle_enable:1;
        unsigned int undefined_bits_3_31:29;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_switch_g2intenable_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_switch_g2intenable_u old_value_t = { .reg32 = value };
    const g2sb_switch_g2intenable_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: ctxsw_int_enable:1", "", 1, old_value_t.ctxsw_int_enable, new_value_t.ctxsw_int_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "01: vi_done_enable:1", "", 1, old_value_t.vi_done_enable, new_value_t.vi_done_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "02: gr2d_idle_enable:1", "", 1, old_value_t.gr2d_idle_enable, new_value_t.gr2d_idle_enable };
    m_bit_details_model.bits.append(entry);
    entry = { "03: undefined_bits_3_31:29", "", 29, old_value_t.undefined_bits_3_31, new_value_t.undefined_bits_3_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_SWITCH_G2CURRENTCONTEXT_OFFSET 0xF002
#define G2SB_SWITCH_G2CURRENTCONTEXT_UNDEFMASK 0xFFFFFF00
union g2sb_switch_g2currentcontext_u {
    struct {
        unsigned int curr_context:8;
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_switch_g2currentcontext_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_switch_g2currentcontext_u old_value_t = { .reg32 = value };
    const g2sb_switch_g2currentcontext_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: curr_context:8", "", 8, old_value_t.curr_context, new_value_t.curr_context };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_SWITCH_G2NXTCXTSWITCH_OFFSET 0xF003
#define G2SB_SWITCH_G2NXTCXTSWITCH_UNDEFMASK 0xFFF0FC00
union g2sb_switch_g2nxtcxtswitch_u {
    struct {
        unsigned int next_class:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int next_channel:4;
        unsigned int undefined_bits_20_31:12;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_switch_g2nxtcxtswitch_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_switch_g2nxtcxtswitch_u old_value_t = { .reg32 = value };
    const g2sb_switch_g2nxtcxtswitch_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: next_class:10", "", 10, old_value_t.next_class, new_value_t.next_class };
    m_bit_details_model.bits.append(entry);
    entry = { "10: undefined_bits_10_15:6", "", 6, old_value_t.undefined_bits_10_15, new_value_t.undefined_bits_10_15 };
    m_bit_details_model.bits.append(entry);
    entry = { "16: next_channel:4", "", 4, old_value_t.next_channel, new_value_t.next_channel };
    m_bit_details_model.bits.append(entry);
    entry = { "20: undefined_bits_20_31:12", "", 12, old_value_t.undefined_bits_20_31, new_value_t.undefined_bits_20_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_SWITCH_G2GLOBALCONTROL_OFFSET 0xF004
#define G2SB_SWITCH_G2GLOBALCONTROL_UNDEFMASK 0xFFFFFFFC
union g2sb_switch_g2globalcontrol_u {
    struct {
        unsigned int dst_addr_idx_ini:2;    /* 31:8 rw CLOCKFREEON init = 0 */
        unsigned int undefined_bits_2_31:30;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_switch_g2globalcontrol_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_switch_g2globalcontrol_u old_value_t = { .reg32 = value };
    const g2sb_switch_g2globalcontrol_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: dst_addr_idx_ini:2",
              "31:8 rw CLOCKFREEON init = 0",
              2, old_value_t.dst_addr_idx_ini, new_value_t.dst_addr_idx_ini };
    m_bit_details_model.bits.append(entry);
    entry = { "02: undefined_bits_2_31:30", "", 30, old_value_t.undefined_bits_2_31, new_value_t.undefined_bits_2_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_SWITCH_G2GLOBALCONTROLB_OFFSET 0xF005
#define G2SB_SWITCH_G2GLOBALCONTROLB_UNDEFMASK 0xFFFFFF00
union g2sb_switch_g2globalcontrolb_u {
    struct {
        unsigned int octan_bias:8;
        unsigned int undefined_bits_8_31:24;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_switch_g2globalcontrolb_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_switch_g2globalcontrolb_u old_value_t = { .reg32 = value };
    const g2sb_switch_g2globalcontrolb_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: octan_bias:8", "", 8, old_value_t.octan_bias, new_value_t.octan_bias };
    m_bit_details_model.bits.append(entry);
    entry = { "08: undefined_bits_8_31:24", "", 24, old_value_t.undefined_bits_8_31, new_value_t.undefined_bits_8_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_SWITCH_G2WORKINGSTAT_OFFSET 0xF006
#define G2SB_SWITCH_G2WORKINGSTAT_UNDEFMASK 0xFFFFF000
union g2sb_switch_g2workingstat_u {
    struct {
        unsigned int working_channel:4;
        unsigned int working_ctx:8;
        unsigned int undefined_bits_12_31:20;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_switch_g2workingstat_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_switch_g2workingstat_u old_value_t = { .reg32 = value };
    const g2sb_switch_g2workingstat_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: working_channel:4", "", 4, old_value_t.working_channel, new_value_t.working_channel };
    m_bit_details_model.bits.append(entry);
    entry = { "04: working_ctx:8", "", 8, old_value_t.working_ctx, new_value_t.working_ctx };
    m_bit_details_model.bits.append(entry);
    entry = { "12: undefined_bits_12_31:20", "", 20, old_value_t.undefined_bits_12_31, new_value_t.undefined_bits_12_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_SWITCH_G2BUFTHRESHOLD_OFFSET 0xF007
#define G2SB_SWITCH_G2BUFTHRESHOLD_UNDEFMASK 0xFFFFFFF0
union g2sb_switch_g2bufthreshold_u {
    struct {
        unsigned int buffer_count_threshold:4;
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_switch_g2bufthreshold_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_switch_g2bufthreshold_u old_value_t = { .reg32 = value };
    const g2sb_switch_g2bufthreshold_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: buffer_count_threshold:4", "", 4, old_value_t.buffer_count_threshold, new_value_t.buffer_count_threshold };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_SWITCH_CLKEN_OVERIDE_OFFSET 0xF008
#define G2SB_SWITCH_CLKEN_OVERIDE_UNDEFMASK 0xFF800000
union g2sb_switch_clken_overide_u {
    struct {
        unsigned int context0_clken_ovr:1;
        unsigned int context1_clken_ovr:1;
        unsigned int context2_clken_ovr:1;
        unsigned int context3_clken_ovr:1;
        unsigned int context4_clken_ovr:1;
        unsigned int context5_clken_ovr:1;
        unsigned int context6_clken_ovr:1;
        unsigned int context7_clken_ovr:1;
        unsigned int con_clken_ovr:1;
        unsigned int dstw_clken_ovr:1;      /* It forces ccw_g2dw2mc_clk on too */
        unsigned int bblt_clken_ovr:1;
        unsigned int src_clken_ovr:1;
        unsigned int srcr_clken_ovr:1;      /* It forces cbr_g2sr2mc_clk on too */
        unsigned int patr_clken_ovr:1;      /* It forces cbr_g2pr2mc_clk on too */
        unsigned int dstr_clken_ovr:1;
        unsigned int fr_clken_ovr:1;
        unsigned int line_clken_ovr:1;
        unsigned int liner_clken_ovr:1;
        unsigned int vcaa_clken_ovr:1;
        unsigned int g2sr2mc_clken_ovr:1;
        unsigned int g2dr2mc_clken_ovr:1;
        unsigned int g2pr2mc_clken_ovr:1;
        unsigned int sb_clken_ovr:1;
        unsigned int undefined_bits_23_31:9;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_switch_clken_overide_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_switch_clken_overide_u old_value_t = { .reg32 = value };
    const g2sb_switch_clken_overide_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: context0_clken_ovr:1", "", 1, old_value_t.context0_clken_ovr, new_value_t.context0_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "01: context1_clken_ovr:1", "", 1, old_value_t.context1_clken_ovr, new_value_t.context1_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "02: context2_clken_ovr:1", "", 1, old_value_t.context2_clken_ovr, new_value_t.context2_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "03: context3_clken_ovr:1", "", 1, old_value_t.context3_clken_ovr, new_value_t.context3_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "04: context4_clken_ovr:1", "", 1, old_value_t.context4_clken_ovr, new_value_t.context4_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "05: context5_clken_ovr:1", "", 1, old_value_t.context5_clken_ovr, new_value_t.context5_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "06: context6_clken_ovr:1", "", 1, old_value_t.context6_clken_ovr, new_value_t.context6_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "07: context7_clken_ovr:1", "", 1, old_value_t.context7_clken_ovr, new_value_t.context7_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "08: con_clken_ovr:1", "", 1, old_value_t.con_clken_ovr, new_value_t.con_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "09: dstw_clken_ovr:1",
              "It forces ccw_g2dw2mc_clk on too",
              1, old_value_t.dstw_clken_ovr, new_value_t.dstw_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "10: bblt_clken_ovr:1", "", 1, old_value_t.bblt_clken_ovr, new_value_t.bblt_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "11: src_clken_ovr:1", "", 1, old_value_t.src_clken_ovr, new_value_t.src_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "12: srcr_clken_ovr:1",
              "It forces cbr_g2sr2mc_clk on too",
              1, old_value_t.srcr_clken_ovr, new_value_t.srcr_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "13: patr_clken_ovr:1",
              "It forces cbr_g2pr2mc_clk on too",
              1, old_value_t.patr_clken_ovr, new_value_t.patr_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "14: dstr_clken_ovr:1", "", 1, old_value_t.dstr_clken_ovr, new_value_t.dstr_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "15: fr_clken_ovr:1", "", 1, old_value_t.fr_clken_ovr, new_value_t.fr_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "16: line_clken_ovr:1", "", 1, old_value_t.line_clken_ovr, new_value_t.line_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "17: liner_clken_ovr:1", "", 1, old_value_t.liner_clken_ovr, new_value_t.liner_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "18: vcaa_clken_ovr:1", "", 1, old_value_t.vcaa_clken_ovr, new_value_t.vcaa_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "19: g2sr2mc_clken_ovr:1", "", 1, old_value_t.g2sr2mc_clken_ovr, new_value_t.g2sr2mc_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "20: g2dr2mc_clken_ovr:1", "", 1, old_value_t.g2dr2mc_clken_ovr, new_value_t.g2dr2mc_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "21: g2pr2mc_clken_ovr:1", "", 1, old_value_t.g2pr2mc_clken_ovr, new_value_t.g2pr2mc_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "22: sb_clken_ovr:1", "", 1, old_value_t.sb_clken_ovr, new_value_t.sb_clken_ovr };
    m_bit_details_model.bits.append(entry);
    entry = { "23: undefined_bits_23_31:9", "", 9, old_value_t.undefined_bits_23_31, new_value_t.undefined_bits_23_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_SWITCH_G2_MCCIF_FIFOCTRL_OFFSET 0xF009
#define G2SB_SWITCH_G2_MCCIF_FIFOCTRL_UNDEFMASK 0xFFFFFFF0
union g2sb_switch_g2_mccif_fifoctrl_u {
    struct {
        unsigned int g2_mccif_wrcl_mcle2x:1;
        unsigned int g2_mccif_rdmc_rdfast:1;
        unsigned int g2_mccif_wrmc_clle2x:1;
        unsigned int g2_mccif_rdcl_rdfast:1;
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_switch_g2_mccif_fifoctrl_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_switch_g2_mccif_fifoctrl_u old_value_t = { .reg32 = value };
    const g2sb_switch_g2_mccif_fifoctrl_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: g2_mccif_wrcl_mcle2x:1", "", 1, old_value_t.g2_mccif_wrcl_mcle2x, new_value_t.g2_mccif_wrcl_mcle2x };
    m_bit_details_model.bits.append(entry);
    entry = { "01: g2_mccif_rdmc_rdfast:1", "", 1, old_value_t.g2_mccif_rdmc_rdfast, new_value_t.g2_mccif_rdmc_rdfast };
    m_bit_details_model.bits.append(entry);
    entry = { "02: g2_mccif_wrmc_clle2x:1", "", 1, old_value_t.g2_mccif_wrmc_clle2x, new_value_t.g2_mccif_wrmc_clle2x };
    m_bit_details_model.bits.append(entry);
    entry = { "03: g2_mccif_rdcl_rdfast:1", "", 1, old_value_t.g2_mccif_rdcl_rdfast, new_value_t.g2_mccif_rdcl_rdfast };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}

#define G2SB_SWITCH_TIMEOUT_WCOAL_G2_OFFSET 0xF00A
#define G2SB_SWITCH_TIMEOUT_WCOAL_G2_UNDEFMASK 0xFFFFFFF0
union g2sb_switch_timeout_wcoal_g2_u {
    struct {
        unsigned int g2dw_wcoal_tmval:4;
        unsigned int undefined_bits_4_31:28;
    };

    u_int32_t reg32;
};

void Gr2dDev::fill_g2sb_switch_timeout_wcoal_g2_details(const u_int32_t &value, const u_int32_t &new_value)
{
    const g2sb_switch_timeout_wcoal_g2_u old_value_t = { .reg32 = value };
    const g2sb_switch_timeout_wcoal_g2_u new_value_t = { .reg32 = new_value };
    BitDetails::bit_entry entry;

    m_bit_details_model.has_changed_bits = (value != new_value);

    entry = { "00: g2dw_wcoal_tmval:4", "", 4, old_value_t.g2dw_wcoal_tmval, new_value_t.g2dw_wcoal_tmval };
    m_bit_details_model.bits.append(entry);
    entry = { "04: undefined_bits_4_31:28", "", 28, old_value_t.undefined_bits_4_31, new_value_t.undefined_bits_4_31 };
    m_bit_details_model.bits.append(entry);
}



bool Gr2dDev::is_offset_valid(const u_int32_t &offset) const
{
    switch (offset) {
    case G2SB_INCR_SYNCPT_OFFSET:
    case G2SB_INCR_SYNCPT_CNTRL_OFFSET:
    case G2SB_INCR_SYNCPT_ERROR_OFFSET:
    case G2SB_G2CLASSCHANNEL_REGONLY_OFFSET:
    case G2SB_G2TRIGGER_OFFSET:
    case G2SB_G2TRIGGER1_OFFSET:
    case G2SB_G2TRIGGER2_OFFSET:
    case G2SB_G2CMDSEL_OFFSET:
    case G2SB_G2RAISE_OFFSET:
    case G2SB_G2HOSTSET_OFFSET:
    case G2SB_G2HOSTFIFO_OFFSET:
    case G2SB_G2VDDA_OFFSET:
    case G2SB_G2VDDAINI_OFFSET:
    case G2SB_G2HDDA_OFFSET:
    case G2SB_G2HDDAINILS_OFFSET:
    case G2SB_G2CSCFIRST_OFFSET:
    case G2SB_G2CSCSECOND_OFFSET:
    case G2SB_G2CSCTHIRD_OFFSET:
    case G2SB_G2CMKEYL_OFFSET:
    case G2SB_G2CMKEYU_OFFSET:
    case G2SB_G2UBA_A_OFFSET:
    case G2SB_G2VBA_A_OFFSET:
    case G2SB_G2SBFORMAT_OFFSET:
    case G2SB_G2CONTROLSB_OFFSET:
    case G2SB_G2CONTROLSECOND_OFFSET:
    case G2SB_G2CONTROLMAIN_OFFSET:
    case G2SB_G2ROPFADE_OFFSET:
    case G2SB_G2ALPHABLEND_OFFSET:
    case G2SB_G2CLIPLEFTTOP_OFFSET:
    case G2SB_G2CLIPRIGHTBOT_OFFSET:
    case G2SB_G2PATPACK_OFFSET:
    case G2SB_G2PATPACK_SIZE_OFFSET:
    case G2SB_G2PATBA_OFFSET:
    case G2SB_G2PATOS_OFFSET:
    case G2SB_G2PATBGC_OFFSET:
    case G2SB_G2PATFGC_OFFSET:
    case G2SB_G2PATKEY_OFFSET:
    case G2SB_G2DSTBA_OFFSET:
    case G2SB_G2DSTBA_B_OFFSET:
    case G2SB_G2DSTBA_C_OFFSET:
    case G2SB_G2DSTST_OFFSET:
    case G2SB_G2SRCPACK_OFFSET:
    case G2SB_G2SRCPACK_SIZE_OFFSET:
    case G2SB_G2SRCBA_OFFSET:
    case G2SB_G2SRCBA_B_OFFSET:
    case G2SB_G2SRCST_OFFSET:
    case G2SB_G2SRCBGC_OFFSET:
    case G2SB_G2SRCFGC_OFFSET:
    case G2SB_G2SRCKEY_OFFSET:
    case G2SB_G2SRCSIZE_OFFSET:
    case G2SB_G2DSTSIZE_OFFSET:
    case G2SB_G2SRCPS_OFFSET:
    case G2SB_G2DSTPS_OFFSET:
    case G2SB_G2CBDES_OFFSET:
    case G2SB_G2CBSTRIDE_OFFSET:
    case G2SB_G2LINESETTING_OFFSET:
    case G2SB_G2LINEDELTAN_OFFSET:
    case G2SB_G2LINEDELTAM_OFFSET:
    case G2SB_G2LINEPOS_OFFSET:
    case G2SB_G2LINELEN_OFFSET:
    case G2SB_G2CSCFOURTH_OFFSET:
    case G2SB_G2SRCST_B_OFFSET:
    case G2SB_G2UVSTRIDE_OFFSET:
    case G2SB_G2CBDES2_OFFSET:
    case G2SB_G2TILEMODE_OFFSET:
    case G2SB_G2PATBASE_OFFSET:
    case G2SB_G2SRCBA_SB_SURFBASE_OFFSET:
    case G2SB_G2DSTBA_SB_SURFBASE_OFFSET:
    case G2SB_G2DSTBA_B_SB_SURFBASE_OFFSET:
    case G2SB_G2VBA_A_SB_SURFBASE_OFFSET:
    case G2SB_G2UBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX1_INCR_SYNCPT_OFFSET:
    case G2SB_CTX1_INCR_SYNCPT_CNTRL_OFFSET:
    case G2SB_CTX1_INCR_SYNCPT_ERROR_OFFSET:
    case G2SB_CTX1_G2CLASSCHANNEL_REGONLY_OFFSET:
    case G2SB_CTX1_G2TRIGGER_OFFSET:
    case G2SB_CTX1_G2TRIGGER1_OFFSET:
    case G2SB_CTX1_G2TRIGGER2_OFFSET:
    case G2SB_CTX1_G2CMDSEL_OFFSET:
    case G2SB_CTX1_G2RAISE_OFFSET:
    case G2SB_CTX1_G2HOSTSET_OFFSET:
    case G2SB_CTX1_G2HOSTFIFO_OFFSET:
    case G2SB_CTX1_G2VDDA_OFFSET:
    case G2SB_CTX1_G2VDDAINI_OFFSET:
    case G2SB_CTX1_G2HDDA_OFFSET:
    case G2SB_CTX1_G2HDDAINILS_OFFSET:
    case G2SB_CTX1_G2CSCFIRST_OFFSET:
    case G2SB_CTX1_G2CSCSECOND_OFFSET:
    case G2SB_CTX1_G2CSCTHIRD_OFFSET:
    case G2SB_CTX1_G2CMKEYL_OFFSET:
    case G2SB_CTX1_G2CMKEYU_OFFSET:
    case G2SB_CTX1_G2UBA_A_OFFSET:
    case G2SB_CTX1_G2VBA_A_OFFSET:
    case G2SB_CTX1_G2SBFORMAT_OFFSET:
    case G2SB_CTX1_G2CONTROLSB_OFFSET:
    case G2SB_CTX1_G2CONTROLSECOND_OFFSET:
    case G2SB_CTX1_G2CONTROLMAIN_OFFSET:
    case G2SB_CTX1_G2ROPFADE_OFFSET:
    case G2SB_CTX1_G2ALPHABLEND_OFFSET:
    case G2SB_CTX1_G2CLIPLEFTTOP_OFFSET:
    case G2SB_CTX1_G2CLIPRIGHTBOT_OFFSET:
    case G2SB_CTX1_G2PATPACK_OFFSET:
    case G2SB_CTX1_G2PATPACK_SIZE_OFFSET:
    case G2SB_CTX1_G2PATBA_OFFSET:
    case G2SB_CTX1_G2PATOS_OFFSET:
    case G2SB_CTX1_G2PATBGC_OFFSET:
    case G2SB_CTX1_G2PATFGC_OFFSET:
    case G2SB_CTX1_G2PATKEY_OFFSET:
    case G2SB_CTX1_G2DSTBA_OFFSET:
    case G2SB_CTX1_G2DSTBA_B_OFFSET:
    case G2SB_CTX1_G2DSTBA_C_OFFSET:
    case G2SB_CTX1_G2DSTST_OFFSET:
    case G2SB_CTX1_G2SRCPACK_OFFSET:
    case G2SB_CTX1_G2SRCPACK_SIZE_OFFSET:
    case G2SB_CTX1_G2SRCBA_OFFSET:
    case G2SB_CTX1_G2SRCBA_B_OFFSET:
    case G2SB_CTX1_G2SRCST_OFFSET:
    case G2SB_CTX1_G2SRCBGC_OFFSET:
    case G2SB_CTX1_G2SRCFGC_OFFSET:
    case G2SB_CTX1_G2SRCKEY_OFFSET:
    case G2SB_CTX1_G2SRCSIZE_OFFSET:
    case G2SB_CTX1_G2DSTSIZE_OFFSET:
    case G2SB_CTX1_G2SRCPS_OFFSET:
    case G2SB_CTX1_G2DSTPS_OFFSET:
    case G2SB_CTX1_G2CBDES_OFFSET:
    case G2SB_CTX1_G2CBSTRIDE_OFFSET:
    case G2SB_CTX1_G2LINESETTING_OFFSET:
    case G2SB_CTX1_G2LINEDELTAN_OFFSET:
    case G2SB_CTX1_G2LINEDELTAM_OFFSET:
    case G2SB_CTX1_G2LINEPOS_OFFSET:
    case G2SB_CTX1_G2LINELEN_OFFSET:
    case G2SB_CTX1_G2CSCFOURTH_OFFSET:
    case G2SB_CTX1_G2SRCST_B_OFFSET:
    case G2SB_CTX1_G2UVSTRIDE_OFFSET:
    case G2SB_CTX1_G2CBDES2_OFFSET:
    case G2SB_CTX1_G2TILEMODE_OFFSET:
    case G2SB_CTX1_G2PATBASE_OFFSET:
    case G2SB_CTX1_G2SRCBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX1_G2DSTBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX1_G2DSTBA_B_SB_SURFBASE_OFFSET:
    case G2SB_CTX1_G2VBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX1_G2UBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX2_INCR_SYNCPT_OFFSET:
    case G2SB_CTX2_INCR_SYNCPT_CNTRL_OFFSET:
    case G2SB_CTX2_INCR_SYNCPT_ERROR_OFFSET:
    case G2SB_CTX2_G2CLASSCHANNEL_REGONLY_OFFSET:
    case G2SB_CTX2_G2TRIGGER_OFFSET:
    case G2SB_CTX2_G2TRIGGER1_OFFSET:
    case G2SB_CTX2_G2TRIGGER2_OFFSET:
    case G2SB_CTX2_G2CMDSEL_OFFSET:
    case G2SB_CTX2_G2RAISE_OFFSET:
    case G2SB_CTX2_G2HOSTSET_OFFSET:
    case G2SB_CTX2_G2HOSTFIFO_OFFSET:
    case G2SB_CTX2_G2VDDA_OFFSET:
    case G2SB_CTX2_G2VDDAINI_OFFSET:
    case G2SB_CTX2_G2HDDA_OFFSET:
    case G2SB_CTX2_G2HDDAINILS_OFFSET:
    case G2SB_CTX2_G2CSCFIRST_OFFSET:
    case G2SB_CTX2_G2CSCSECOND_OFFSET:
    case G2SB_CTX2_G2CSCTHIRD_OFFSET:
    case G2SB_CTX2_G2CMKEYL_OFFSET:
    case G2SB_CTX2_G2CMKEYU_OFFSET:
    case G2SB_CTX2_G2UBA_A_OFFSET:
    case G2SB_CTX2_G2VBA_A_OFFSET:
    case G2SB_CTX2_G2SBFORMAT_OFFSET:
    case G2SB_CTX2_G2CONTROLSB_OFFSET:
    case G2SB_CTX2_G2CONTROLSECOND_OFFSET:
    case G2SB_CTX2_G2CONTROLMAIN_OFFSET:
    case G2SB_CTX2_G2ROPFADE_OFFSET:
    case G2SB_CTX2_G2ALPHABLEND_OFFSET:
    case G2SB_CTX2_G2CLIPLEFTTOP_OFFSET:
    case G2SB_CTX2_G2CLIPRIGHTBOT_OFFSET:
    case G2SB_CTX2_G2PATPACK_OFFSET:
    case G2SB_CTX2_G2PATPACK_SIZE_OFFSET:
    case G2SB_CTX2_G2PATBA_OFFSET:
    case G2SB_CTX2_G2PATOS_OFFSET:
    case G2SB_CTX2_G2PATBGC_OFFSET:
    case G2SB_CTX2_G2PATFGC_OFFSET:
    case G2SB_CTX2_G2PATKEY_OFFSET:
    case G2SB_CTX2_G2DSTBA_OFFSET:
    case G2SB_CTX2_G2DSTBA_B_OFFSET:
    case G2SB_CTX2_G2DSTBA_C_OFFSET:
    case G2SB_CTX2_G2DSTST_OFFSET:
    case G2SB_CTX2_G2SRCPACK_OFFSET:
    case G2SB_CTX2_G2SRCPACK_SIZE_OFFSET:
    case G2SB_CTX2_G2SRCBA_OFFSET:
    case G2SB_CTX2_G2SRCBA_B_OFFSET:
    case G2SB_CTX2_G2SRCST_OFFSET:
    case G2SB_CTX2_G2SRCBGC_OFFSET:
    case G2SB_CTX2_G2SRCFGC_OFFSET:
    case G2SB_CTX2_G2SRCKEY_OFFSET:
    case G2SB_CTX2_G2SRCSIZE_OFFSET:
    case G2SB_CTX2_G2DSTSIZE_OFFSET:
    case G2SB_CTX2_G2SRCPS_OFFSET:
    case G2SB_CTX2_G2DSTPS_OFFSET:
    case G2SB_CTX2_G2CBDES_OFFSET:
    case G2SB_CTX2_G2CBSTRIDE_OFFSET:
    case G2SB_CTX2_G2LINESETTING_OFFSET:
    case G2SB_CTX2_G2LINEDELTAN_OFFSET:
    case G2SB_CTX2_G2LINEDELTAM_OFFSET:
    case G2SB_CTX2_G2LINEPOS_OFFSET:
    case G2SB_CTX2_G2LINELEN_OFFSET:
    case G2SB_CTX2_G2CSCFOURTH_OFFSET:
    case G2SB_CTX2_G2SRCST_B_OFFSET:
    case G2SB_CTX2_G2UVSTRIDE_OFFSET:
    case G2SB_CTX2_G2CBDES2_OFFSET:
    case G2SB_CTX2_G2TILEMODE_OFFSET:
    case G2SB_CTX2_G2PATBASE_OFFSET:
    case G2SB_CTX2_G2SRCBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX2_G2DSTBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX2_G2DSTBA_B_SB_SURFBASE_OFFSET:
    case G2SB_CTX2_G2VBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX2_G2UBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX3_INCR_SYNCPT_OFFSET:
    case G2SB_CTX3_INCR_SYNCPT_CNTRL_OFFSET:
    case G2SB_CTX3_INCR_SYNCPT_ERROR_OFFSET:
    case G2SB_CTX3_G2CLASSCHANNEL_REGONLY_OFFSET:
    case G2SB_CTX3_G2TRIGGER_OFFSET:
    case G2SB_CTX3_G2TRIGGER1_OFFSET:
    case G2SB_CTX3_G2TRIGGER2_OFFSET:
    case G2SB_CTX3_G2CMDSEL_OFFSET:
    case G2SB_CTX3_G2RAISE_OFFSET:
    case G2SB_CTX3_G2HOSTSET_OFFSET:
    case G2SB_CTX3_G2HOSTFIFO_OFFSET:
    case G2SB_CTX3_G2VDDA_OFFSET:
    case G2SB_CTX3_G2VDDAINI_OFFSET:
    case G2SB_CTX3_G2HDDA_OFFSET:
    case G2SB_CTX3_G2HDDAINILS_OFFSET:
    case G2SB_CTX3_G2CSCFIRST_OFFSET:
    case G2SB_CTX3_G2CSCSECOND_OFFSET:
    case G2SB_CTX3_G2CSCTHIRD_OFFSET:
    case G2SB_CTX3_G2CMKEYL_OFFSET:
    case G2SB_CTX3_G2CMKEYU_OFFSET:
    case G2SB_CTX3_G2UBA_A_OFFSET:
    case G2SB_CTX3_G2VBA_A_OFFSET:
    case G2SB_CTX3_G2SBFORMAT_OFFSET:
    case G2SB_CTX3_G2CONTROLSB_OFFSET:
    case G2SB_CTX3_G2CONTROLSECOND_OFFSET:
    case G2SB_CTX3_G2CONTROLMAIN_OFFSET:
    case G2SB_CTX3_G2ROPFADE_OFFSET:
    case G2SB_CTX3_G2ALPHABLEND_OFFSET:
    case G2SB_CTX3_G2CLIPLEFTTOP_OFFSET:
    case G2SB_CTX3_G2CLIPRIGHTBOT_OFFSET:
    case G2SB_CTX3_G2PATPACK_OFFSET:
    case G2SB_CTX3_G2PATPACK_SIZE_OFFSET:
    case G2SB_CTX3_G2PATBA_OFFSET:
    case G2SB_CTX3_G2PATOS_OFFSET:
    case G2SB_CTX3_G2PATBGC_OFFSET:
    case G2SB_CTX3_G2PATFGC_OFFSET:
    case G2SB_CTX3_G2PATKEY_OFFSET:
    case G2SB_CTX3_G2DSTBA_OFFSET:
    case G2SB_CTX3_G2DSTBA_B_OFFSET:
    case G2SB_CTX3_G2DSTBA_C_OFFSET:
    case G2SB_CTX3_G2DSTST_OFFSET:
    case G2SB_CTX3_G2SRCPACK_OFFSET:
    case G2SB_CTX3_G2SRCPACK_SIZE_OFFSET:
    case G2SB_CTX3_G2SRCBA_OFFSET:
    case G2SB_CTX3_G2SRCBA_B_OFFSET:
    case G2SB_CTX3_G2SRCST_OFFSET:
    case G2SB_CTX3_G2SRCBGC_OFFSET:
    case G2SB_CTX3_G2SRCFGC_OFFSET:
    case G2SB_CTX3_G2SRCKEY_OFFSET:
    case G2SB_CTX3_G2SRCSIZE_OFFSET:
    case G2SB_CTX3_G2DSTSIZE_OFFSET:
    case G2SB_CTX3_G2SRCPS_OFFSET:
    case G2SB_CTX3_G2DSTPS_OFFSET:
    case G2SB_CTX3_G2CBDES_OFFSET:
    case G2SB_CTX3_G2CBSTRIDE_OFFSET:
    case G2SB_CTX3_G2LINESETTING_OFFSET:
    case G2SB_CTX3_G2LINEDELTAN_OFFSET:
    case G2SB_CTX3_G2LINEDELTAM_OFFSET:
    case G2SB_CTX3_G2LINEPOS_OFFSET:
    case G2SB_CTX3_G2LINELEN_OFFSET:
    case G2SB_CTX3_G2CSCFOURTH_OFFSET:
    case G2SB_CTX3_G2SRCST_B_OFFSET:
    case G2SB_CTX3_G2UVSTRIDE_OFFSET:
    case G2SB_CTX3_G2CBDES2_OFFSET:
    case G2SB_CTX3_G2TILEMODE_OFFSET:
    case G2SB_CTX3_G2PATBASE_OFFSET:
    case G2SB_CTX3_G2SRCBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX3_G2DSTBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX3_G2DSTBA_B_SB_SURFBASE_OFFSET:
    case G2SB_CTX3_G2VBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX3_G2UBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX4_INCR_SYNCPT_OFFSET:
    case G2SB_CTX4_INCR_SYNCPT_CNTRL_OFFSET:
    case G2SB_CTX4_INCR_SYNCPT_ERROR_OFFSET:
    case G2SB_CTX4_G2CLASSCHANNEL_REGONLY_OFFSET:
    case G2SB_CTX4_G2TRIGGER_OFFSET:
    case G2SB_CTX4_G2TRIGGER1_OFFSET:
    case G2SB_CTX4_G2TRIGGER2_OFFSET:
    case G2SB_CTX4_G2CMDSEL_OFFSET:
    case G2SB_CTX4_G2RAISE_OFFSET:
    case G2SB_CTX4_G2HOSTSET_OFFSET:
    case G2SB_CTX4_G2HOSTFIFO_OFFSET:
    case G2SB_CTX4_G2VDDA_OFFSET:
    case G2SB_CTX4_G2VDDAINI_OFFSET:
    case G2SB_CTX4_G2HDDA_OFFSET:
    case G2SB_CTX4_G2HDDAINILS_OFFSET:
    case G2SB_CTX4_G2CSCFIRST_OFFSET:
    case G2SB_CTX4_G2CSCSECOND_OFFSET:
    case G2SB_CTX4_G2CSCTHIRD_OFFSET:
    case G2SB_CTX4_G2CMKEYL_OFFSET:
    case G2SB_CTX4_G2CMKEYU_OFFSET:
    case G2SB_CTX4_G2UBA_A_OFFSET:
    case G2SB_CTX4_G2VBA_A_OFFSET:
    case G2SB_CTX4_G2SBFORMAT_OFFSET:
    case G2SB_CTX4_G2CONTROLSB_OFFSET:
    case G2SB_CTX4_G2CONTROLSECOND_OFFSET:
    case G2SB_CTX4_G2CONTROLMAIN_OFFSET:
    case G2SB_CTX4_G2ROPFADE_OFFSET:
    case G2SB_CTX4_G2ALPHABLEND_OFFSET:
    case G2SB_CTX4_G2CLIPLEFTTOP_OFFSET:
    case G2SB_CTX4_G2CLIPRIGHTBOT_OFFSET:
    case G2SB_CTX4_G2PATPACK_OFFSET:
    case G2SB_CTX4_G2PATPACK_SIZE_OFFSET:
    case G2SB_CTX4_G2PATBA_OFFSET:
    case G2SB_CTX4_G2PATOS_OFFSET:
    case G2SB_CTX4_G2PATBGC_OFFSET:
    case G2SB_CTX4_G2PATFGC_OFFSET:
    case G2SB_CTX4_G2PATKEY_OFFSET:
    case G2SB_CTX4_G2DSTBA_OFFSET:
    case G2SB_CTX4_G2DSTBA_B_OFFSET:
    case G2SB_CTX4_G2DSTBA_C_OFFSET:
    case G2SB_CTX4_G2DSTST_OFFSET:
    case G2SB_CTX4_G2SRCPACK_OFFSET:
    case G2SB_CTX4_G2SRCPACK_SIZE_OFFSET:
    case G2SB_CTX4_G2SRCBA_OFFSET:
    case G2SB_CTX4_G2SRCBA_B_OFFSET:
    case G2SB_CTX4_G2SRCST_OFFSET:
    case G2SB_CTX4_G2SRCBGC_OFFSET:
    case G2SB_CTX4_G2SRCFGC_OFFSET:
    case G2SB_CTX4_G2SRCKEY_OFFSET:
    case G2SB_CTX4_G2SRCSIZE_OFFSET:
    case G2SB_CTX4_G2DSTSIZE_OFFSET:
    case G2SB_CTX4_G2SRCPS_OFFSET:
    case G2SB_CTX4_G2DSTPS_OFFSET:
    case G2SB_CTX4_G2CBDES_OFFSET:
    case G2SB_CTX4_G2CBSTRIDE_OFFSET:
    case G2SB_CTX4_G2LINESETTING_OFFSET:
    case G2SB_CTX4_G2LINEDELTAN_OFFSET:
    case G2SB_CTX4_G2LINEDELTAM_OFFSET:
    case G2SB_CTX4_G2LINEPOS_OFFSET:
    case G2SB_CTX4_G2LINELEN_OFFSET:
    case G2SB_CTX4_G2CSCFOURTH_OFFSET:
    case G2SB_CTX4_G2SRCST_B_OFFSET:
    case G2SB_CTX4_G2UVSTRIDE_OFFSET:
    case G2SB_CTX4_G2CBDES2_OFFSET:
    case G2SB_CTX4_G2TILEMODE_OFFSET:
    case G2SB_CTX4_G2PATBASE_OFFSET:
    case G2SB_CTX4_G2SRCBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX4_G2DSTBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX4_G2DSTBA_B_SB_SURFBASE_OFFSET:
    case G2SB_CTX4_G2VBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX4_G2UBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX5_INCR_SYNCPT_OFFSET:
    case G2SB_CTX5_INCR_SYNCPT_CNTRL_OFFSET:
    case G2SB_CTX5_INCR_SYNCPT_ERROR_OFFSET:
    case G2SB_CTX5_G2CLASSCHANNEL_REGONLY_OFFSET:
    case G2SB_CTX5_G2TRIGGER_OFFSET:
    case G2SB_CTX5_G2TRIGGER1_OFFSET:
    case G2SB_CTX5_G2TRIGGER2_OFFSET:
    case G2SB_CTX5_G2CMDSEL_OFFSET:
    case G2SB_CTX5_G2RAISE_OFFSET:
    case G2SB_CTX5_G2HOSTSET_OFFSET:
    case G2SB_CTX5_G2HOSTFIFO_OFFSET:
    case G2SB_CTX5_G2VDDA_OFFSET:
    case G2SB_CTX5_G2VDDAINI_OFFSET:
    case G2SB_CTX5_G2HDDA_OFFSET:
    case G2SB_CTX5_G2HDDAINILS_OFFSET:
    case G2SB_CTX5_G2CSCFIRST_OFFSET:
    case G2SB_CTX5_G2CSCSECOND_OFFSET:
    case G2SB_CTX5_G2CSCTHIRD_OFFSET:
    case G2SB_CTX5_G2CMKEYL_OFFSET:
    case G2SB_CTX5_G2CMKEYU_OFFSET:
    case G2SB_CTX5_G2UBA_A_OFFSET:
    case G2SB_CTX5_G2VBA_A_OFFSET:
    case G2SB_CTX5_G2SBFORMAT_OFFSET:
    case G2SB_CTX5_G2CONTROLSB_OFFSET:
    case G2SB_CTX5_G2CONTROLSECOND_OFFSET:
    case G2SB_CTX5_G2CONTROLMAIN_OFFSET:
    case G2SB_CTX5_G2ROPFADE_OFFSET:
    case G2SB_CTX5_G2ALPHABLEND_OFFSET:
    case G2SB_CTX5_G2CLIPLEFTTOP_OFFSET:
    case G2SB_CTX5_G2CLIPRIGHTBOT_OFFSET:
    case G2SB_CTX5_G2PATPACK_OFFSET:
    case G2SB_CTX5_G2PATPACK_SIZE_OFFSET:
    case G2SB_CTX5_G2PATBA_OFFSET:
    case G2SB_CTX5_G2PATOS_OFFSET:
    case G2SB_CTX5_G2PATBGC_OFFSET:
    case G2SB_CTX5_G2PATFGC_OFFSET:
    case G2SB_CTX5_G2PATKEY_OFFSET:
    case G2SB_CTX5_G2DSTBA_OFFSET:
    case G2SB_CTX5_G2DSTBA_B_OFFSET:
    case G2SB_CTX5_G2DSTBA_C_OFFSET:
    case G2SB_CTX5_G2DSTST_OFFSET:
    case G2SB_CTX5_G2SRCPACK_OFFSET:
    case G2SB_CTX5_G2SRCPACK_SIZE_OFFSET:
    case G2SB_CTX5_G2SRCBA_OFFSET:
    case G2SB_CTX5_G2SRCBA_B_OFFSET:
    case G2SB_CTX5_G2SRCST_OFFSET:
    case G2SB_CTX5_G2SRCBGC_OFFSET:
    case G2SB_CTX5_G2SRCFGC_OFFSET:
    case G2SB_CTX5_G2SRCKEY_OFFSET:
    case G2SB_CTX5_G2SRCSIZE_OFFSET:
    case G2SB_CTX5_G2DSTSIZE_OFFSET:
    case G2SB_CTX5_G2SRCPS_OFFSET:
    case G2SB_CTX5_G2DSTPS_OFFSET:
    case G2SB_CTX5_G2CBDES_OFFSET:
    case G2SB_CTX5_G2CBSTRIDE_OFFSET:
    case G2SB_CTX5_G2LINESETTING_OFFSET:
    case G2SB_CTX5_G2LINEDELTAN_OFFSET:
    case G2SB_CTX5_G2LINEDELTAM_OFFSET:
    case G2SB_CTX5_G2LINEPOS_OFFSET:
    case G2SB_CTX5_G2LINELEN_OFFSET:
    case G2SB_CTX5_G2CSCFOURTH_OFFSET:
    case G2SB_CTX5_G2SRCST_B_OFFSET:
    case G2SB_CTX5_G2UVSTRIDE_OFFSET:
    case G2SB_CTX5_G2CBDES2_OFFSET:
    case G2SB_CTX5_G2TILEMODE_OFFSET:
    case G2SB_CTX5_G2PATBASE_OFFSET:
    case G2SB_CTX5_G2SRCBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX5_G2DSTBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX5_G2DSTBA_B_SB_SURFBASE_OFFSET:
    case G2SB_CTX5_G2VBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX5_G2UBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX6_INCR_SYNCPT_OFFSET:
    case G2SB_CTX6_INCR_SYNCPT_CNTRL_OFFSET:
    case G2SB_CTX6_INCR_SYNCPT_ERROR_OFFSET:
    case G2SB_CTX6_G2CLASSCHANNEL_REGONLY_OFFSET:
    case G2SB_CTX6_G2TRIGGER_OFFSET:
    case G2SB_CTX6_G2TRIGGER1_OFFSET:
    case G2SB_CTX6_G2TRIGGER2_OFFSET:
    case G2SB_CTX6_G2CMDSEL_OFFSET:
    case G2SB_CTX6_G2RAISE_OFFSET:
    case G2SB_CTX6_G2HOSTSET_OFFSET:
    case G2SB_CTX6_G2HOSTFIFO_OFFSET:
    case G2SB_CTX6_G2VDDA_OFFSET:
    case G2SB_CTX6_G2VDDAINI_OFFSET:
    case G2SB_CTX6_G2HDDA_OFFSET:
    case G2SB_CTX6_G2HDDAINILS_OFFSET:
    case G2SB_CTX6_G2CSCFIRST_OFFSET:
    case G2SB_CTX6_G2CSCSECOND_OFFSET:
    case G2SB_CTX6_G2CSCTHIRD_OFFSET:
    case G2SB_CTX6_G2CMKEYL_OFFSET:
    case G2SB_CTX6_G2CMKEYU_OFFSET:
    case G2SB_CTX6_G2UBA_A_OFFSET:
    case G2SB_CTX6_G2VBA_A_OFFSET:
    case G2SB_CTX6_G2SBFORMAT_OFFSET:
    case G2SB_CTX6_G2CONTROLSB_OFFSET:
    case G2SB_CTX6_G2CONTROLSECOND_OFFSET:
    case G2SB_CTX6_G2CONTROLMAIN_OFFSET:
    case G2SB_CTX6_G2ROPFADE_OFFSET:
    case G2SB_CTX6_G2ALPHABLEND_OFFSET:
    case G2SB_CTX6_G2CLIPLEFTTOP_OFFSET:
    case G2SB_CTX6_G2CLIPRIGHTBOT_OFFSET:
    case G2SB_CTX6_G2PATPACK_OFFSET:
    case G2SB_CTX6_G2PATPACK_SIZE_OFFSET:
    case G2SB_CTX6_G2PATBA_OFFSET:
    case G2SB_CTX6_G2PATOS_OFFSET:
    case G2SB_CTX6_G2PATBGC_OFFSET:
    case G2SB_CTX6_G2PATFGC_OFFSET:
    case G2SB_CTX6_G2PATKEY_OFFSET:
    case G2SB_CTX6_G2DSTBA_OFFSET:
    case G2SB_CTX6_G2DSTBA_B_OFFSET:
    case G2SB_CTX6_G2DSTBA_C_OFFSET:
    case G2SB_CTX6_G2DSTST_OFFSET:
    case G2SB_CTX6_G2SRCPACK_OFFSET:
    case G2SB_CTX6_G2SRCPACK_SIZE_OFFSET:
    case G2SB_CTX6_G2SRCBA_OFFSET:
    case G2SB_CTX6_G2SRCBA_B_OFFSET:
    case G2SB_CTX6_G2SRCST_OFFSET:
    case G2SB_CTX6_G2SRCBGC_OFFSET:
    case G2SB_CTX6_G2SRCFGC_OFFSET:
    case G2SB_CTX6_G2SRCKEY_OFFSET:
    case G2SB_CTX6_G2SRCSIZE_OFFSET:
    case G2SB_CTX6_G2DSTSIZE_OFFSET:
    case G2SB_CTX6_G2SRCPS_OFFSET:
    case G2SB_CTX6_G2DSTPS_OFFSET:
    case G2SB_CTX6_G2CBDES_OFFSET:
    case G2SB_CTX6_G2CBSTRIDE_OFFSET:
    case G2SB_CTX6_G2LINESETTING_OFFSET:
    case G2SB_CTX6_G2LINEDELTAN_OFFSET:
    case G2SB_CTX6_G2LINEDELTAM_OFFSET:
    case G2SB_CTX6_G2LINEPOS_OFFSET:
    case G2SB_CTX6_G2LINELEN_OFFSET:
    case G2SB_CTX6_G2CSCFOURTH_OFFSET:
    case G2SB_CTX6_G2SRCST_B_OFFSET:
    case G2SB_CTX6_G2UVSTRIDE_OFFSET:
    case G2SB_CTX6_G2CBDES2_OFFSET:
    case G2SB_CTX6_G2TILEMODE_OFFSET:
    case G2SB_CTX6_G2PATBASE_OFFSET:
    case G2SB_CTX6_G2SRCBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX6_G2DSTBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX6_G2DSTBA_B_SB_SURFBASE_OFFSET:
    case G2SB_CTX6_G2VBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX6_G2UBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX7_INCR_SYNCPT_OFFSET:
    case G2SB_CTX7_INCR_SYNCPT_CNTRL_OFFSET:
    case G2SB_CTX7_INCR_SYNCPT_ERROR_OFFSET:
    case G2SB_CTX7_G2CLASSCHANNEL_REGONLY_OFFSET:
    case G2SB_CTX7_G2TRIGGER_OFFSET:
    case G2SB_CTX7_G2TRIGGER1_OFFSET:
    case G2SB_CTX7_G2TRIGGER2_OFFSET:
    case G2SB_CTX7_G2CMDSEL_OFFSET:
    case G2SB_CTX7_G2RAISE_OFFSET:
    case G2SB_CTX7_G2HOSTSET_OFFSET:
    case G2SB_CTX7_G2HOSTFIFO_OFFSET:
    case G2SB_CTX7_G2VDDA_OFFSET:
    case G2SB_CTX7_G2VDDAINI_OFFSET:
    case G2SB_CTX7_G2HDDA_OFFSET:
    case G2SB_CTX7_G2HDDAINILS_OFFSET:
    case G2SB_CTX7_G2CSCFIRST_OFFSET:
    case G2SB_CTX7_G2CSCSECOND_OFFSET:
    case G2SB_CTX7_G2CSCTHIRD_OFFSET:
    case G2SB_CTX7_G2CMKEYL_OFFSET:
    case G2SB_CTX7_G2CMKEYU_OFFSET:
    case G2SB_CTX7_G2UBA_A_OFFSET:
    case G2SB_CTX7_G2VBA_A_OFFSET:
    case G2SB_CTX7_G2SBFORMAT_OFFSET:
    case G2SB_CTX7_G2CONTROLSB_OFFSET:
    case G2SB_CTX7_G2CONTROLSECOND_OFFSET:
    case G2SB_CTX7_G2CONTROLMAIN_OFFSET:
    case G2SB_CTX7_G2ROPFADE_OFFSET:
    case G2SB_CTX7_G2ALPHABLEND_OFFSET:
    case G2SB_CTX7_G2CLIPLEFTTOP_OFFSET:
    case G2SB_CTX7_G2CLIPRIGHTBOT_OFFSET:
    case G2SB_CTX7_G2PATPACK_OFFSET:
    case G2SB_CTX7_G2PATPACK_SIZE_OFFSET:
    case G2SB_CTX7_G2PATBA_OFFSET:
    case G2SB_CTX7_G2PATOS_OFFSET:
    case G2SB_CTX7_G2PATBGC_OFFSET:
    case G2SB_CTX7_G2PATFGC_OFFSET:
    case G2SB_CTX7_G2PATKEY_OFFSET:
    case G2SB_CTX7_G2DSTBA_OFFSET:
    case G2SB_CTX7_G2DSTBA_B_OFFSET:
    case G2SB_CTX7_G2DSTBA_C_OFFSET:
    case G2SB_CTX7_G2DSTST_OFFSET:
    case G2SB_CTX7_G2SRCPACK_OFFSET:
    case G2SB_CTX7_G2SRCPACK_SIZE_OFFSET:
    case G2SB_CTX7_G2SRCBA_OFFSET:
    case G2SB_CTX7_G2SRCBA_B_OFFSET:
    case G2SB_CTX7_G2SRCST_OFFSET:
    case G2SB_CTX7_G2SRCBGC_OFFSET:
    case G2SB_CTX7_G2SRCFGC_OFFSET:
    case G2SB_CTX7_G2SRCKEY_OFFSET:
    case G2SB_CTX7_G2SRCSIZE_OFFSET:
    case G2SB_CTX7_G2DSTSIZE_OFFSET:
    case G2SB_CTX7_G2SRCPS_OFFSET:
    case G2SB_CTX7_G2DSTPS_OFFSET:
    case G2SB_CTX7_G2CBDES_OFFSET:
    case G2SB_CTX7_G2CBSTRIDE_OFFSET:
    case G2SB_CTX7_G2LINESETTING_OFFSET:
    case G2SB_CTX7_G2LINEDELTAN_OFFSET:
    case G2SB_CTX7_G2LINEDELTAM_OFFSET:
    case G2SB_CTX7_G2LINEPOS_OFFSET:
    case G2SB_CTX7_G2LINELEN_OFFSET:
    case G2SB_CTX7_G2CSCFOURTH_OFFSET:
    case G2SB_CTX7_G2SRCST_B_OFFSET:
    case G2SB_CTX7_G2UVSTRIDE_OFFSET:
    case G2SB_CTX7_G2CBDES2_OFFSET:
    case G2SB_CTX7_G2TILEMODE_OFFSET:
    case G2SB_CTX7_G2PATBASE_OFFSET:
    case G2SB_CTX7_G2SRCBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX7_G2DSTBA_SB_SURFBASE_OFFSET:
    case G2SB_CTX7_G2DSTBA_B_SB_SURFBASE_OFFSET:
    case G2SB_CTX7_G2VBA_A_SB_SURFBASE_OFFSET:
    case G2SB_CTX7_G2UBA_A_SB_SURFBASE_OFFSET:
    case G2SB_SWITCH_G2INTERRUPT_OFFSET:
    case G2SB_SWITCH_G2INTENABLE_OFFSET:
    case G2SB_SWITCH_G2CURRENTCONTEXT_OFFSET:
    case G2SB_SWITCH_G2NXTCXTSWITCH_OFFSET:
    case G2SB_SWITCH_G2GLOBALCONTROL_OFFSET:
    case G2SB_SWITCH_G2GLOBALCONTROLB_OFFSET:
    case G2SB_SWITCH_G2WORKINGSTAT_OFFSET:
    case G2SB_SWITCH_G2BUFTHRESHOLD_OFFSET:
    case G2SB_SWITCH_CLKEN_OVERIDE_OFFSET:
    case G2SB_SWITCH_G2_MCCIF_FIFOCTRL_OFFSET:
    case G2SB_SWITCH_TIMEOUT_WCOAL_G2_OFFSET:
        return true;
    default:
        break;
    }

    return false;
}

bool Gr2dDev::is_undef_changed(const u_int32_t &offset,
                                           const u_int32_t &value,
                                           const u_int32_t &new_value) const
{
    switch (offset) {
    case G2SB_INCR_SYNCPT_OFFSET:
        if ((value ^ new_value) & G2SB_INCR_SYNCPT_UNDEFMASK)
            return true;
        break;
    case G2SB_INCR_SYNCPT_CNTRL_OFFSET:
        if ((value ^ new_value) & G2SB_INCR_SYNCPT_CNTRL_UNDEFMASK)
            return true;
        break;
    case G2SB_INCR_SYNCPT_ERROR_OFFSET:
        if ((value ^ new_value) & G2SB_INCR_SYNCPT_ERROR_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CLASSCHANNEL_REGONLY_OFFSET:
        if ((value ^ new_value) & G2SB_G2CLASSCHANNEL_REGONLY_UNDEFMASK)
            return true;
        break;
    case G2SB_G2TRIGGER_OFFSET:
        if ((value ^ new_value) & G2SB_G2TRIGGER_UNDEFMASK)
            return true;
        break;
    case G2SB_G2TRIGGER1_OFFSET:
        if ((value ^ new_value) & G2SB_G2TRIGGER1_UNDEFMASK)
            return true;
        break;
    case G2SB_G2TRIGGER2_OFFSET:
        if ((value ^ new_value) & G2SB_G2TRIGGER2_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CMDSEL_OFFSET:
        if ((value ^ new_value) & G2SB_G2CMDSEL_UNDEFMASK)
            return true;
        break;
    case G2SB_G2RAISE_OFFSET:
        if ((value ^ new_value) & G2SB_G2RAISE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2HOSTSET_OFFSET:
        if ((value ^ new_value) & G2SB_G2HOSTSET_UNDEFMASK)
            return true;
        break;
    case G2SB_G2HOSTFIFO_OFFSET:
        if ((value ^ new_value) & G2SB_G2HOSTFIFO_UNDEFMASK)
            return true;
        break;
    case G2SB_G2VDDA_OFFSET:
        if ((value ^ new_value) & G2SB_G2VDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_G2VDDAINI_OFFSET:
        if ((value ^ new_value) & G2SB_G2VDDAINI_UNDEFMASK)
            return true;
        break;
    case G2SB_G2HDDA_OFFSET:
        if ((value ^ new_value) & G2SB_G2HDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_G2HDDAINILS_OFFSET:
        if ((value ^ new_value) & G2SB_G2HDDAINILS_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CSCFIRST_OFFSET:
        if ((value ^ new_value) & G2SB_G2CSCFIRST_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CSCSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_G2CSCSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CSCTHIRD_OFFSET:
        if ((value ^ new_value) & G2SB_G2CSCTHIRD_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CMKEYL_OFFSET:
        if ((value ^ new_value) & G2SB_G2CMKEYL_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CMKEYU_OFFSET:
        if ((value ^ new_value) & G2SB_G2CMKEYU_UNDEFMASK)
            return true;
        break;
    case G2SB_G2UBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_G2UBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_G2VBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_G2VBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_G2SBFORMAT_OFFSET:
        if ((value ^ new_value) & G2SB_G2SBFORMAT_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CONTROLSB_OFFSET:
        if ((value ^ new_value) & G2SB_G2CONTROLSB_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CONTROLSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_G2CONTROLSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CONTROLMAIN_OFFSET:
        if ((value ^ new_value) & G2SB_G2CONTROLMAIN_UNDEFMASK)
            return true;
        break;
    case G2SB_G2ROPFADE_OFFSET:
        if ((value ^ new_value) & G2SB_G2ROPFADE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2ALPHABLEND_OFFSET:
        if ((value ^ new_value) & G2SB_G2ALPHABLEND_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CLIPLEFTTOP_OFFSET:
        if ((value ^ new_value) & G2SB_G2CLIPLEFTTOP_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CLIPRIGHTBOT_OFFSET:
        if ((value ^ new_value) & G2SB_G2CLIPRIGHTBOT_UNDEFMASK)
            return true;
        break;
    case G2SB_G2PATPACK_OFFSET:
        if ((value ^ new_value) & G2SB_G2PATPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_G2PATPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_G2PATPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2PATBA_OFFSET:
        if ((value ^ new_value) & G2SB_G2PATBA_UNDEFMASK)
            return true;
        break;
    case G2SB_G2PATOS_OFFSET:
        if ((value ^ new_value) & G2SB_G2PATOS_UNDEFMASK)
            return true;
        break;
    case G2SB_G2PATBGC_OFFSET:
        if ((value ^ new_value) & G2SB_G2PATBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_G2PATFGC_OFFSET:
        if ((value ^ new_value) & G2SB_G2PATFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_G2PATKEY_OFFSET:
        if ((value ^ new_value) & G2SB_G2PATKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_G2DSTBA_OFFSET:
        if ((value ^ new_value) & G2SB_G2DSTBA_UNDEFMASK)
            return true;
        break;
    case G2SB_G2DSTBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_G2DSTBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_G2DSTBA_C_OFFSET:
        if ((value ^ new_value) & G2SB_G2DSTBA_C_UNDEFMASK)
            return true;
        break;
    case G2SB_G2DSTST_OFFSET:
        if ((value ^ new_value) & G2SB_G2DSTST_UNDEFMASK)
            return true;
        break;
    case G2SB_G2SRCPACK_OFFSET:
        if ((value ^ new_value) & G2SB_G2SRCPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_G2SRCPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_G2SRCPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2SRCBA_OFFSET:
        if ((value ^ new_value) & G2SB_G2SRCBA_UNDEFMASK)
            return true;
        break;
    case G2SB_G2SRCBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_G2SRCBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_G2SRCST_OFFSET:
        if ((value ^ new_value) & G2SB_G2SRCST_UNDEFMASK)
            return true;
        break;
    case G2SB_G2SRCBGC_OFFSET:
        if ((value ^ new_value) & G2SB_G2SRCBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_G2SRCFGC_OFFSET:
        if ((value ^ new_value) & G2SB_G2SRCFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_G2SRCKEY_OFFSET:
        if ((value ^ new_value) & G2SB_G2SRCKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_G2SRCSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_G2SRCSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2DSTSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_G2DSTSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2SRCPS_OFFSET:
        if ((value ^ new_value) & G2SB_G2SRCPS_UNDEFMASK)
            return true;
        break;
    case G2SB_G2DSTPS_OFFSET:
        if ((value ^ new_value) & G2SB_G2DSTPS_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CBDES_OFFSET:
        if ((value ^ new_value) & G2SB_G2CBDES_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CBSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_G2CBSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2LINESETTING_OFFSET:
        if ((value ^ new_value) & G2SB_G2LINESETTING_UNDEFMASK)
            return true;
        break;
    case G2SB_G2LINEDELTAN_OFFSET:
        if ((value ^ new_value) & G2SB_G2LINEDELTAN_UNDEFMASK)
            return true;
        break;
    case G2SB_G2LINEDELTAM_OFFSET:
        if ((value ^ new_value) & G2SB_G2LINEDELTAM_UNDEFMASK)
            return true;
        break;
    case G2SB_G2LINEPOS_OFFSET:
        if ((value ^ new_value) & G2SB_G2LINEPOS_UNDEFMASK)
            return true;
        break;
    case G2SB_G2LINELEN_OFFSET:
        if ((value ^ new_value) & G2SB_G2LINELEN_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CSCFOURTH_OFFSET:
        if ((value ^ new_value) & G2SB_G2CSCFOURTH_UNDEFMASK)
            return true;
        break;
    case G2SB_G2SRCST_B_OFFSET:
        if ((value ^ new_value) & G2SB_G2SRCST_B_UNDEFMASK)
            return true;
        break;
    case G2SB_G2UVSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_G2UVSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2CBDES2_OFFSET:
        if ((value ^ new_value) & G2SB_G2CBDES2_UNDEFMASK)
            return true;
        break;
    case G2SB_G2TILEMODE_OFFSET:
        if ((value ^ new_value) & G2SB_G2TILEMODE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2PATBASE_OFFSET:
        if ((value ^ new_value) & G2SB_G2PATBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2SRCBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_G2SRCBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2DSTBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_G2DSTBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2DSTBA_B_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_G2DSTBA_B_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2VBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_G2VBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_G2UBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_G2UBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_INCR_SYNCPT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_INCR_SYNCPT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_INCR_SYNCPT_CNTRL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_INCR_SYNCPT_CNTRL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_INCR_SYNCPT_ERROR_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_INCR_SYNCPT_ERROR_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CLASSCHANNEL_REGONLY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CLASSCHANNEL_REGONLY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2TRIGGER_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2TRIGGER_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2TRIGGER1_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2TRIGGER1_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2TRIGGER2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2TRIGGER2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CMDSEL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CMDSEL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2RAISE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2RAISE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2HOSTSET_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2HOSTSET_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2HOSTFIFO_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2HOSTFIFO_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2VDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2VDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2VDDAINI_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2VDDAINI_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2HDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2HDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2HDDAINILS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2HDDAINILS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CSCFIRST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CSCFIRST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CSCSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CSCSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CSCTHIRD_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CSCTHIRD_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CMKEYL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CMKEYL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CMKEYU_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CMKEYU_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2UBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2UBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2VBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2VBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2SBFORMAT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2SBFORMAT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CONTROLSB_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CONTROLSB_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CONTROLSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CONTROLSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CONTROLMAIN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CONTROLMAIN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2ROPFADE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2ROPFADE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2ALPHABLEND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2ALPHABLEND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CLIPLEFTTOP_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CLIPLEFTTOP_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CLIPRIGHTBOT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CLIPRIGHTBOT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2PATPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2PATPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2PATPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2PATPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2PATBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2PATBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2PATOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2PATOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2PATBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2PATBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2PATFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2PATFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2PATKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2PATKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2DSTBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2DSTBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2DSTBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2DSTBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2DSTBA_C_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2DSTBA_C_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2DSTST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2DSTST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2SRCPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2SRCPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2SRCPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2SRCPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2SRCBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2SRCBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2SRCBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2SRCBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2SRCST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2SRCST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2SRCBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2SRCBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2SRCFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2SRCFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2SRCKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2SRCKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2SRCSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2SRCSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2DSTSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2DSTSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2SRCPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2SRCPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2DSTPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2DSTPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CBDES_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CBDES_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CBSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CBSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2LINESETTING_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2LINESETTING_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2LINEDELTAN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2LINEDELTAN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2LINEDELTAM_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2LINEDELTAM_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2LINEPOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2LINEPOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2LINELEN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2LINELEN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CSCFOURTH_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CSCFOURTH_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2SRCST_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2SRCST_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2UVSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2UVSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2CBDES2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2CBDES2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2TILEMODE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2TILEMODE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2PATBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2PATBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2SRCBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2SRCBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2DSTBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2DSTBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2DSTBA_B_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2DSTBA_B_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2VBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2VBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX1_G2UBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX1_G2UBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_INCR_SYNCPT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_INCR_SYNCPT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_INCR_SYNCPT_CNTRL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_INCR_SYNCPT_CNTRL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_INCR_SYNCPT_ERROR_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_INCR_SYNCPT_ERROR_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CLASSCHANNEL_REGONLY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CLASSCHANNEL_REGONLY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2TRIGGER_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2TRIGGER_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2TRIGGER1_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2TRIGGER1_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2TRIGGER2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2TRIGGER2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CMDSEL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CMDSEL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2RAISE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2RAISE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2HOSTSET_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2HOSTSET_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2HOSTFIFO_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2HOSTFIFO_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2VDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2VDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2VDDAINI_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2VDDAINI_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2HDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2HDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2HDDAINILS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2HDDAINILS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CSCFIRST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CSCFIRST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CSCSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CSCSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CSCTHIRD_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CSCTHIRD_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CMKEYL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CMKEYL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CMKEYU_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CMKEYU_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2UBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2UBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2VBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2VBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2SBFORMAT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2SBFORMAT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CONTROLSB_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CONTROLSB_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CONTROLSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CONTROLSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CONTROLMAIN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CONTROLMAIN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2ROPFADE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2ROPFADE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2ALPHABLEND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2ALPHABLEND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CLIPLEFTTOP_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CLIPLEFTTOP_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CLIPRIGHTBOT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CLIPRIGHTBOT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2PATPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2PATPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2PATPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2PATPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2PATBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2PATBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2PATOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2PATOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2PATBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2PATBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2PATFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2PATFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2PATKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2PATKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2DSTBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2DSTBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2DSTBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2DSTBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2DSTBA_C_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2DSTBA_C_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2DSTST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2DSTST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2SRCPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2SRCPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2SRCPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2SRCPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2SRCBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2SRCBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2SRCBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2SRCBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2SRCST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2SRCST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2SRCBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2SRCBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2SRCFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2SRCFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2SRCKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2SRCKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2SRCSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2SRCSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2DSTSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2DSTSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2SRCPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2SRCPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2DSTPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2DSTPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CBDES_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CBDES_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CBSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CBSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2LINESETTING_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2LINESETTING_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2LINEDELTAN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2LINEDELTAN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2LINEDELTAM_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2LINEDELTAM_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2LINEPOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2LINEPOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2LINELEN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2LINELEN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CSCFOURTH_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CSCFOURTH_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2SRCST_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2SRCST_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2UVSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2UVSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2CBDES2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2CBDES2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2TILEMODE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2TILEMODE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2PATBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2PATBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2SRCBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2SRCBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2DSTBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2DSTBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2DSTBA_B_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2DSTBA_B_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2VBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2VBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX2_G2UBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX2_G2UBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_INCR_SYNCPT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_INCR_SYNCPT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_INCR_SYNCPT_CNTRL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_INCR_SYNCPT_CNTRL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_INCR_SYNCPT_ERROR_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_INCR_SYNCPT_ERROR_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CLASSCHANNEL_REGONLY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CLASSCHANNEL_REGONLY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2TRIGGER_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2TRIGGER_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2TRIGGER1_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2TRIGGER1_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2TRIGGER2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2TRIGGER2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CMDSEL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CMDSEL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2RAISE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2RAISE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2HOSTSET_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2HOSTSET_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2HOSTFIFO_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2HOSTFIFO_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2VDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2VDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2VDDAINI_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2VDDAINI_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2HDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2HDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2HDDAINILS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2HDDAINILS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CSCFIRST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CSCFIRST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CSCSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CSCSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CSCTHIRD_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CSCTHIRD_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CMKEYL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CMKEYL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CMKEYU_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CMKEYU_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2UBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2UBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2VBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2VBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2SBFORMAT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2SBFORMAT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CONTROLSB_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CONTROLSB_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CONTROLSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CONTROLSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CONTROLMAIN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CONTROLMAIN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2ROPFADE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2ROPFADE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2ALPHABLEND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2ALPHABLEND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CLIPLEFTTOP_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CLIPLEFTTOP_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CLIPRIGHTBOT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CLIPRIGHTBOT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2PATPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2PATPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2PATPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2PATPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2PATBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2PATBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2PATOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2PATOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2PATBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2PATBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2PATFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2PATFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2PATKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2PATKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2DSTBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2DSTBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2DSTBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2DSTBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2DSTBA_C_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2DSTBA_C_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2DSTST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2DSTST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2SRCPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2SRCPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2SRCPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2SRCPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2SRCBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2SRCBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2SRCBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2SRCBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2SRCST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2SRCST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2SRCBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2SRCBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2SRCFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2SRCFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2SRCKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2SRCKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2SRCSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2SRCSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2DSTSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2DSTSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2SRCPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2SRCPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2DSTPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2DSTPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CBDES_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CBDES_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CBSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CBSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2LINESETTING_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2LINESETTING_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2LINEDELTAN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2LINEDELTAN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2LINEDELTAM_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2LINEDELTAM_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2LINEPOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2LINEPOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2LINELEN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2LINELEN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CSCFOURTH_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CSCFOURTH_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2SRCST_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2SRCST_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2UVSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2UVSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2CBDES2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2CBDES2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2TILEMODE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2TILEMODE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2PATBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2PATBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2SRCBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2SRCBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2DSTBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2DSTBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2DSTBA_B_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2DSTBA_B_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2VBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2VBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX3_G2UBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX3_G2UBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_INCR_SYNCPT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_INCR_SYNCPT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_INCR_SYNCPT_CNTRL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_INCR_SYNCPT_CNTRL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_INCR_SYNCPT_ERROR_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_INCR_SYNCPT_ERROR_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CLASSCHANNEL_REGONLY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CLASSCHANNEL_REGONLY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2TRIGGER_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2TRIGGER_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2TRIGGER1_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2TRIGGER1_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2TRIGGER2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2TRIGGER2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CMDSEL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CMDSEL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2RAISE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2RAISE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2HOSTSET_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2HOSTSET_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2HOSTFIFO_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2HOSTFIFO_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2VDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2VDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2VDDAINI_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2VDDAINI_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2HDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2HDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2HDDAINILS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2HDDAINILS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CSCFIRST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CSCFIRST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CSCSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CSCSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CSCTHIRD_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CSCTHIRD_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CMKEYL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CMKEYL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CMKEYU_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CMKEYU_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2UBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2UBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2VBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2VBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2SBFORMAT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2SBFORMAT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CONTROLSB_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CONTROLSB_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CONTROLSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CONTROLSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CONTROLMAIN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CONTROLMAIN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2ROPFADE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2ROPFADE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2ALPHABLEND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2ALPHABLEND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CLIPLEFTTOP_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CLIPLEFTTOP_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CLIPRIGHTBOT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CLIPRIGHTBOT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2PATPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2PATPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2PATPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2PATPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2PATBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2PATBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2PATOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2PATOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2PATBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2PATBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2PATFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2PATFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2PATKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2PATKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2DSTBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2DSTBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2DSTBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2DSTBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2DSTBA_C_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2DSTBA_C_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2DSTST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2DSTST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2SRCPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2SRCPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2SRCPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2SRCPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2SRCBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2SRCBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2SRCBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2SRCBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2SRCST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2SRCST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2SRCBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2SRCBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2SRCFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2SRCFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2SRCKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2SRCKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2SRCSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2SRCSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2DSTSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2DSTSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2SRCPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2SRCPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2DSTPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2DSTPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CBDES_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CBDES_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CBSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CBSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2LINESETTING_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2LINESETTING_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2LINEDELTAN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2LINEDELTAN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2LINEDELTAM_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2LINEDELTAM_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2LINEPOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2LINEPOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2LINELEN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2LINELEN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CSCFOURTH_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CSCFOURTH_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2SRCST_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2SRCST_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2UVSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2UVSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2CBDES2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2CBDES2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2TILEMODE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2TILEMODE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2PATBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2PATBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2SRCBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2SRCBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2DSTBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2DSTBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2DSTBA_B_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2DSTBA_B_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2VBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2VBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX4_G2UBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX4_G2UBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_INCR_SYNCPT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_INCR_SYNCPT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_INCR_SYNCPT_CNTRL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_INCR_SYNCPT_CNTRL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_INCR_SYNCPT_ERROR_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_INCR_SYNCPT_ERROR_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CLASSCHANNEL_REGONLY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CLASSCHANNEL_REGONLY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2TRIGGER_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2TRIGGER_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2TRIGGER1_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2TRIGGER1_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2TRIGGER2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2TRIGGER2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CMDSEL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CMDSEL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2RAISE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2RAISE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2HOSTSET_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2HOSTSET_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2HOSTFIFO_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2HOSTFIFO_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2VDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2VDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2VDDAINI_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2VDDAINI_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2HDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2HDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2HDDAINILS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2HDDAINILS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CSCFIRST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CSCFIRST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CSCSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CSCSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CSCTHIRD_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CSCTHIRD_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CMKEYL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CMKEYL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CMKEYU_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CMKEYU_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2UBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2UBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2VBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2VBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2SBFORMAT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2SBFORMAT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CONTROLSB_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CONTROLSB_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CONTROLSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CONTROLSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CONTROLMAIN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CONTROLMAIN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2ROPFADE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2ROPFADE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2ALPHABLEND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2ALPHABLEND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CLIPLEFTTOP_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CLIPLEFTTOP_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CLIPRIGHTBOT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CLIPRIGHTBOT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2PATPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2PATPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2PATPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2PATPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2PATBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2PATBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2PATOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2PATOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2PATBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2PATBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2PATFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2PATFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2PATKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2PATKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2DSTBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2DSTBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2DSTBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2DSTBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2DSTBA_C_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2DSTBA_C_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2DSTST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2DSTST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2SRCPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2SRCPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2SRCPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2SRCPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2SRCBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2SRCBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2SRCBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2SRCBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2SRCST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2SRCST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2SRCBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2SRCBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2SRCFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2SRCFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2SRCKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2SRCKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2SRCSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2SRCSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2DSTSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2DSTSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2SRCPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2SRCPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2DSTPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2DSTPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CBDES_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CBDES_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CBSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CBSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2LINESETTING_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2LINESETTING_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2LINEDELTAN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2LINEDELTAN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2LINEDELTAM_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2LINEDELTAM_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2LINEPOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2LINEPOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2LINELEN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2LINELEN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CSCFOURTH_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CSCFOURTH_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2SRCST_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2SRCST_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2UVSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2UVSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2CBDES2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2CBDES2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2TILEMODE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2TILEMODE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2PATBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2PATBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2SRCBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2SRCBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2DSTBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2DSTBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2DSTBA_B_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2DSTBA_B_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2VBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2VBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX5_G2UBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX5_G2UBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_INCR_SYNCPT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_INCR_SYNCPT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_INCR_SYNCPT_CNTRL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_INCR_SYNCPT_CNTRL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_INCR_SYNCPT_ERROR_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_INCR_SYNCPT_ERROR_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CLASSCHANNEL_REGONLY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CLASSCHANNEL_REGONLY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2TRIGGER_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2TRIGGER_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2TRIGGER1_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2TRIGGER1_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2TRIGGER2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2TRIGGER2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CMDSEL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CMDSEL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2RAISE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2RAISE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2HOSTSET_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2HOSTSET_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2HOSTFIFO_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2HOSTFIFO_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2VDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2VDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2VDDAINI_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2VDDAINI_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2HDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2HDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2HDDAINILS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2HDDAINILS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CSCFIRST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CSCFIRST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CSCSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CSCSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CSCTHIRD_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CSCTHIRD_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CMKEYL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CMKEYL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CMKEYU_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CMKEYU_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2UBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2UBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2VBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2VBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2SBFORMAT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2SBFORMAT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CONTROLSB_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CONTROLSB_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CONTROLSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CONTROLSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CONTROLMAIN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CONTROLMAIN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2ROPFADE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2ROPFADE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2ALPHABLEND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2ALPHABLEND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CLIPLEFTTOP_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CLIPLEFTTOP_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CLIPRIGHTBOT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CLIPRIGHTBOT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2PATPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2PATPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2PATPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2PATPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2PATBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2PATBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2PATOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2PATOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2PATBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2PATBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2PATFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2PATFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2PATKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2PATKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2DSTBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2DSTBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2DSTBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2DSTBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2DSTBA_C_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2DSTBA_C_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2DSTST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2DSTST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2SRCPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2SRCPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2SRCPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2SRCPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2SRCBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2SRCBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2SRCBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2SRCBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2SRCST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2SRCST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2SRCBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2SRCBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2SRCFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2SRCFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2SRCKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2SRCKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2SRCSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2SRCSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2DSTSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2DSTSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2SRCPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2SRCPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2DSTPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2DSTPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CBDES_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CBDES_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CBSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CBSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2LINESETTING_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2LINESETTING_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2LINEDELTAN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2LINEDELTAN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2LINEDELTAM_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2LINEDELTAM_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2LINEPOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2LINEPOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2LINELEN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2LINELEN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CSCFOURTH_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CSCFOURTH_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2SRCST_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2SRCST_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2UVSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2UVSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2CBDES2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2CBDES2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2TILEMODE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2TILEMODE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2PATBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2PATBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2SRCBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2SRCBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2DSTBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2DSTBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2DSTBA_B_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2DSTBA_B_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2VBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2VBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX6_G2UBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX6_G2UBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_INCR_SYNCPT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_INCR_SYNCPT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_INCR_SYNCPT_CNTRL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_INCR_SYNCPT_CNTRL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_INCR_SYNCPT_ERROR_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_INCR_SYNCPT_ERROR_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CLASSCHANNEL_REGONLY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CLASSCHANNEL_REGONLY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2TRIGGER_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2TRIGGER_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2TRIGGER1_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2TRIGGER1_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2TRIGGER2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2TRIGGER2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CMDSEL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CMDSEL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2RAISE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2RAISE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2HOSTSET_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2HOSTSET_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2HOSTFIFO_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2HOSTFIFO_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2VDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2VDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2VDDAINI_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2VDDAINI_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2HDDA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2HDDA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2HDDAINILS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2HDDAINILS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CSCFIRST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CSCFIRST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CSCSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CSCSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CSCTHIRD_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CSCTHIRD_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CMKEYL_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CMKEYL_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CMKEYU_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CMKEYU_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2UBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2UBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2VBA_A_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2VBA_A_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2SBFORMAT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2SBFORMAT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CONTROLSB_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CONTROLSB_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CONTROLSECOND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CONTROLSECOND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CONTROLMAIN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CONTROLMAIN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2ROPFADE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2ROPFADE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2ALPHABLEND_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2ALPHABLEND_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CLIPLEFTTOP_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CLIPLEFTTOP_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CLIPRIGHTBOT_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CLIPRIGHTBOT_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2PATPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2PATPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2PATPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2PATPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2PATBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2PATBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2PATOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2PATOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2PATBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2PATBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2PATFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2PATFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2PATKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2PATKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2DSTBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2DSTBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2DSTBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2DSTBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2DSTBA_C_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2DSTBA_C_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2DSTST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2DSTST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2SRCPACK_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2SRCPACK_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2SRCPACK_SIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2SRCPACK_SIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2SRCBA_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2SRCBA_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2SRCBA_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2SRCBA_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2SRCST_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2SRCST_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2SRCBGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2SRCBGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2SRCFGC_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2SRCFGC_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2SRCKEY_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2SRCKEY_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2SRCSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2SRCSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2DSTSIZE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2DSTSIZE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2SRCPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2SRCPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2DSTPS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2DSTPS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CBDES_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CBDES_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CBSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CBSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2LINESETTING_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2LINESETTING_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2LINEDELTAN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2LINEDELTAN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2LINEDELTAM_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2LINEDELTAM_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2LINEPOS_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2LINEPOS_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2LINELEN_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2LINELEN_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CSCFOURTH_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CSCFOURTH_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2SRCST_B_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2SRCST_B_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2UVSTRIDE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2UVSTRIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2CBDES2_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2CBDES2_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2TILEMODE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2TILEMODE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2PATBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2PATBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2SRCBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2SRCBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2DSTBA_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2DSTBA_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2DSTBA_B_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2DSTBA_B_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2VBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2VBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_CTX7_G2UBA_A_SB_SURFBASE_OFFSET:
        if ((value ^ new_value) & G2SB_CTX7_G2UBA_A_SB_SURFBASE_UNDEFMASK)
            return true;
        break;
    case G2SB_SWITCH_G2INTERRUPT_OFFSET:
        if ((value ^ new_value) & G2SB_SWITCH_G2INTERRUPT_UNDEFMASK)
            return true;
        break;
    case G2SB_SWITCH_G2INTENABLE_OFFSET:
        if ((value ^ new_value) & G2SB_SWITCH_G2INTENABLE_UNDEFMASK)
            return true;
        break;
    case G2SB_SWITCH_G2CURRENTCONTEXT_OFFSET:
        if ((value ^ new_value) & G2SB_SWITCH_G2CURRENTCONTEXT_UNDEFMASK)
            return true;
        break;
    case G2SB_SWITCH_G2NXTCXTSWITCH_OFFSET:
        if ((value ^ new_value) & G2SB_SWITCH_G2NXTCXTSWITCH_UNDEFMASK)
            return true;
        break;
    case G2SB_SWITCH_G2GLOBALCONTROL_OFFSET:
        if ((value ^ new_value) & G2SB_SWITCH_G2GLOBALCONTROL_UNDEFMASK)
            return true;
        break;
    case G2SB_SWITCH_G2GLOBALCONTROLB_OFFSET:
        if ((value ^ new_value) & G2SB_SWITCH_G2GLOBALCONTROLB_UNDEFMASK)
            return true;
        break;
    case G2SB_SWITCH_G2WORKINGSTAT_OFFSET:
        if ((value ^ new_value) & G2SB_SWITCH_G2WORKINGSTAT_UNDEFMASK)
            return true;
        break;
    case G2SB_SWITCH_G2BUFTHRESHOLD_OFFSET:
        if ((value ^ new_value) & G2SB_SWITCH_G2BUFTHRESHOLD_UNDEFMASK)
            return true;
        break;
    case G2SB_SWITCH_CLKEN_OVERIDE_OFFSET:
        if ((value ^ new_value) & G2SB_SWITCH_CLKEN_OVERIDE_UNDEFMASK)
            return true;
        break;
    case G2SB_SWITCH_G2_MCCIF_FIFOCTRL_OFFSET:
        if ((value ^ new_value) & G2SB_SWITCH_G2_MCCIF_FIFOCTRL_UNDEFMASK)
            return true;
        break;
    case G2SB_SWITCH_TIMEOUT_WCOAL_G2_OFFSET:
        if ((value ^ new_value) & G2SB_SWITCH_TIMEOUT_WCOAL_G2_UNDEFMASK)
            return true;
        break;

    default:
        break;
    }

    return false;
}


QString Gr2dDev::get_register_name(const log_entry &entry) const
{
    switch (entry.offset) {
    case G2SB_INCR_SYNCPT_OFFSET:
        return QString("G2SB_INCR_SYNCPT");
    case G2SB_INCR_SYNCPT_CNTRL_OFFSET:
        return QString("G2SB_INCR_SYNCPT_CNTRL");
    case G2SB_INCR_SYNCPT_ERROR_OFFSET:
        return QString("G2SB_INCR_SYNCPT_ERROR");
    case G2SB_G2CLASSCHANNEL_REGONLY_OFFSET:
        return QString("G2SB_G2CLASSCHANNEL_REGONLY");
    case G2SB_G2TRIGGER_OFFSET:
        return QString("G2SB_G2TRIGGER");
    case G2SB_G2TRIGGER1_OFFSET:
        return QString("G2SB_G2TRIGGER1");
    case G2SB_G2TRIGGER2_OFFSET:
        return QString("G2SB_G2TRIGGER2");
    case G2SB_G2CMDSEL_OFFSET:
        return QString("G2SB_G2CMDSEL");
    case G2SB_G2RAISE_OFFSET:
        return QString("G2SB_G2RAISE");
    case G2SB_G2HOSTSET_OFFSET:
        return QString("G2SB_G2HOSTSET");
    case G2SB_G2HOSTFIFO_OFFSET:
        return QString("G2SB_G2HOSTFIFO");
    case G2SB_G2VDDA_OFFSET:
        return QString("G2SB_G2VDDA");
    case G2SB_G2VDDAINI_OFFSET:
        return QString("G2SB_G2VDDAINI");
    case G2SB_G2HDDA_OFFSET:
        return QString("G2SB_G2HDDA");
    case G2SB_G2HDDAINILS_OFFSET:
        return QString("G2SB_G2HDDAINILS");
    case G2SB_G2CSCFIRST_OFFSET:
        return QString("G2SB_G2CSCFIRST");
    case G2SB_G2CSCSECOND_OFFSET:
        return QString("G2SB_G2CSCSECOND");
    case G2SB_G2CSCTHIRD_OFFSET:
        return QString("G2SB_G2CSCTHIRD");
    case G2SB_G2CMKEYL_OFFSET:
        return QString("G2SB_G2CMKEYL");
    case G2SB_G2CMKEYU_OFFSET:
        return QString("G2SB_G2CMKEYU");
    case G2SB_G2UBA_A_OFFSET:
        return QString("G2SB_G2UBA_A");
    case G2SB_G2VBA_A_OFFSET:
        return QString("G2SB_G2VBA_A");
    case G2SB_G2SBFORMAT_OFFSET:
        return QString("G2SB_G2SBFORMAT");
    case G2SB_G2CONTROLSB_OFFSET:
        return QString("G2SB_G2CONTROLSB");
    case G2SB_G2CONTROLSECOND_OFFSET:
        return QString("G2SB_G2CONTROLSECOND");
    case G2SB_G2CONTROLMAIN_OFFSET:
        return QString("G2SB_G2CONTROLMAIN");
    case G2SB_G2ROPFADE_OFFSET:
        return QString("G2SB_G2ROPFADE");
    case G2SB_G2ALPHABLEND_OFFSET:
        return QString("G2SB_G2ALPHABLEND");
    case G2SB_G2CLIPLEFTTOP_OFFSET:
        return QString("G2SB_G2CLIPLEFTTOP");
    case G2SB_G2CLIPRIGHTBOT_OFFSET:
        return QString("G2SB_G2CLIPRIGHTBOT");
    case G2SB_G2PATPACK_OFFSET:
        return QString("G2SB_G2PATPACK");
    case G2SB_G2PATPACK_SIZE_OFFSET:
        return QString("G2SB_G2PATPACK_SIZE");
    case G2SB_G2PATBA_OFFSET:
        return QString("G2SB_G2PATBA");
    case G2SB_G2PATOS_OFFSET:
        return QString("G2SB_G2PATOS");
    case G2SB_G2PATBGC_OFFSET:
        return QString("G2SB_G2PATBGC");
    case G2SB_G2PATFGC_OFFSET:
        return QString("G2SB_G2PATFGC");
    case G2SB_G2PATKEY_OFFSET:
        return QString("G2SB_G2PATKEY");
    case G2SB_G2DSTBA_OFFSET:
        return QString("G2SB_G2DSTBA");
    case G2SB_G2DSTBA_B_OFFSET:
        return QString("G2SB_G2DSTBA_B");
    case G2SB_G2DSTBA_C_OFFSET:
        return QString("G2SB_G2DSTBA_C");
    case G2SB_G2DSTST_OFFSET:
        return QString("G2SB_G2DSTST");
    case G2SB_G2SRCPACK_OFFSET:
        return QString("G2SB_G2SRCPACK");
    case G2SB_G2SRCPACK_SIZE_OFFSET:
        return QString("G2SB_G2SRCPACK_SIZE");
    case G2SB_G2SRCBA_OFFSET:
        return QString("G2SB_G2SRCBA");
    case G2SB_G2SRCBA_B_OFFSET:
        return QString("G2SB_G2SRCBA_B");
    case G2SB_G2SRCST_OFFSET:
        return QString("G2SB_G2SRCST");
    case G2SB_G2SRCBGC_OFFSET:
        return QString("G2SB_G2SRCBGC");
    case G2SB_G2SRCFGC_OFFSET:
        return QString("G2SB_G2SRCFGC");
    case G2SB_G2SRCKEY_OFFSET:
        return QString("G2SB_G2SRCKEY");
    case G2SB_G2SRCSIZE_OFFSET:
        return QString("G2SB_G2SRCSIZE");
    case G2SB_G2DSTSIZE_OFFSET:
        return QString("G2SB_G2DSTSIZE");
    case G2SB_G2SRCPS_OFFSET:
        return QString("G2SB_G2SRCPS");
    case G2SB_G2DSTPS_OFFSET:
        return QString("G2SB_G2DSTPS");
    case G2SB_G2CBDES_OFFSET:
        return QString("G2SB_G2CBDES");
    case G2SB_G2CBSTRIDE_OFFSET:
        return QString("G2SB_G2CBSTRIDE");
    case G2SB_G2LINESETTING_OFFSET:
        return QString("G2SB_G2LINESETTING");
    case G2SB_G2LINEDELTAN_OFFSET:
        return QString("G2SB_G2LINEDELTAN");
    case G2SB_G2LINEDELTAM_OFFSET:
        return QString("G2SB_G2LINEDELTAM");
    case G2SB_G2LINEPOS_OFFSET:
        return QString("G2SB_G2LINEPOS");
    case G2SB_G2LINELEN_OFFSET:
        return QString("G2SB_G2LINELEN");
    case G2SB_G2CSCFOURTH_OFFSET:
        return QString("G2SB_G2CSCFOURTH");
    case G2SB_G2SRCST_B_OFFSET:
        return QString("G2SB_G2SRCST_B");
    case G2SB_G2UVSTRIDE_OFFSET:
        return QString("G2SB_G2UVSTRIDE");
    case G2SB_G2CBDES2_OFFSET:
        return QString("G2SB_G2CBDES2");
    case G2SB_G2TILEMODE_OFFSET:
        return QString("G2SB_G2TILEMODE");
    case G2SB_G2PATBASE_OFFSET:
        return QString("G2SB_G2PATBASE");
    case G2SB_G2SRCBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_G2SRCBA_SB_SURFBASE");
    case G2SB_G2DSTBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_G2DSTBA_SB_SURFBASE");
    case G2SB_G2DSTBA_B_SB_SURFBASE_OFFSET:
        return QString("G2SB_G2DSTBA_B_SB_SURFBASE");
    case G2SB_G2VBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_G2VBA_A_SB_SURFBASE");
    case G2SB_G2UBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_G2UBA_A_SB_SURFBASE");
    case G2SB_CTX1_INCR_SYNCPT_OFFSET:
        return QString("G2SB_CTX1_INCR_SYNCPT");
    case G2SB_CTX1_INCR_SYNCPT_CNTRL_OFFSET:
        return QString("G2SB_CTX1_INCR_SYNCPT_CNTRL");
    case G2SB_CTX1_INCR_SYNCPT_ERROR_OFFSET:
        return QString("G2SB_CTX1_INCR_SYNCPT_ERROR");
    case G2SB_CTX1_G2CLASSCHANNEL_REGONLY_OFFSET:
        return QString("G2SB_CTX1_G2CLASSCHANNEL_REGONLY");
    case G2SB_CTX1_G2TRIGGER_OFFSET:
        return QString("G2SB_CTX1_G2TRIGGER");
    case G2SB_CTX1_G2TRIGGER1_OFFSET:
        return QString("G2SB_CTX1_G2TRIGGER1");
    case G2SB_CTX1_G2TRIGGER2_OFFSET:
        return QString("G2SB_CTX1_G2TRIGGER2");
    case G2SB_CTX1_G2CMDSEL_OFFSET:
        return QString("G2SB_CTX1_G2CMDSEL");
    case G2SB_CTX1_G2RAISE_OFFSET:
        return QString("G2SB_CTX1_G2RAISE");
    case G2SB_CTX1_G2HOSTSET_OFFSET:
        return QString("G2SB_CTX1_G2HOSTSET");
    case G2SB_CTX1_G2HOSTFIFO_OFFSET:
        return QString("G2SB_CTX1_G2HOSTFIFO");
    case G2SB_CTX1_G2VDDA_OFFSET:
        return QString("G2SB_CTX1_G2VDDA");
    case G2SB_CTX1_G2VDDAINI_OFFSET:
        return QString("G2SB_CTX1_G2VDDAINI");
    case G2SB_CTX1_G2HDDA_OFFSET:
        return QString("G2SB_CTX1_G2HDDA");
    case G2SB_CTX1_G2HDDAINILS_OFFSET:
        return QString("G2SB_CTX1_G2HDDAINILS");
    case G2SB_CTX1_G2CSCFIRST_OFFSET:
        return QString("G2SB_CTX1_G2CSCFIRST");
    case G2SB_CTX1_G2CSCSECOND_OFFSET:
        return QString("G2SB_CTX1_G2CSCSECOND");
    case G2SB_CTX1_G2CSCTHIRD_OFFSET:
        return QString("G2SB_CTX1_G2CSCTHIRD");
    case G2SB_CTX1_G2CMKEYL_OFFSET:
        return QString("G2SB_CTX1_G2CMKEYL");
    case G2SB_CTX1_G2CMKEYU_OFFSET:
        return QString("G2SB_CTX1_G2CMKEYU");
    case G2SB_CTX1_G2UBA_A_OFFSET:
        return QString("G2SB_CTX1_G2UBA_A");
    case G2SB_CTX1_G2VBA_A_OFFSET:
        return QString("G2SB_CTX1_G2VBA_A");
    case G2SB_CTX1_G2SBFORMAT_OFFSET:
        return QString("G2SB_CTX1_G2SBFORMAT");
    case G2SB_CTX1_G2CONTROLSB_OFFSET:
        return QString("G2SB_CTX1_G2CONTROLSB");
    case G2SB_CTX1_G2CONTROLSECOND_OFFSET:
        return QString("G2SB_CTX1_G2CONTROLSECOND");
    case G2SB_CTX1_G2CONTROLMAIN_OFFSET:
        return QString("G2SB_CTX1_G2CONTROLMAIN");
    case G2SB_CTX1_G2ROPFADE_OFFSET:
        return QString("G2SB_CTX1_G2ROPFADE");
    case G2SB_CTX1_G2ALPHABLEND_OFFSET:
        return QString("G2SB_CTX1_G2ALPHABLEND");
    case G2SB_CTX1_G2CLIPLEFTTOP_OFFSET:
        return QString("G2SB_CTX1_G2CLIPLEFTTOP");
    case G2SB_CTX1_G2CLIPRIGHTBOT_OFFSET:
        return QString("G2SB_CTX1_G2CLIPRIGHTBOT");
    case G2SB_CTX1_G2PATPACK_OFFSET:
        return QString("G2SB_CTX1_G2PATPACK");
    case G2SB_CTX1_G2PATPACK_SIZE_OFFSET:
        return QString("G2SB_CTX1_G2PATPACK_SIZE");
    case G2SB_CTX1_G2PATBA_OFFSET:
        return QString("G2SB_CTX1_G2PATBA");
    case G2SB_CTX1_G2PATOS_OFFSET:
        return QString("G2SB_CTX1_G2PATOS");
    case G2SB_CTX1_G2PATBGC_OFFSET:
        return QString("G2SB_CTX1_G2PATBGC");
    case G2SB_CTX1_G2PATFGC_OFFSET:
        return QString("G2SB_CTX1_G2PATFGC");
    case G2SB_CTX1_G2PATKEY_OFFSET:
        return QString("G2SB_CTX1_G2PATKEY");
    case G2SB_CTX1_G2DSTBA_OFFSET:
        return QString("G2SB_CTX1_G2DSTBA");
    case G2SB_CTX1_G2DSTBA_B_OFFSET:
        return QString("G2SB_CTX1_G2DSTBA_B");
    case G2SB_CTX1_G2DSTBA_C_OFFSET:
        return QString("G2SB_CTX1_G2DSTBA_C");
    case G2SB_CTX1_G2DSTST_OFFSET:
        return QString("G2SB_CTX1_G2DSTST");
    case G2SB_CTX1_G2SRCPACK_OFFSET:
        return QString("G2SB_CTX1_G2SRCPACK");
    case G2SB_CTX1_G2SRCPACK_SIZE_OFFSET:
        return QString("G2SB_CTX1_G2SRCPACK_SIZE");
    case G2SB_CTX1_G2SRCBA_OFFSET:
        return QString("G2SB_CTX1_G2SRCBA");
    case G2SB_CTX1_G2SRCBA_B_OFFSET:
        return QString("G2SB_CTX1_G2SRCBA_B");
    case G2SB_CTX1_G2SRCST_OFFSET:
        return QString("G2SB_CTX1_G2SRCST");
    case G2SB_CTX1_G2SRCBGC_OFFSET:
        return QString("G2SB_CTX1_G2SRCBGC");
    case G2SB_CTX1_G2SRCFGC_OFFSET:
        return QString("G2SB_CTX1_G2SRCFGC");
    case G2SB_CTX1_G2SRCKEY_OFFSET:
        return QString("G2SB_CTX1_G2SRCKEY");
    case G2SB_CTX1_G2SRCSIZE_OFFSET:
        return QString("G2SB_CTX1_G2SRCSIZE");
    case G2SB_CTX1_G2DSTSIZE_OFFSET:
        return QString("G2SB_CTX1_G2DSTSIZE");
    case G2SB_CTX1_G2SRCPS_OFFSET:
        return QString("G2SB_CTX1_G2SRCPS");
    case G2SB_CTX1_G2DSTPS_OFFSET:
        return QString("G2SB_CTX1_G2DSTPS");
    case G2SB_CTX1_G2CBDES_OFFSET:
        return QString("G2SB_CTX1_G2CBDES");
    case G2SB_CTX1_G2CBSTRIDE_OFFSET:
        return QString("G2SB_CTX1_G2CBSTRIDE");
    case G2SB_CTX1_G2LINESETTING_OFFSET:
        return QString("G2SB_CTX1_G2LINESETTING");
    case G2SB_CTX1_G2LINEDELTAN_OFFSET:
        return QString("G2SB_CTX1_G2LINEDELTAN");
    case G2SB_CTX1_G2LINEDELTAM_OFFSET:
        return QString("G2SB_CTX1_G2LINEDELTAM");
    case G2SB_CTX1_G2LINEPOS_OFFSET:
        return QString("G2SB_CTX1_G2LINEPOS");
    case G2SB_CTX1_G2LINELEN_OFFSET:
        return QString("G2SB_CTX1_G2LINELEN");
    case G2SB_CTX1_G2CSCFOURTH_OFFSET:
        return QString("G2SB_CTX1_G2CSCFOURTH");
    case G2SB_CTX1_G2SRCST_B_OFFSET:
        return QString("G2SB_CTX1_G2SRCST_B");
    case G2SB_CTX1_G2UVSTRIDE_OFFSET:
        return QString("G2SB_CTX1_G2UVSTRIDE");
    case G2SB_CTX1_G2CBDES2_OFFSET:
        return QString("G2SB_CTX1_G2CBDES2");
    case G2SB_CTX1_G2TILEMODE_OFFSET:
        return QString("G2SB_CTX1_G2TILEMODE");
    case G2SB_CTX1_G2PATBASE_OFFSET:
        return QString("G2SB_CTX1_G2PATBASE");
    case G2SB_CTX1_G2SRCBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX1_G2SRCBA_SB_SURFBASE");
    case G2SB_CTX1_G2DSTBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX1_G2DSTBA_SB_SURFBASE");
    case G2SB_CTX1_G2DSTBA_B_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX1_G2DSTBA_B_SB_SURFBASE");
    case G2SB_CTX1_G2VBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX1_G2VBA_A_SB_SURFBASE");
    case G2SB_CTX1_G2UBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX1_G2UBA_A_SB_SURFBASE");
    case G2SB_CTX2_INCR_SYNCPT_OFFSET:
        return QString("G2SB_CTX2_INCR_SYNCPT");
    case G2SB_CTX2_INCR_SYNCPT_CNTRL_OFFSET:
        return QString("G2SB_CTX2_INCR_SYNCPT_CNTRL");
    case G2SB_CTX2_INCR_SYNCPT_ERROR_OFFSET:
        return QString("G2SB_CTX2_INCR_SYNCPT_ERROR");
    case G2SB_CTX2_G2CLASSCHANNEL_REGONLY_OFFSET:
        return QString("G2SB_CTX2_G2CLASSCHANNEL_REGONLY");
    case G2SB_CTX2_G2TRIGGER_OFFSET:
        return QString("G2SB_CTX2_G2TRIGGER");
    case G2SB_CTX2_G2TRIGGER1_OFFSET:
        return QString("G2SB_CTX2_G2TRIGGER1");
    case G2SB_CTX2_G2TRIGGER2_OFFSET:
        return QString("G2SB_CTX2_G2TRIGGER2");
    case G2SB_CTX2_G2CMDSEL_OFFSET:
        return QString("G2SB_CTX2_G2CMDSEL");
    case G2SB_CTX2_G2RAISE_OFFSET:
        return QString("G2SB_CTX2_G2RAISE");
    case G2SB_CTX2_G2HOSTSET_OFFSET:
        return QString("G2SB_CTX2_G2HOSTSET");
    case G2SB_CTX2_G2HOSTFIFO_OFFSET:
        return QString("G2SB_CTX2_G2HOSTFIFO");
    case G2SB_CTX2_G2VDDA_OFFSET:
        return QString("G2SB_CTX2_G2VDDA");
    case G2SB_CTX2_G2VDDAINI_OFFSET:
        return QString("G2SB_CTX2_G2VDDAINI");
    case G2SB_CTX2_G2HDDA_OFFSET:
        return QString("G2SB_CTX2_G2HDDA");
    case G2SB_CTX2_G2HDDAINILS_OFFSET:
        return QString("G2SB_CTX2_G2HDDAINILS");
    case G2SB_CTX2_G2CSCFIRST_OFFSET:
        return QString("G2SB_CTX2_G2CSCFIRST");
    case G2SB_CTX2_G2CSCSECOND_OFFSET:
        return QString("G2SB_CTX2_G2CSCSECOND");
    case G2SB_CTX2_G2CSCTHIRD_OFFSET:
        return QString("G2SB_CTX2_G2CSCTHIRD");
    case G2SB_CTX2_G2CMKEYL_OFFSET:
        return QString("G2SB_CTX2_G2CMKEYL");
    case G2SB_CTX2_G2CMKEYU_OFFSET:
        return QString("G2SB_CTX2_G2CMKEYU");
    case G2SB_CTX2_G2UBA_A_OFFSET:
        return QString("G2SB_CTX2_G2UBA_A");
    case G2SB_CTX2_G2VBA_A_OFFSET:
        return QString("G2SB_CTX2_G2VBA_A");
    case G2SB_CTX2_G2SBFORMAT_OFFSET:
        return QString("G2SB_CTX2_G2SBFORMAT");
    case G2SB_CTX2_G2CONTROLSB_OFFSET:
        return QString("G2SB_CTX2_G2CONTROLSB");
    case G2SB_CTX2_G2CONTROLSECOND_OFFSET:
        return QString("G2SB_CTX2_G2CONTROLSECOND");
    case G2SB_CTX2_G2CONTROLMAIN_OFFSET:
        return QString("G2SB_CTX2_G2CONTROLMAIN");
    case G2SB_CTX2_G2ROPFADE_OFFSET:
        return QString("G2SB_CTX2_G2ROPFADE");
    case G2SB_CTX2_G2ALPHABLEND_OFFSET:
        return QString("G2SB_CTX2_G2ALPHABLEND");
    case G2SB_CTX2_G2CLIPLEFTTOP_OFFSET:
        return QString("G2SB_CTX2_G2CLIPLEFTTOP");
    case G2SB_CTX2_G2CLIPRIGHTBOT_OFFSET:
        return QString("G2SB_CTX2_G2CLIPRIGHTBOT");
    case G2SB_CTX2_G2PATPACK_OFFSET:
        return QString("G2SB_CTX2_G2PATPACK");
    case G2SB_CTX2_G2PATPACK_SIZE_OFFSET:
        return QString("G2SB_CTX2_G2PATPACK_SIZE");
    case G2SB_CTX2_G2PATBA_OFFSET:
        return QString("G2SB_CTX2_G2PATBA");
    case G2SB_CTX2_G2PATOS_OFFSET:
        return QString("G2SB_CTX2_G2PATOS");
    case G2SB_CTX2_G2PATBGC_OFFSET:
        return QString("G2SB_CTX2_G2PATBGC");
    case G2SB_CTX2_G2PATFGC_OFFSET:
        return QString("G2SB_CTX2_G2PATFGC");
    case G2SB_CTX2_G2PATKEY_OFFSET:
        return QString("G2SB_CTX2_G2PATKEY");
    case G2SB_CTX2_G2DSTBA_OFFSET:
        return QString("G2SB_CTX2_G2DSTBA");
    case G2SB_CTX2_G2DSTBA_B_OFFSET:
        return QString("G2SB_CTX2_G2DSTBA_B");
    case G2SB_CTX2_G2DSTBA_C_OFFSET:
        return QString("G2SB_CTX2_G2DSTBA_C");
    case G2SB_CTX2_G2DSTST_OFFSET:
        return QString("G2SB_CTX2_G2DSTST");
    case G2SB_CTX2_G2SRCPACK_OFFSET:
        return QString("G2SB_CTX2_G2SRCPACK");
    case G2SB_CTX2_G2SRCPACK_SIZE_OFFSET:
        return QString("G2SB_CTX2_G2SRCPACK_SIZE");
    case G2SB_CTX2_G2SRCBA_OFFSET:
        return QString("G2SB_CTX2_G2SRCBA");
    case G2SB_CTX2_G2SRCBA_B_OFFSET:
        return QString("G2SB_CTX2_G2SRCBA_B");
    case G2SB_CTX2_G2SRCST_OFFSET:
        return QString("G2SB_CTX2_G2SRCST");
    case G2SB_CTX2_G2SRCBGC_OFFSET:
        return QString("G2SB_CTX2_G2SRCBGC");
    case G2SB_CTX2_G2SRCFGC_OFFSET:
        return QString("G2SB_CTX2_G2SRCFGC");
    case G2SB_CTX2_G2SRCKEY_OFFSET:
        return QString("G2SB_CTX2_G2SRCKEY");
    case G2SB_CTX2_G2SRCSIZE_OFFSET:
        return QString("G2SB_CTX2_G2SRCSIZE");
    case G2SB_CTX2_G2DSTSIZE_OFFSET:
        return QString("G2SB_CTX2_G2DSTSIZE");
    case G2SB_CTX2_G2SRCPS_OFFSET:
        return QString("G2SB_CTX2_G2SRCPS");
    case G2SB_CTX2_G2DSTPS_OFFSET:
        return QString("G2SB_CTX2_G2DSTPS");
    case G2SB_CTX2_G2CBDES_OFFSET:
        return QString("G2SB_CTX2_G2CBDES");
    case G2SB_CTX2_G2CBSTRIDE_OFFSET:
        return QString("G2SB_CTX2_G2CBSTRIDE");
    case G2SB_CTX2_G2LINESETTING_OFFSET:
        return QString("G2SB_CTX2_G2LINESETTING");
    case G2SB_CTX2_G2LINEDELTAN_OFFSET:
        return QString("G2SB_CTX2_G2LINEDELTAN");
    case G2SB_CTX2_G2LINEDELTAM_OFFSET:
        return QString("G2SB_CTX2_G2LINEDELTAM");
    case G2SB_CTX2_G2LINEPOS_OFFSET:
        return QString("G2SB_CTX2_G2LINEPOS");
    case G2SB_CTX2_G2LINELEN_OFFSET:
        return QString("G2SB_CTX2_G2LINELEN");
    case G2SB_CTX2_G2CSCFOURTH_OFFSET:
        return QString("G2SB_CTX2_G2CSCFOURTH");
    case G2SB_CTX2_G2SRCST_B_OFFSET:
        return QString("G2SB_CTX2_G2SRCST_B");
    case G2SB_CTX2_G2UVSTRIDE_OFFSET:
        return QString("G2SB_CTX2_G2UVSTRIDE");
    case G2SB_CTX2_G2CBDES2_OFFSET:
        return QString("G2SB_CTX2_G2CBDES2");
    case G2SB_CTX2_G2TILEMODE_OFFSET:
        return QString("G2SB_CTX2_G2TILEMODE");
    case G2SB_CTX2_G2PATBASE_OFFSET:
        return QString("G2SB_CTX2_G2PATBASE");
    case G2SB_CTX2_G2SRCBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX2_G2SRCBA_SB_SURFBASE");
    case G2SB_CTX2_G2DSTBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX2_G2DSTBA_SB_SURFBASE");
    case G2SB_CTX2_G2DSTBA_B_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX2_G2DSTBA_B_SB_SURFBASE");
    case G2SB_CTX2_G2VBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX2_G2VBA_A_SB_SURFBASE");
    case G2SB_CTX2_G2UBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX2_G2UBA_A_SB_SURFBASE");
    case G2SB_CTX3_INCR_SYNCPT_OFFSET:
        return QString("G2SB_CTX3_INCR_SYNCPT");
    case G2SB_CTX3_INCR_SYNCPT_CNTRL_OFFSET:
        return QString("G2SB_CTX3_INCR_SYNCPT_CNTRL");
    case G2SB_CTX3_INCR_SYNCPT_ERROR_OFFSET:
        return QString("G2SB_CTX3_INCR_SYNCPT_ERROR");
    case G2SB_CTX3_G2CLASSCHANNEL_REGONLY_OFFSET:
        return QString("G2SB_CTX3_G2CLASSCHANNEL_REGONLY");
    case G2SB_CTX3_G2TRIGGER_OFFSET:
        return QString("G2SB_CTX3_G2TRIGGER");
    case G2SB_CTX3_G2TRIGGER1_OFFSET:
        return QString("G2SB_CTX3_G2TRIGGER1");
    case G2SB_CTX3_G2TRIGGER2_OFFSET:
        return QString("G2SB_CTX3_G2TRIGGER2");
    case G2SB_CTX3_G2CMDSEL_OFFSET:
        return QString("G2SB_CTX3_G2CMDSEL");
    case G2SB_CTX3_G2RAISE_OFFSET:
        return QString("G2SB_CTX3_G2RAISE");
    case G2SB_CTX3_G2HOSTSET_OFFSET:
        return QString("G2SB_CTX3_G2HOSTSET");
    case G2SB_CTX3_G2HOSTFIFO_OFFSET:
        return QString("G2SB_CTX3_G2HOSTFIFO");
    case G2SB_CTX3_G2VDDA_OFFSET:
        return QString("G2SB_CTX3_G2VDDA");
    case G2SB_CTX3_G2VDDAINI_OFFSET:
        return QString("G2SB_CTX3_G2VDDAINI");
    case G2SB_CTX3_G2HDDA_OFFSET:
        return QString("G2SB_CTX3_G2HDDA");
    case G2SB_CTX3_G2HDDAINILS_OFFSET:
        return QString("G2SB_CTX3_G2HDDAINILS");
    case G2SB_CTX3_G2CSCFIRST_OFFSET:
        return QString("G2SB_CTX3_G2CSCFIRST");
    case G2SB_CTX3_G2CSCSECOND_OFFSET:
        return QString("G2SB_CTX3_G2CSCSECOND");
    case G2SB_CTX3_G2CSCTHIRD_OFFSET:
        return QString("G2SB_CTX3_G2CSCTHIRD");
    case G2SB_CTX3_G2CMKEYL_OFFSET:
        return QString("G2SB_CTX3_G2CMKEYL");
    case G2SB_CTX3_G2CMKEYU_OFFSET:
        return QString("G2SB_CTX3_G2CMKEYU");
    case G2SB_CTX3_G2UBA_A_OFFSET:
        return QString("G2SB_CTX3_G2UBA_A");
    case G2SB_CTX3_G2VBA_A_OFFSET:
        return QString("G2SB_CTX3_G2VBA_A");
    case G2SB_CTX3_G2SBFORMAT_OFFSET:
        return QString("G2SB_CTX3_G2SBFORMAT");
    case G2SB_CTX3_G2CONTROLSB_OFFSET:
        return QString("G2SB_CTX3_G2CONTROLSB");
    case G2SB_CTX3_G2CONTROLSECOND_OFFSET:
        return QString("G2SB_CTX3_G2CONTROLSECOND");
    case G2SB_CTX3_G2CONTROLMAIN_OFFSET:
        return QString("G2SB_CTX3_G2CONTROLMAIN");
    case G2SB_CTX3_G2ROPFADE_OFFSET:
        return QString("G2SB_CTX3_G2ROPFADE");
    case G2SB_CTX3_G2ALPHABLEND_OFFSET:
        return QString("G2SB_CTX3_G2ALPHABLEND");
    case G2SB_CTX3_G2CLIPLEFTTOP_OFFSET:
        return QString("G2SB_CTX3_G2CLIPLEFTTOP");
    case G2SB_CTX3_G2CLIPRIGHTBOT_OFFSET:
        return QString("G2SB_CTX3_G2CLIPRIGHTBOT");
    case G2SB_CTX3_G2PATPACK_OFFSET:
        return QString("G2SB_CTX3_G2PATPACK");
    case G2SB_CTX3_G2PATPACK_SIZE_OFFSET:
        return QString("G2SB_CTX3_G2PATPACK_SIZE");
    case G2SB_CTX3_G2PATBA_OFFSET:
        return QString("G2SB_CTX3_G2PATBA");
    case G2SB_CTX3_G2PATOS_OFFSET:
        return QString("G2SB_CTX3_G2PATOS");
    case G2SB_CTX3_G2PATBGC_OFFSET:
        return QString("G2SB_CTX3_G2PATBGC");
    case G2SB_CTX3_G2PATFGC_OFFSET:
        return QString("G2SB_CTX3_G2PATFGC");
    case G2SB_CTX3_G2PATKEY_OFFSET:
        return QString("G2SB_CTX3_G2PATKEY");
    case G2SB_CTX3_G2DSTBA_OFFSET:
        return QString("G2SB_CTX3_G2DSTBA");
    case G2SB_CTX3_G2DSTBA_B_OFFSET:
        return QString("G2SB_CTX3_G2DSTBA_B");
    case G2SB_CTX3_G2DSTBA_C_OFFSET:
        return QString("G2SB_CTX3_G2DSTBA_C");
    case G2SB_CTX3_G2DSTST_OFFSET:
        return QString("G2SB_CTX3_G2DSTST");
    case G2SB_CTX3_G2SRCPACK_OFFSET:
        return QString("G2SB_CTX3_G2SRCPACK");
    case G2SB_CTX3_G2SRCPACK_SIZE_OFFSET:
        return QString("G2SB_CTX3_G2SRCPACK_SIZE");
    case G2SB_CTX3_G2SRCBA_OFFSET:
        return QString("G2SB_CTX3_G2SRCBA");
    case G2SB_CTX3_G2SRCBA_B_OFFSET:
        return QString("G2SB_CTX3_G2SRCBA_B");
    case G2SB_CTX3_G2SRCST_OFFSET:
        return QString("G2SB_CTX3_G2SRCST");
    case G2SB_CTX3_G2SRCBGC_OFFSET:
        return QString("G2SB_CTX3_G2SRCBGC");
    case G2SB_CTX3_G2SRCFGC_OFFSET:
        return QString("G2SB_CTX3_G2SRCFGC");
    case G2SB_CTX3_G2SRCKEY_OFFSET:
        return QString("G2SB_CTX3_G2SRCKEY");
    case G2SB_CTX3_G2SRCSIZE_OFFSET:
        return QString("G2SB_CTX3_G2SRCSIZE");
    case G2SB_CTX3_G2DSTSIZE_OFFSET:
        return QString("G2SB_CTX3_G2DSTSIZE");
    case G2SB_CTX3_G2SRCPS_OFFSET:
        return QString("G2SB_CTX3_G2SRCPS");
    case G2SB_CTX3_G2DSTPS_OFFSET:
        return QString("G2SB_CTX3_G2DSTPS");
    case G2SB_CTX3_G2CBDES_OFFSET:
        return QString("G2SB_CTX3_G2CBDES");
    case G2SB_CTX3_G2CBSTRIDE_OFFSET:
        return QString("G2SB_CTX3_G2CBSTRIDE");
    case G2SB_CTX3_G2LINESETTING_OFFSET:
        return QString("G2SB_CTX3_G2LINESETTING");
    case G2SB_CTX3_G2LINEDELTAN_OFFSET:
        return QString("G2SB_CTX3_G2LINEDELTAN");
    case G2SB_CTX3_G2LINEDELTAM_OFFSET:
        return QString("G2SB_CTX3_G2LINEDELTAM");
    case G2SB_CTX3_G2LINEPOS_OFFSET:
        return QString("G2SB_CTX3_G2LINEPOS");
    case G2SB_CTX3_G2LINELEN_OFFSET:
        return QString("G2SB_CTX3_G2LINELEN");
    case G2SB_CTX3_G2CSCFOURTH_OFFSET:
        return QString("G2SB_CTX3_G2CSCFOURTH");
    case G2SB_CTX3_G2SRCST_B_OFFSET:
        return QString("G2SB_CTX3_G2SRCST_B");
    case G2SB_CTX3_G2UVSTRIDE_OFFSET:
        return QString("G2SB_CTX3_G2UVSTRIDE");
    case G2SB_CTX3_G2CBDES2_OFFSET:
        return QString("G2SB_CTX3_G2CBDES2");
    case G2SB_CTX3_G2TILEMODE_OFFSET:
        return QString("G2SB_CTX3_G2TILEMODE");
    case G2SB_CTX3_G2PATBASE_OFFSET:
        return QString("G2SB_CTX3_G2PATBASE");
    case G2SB_CTX3_G2SRCBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX3_G2SRCBA_SB_SURFBASE");
    case G2SB_CTX3_G2DSTBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX3_G2DSTBA_SB_SURFBASE");
    case G2SB_CTX3_G2DSTBA_B_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX3_G2DSTBA_B_SB_SURFBASE");
    case G2SB_CTX3_G2VBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX3_G2VBA_A_SB_SURFBASE");
    case G2SB_CTX3_G2UBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX3_G2UBA_A_SB_SURFBASE");
    case G2SB_CTX4_INCR_SYNCPT_OFFSET:
        return QString("G2SB_CTX4_INCR_SYNCPT");
    case G2SB_CTX4_INCR_SYNCPT_CNTRL_OFFSET:
        return QString("G2SB_CTX4_INCR_SYNCPT_CNTRL");
    case G2SB_CTX4_INCR_SYNCPT_ERROR_OFFSET:
        return QString("G2SB_CTX4_INCR_SYNCPT_ERROR");
    case G2SB_CTX4_G2CLASSCHANNEL_REGONLY_OFFSET:
        return QString("G2SB_CTX4_G2CLASSCHANNEL_REGONLY");
    case G2SB_CTX4_G2TRIGGER_OFFSET:
        return QString("G2SB_CTX4_G2TRIGGER");
    case G2SB_CTX4_G2TRIGGER1_OFFSET:
        return QString("G2SB_CTX4_G2TRIGGER1");
    case G2SB_CTX4_G2TRIGGER2_OFFSET:
        return QString("G2SB_CTX4_G2TRIGGER2");
    case G2SB_CTX4_G2CMDSEL_OFFSET:
        return QString("G2SB_CTX4_G2CMDSEL");
    case G2SB_CTX4_G2RAISE_OFFSET:
        return QString("G2SB_CTX4_G2RAISE");
    case G2SB_CTX4_G2HOSTSET_OFFSET:
        return QString("G2SB_CTX4_G2HOSTSET");
    case G2SB_CTX4_G2HOSTFIFO_OFFSET:
        return QString("G2SB_CTX4_G2HOSTFIFO");
    case G2SB_CTX4_G2VDDA_OFFSET:
        return QString("G2SB_CTX4_G2VDDA");
    case G2SB_CTX4_G2VDDAINI_OFFSET:
        return QString("G2SB_CTX4_G2VDDAINI");
    case G2SB_CTX4_G2HDDA_OFFSET:
        return QString("G2SB_CTX4_G2HDDA");
    case G2SB_CTX4_G2HDDAINILS_OFFSET:
        return QString("G2SB_CTX4_G2HDDAINILS");
    case G2SB_CTX4_G2CSCFIRST_OFFSET:
        return QString("G2SB_CTX4_G2CSCFIRST");
    case G2SB_CTX4_G2CSCSECOND_OFFSET:
        return QString("G2SB_CTX4_G2CSCSECOND");
    case G2SB_CTX4_G2CSCTHIRD_OFFSET:
        return QString("G2SB_CTX4_G2CSCTHIRD");
    case G2SB_CTX4_G2CMKEYL_OFFSET:
        return QString("G2SB_CTX4_G2CMKEYL");
    case G2SB_CTX4_G2CMKEYU_OFFSET:
        return QString("G2SB_CTX4_G2CMKEYU");
    case G2SB_CTX4_G2UBA_A_OFFSET:
        return QString("G2SB_CTX4_G2UBA_A");
    case G2SB_CTX4_G2VBA_A_OFFSET:
        return QString("G2SB_CTX4_G2VBA_A");
    case G2SB_CTX4_G2SBFORMAT_OFFSET:
        return QString("G2SB_CTX4_G2SBFORMAT");
    case G2SB_CTX4_G2CONTROLSB_OFFSET:
        return QString("G2SB_CTX4_G2CONTROLSB");
    case G2SB_CTX4_G2CONTROLSECOND_OFFSET:
        return QString("G2SB_CTX4_G2CONTROLSECOND");
    case G2SB_CTX4_G2CONTROLMAIN_OFFSET:
        return QString("G2SB_CTX4_G2CONTROLMAIN");
    case G2SB_CTX4_G2ROPFADE_OFFSET:
        return QString("G2SB_CTX4_G2ROPFADE");
    case G2SB_CTX4_G2ALPHABLEND_OFFSET:
        return QString("G2SB_CTX4_G2ALPHABLEND");
    case G2SB_CTX4_G2CLIPLEFTTOP_OFFSET:
        return QString("G2SB_CTX4_G2CLIPLEFTTOP");
    case G2SB_CTX4_G2CLIPRIGHTBOT_OFFSET:
        return QString("G2SB_CTX4_G2CLIPRIGHTBOT");
    case G2SB_CTX4_G2PATPACK_OFFSET:
        return QString("G2SB_CTX4_G2PATPACK");
    case G2SB_CTX4_G2PATPACK_SIZE_OFFSET:
        return QString("G2SB_CTX4_G2PATPACK_SIZE");
    case G2SB_CTX4_G2PATBA_OFFSET:
        return QString("G2SB_CTX4_G2PATBA");
    case G2SB_CTX4_G2PATOS_OFFSET:
        return QString("G2SB_CTX4_G2PATOS");
    case G2SB_CTX4_G2PATBGC_OFFSET:
        return QString("G2SB_CTX4_G2PATBGC");
    case G2SB_CTX4_G2PATFGC_OFFSET:
        return QString("G2SB_CTX4_G2PATFGC");
    case G2SB_CTX4_G2PATKEY_OFFSET:
        return QString("G2SB_CTX4_G2PATKEY");
    case G2SB_CTX4_G2DSTBA_OFFSET:
        return QString("G2SB_CTX4_G2DSTBA");
    case G2SB_CTX4_G2DSTBA_B_OFFSET:
        return QString("G2SB_CTX4_G2DSTBA_B");
    case G2SB_CTX4_G2DSTBA_C_OFFSET:
        return QString("G2SB_CTX4_G2DSTBA_C");
    case G2SB_CTX4_G2DSTST_OFFSET:
        return QString("G2SB_CTX4_G2DSTST");
    case G2SB_CTX4_G2SRCPACK_OFFSET:
        return QString("G2SB_CTX4_G2SRCPACK");
    case G2SB_CTX4_G2SRCPACK_SIZE_OFFSET:
        return QString("G2SB_CTX4_G2SRCPACK_SIZE");
    case G2SB_CTX4_G2SRCBA_OFFSET:
        return QString("G2SB_CTX4_G2SRCBA");
    case G2SB_CTX4_G2SRCBA_B_OFFSET:
        return QString("G2SB_CTX4_G2SRCBA_B");
    case G2SB_CTX4_G2SRCST_OFFSET:
        return QString("G2SB_CTX4_G2SRCST");
    case G2SB_CTX4_G2SRCBGC_OFFSET:
        return QString("G2SB_CTX4_G2SRCBGC");
    case G2SB_CTX4_G2SRCFGC_OFFSET:
        return QString("G2SB_CTX4_G2SRCFGC");
    case G2SB_CTX4_G2SRCKEY_OFFSET:
        return QString("G2SB_CTX4_G2SRCKEY");
    case G2SB_CTX4_G2SRCSIZE_OFFSET:
        return QString("G2SB_CTX4_G2SRCSIZE");
    case G2SB_CTX4_G2DSTSIZE_OFFSET:
        return QString("G2SB_CTX4_G2DSTSIZE");
    case G2SB_CTX4_G2SRCPS_OFFSET:
        return QString("G2SB_CTX4_G2SRCPS");
    case G2SB_CTX4_G2DSTPS_OFFSET:
        return QString("G2SB_CTX4_G2DSTPS");
    case G2SB_CTX4_G2CBDES_OFFSET:
        return QString("G2SB_CTX4_G2CBDES");
    case G2SB_CTX4_G2CBSTRIDE_OFFSET:
        return QString("G2SB_CTX4_G2CBSTRIDE");
    case G2SB_CTX4_G2LINESETTING_OFFSET:
        return QString("G2SB_CTX4_G2LINESETTING");
    case G2SB_CTX4_G2LINEDELTAN_OFFSET:
        return QString("G2SB_CTX4_G2LINEDELTAN");
    case G2SB_CTX4_G2LINEDELTAM_OFFSET:
        return QString("G2SB_CTX4_G2LINEDELTAM");
    case G2SB_CTX4_G2LINEPOS_OFFSET:
        return QString("G2SB_CTX4_G2LINEPOS");
    case G2SB_CTX4_G2LINELEN_OFFSET:
        return QString("G2SB_CTX4_G2LINELEN");
    case G2SB_CTX4_G2CSCFOURTH_OFFSET:
        return QString("G2SB_CTX4_G2CSCFOURTH");
    case G2SB_CTX4_G2SRCST_B_OFFSET:
        return QString("G2SB_CTX4_G2SRCST_B");
    case G2SB_CTX4_G2UVSTRIDE_OFFSET:
        return QString("G2SB_CTX4_G2UVSTRIDE");
    case G2SB_CTX4_G2CBDES2_OFFSET:
        return QString("G2SB_CTX4_G2CBDES2");
    case G2SB_CTX4_G2TILEMODE_OFFSET:
        return QString("G2SB_CTX4_G2TILEMODE");
    case G2SB_CTX4_G2PATBASE_OFFSET:
        return QString("G2SB_CTX4_G2PATBASE");
    case G2SB_CTX4_G2SRCBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX4_G2SRCBA_SB_SURFBASE");
    case G2SB_CTX4_G2DSTBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX4_G2DSTBA_SB_SURFBASE");
    case G2SB_CTX4_G2DSTBA_B_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX4_G2DSTBA_B_SB_SURFBASE");
    case G2SB_CTX4_G2VBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX4_G2VBA_A_SB_SURFBASE");
    case G2SB_CTX4_G2UBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX4_G2UBA_A_SB_SURFBASE");
    case G2SB_CTX5_INCR_SYNCPT_OFFSET:
        return QString("G2SB_CTX5_INCR_SYNCPT");
    case G2SB_CTX5_INCR_SYNCPT_CNTRL_OFFSET:
        return QString("G2SB_CTX5_INCR_SYNCPT_CNTRL");
    case G2SB_CTX5_INCR_SYNCPT_ERROR_OFFSET:
        return QString("G2SB_CTX5_INCR_SYNCPT_ERROR");
    case G2SB_CTX5_G2CLASSCHANNEL_REGONLY_OFFSET:
        return QString("G2SB_CTX5_G2CLASSCHANNEL_REGONLY");
    case G2SB_CTX5_G2TRIGGER_OFFSET:
        return QString("G2SB_CTX5_G2TRIGGER");
    case G2SB_CTX5_G2TRIGGER1_OFFSET:
        return QString("G2SB_CTX5_G2TRIGGER1");
    case G2SB_CTX5_G2TRIGGER2_OFFSET:
        return QString("G2SB_CTX5_G2TRIGGER2");
    case G2SB_CTX5_G2CMDSEL_OFFSET:
        return QString("G2SB_CTX5_G2CMDSEL");
    case G2SB_CTX5_G2RAISE_OFFSET:
        return QString("G2SB_CTX5_G2RAISE");
    case G2SB_CTX5_G2HOSTSET_OFFSET:
        return QString("G2SB_CTX5_G2HOSTSET");
    case G2SB_CTX5_G2HOSTFIFO_OFFSET:
        return QString("G2SB_CTX5_G2HOSTFIFO");
    case G2SB_CTX5_G2VDDA_OFFSET:
        return QString("G2SB_CTX5_G2VDDA");
    case G2SB_CTX5_G2VDDAINI_OFFSET:
        return QString("G2SB_CTX5_G2VDDAINI");
    case G2SB_CTX5_G2HDDA_OFFSET:
        return QString("G2SB_CTX5_G2HDDA");
    case G2SB_CTX5_G2HDDAINILS_OFFSET:
        return QString("G2SB_CTX5_G2HDDAINILS");
    case G2SB_CTX5_G2CSCFIRST_OFFSET:
        return QString("G2SB_CTX5_G2CSCFIRST");
    case G2SB_CTX5_G2CSCSECOND_OFFSET:
        return QString("G2SB_CTX5_G2CSCSECOND");
    case G2SB_CTX5_G2CSCTHIRD_OFFSET:
        return QString("G2SB_CTX5_G2CSCTHIRD");
    case G2SB_CTX5_G2CMKEYL_OFFSET:
        return QString("G2SB_CTX5_G2CMKEYL");
    case G2SB_CTX5_G2CMKEYU_OFFSET:
        return QString("G2SB_CTX5_G2CMKEYU");
    case G2SB_CTX5_G2UBA_A_OFFSET:
        return QString("G2SB_CTX5_G2UBA_A");
    case G2SB_CTX5_G2VBA_A_OFFSET:
        return QString("G2SB_CTX5_G2VBA_A");
    case G2SB_CTX5_G2SBFORMAT_OFFSET:
        return QString("G2SB_CTX5_G2SBFORMAT");
    case G2SB_CTX5_G2CONTROLSB_OFFSET:
        return QString("G2SB_CTX5_G2CONTROLSB");
    case G2SB_CTX5_G2CONTROLSECOND_OFFSET:
        return QString("G2SB_CTX5_G2CONTROLSECOND");
    case G2SB_CTX5_G2CONTROLMAIN_OFFSET:
        return QString("G2SB_CTX5_G2CONTROLMAIN");
    case G2SB_CTX5_G2ROPFADE_OFFSET:
        return QString("G2SB_CTX5_G2ROPFADE");
    case G2SB_CTX5_G2ALPHABLEND_OFFSET:
        return QString("G2SB_CTX5_G2ALPHABLEND");
    case G2SB_CTX5_G2CLIPLEFTTOP_OFFSET:
        return QString("G2SB_CTX5_G2CLIPLEFTTOP");
    case G2SB_CTX5_G2CLIPRIGHTBOT_OFFSET:
        return QString("G2SB_CTX5_G2CLIPRIGHTBOT");
    case G2SB_CTX5_G2PATPACK_OFFSET:
        return QString("G2SB_CTX5_G2PATPACK");
    case G2SB_CTX5_G2PATPACK_SIZE_OFFSET:
        return QString("G2SB_CTX5_G2PATPACK_SIZE");
    case G2SB_CTX5_G2PATBA_OFFSET:
        return QString("G2SB_CTX5_G2PATBA");
    case G2SB_CTX5_G2PATOS_OFFSET:
        return QString("G2SB_CTX5_G2PATOS");
    case G2SB_CTX5_G2PATBGC_OFFSET:
        return QString("G2SB_CTX5_G2PATBGC");
    case G2SB_CTX5_G2PATFGC_OFFSET:
        return QString("G2SB_CTX5_G2PATFGC");
    case G2SB_CTX5_G2PATKEY_OFFSET:
        return QString("G2SB_CTX5_G2PATKEY");
    case G2SB_CTX5_G2DSTBA_OFFSET:
        return QString("G2SB_CTX5_G2DSTBA");
    case G2SB_CTX5_G2DSTBA_B_OFFSET:
        return QString("G2SB_CTX5_G2DSTBA_B");
    case G2SB_CTX5_G2DSTBA_C_OFFSET:
        return QString("G2SB_CTX5_G2DSTBA_C");
    case G2SB_CTX5_G2DSTST_OFFSET:
        return QString("G2SB_CTX5_G2DSTST");
    case G2SB_CTX5_G2SRCPACK_OFFSET:
        return QString("G2SB_CTX5_G2SRCPACK");
    case G2SB_CTX5_G2SRCPACK_SIZE_OFFSET:
        return QString("G2SB_CTX5_G2SRCPACK_SIZE");
    case G2SB_CTX5_G2SRCBA_OFFSET:
        return QString("G2SB_CTX5_G2SRCBA");
    case G2SB_CTX5_G2SRCBA_B_OFFSET:
        return QString("G2SB_CTX5_G2SRCBA_B");
    case G2SB_CTX5_G2SRCST_OFFSET:
        return QString("G2SB_CTX5_G2SRCST");
    case G2SB_CTX5_G2SRCBGC_OFFSET:
        return QString("G2SB_CTX5_G2SRCBGC");
    case G2SB_CTX5_G2SRCFGC_OFFSET:
        return QString("G2SB_CTX5_G2SRCFGC");
    case G2SB_CTX5_G2SRCKEY_OFFSET:
        return QString("G2SB_CTX5_G2SRCKEY");
    case G2SB_CTX5_G2SRCSIZE_OFFSET:
        return QString("G2SB_CTX5_G2SRCSIZE");
    case G2SB_CTX5_G2DSTSIZE_OFFSET:
        return QString("G2SB_CTX5_G2DSTSIZE");
    case G2SB_CTX5_G2SRCPS_OFFSET:
        return QString("G2SB_CTX5_G2SRCPS");
    case G2SB_CTX5_G2DSTPS_OFFSET:
        return QString("G2SB_CTX5_G2DSTPS");
    case G2SB_CTX5_G2CBDES_OFFSET:
        return QString("G2SB_CTX5_G2CBDES");
    case G2SB_CTX5_G2CBSTRIDE_OFFSET:
        return QString("G2SB_CTX5_G2CBSTRIDE");
    case G2SB_CTX5_G2LINESETTING_OFFSET:
        return QString("G2SB_CTX5_G2LINESETTING");
    case G2SB_CTX5_G2LINEDELTAN_OFFSET:
        return QString("G2SB_CTX5_G2LINEDELTAN");
    case G2SB_CTX5_G2LINEDELTAM_OFFSET:
        return QString("G2SB_CTX5_G2LINEDELTAM");
    case G2SB_CTX5_G2LINEPOS_OFFSET:
        return QString("G2SB_CTX5_G2LINEPOS");
    case G2SB_CTX5_G2LINELEN_OFFSET:
        return QString("G2SB_CTX5_G2LINELEN");
    case G2SB_CTX5_G2CSCFOURTH_OFFSET:
        return QString("G2SB_CTX5_G2CSCFOURTH");
    case G2SB_CTX5_G2SRCST_B_OFFSET:
        return QString("G2SB_CTX5_G2SRCST_B");
    case G2SB_CTX5_G2UVSTRIDE_OFFSET:
        return QString("G2SB_CTX5_G2UVSTRIDE");
    case G2SB_CTX5_G2CBDES2_OFFSET:
        return QString("G2SB_CTX5_G2CBDES2");
    case G2SB_CTX5_G2TILEMODE_OFFSET:
        return QString("G2SB_CTX5_G2TILEMODE");
    case G2SB_CTX5_G2PATBASE_OFFSET:
        return QString("G2SB_CTX5_G2PATBASE");
    case G2SB_CTX5_G2SRCBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX5_G2SRCBA_SB_SURFBASE");
    case G2SB_CTX5_G2DSTBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX5_G2DSTBA_SB_SURFBASE");
    case G2SB_CTX5_G2DSTBA_B_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX5_G2DSTBA_B_SB_SURFBASE");
    case G2SB_CTX5_G2VBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX5_G2VBA_A_SB_SURFBASE");
    case G2SB_CTX5_G2UBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX5_G2UBA_A_SB_SURFBASE");
    case G2SB_CTX6_INCR_SYNCPT_OFFSET:
        return QString("G2SB_CTX6_INCR_SYNCPT");
    case G2SB_CTX6_INCR_SYNCPT_CNTRL_OFFSET:
        return QString("G2SB_CTX6_INCR_SYNCPT_CNTRL");
    case G2SB_CTX6_INCR_SYNCPT_ERROR_OFFSET:
        return QString("G2SB_CTX6_INCR_SYNCPT_ERROR");
    case G2SB_CTX6_G2CLASSCHANNEL_REGONLY_OFFSET:
        return QString("G2SB_CTX6_G2CLASSCHANNEL_REGONLY");
    case G2SB_CTX6_G2TRIGGER_OFFSET:
        return QString("G2SB_CTX6_G2TRIGGER");
    case G2SB_CTX6_G2TRIGGER1_OFFSET:
        return QString("G2SB_CTX6_G2TRIGGER1");
    case G2SB_CTX6_G2TRIGGER2_OFFSET:
        return QString("G2SB_CTX6_G2TRIGGER2");
    case G2SB_CTX6_G2CMDSEL_OFFSET:
        return QString("G2SB_CTX6_G2CMDSEL");
    case G2SB_CTX6_G2RAISE_OFFSET:
        return QString("G2SB_CTX6_G2RAISE");
    case G2SB_CTX6_G2HOSTSET_OFFSET:
        return QString("G2SB_CTX6_G2HOSTSET");
    case G2SB_CTX6_G2HOSTFIFO_OFFSET:
        return QString("G2SB_CTX6_G2HOSTFIFO");
    case G2SB_CTX6_G2VDDA_OFFSET:
        return QString("G2SB_CTX6_G2VDDA");
    case G2SB_CTX6_G2VDDAINI_OFFSET:
        return QString("G2SB_CTX6_G2VDDAINI");
    case G2SB_CTX6_G2HDDA_OFFSET:
        return QString("G2SB_CTX6_G2HDDA");
    case G2SB_CTX6_G2HDDAINILS_OFFSET:
        return QString("G2SB_CTX6_G2HDDAINILS");
    case G2SB_CTX6_G2CSCFIRST_OFFSET:
        return QString("G2SB_CTX6_G2CSCFIRST");
    case G2SB_CTX6_G2CSCSECOND_OFFSET:
        return QString("G2SB_CTX6_G2CSCSECOND");
    case G2SB_CTX6_G2CSCTHIRD_OFFSET:
        return QString("G2SB_CTX6_G2CSCTHIRD");
    case G2SB_CTX6_G2CMKEYL_OFFSET:
        return QString("G2SB_CTX6_G2CMKEYL");
    case G2SB_CTX6_G2CMKEYU_OFFSET:
        return QString("G2SB_CTX6_G2CMKEYU");
    case G2SB_CTX6_G2UBA_A_OFFSET:
        return QString("G2SB_CTX6_G2UBA_A");
    case G2SB_CTX6_G2VBA_A_OFFSET:
        return QString("G2SB_CTX6_G2VBA_A");
    case G2SB_CTX6_G2SBFORMAT_OFFSET:
        return QString("G2SB_CTX6_G2SBFORMAT");
    case G2SB_CTX6_G2CONTROLSB_OFFSET:
        return QString("G2SB_CTX6_G2CONTROLSB");
    case G2SB_CTX6_G2CONTROLSECOND_OFFSET:
        return QString("G2SB_CTX6_G2CONTROLSECOND");
    case G2SB_CTX6_G2CONTROLMAIN_OFFSET:
        return QString("G2SB_CTX6_G2CONTROLMAIN");
    case G2SB_CTX6_G2ROPFADE_OFFSET:
        return QString("G2SB_CTX6_G2ROPFADE");
    case G2SB_CTX6_G2ALPHABLEND_OFFSET:
        return QString("G2SB_CTX6_G2ALPHABLEND");
    case G2SB_CTX6_G2CLIPLEFTTOP_OFFSET:
        return QString("G2SB_CTX6_G2CLIPLEFTTOP");
    case G2SB_CTX6_G2CLIPRIGHTBOT_OFFSET:
        return QString("G2SB_CTX6_G2CLIPRIGHTBOT");
    case G2SB_CTX6_G2PATPACK_OFFSET:
        return QString("G2SB_CTX6_G2PATPACK");
    case G2SB_CTX6_G2PATPACK_SIZE_OFFSET:
        return QString("G2SB_CTX6_G2PATPACK_SIZE");
    case G2SB_CTX6_G2PATBA_OFFSET:
        return QString("G2SB_CTX6_G2PATBA");
    case G2SB_CTX6_G2PATOS_OFFSET:
        return QString("G2SB_CTX6_G2PATOS");
    case G2SB_CTX6_G2PATBGC_OFFSET:
        return QString("G2SB_CTX6_G2PATBGC");
    case G2SB_CTX6_G2PATFGC_OFFSET:
        return QString("G2SB_CTX6_G2PATFGC");
    case G2SB_CTX6_G2PATKEY_OFFSET:
        return QString("G2SB_CTX6_G2PATKEY");
    case G2SB_CTX6_G2DSTBA_OFFSET:
        return QString("G2SB_CTX6_G2DSTBA");
    case G2SB_CTX6_G2DSTBA_B_OFFSET:
        return QString("G2SB_CTX6_G2DSTBA_B");
    case G2SB_CTX6_G2DSTBA_C_OFFSET:
        return QString("G2SB_CTX6_G2DSTBA_C");
    case G2SB_CTX6_G2DSTST_OFFSET:
        return QString("G2SB_CTX6_G2DSTST");
    case G2SB_CTX6_G2SRCPACK_OFFSET:
        return QString("G2SB_CTX6_G2SRCPACK");
    case G2SB_CTX6_G2SRCPACK_SIZE_OFFSET:
        return QString("G2SB_CTX6_G2SRCPACK_SIZE");
    case G2SB_CTX6_G2SRCBA_OFFSET:
        return QString("G2SB_CTX6_G2SRCBA");
    case G2SB_CTX6_G2SRCBA_B_OFFSET:
        return QString("G2SB_CTX6_G2SRCBA_B");
    case G2SB_CTX6_G2SRCST_OFFSET:
        return QString("G2SB_CTX6_G2SRCST");
    case G2SB_CTX6_G2SRCBGC_OFFSET:
        return QString("G2SB_CTX6_G2SRCBGC");
    case G2SB_CTX6_G2SRCFGC_OFFSET:
        return QString("G2SB_CTX6_G2SRCFGC");
    case G2SB_CTX6_G2SRCKEY_OFFSET:
        return QString("G2SB_CTX6_G2SRCKEY");
    case G2SB_CTX6_G2SRCSIZE_OFFSET:
        return QString("G2SB_CTX6_G2SRCSIZE");
    case G2SB_CTX6_G2DSTSIZE_OFFSET:
        return QString("G2SB_CTX6_G2DSTSIZE");
    case G2SB_CTX6_G2SRCPS_OFFSET:
        return QString("G2SB_CTX6_G2SRCPS");
    case G2SB_CTX6_G2DSTPS_OFFSET:
        return QString("G2SB_CTX6_G2DSTPS");
    case G2SB_CTX6_G2CBDES_OFFSET:
        return QString("G2SB_CTX6_G2CBDES");
    case G2SB_CTX6_G2CBSTRIDE_OFFSET:
        return QString("G2SB_CTX6_G2CBSTRIDE");
    case G2SB_CTX6_G2LINESETTING_OFFSET:
        return QString("G2SB_CTX6_G2LINESETTING");
    case G2SB_CTX6_G2LINEDELTAN_OFFSET:
        return QString("G2SB_CTX6_G2LINEDELTAN");
    case G2SB_CTX6_G2LINEDELTAM_OFFSET:
        return QString("G2SB_CTX6_G2LINEDELTAM");
    case G2SB_CTX6_G2LINEPOS_OFFSET:
        return QString("G2SB_CTX6_G2LINEPOS");
    case G2SB_CTX6_G2LINELEN_OFFSET:
        return QString("G2SB_CTX6_G2LINELEN");
    case G2SB_CTX6_G2CSCFOURTH_OFFSET:
        return QString("G2SB_CTX6_G2CSCFOURTH");
    case G2SB_CTX6_G2SRCST_B_OFFSET:
        return QString("G2SB_CTX6_G2SRCST_B");
    case G2SB_CTX6_G2UVSTRIDE_OFFSET:
        return QString("G2SB_CTX6_G2UVSTRIDE");
    case G2SB_CTX6_G2CBDES2_OFFSET:
        return QString("G2SB_CTX6_G2CBDES2");
    case G2SB_CTX6_G2TILEMODE_OFFSET:
        return QString("G2SB_CTX6_G2TILEMODE");
    case G2SB_CTX6_G2PATBASE_OFFSET:
        return QString("G2SB_CTX6_G2PATBASE");
    case G2SB_CTX6_G2SRCBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX6_G2SRCBA_SB_SURFBASE");
    case G2SB_CTX6_G2DSTBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX6_G2DSTBA_SB_SURFBASE");
    case G2SB_CTX6_G2DSTBA_B_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX6_G2DSTBA_B_SB_SURFBASE");
    case G2SB_CTX6_G2VBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX6_G2VBA_A_SB_SURFBASE");
    case G2SB_CTX6_G2UBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX6_G2UBA_A_SB_SURFBASE");
    case G2SB_CTX7_INCR_SYNCPT_OFFSET:
        return QString("G2SB_CTX7_INCR_SYNCPT");
    case G2SB_CTX7_INCR_SYNCPT_CNTRL_OFFSET:
        return QString("G2SB_CTX7_INCR_SYNCPT_CNTRL");
    case G2SB_CTX7_INCR_SYNCPT_ERROR_OFFSET:
        return QString("G2SB_CTX7_INCR_SYNCPT_ERROR");
    case G2SB_CTX7_G2CLASSCHANNEL_REGONLY_OFFSET:
        return QString("G2SB_CTX7_G2CLASSCHANNEL_REGONLY");
    case G2SB_CTX7_G2TRIGGER_OFFSET:
        return QString("G2SB_CTX7_G2TRIGGER");
    case G2SB_CTX7_G2TRIGGER1_OFFSET:
        return QString("G2SB_CTX7_G2TRIGGER1");
    case G2SB_CTX7_G2TRIGGER2_OFFSET:
        return QString("G2SB_CTX7_G2TRIGGER2");
    case G2SB_CTX7_G2CMDSEL_OFFSET:
        return QString("G2SB_CTX7_G2CMDSEL");
    case G2SB_CTX7_G2RAISE_OFFSET:
        return QString("G2SB_CTX7_G2RAISE");
    case G2SB_CTX7_G2HOSTSET_OFFSET:
        return QString("G2SB_CTX7_G2HOSTSET");
    case G2SB_CTX7_G2HOSTFIFO_OFFSET:
        return QString("G2SB_CTX7_G2HOSTFIFO");
    case G2SB_CTX7_G2VDDA_OFFSET:
        return QString("G2SB_CTX7_G2VDDA");
    case G2SB_CTX7_G2VDDAINI_OFFSET:
        return QString("G2SB_CTX7_G2VDDAINI");
    case G2SB_CTX7_G2HDDA_OFFSET:
        return QString("G2SB_CTX7_G2HDDA");
    case G2SB_CTX7_G2HDDAINILS_OFFSET:
        return QString("G2SB_CTX7_G2HDDAINILS");
    case G2SB_CTX7_G2CSCFIRST_OFFSET:
        return QString("G2SB_CTX7_G2CSCFIRST");
    case G2SB_CTX7_G2CSCSECOND_OFFSET:
        return QString("G2SB_CTX7_G2CSCSECOND");
    case G2SB_CTX7_G2CSCTHIRD_OFFSET:
        return QString("G2SB_CTX7_G2CSCTHIRD");
    case G2SB_CTX7_G2CMKEYL_OFFSET:
        return QString("G2SB_CTX7_G2CMKEYL");
    case G2SB_CTX7_G2CMKEYU_OFFSET:
        return QString("G2SB_CTX7_G2CMKEYU");
    case G2SB_CTX7_G2UBA_A_OFFSET:
        return QString("G2SB_CTX7_G2UBA_A");
    case G2SB_CTX7_G2VBA_A_OFFSET:
        return QString("G2SB_CTX7_G2VBA_A");
    case G2SB_CTX7_G2SBFORMAT_OFFSET:
        return QString("G2SB_CTX7_G2SBFORMAT");
    case G2SB_CTX7_G2CONTROLSB_OFFSET:
        return QString("G2SB_CTX7_G2CONTROLSB");
    case G2SB_CTX7_G2CONTROLSECOND_OFFSET:
        return QString("G2SB_CTX7_G2CONTROLSECOND");
    case G2SB_CTX7_G2CONTROLMAIN_OFFSET:
        return QString("G2SB_CTX7_G2CONTROLMAIN");
    case G2SB_CTX7_G2ROPFADE_OFFSET:
        return QString("G2SB_CTX7_G2ROPFADE");
    case G2SB_CTX7_G2ALPHABLEND_OFFSET:
        return QString("G2SB_CTX7_G2ALPHABLEND");
    case G2SB_CTX7_G2CLIPLEFTTOP_OFFSET:
        return QString("G2SB_CTX7_G2CLIPLEFTTOP");
    case G2SB_CTX7_G2CLIPRIGHTBOT_OFFSET:
        return QString("G2SB_CTX7_G2CLIPRIGHTBOT");
    case G2SB_CTX7_G2PATPACK_OFFSET:
        return QString("G2SB_CTX7_G2PATPACK");
    case G2SB_CTX7_G2PATPACK_SIZE_OFFSET:
        return QString("G2SB_CTX7_G2PATPACK_SIZE");
    case G2SB_CTX7_G2PATBA_OFFSET:
        return QString("G2SB_CTX7_G2PATBA");
    case G2SB_CTX7_G2PATOS_OFFSET:
        return QString("G2SB_CTX7_G2PATOS");
    case G2SB_CTX7_G2PATBGC_OFFSET:
        return QString("G2SB_CTX7_G2PATBGC");
    case G2SB_CTX7_G2PATFGC_OFFSET:
        return QString("G2SB_CTX7_G2PATFGC");
    case G2SB_CTX7_G2PATKEY_OFFSET:
        return QString("G2SB_CTX7_G2PATKEY");
    case G2SB_CTX7_G2DSTBA_OFFSET:
        return QString("G2SB_CTX7_G2DSTBA");
    case G2SB_CTX7_G2DSTBA_B_OFFSET:
        return QString("G2SB_CTX7_G2DSTBA_B");
    case G2SB_CTX7_G2DSTBA_C_OFFSET:
        return QString("G2SB_CTX7_G2DSTBA_C");
    case G2SB_CTX7_G2DSTST_OFFSET:
        return QString("G2SB_CTX7_G2DSTST");
    case G2SB_CTX7_G2SRCPACK_OFFSET:
        return QString("G2SB_CTX7_G2SRCPACK");
    case G2SB_CTX7_G2SRCPACK_SIZE_OFFSET:
        return QString("G2SB_CTX7_G2SRCPACK_SIZE");
    case G2SB_CTX7_G2SRCBA_OFFSET:
        return QString("G2SB_CTX7_G2SRCBA");
    case G2SB_CTX7_G2SRCBA_B_OFFSET:
        return QString("G2SB_CTX7_G2SRCBA_B");
    case G2SB_CTX7_G2SRCST_OFFSET:
        return QString("G2SB_CTX7_G2SRCST");
    case G2SB_CTX7_G2SRCBGC_OFFSET:
        return QString("G2SB_CTX7_G2SRCBGC");
    case G2SB_CTX7_G2SRCFGC_OFFSET:
        return QString("G2SB_CTX7_G2SRCFGC");
    case G2SB_CTX7_G2SRCKEY_OFFSET:
        return QString("G2SB_CTX7_G2SRCKEY");
    case G2SB_CTX7_G2SRCSIZE_OFFSET:
        return QString("G2SB_CTX7_G2SRCSIZE");
    case G2SB_CTX7_G2DSTSIZE_OFFSET:
        return QString("G2SB_CTX7_G2DSTSIZE");
    case G2SB_CTX7_G2SRCPS_OFFSET:
        return QString("G2SB_CTX7_G2SRCPS");
    case G2SB_CTX7_G2DSTPS_OFFSET:
        return QString("G2SB_CTX7_G2DSTPS");
    case G2SB_CTX7_G2CBDES_OFFSET:
        return QString("G2SB_CTX7_G2CBDES");
    case G2SB_CTX7_G2CBSTRIDE_OFFSET:
        return QString("G2SB_CTX7_G2CBSTRIDE");
    case G2SB_CTX7_G2LINESETTING_OFFSET:
        return QString("G2SB_CTX7_G2LINESETTING");
    case G2SB_CTX7_G2LINEDELTAN_OFFSET:
        return QString("G2SB_CTX7_G2LINEDELTAN");
    case G2SB_CTX7_G2LINEDELTAM_OFFSET:
        return QString("G2SB_CTX7_G2LINEDELTAM");
    case G2SB_CTX7_G2LINEPOS_OFFSET:
        return QString("G2SB_CTX7_G2LINEPOS");
    case G2SB_CTX7_G2LINELEN_OFFSET:
        return QString("G2SB_CTX7_G2LINELEN");
    case G2SB_CTX7_G2CSCFOURTH_OFFSET:
        return QString("G2SB_CTX7_G2CSCFOURTH");
    case G2SB_CTX7_G2SRCST_B_OFFSET:
        return QString("G2SB_CTX7_G2SRCST_B");
    case G2SB_CTX7_G2UVSTRIDE_OFFSET:
        return QString("G2SB_CTX7_G2UVSTRIDE");
    case G2SB_CTX7_G2CBDES2_OFFSET:
        return QString("G2SB_CTX7_G2CBDES2");
    case G2SB_CTX7_G2TILEMODE_OFFSET:
        return QString("G2SB_CTX7_G2TILEMODE");
    case G2SB_CTX7_G2PATBASE_OFFSET:
        return QString("G2SB_CTX7_G2PATBASE");
    case G2SB_CTX7_G2SRCBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX7_G2SRCBA_SB_SURFBASE");
    case G2SB_CTX7_G2DSTBA_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX7_G2DSTBA_SB_SURFBASE");
    case G2SB_CTX7_G2DSTBA_B_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX7_G2DSTBA_B_SB_SURFBASE");
    case G2SB_CTX7_G2VBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX7_G2VBA_A_SB_SURFBASE");
    case G2SB_CTX7_G2UBA_A_SB_SURFBASE_OFFSET:
        return QString("G2SB_CTX7_G2UBA_A_SB_SURFBASE");
    case G2SB_SWITCH_G2INTERRUPT_OFFSET:
        return QString("G2SB_SWITCH_G2INTERRUPT");
    case G2SB_SWITCH_G2INTENABLE_OFFSET:
        return QString("G2SB_SWITCH_G2INTENABLE");
    case G2SB_SWITCH_G2CURRENTCONTEXT_OFFSET:
        return QString("G2SB_SWITCH_G2CURRENTCONTEXT");
    case G2SB_SWITCH_G2NXTCXTSWITCH_OFFSET:
        return QString("G2SB_SWITCH_G2NXTCXTSWITCH");
    case G2SB_SWITCH_G2GLOBALCONTROL_OFFSET:
        return QString("G2SB_SWITCH_G2GLOBALCONTROL");
    case G2SB_SWITCH_G2GLOBALCONTROLB_OFFSET:
        return QString("G2SB_SWITCH_G2GLOBALCONTROLB");
    case G2SB_SWITCH_G2WORKINGSTAT_OFFSET:
        return QString("G2SB_SWITCH_G2WORKINGSTAT");
    case G2SB_SWITCH_G2BUFTHRESHOLD_OFFSET:
        return QString("G2SB_SWITCH_G2BUFTHRESHOLD");
    case G2SB_SWITCH_CLKEN_OVERIDE_OFFSET:
        return QString("G2SB_SWITCH_CLKEN_OVERIDE");
    case G2SB_SWITCH_G2_MCCIF_FIFOCTRL_OFFSET:
        return QString("G2SB_SWITCH_G2_MCCIF_FIFOCTRL");
    case G2SB_SWITCH_TIMEOUT_WCOAL_G2_OFFSET:
        return QString("G2SB_SWITCH_TIMEOUT_WCOAL_G2");

    default:
        break;
    }

    qDebug() << QString().sprintf("GR2D: %s: Ooops... 0x%x", __func__, entry.offset);

    return QString().sprintf("Ooops... @0x%X", entry.offset);
}

void Gr2dDev::fill_bits_details(const u_int32_t &offset,
                                      const u_int32_t &value, const u_int32_t &new_value)
{
    switch (offset) {
    case G2SB_INCR_SYNCPT_OFFSET:
        fill_g2sb_incr_syncpt_details(value, new_value);
        break;
    case G2SB_INCR_SYNCPT_CNTRL_OFFSET:
        fill_g2sb_incr_syncpt_cntrl_details(value, new_value);
        break;
    case G2SB_INCR_SYNCPT_ERROR_OFFSET:
        fill_g2sb_incr_syncpt_error_details(value, new_value);
        break;
    case G2SB_G2CLASSCHANNEL_REGONLY_OFFSET:
        fill_g2sb_g2classchannel_regonly_details(value, new_value);
        break;
    case G2SB_G2TRIGGER_OFFSET:
        fill_g2sb_g2trigger_details(value, new_value);
        break;
    case G2SB_G2TRIGGER1_OFFSET:
        fill_g2sb_g2trigger1_details(value, new_value);
        break;
    case G2SB_G2TRIGGER2_OFFSET:
        fill_g2sb_g2trigger2_details(value, new_value);
        break;
    case G2SB_G2CMDSEL_OFFSET:
        fill_g2sb_g2cmdsel_details(value, new_value);
        break;
    case G2SB_G2RAISE_OFFSET:
        fill_g2sb_g2raise_details(value, new_value);
        break;
    case G2SB_G2HOSTSET_OFFSET:
        fill_g2sb_g2hostset_details(value, new_value);
        break;
    case G2SB_G2HOSTFIFO_OFFSET:
        fill_g2sb_g2hostfifo_details(value, new_value);
        break;
    case G2SB_G2VDDA_OFFSET:
        fill_g2sb_g2vdda_details(value, new_value);
        break;
    case G2SB_G2VDDAINI_OFFSET:
        fill_g2sb_g2vddaini_details(value, new_value);
        break;
    case G2SB_G2HDDA_OFFSET:
        fill_g2sb_g2hdda_details(value, new_value);
        break;
    case G2SB_G2HDDAINILS_OFFSET:
        fill_g2sb_g2hddainils_details(value, new_value);
        break;
    case G2SB_G2CSCFIRST_OFFSET:
        fill_g2sb_g2cscfirst_details(value, new_value);
        break;
    case G2SB_G2CSCSECOND_OFFSET:
        fill_g2sb_g2cscsecond_details(value, new_value);
        break;
    case G2SB_G2CSCTHIRD_OFFSET:
        fill_g2sb_g2cscthird_details(value, new_value);
        break;
    case G2SB_G2CMKEYL_OFFSET:
        fill_g2sb_g2cmkeyl_details(value, new_value);
        break;
    case G2SB_G2CMKEYU_OFFSET:
        fill_g2sb_g2cmkeyu_details(value, new_value);
        break;
    case G2SB_G2UBA_A_OFFSET:
        fill_g2sb_g2uba_a_details(value, new_value);
        break;
    case G2SB_G2VBA_A_OFFSET:
        fill_g2sb_g2vba_a_details(value, new_value);
        break;
    case G2SB_G2SBFORMAT_OFFSET:
        fill_g2sb_g2sbformat_details(value, new_value);
        break;
    case G2SB_G2CONTROLSB_OFFSET:
        fill_g2sb_g2controlsb_details(value, new_value);
        break;
    case G2SB_G2CONTROLSECOND_OFFSET:
        fill_g2sb_g2controlsecond_details(value, new_value);
        break;
    case G2SB_G2CONTROLMAIN_OFFSET:
        fill_g2sb_g2controlmain_details(value, new_value);
        break;
    case G2SB_G2ROPFADE_OFFSET:
        fill_g2sb_g2ropfade_details(value, new_value);
        break;
    case G2SB_G2ALPHABLEND_OFFSET:
        fill_g2sb_g2alphablend_details(value, new_value);
        break;
    case G2SB_G2CLIPLEFTTOP_OFFSET:
        fill_g2sb_g2cliplefttop_details(value, new_value);
        break;
    case G2SB_G2CLIPRIGHTBOT_OFFSET:
        fill_g2sb_g2cliprightbot_details(value, new_value);
        break;
    case G2SB_G2PATPACK_OFFSET:
        fill_g2sb_g2patpack_details(value, new_value);
        break;
    case G2SB_G2PATPACK_SIZE_OFFSET:
        fill_g2sb_g2patpack_size_details(value, new_value);
        break;
    case G2SB_G2PATBA_OFFSET:
        fill_g2sb_g2patba_details(value, new_value);
        break;
    case G2SB_G2PATOS_OFFSET:
        fill_g2sb_g2patos_details(value, new_value);
        break;
    case G2SB_G2PATBGC_OFFSET:
        fill_g2sb_g2patbgc_details(value, new_value);
        break;
    case G2SB_G2PATFGC_OFFSET:
        fill_g2sb_g2patfgc_details(value, new_value);
        break;
    case G2SB_G2PATKEY_OFFSET:
        fill_g2sb_g2patkey_details(value, new_value);
        break;
    case G2SB_G2DSTBA_OFFSET:
        fill_g2sb_g2dstba_details(value, new_value);
        break;
    case G2SB_G2DSTBA_B_OFFSET:
        fill_g2sb_g2dstba_b_details(value, new_value);
        break;
    case G2SB_G2DSTBA_C_OFFSET:
        fill_g2sb_g2dstba_c_details(value, new_value);
        break;
    case G2SB_G2DSTST_OFFSET:
        fill_g2sb_g2dstst_details(value, new_value);
        break;
    case G2SB_G2SRCPACK_OFFSET:
        fill_g2sb_g2srcpack_details(value, new_value);
        break;
    case G2SB_G2SRCPACK_SIZE_OFFSET:
        fill_g2sb_g2srcpack_size_details(value, new_value);
        break;
    case G2SB_G2SRCBA_OFFSET:
        fill_g2sb_g2srcba_details(value, new_value);
        break;
    case G2SB_G2SRCBA_B_OFFSET:
        fill_g2sb_g2srcba_b_details(value, new_value);
        break;
    case G2SB_G2SRCST_OFFSET:
        fill_g2sb_g2srcst_details(value, new_value);
        break;
    case G2SB_G2SRCBGC_OFFSET:
        fill_g2sb_g2srcbgc_details(value, new_value);
        break;
    case G2SB_G2SRCFGC_OFFSET:
        fill_g2sb_g2srcfgc_details(value, new_value);
        break;
    case G2SB_G2SRCKEY_OFFSET:
        fill_g2sb_g2srckey_details(value, new_value);
        break;
    case G2SB_G2SRCSIZE_OFFSET:
        fill_g2sb_g2srcsize_details(value, new_value);
        break;
    case G2SB_G2DSTSIZE_OFFSET:
        fill_g2sb_g2dstsize_details(value, new_value);
        break;
    case G2SB_G2SRCPS_OFFSET:
        fill_g2sb_g2srcps_details(value, new_value);
        break;
    case G2SB_G2DSTPS_OFFSET:
        fill_g2sb_g2dstps_details(value, new_value);
        break;
    case G2SB_G2CBDES_OFFSET:
        fill_g2sb_g2cbdes_details(value, new_value);
        break;
    case G2SB_G2CBSTRIDE_OFFSET:
        fill_g2sb_g2cbstride_details(value, new_value);
        break;
    case G2SB_G2LINESETTING_OFFSET:
        fill_g2sb_g2linesetting_details(value, new_value);
        break;
    case G2SB_G2LINEDELTAN_OFFSET:
        fill_g2sb_g2linedeltan_details(value, new_value);
        break;
    case G2SB_G2LINEDELTAM_OFFSET:
        fill_g2sb_g2linedeltam_details(value, new_value);
        break;
    case G2SB_G2LINEPOS_OFFSET:
        fill_g2sb_g2linepos_details(value, new_value);
        break;
    case G2SB_G2LINELEN_OFFSET:
        fill_g2sb_g2linelen_details(value, new_value);
        break;
    case G2SB_G2CSCFOURTH_OFFSET:
        fill_g2sb_g2cscfourth_details(value, new_value);
        break;
    case G2SB_G2SRCST_B_OFFSET:
        fill_g2sb_g2srcst_b_details(value, new_value);
        break;
    case G2SB_G2UVSTRIDE_OFFSET:
        fill_g2sb_g2uvstride_details(value, new_value);
        break;
    case G2SB_G2CBDES2_OFFSET:
        fill_g2sb_g2cbdes2_details(value, new_value);
        break;
    case G2SB_G2TILEMODE_OFFSET:
        fill_g2sb_g2tilemode_details(value, new_value);
        break;
    case G2SB_G2PATBASE_OFFSET:
        fill_g2sb_g2patbase_details(value, new_value);
        break;
    case G2SB_G2SRCBA_SB_SURFBASE_OFFSET:
        fill_g2sb_g2srcba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_G2DSTBA_SB_SURFBASE_OFFSET:
        fill_g2sb_g2dstba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_G2DSTBA_B_SB_SURFBASE_OFFSET:
        fill_g2sb_g2dstba_b_sb_surfbase_details(value, new_value);
        break;
    case G2SB_G2VBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_g2vba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_G2UBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_g2uba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX1_INCR_SYNCPT_OFFSET:
        fill_g2sb_ctx1_incr_syncpt_details(value, new_value);
        break;
    case G2SB_CTX1_INCR_SYNCPT_CNTRL_OFFSET:
        fill_g2sb_ctx1_incr_syncpt_cntrl_details(value, new_value);
        break;
    case G2SB_CTX1_INCR_SYNCPT_ERROR_OFFSET:
        fill_g2sb_ctx1_incr_syncpt_error_details(value, new_value);
        break;
    case G2SB_CTX1_G2CLASSCHANNEL_REGONLY_OFFSET:
        fill_g2sb_ctx1_g2classchannel_regonly_details(value, new_value);
        break;
    case G2SB_CTX1_G2TRIGGER_OFFSET:
        fill_g2sb_ctx1_g2trigger_details(value, new_value);
        break;
    case G2SB_CTX1_G2TRIGGER1_OFFSET:
        fill_g2sb_ctx1_g2trigger1_details(value, new_value);
        break;
    case G2SB_CTX1_G2TRIGGER2_OFFSET:
        fill_g2sb_ctx1_g2trigger2_details(value, new_value);
        break;
    case G2SB_CTX1_G2CMDSEL_OFFSET:
        fill_g2sb_ctx1_g2cmdsel_details(value, new_value);
        break;
    case G2SB_CTX1_G2RAISE_OFFSET:
        fill_g2sb_ctx1_g2raise_details(value, new_value);
        break;
    case G2SB_CTX1_G2HOSTSET_OFFSET:
        fill_g2sb_ctx1_g2hostset_details(value, new_value);
        break;
    case G2SB_CTX1_G2HOSTFIFO_OFFSET:
        fill_g2sb_ctx1_g2hostfifo_details(value, new_value);
        break;
    case G2SB_CTX1_G2VDDA_OFFSET:
        fill_g2sb_ctx1_g2vdda_details(value, new_value);
        break;
    case G2SB_CTX1_G2VDDAINI_OFFSET:
        fill_g2sb_ctx1_g2vddaini_details(value, new_value);
        break;
    case G2SB_CTX1_G2HDDA_OFFSET:
        fill_g2sb_ctx1_g2hdda_details(value, new_value);
        break;
    case G2SB_CTX1_G2HDDAINILS_OFFSET:
        fill_g2sb_ctx1_g2hddainils_details(value, new_value);
        break;
    case G2SB_CTX1_G2CSCFIRST_OFFSET:
        fill_g2sb_ctx1_g2cscfirst_details(value, new_value);
        break;
    case G2SB_CTX1_G2CSCSECOND_OFFSET:
        fill_g2sb_ctx1_g2cscsecond_details(value, new_value);
        break;
    case G2SB_CTX1_G2CSCTHIRD_OFFSET:
        fill_g2sb_ctx1_g2cscthird_details(value, new_value);
        break;
    case G2SB_CTX1_G2CMKEYL_OFFSET:
        fill_g2sb_ctx1_g2cmkeyl_details(value, new_value);
        break;
    case G2SB_CTX1_G2CMKEYU_OFFSET:
        fill_g2sb_ctx1_g2cmkeyu_details(value, new_value);
        break;
    case G2SB_CTX1_G2UBA_A_OFFSET:
        fill_g2sb_ctx1_g2uba_a_details(value, new_value);
        break;
    case G2SB_CTX1_G2VBA_A_OFFSET:
        fill_g2sb_ctx1_g2vba_a_details(value, new_value);
        break;
    case G2SB_CTX1_G2SBFORMAT_OFFSET:
        fill_g2sb_ctx1_g2sbformat_details(value, new_value);
        break;
    case G2SB_CTX1_G2CONTROLSB_OFFSET:
        fill_g2sb_ctx1_g2controlsb_details(value, new_value);
        break;
    case G2SB_CTX1_G2CONTROLSECOND_OFFSET:
        fill_g2sb_ctx1_g2controlsecond_details(value, new_value);
        break;
    case G2SB_CTX1_G2CONTROLMAIN_OFFSET:
        fill_g2sb_ctx1_g2controlmain_details(value, new_value);
        break;
    case G2SB_CTX1_G2ROPFADE_OFFSET:
        fill_g2sb_ctx1_g2ropfade_details(value, new_value);
        break;
    case G2SB_CTX1_G2ALPHABLEND_OFFSET:
        fill_g2sb_ctx1_g2alphablend_details(value, new_value);
        break;
    case G2SB_CTX1_G2CLIPLEFTTOP_OFFSET:
        fill_g2sb_ctx1_g2cliplefttop_details(value, new_value);
        break;
    case G2SB_CTX1_G2CLIPRIGHTBOT_OFFSET:
        fill_g2sb_ctx1_g2cliprightbot_details(value, new_value);
        break;
    case G2SB_CTX1_G2PATPACK_OFFSET:
        fill_g2sb_ctx1_g2patpack_details(value, new_value);
        break;
    case G2SB_CTX1_G2PATPACK_SIZE_OFFSET:
        fill_g2sb_ctx1_g2patpack_size_details(value, new_value);
        break;
    case G2SB_CTX1_G2PATBA_OFFSET:
        fill_g2sb_ctx1_g2patba_details(value, new_value);
        break;
    case G2SB_CTX1_G2PATOS_OFFSET:
        fill_g2sb_ctx1_g2patos_details(value, new_value);
        break;
    case G2SB_CTX1_G2PATBGC_OFFSET:
        fill_g2sb_ctx1_g2patbgc_details(value, new_value);
        break;
    case G2SB_CTX1_G2PATFGC_OFFSET:
        fill_g2sb_ctx1_g2patfgc_details(value, new_value);
        break;
    case G2SB_CTX1_G2PATKEY_OFFSET:
        fill_g2sb_ctx1_g2patkey_details(value, new_value);
        break;
    case G2SB_CTX1_G2DSTBA_OFFSET:
        fill_g2sb_ctx1_g2dstba_details(value, new_value);
        break;
    case G2SB_CTX1_G2DSTBA_B_OFFSET:
        fill_g2sb_ctx1_g2dstba_b_details(value, new_value);
        break;
    case G2SB_CTX1_G2DSTBA_C_OFFSET:
        fill_g2sb_ctx1_g2dstba_c_details(value, new_value);
        break;
    case G2SB_CTX1_G2DSTST_OFFSET:
        fill_g2sb_ctx1_g2dstst_details(value, new_value);
        break;
    case G2SB_CTX1_G2SRCPACK_OFFSET:
        fill_g2sb_ctx1_g2srcpack_details(value, new_value);
        break;
    case G2SB_CTX1_G2SRCPACK_SIZE_OFFSET:
        fill_g2sb_ctx1_g2srcpack_size_details(value, new_value);
        break;
    case G2SB_CTX1_G2SRCBA_OFFSET:
        fill_g2sb_ctx1_g2srcba_details(value, new_value);
        break;
    case G2SB_CTX1_G2SRCBA_B_OFFSET:
        fill_g2sb_ctx1_g2srcba_b_details(value, new_value);
        break;
    case G2SB_CTX1_G2SRCST_OFFSET:
        fill_g2sb_ctx1_g2srcst_details(value, new_value);
        break;
    case G2SB_CTX1_G2SRCBGC_OFFSET:
        fill_g2sb_ctx1_g2srcbgc_details(value, new_value);
        break;
    case G2SB_CTX1_G2SRCFGC_OFFSET:
        fill_g2sb_ctx1_g2srcfgc_details(value, new_value);
        break;
    case G2SB_CTX1_G2SRCKEY_OFFSET:
        fill_g2sb_ctx1_g2srckey_details(value, new_value);
        break;
    case G2SB_CTX1_G2SRCSIZE_OFFSET:
        fill_g2sb_ctx1_g2srcsize_details(value, new_value);
        break;
    case G2SB_CTX1_G2DSTSIZE_OFFSET:
        fill_g2sb_ctx1_g2dstsize_details(value, new_value);
        break;
    case G2SB_CTX1_G2SRCPS_OFFSET:
        fill_g2sb_ctx1_g2srcps_details(value, new_value);
        break;
    case G2SB_CTX1_G2DSTPS_OFFSET:
        fill_g2sb_ctx1_g2dstps_details(value, new_value);
        break;
    case G2SB_CTX1_G2CBDES_OFFSET:
        fill_g2sb_ctx1_g2cbdes_details(value, new_value);
        break;
    case G2SB_CTX1_G2CBSTRIDE_OFFSET:
        fill_g2sb_ctx1_g2cbstride_details(value, new_value);
        break;
    case G2SB_CTX1_G2LINESETTING_OFFSET:
        fill_g2sb_ctx1_g2linesetting_details(value, new_value);
        break;
    case G2SB_CTX1_G2LINEDELTAN_OFFSET:
        fill_g2sb_ctx1_g2linedeltan_details(value, new_value);
        break;
    case G2SB_CTX1_G2LINEDELTAM_OFFSET:
        fill_g2sb_ctx1_g2linedeltam_details(value, new_value);
        break;
    case G2SB_CTX1_G2LINEPOS_OFFSET:
        fill_g2sb_ctx1_g2linepos_details(value, new_value);
        break;
    case G2SB_CTX1_G2LINELEN_OFFSET:
        fill_g2sb_ctx1_g2linelen_details(value, new_value);
        break;
    case G2SB_CTX1_G2CSCFOURTH_OFFSET:
        fill_g2sb_ctx1_g2cscfourth_details(value, new_value);
        break;
    case G2SB_CTX1_G2SRCST_B_OFFSET:
        fill_g2sb_ctx1_g2srcst_b_details(value, new_value);
        break;
    case G2SB_CTX1_G2UVSTRIDE_OFFSET:
        fill_g2sb_ctx1_g2uvstride_details(value, new_value);
        break;
    case G2SB_CTX1_G2CBDES2_OFFSET:
        fill_g2sb_ctx1_g2cbdes2_details(value, new_value);
        break;
    case G2SB_CTX1_G2TILEMODE_OFFSET:
        fill_g2sb_ctx1_g2tilemode_details(value, new_value);
        break;
    case G2SB_CTX1_G2PATBASE_OFFSET:
        fill_g2sb_ctx1_g2patbase_details(value, new_value);
        break;
    case G2SB_CTX1_G2SRCBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx1_g2srcba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX1_G2DSTBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx1_g2dstba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX1_G2DSTBA_B_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx1_g2dstba_b_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX1_G2VBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx1_g2vba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX1_G2UBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx1_g2uba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX2_INCR_SYNCPT_OFFSET:
        fill_g2sb_ctx2_incr_syncpt_details(value, new_value);
        break;
    case G2SB_CTX2_INCR_SYNCPT_CNTRL_OFFSET:
        fill_g2sb_ctx2_incr_syncpt_cntrl_details(value, new_value);
        break;
    case G2SB_CTX2_INCR_SYNCPT_ERROR_OFFSET:
        fill_g2sb_ctx2_incr_syncpt_error_details(value, new_value);
        break;
    case G2SB_CTX2_G2CLASSCHANNEL_REGONLY_OFFSET:
        fill_g2sb_ctx2_g2classchannel_regonly_details(value, new_value);
        break;
    case G2SB_CTX2_G2TRIGGER_OFFSET:
        fill_g2sb_ctx2_g2trigger_details(value, new_value);
        break;
    case G2SB_CTX2_G2TRIGGER1_OFFSET:
        fill_g2sb_ctx2_g2trigger1_details(value, new_value);
        break;
    case G2SB_CTX2_G2TRIGGER2_OFFSET:
        fill_g2sb_ctx2_g2trigger2_details(value, new_value);
        break;
    case G2SB_CTX2_G2CMDSEL_OFFSET:
        fill_g2sb_ctx2_g2cmdsel_details(value, new_value);
        break;
    case G2SB_CTX2_G2RAISE_OFFSET:
        fill_g2sb_ctx2_g2raise_details(value, new_value);
        break;
    case G2SB_CTX2_G2HOSTSET_OFFSET:
        fill_g2sb_ctx2_g2hostset_details(value, new_value);
        break;
    case G2SB_CTX2_G2HOSTFIFO_OFFSET:
        fill_g2sb_ctx2_g2hostfifo_details(value, new_value);
        break;
    case G2SB_CTX2_G2VDDA_OFFSET:
        fill_g2sb_ctx2_g2vdda_details(value, new_value);
        break;
    case G2SB_CTX2_G2VDDAINI_OFFSET:
        fill_g2sb_ctx2_g2vddaini_details(value, new_value);
        break;
    case G2SB_CTX2_G2HDDA_OFFSET:
        fill_g2sb_ctx2_g2hdda_details(value, new_value);
        break;
    case G2SB_CTX2_G2HDDAINILS_OFFSET:
        fill_g2sb_ctx2_g2hddainils_details(value, new_value);
        break;
    case G2SB_CTX2_G2CSCFIRST_OFFSET:
        fill_g2sb_ctx2_g2cscfirst_details(value, new_value);
        break;
    case G2SB_CTX2_G2CSCSECOND_OFFSET:
        fill_g2sb_ctx2_g2cscsecond_details(value, new_value);
        break;
    case G2SB_CTX2_G2CSCTHIRD_OFFSET:
        fill_g2sb_ctx2_g2cscthird_details(value, new_value);
        break;
    case G2SB_CTX2_G2CMKEYL_OFFSET:
        fill_g2sb_ctx2_g2cmkeyl_details(value, new_value);
        break;
    case G2SB_CTX2_G2CMKEYU_OFFSET:
        fill_g2sb_ctx2_g2cmkeyu_details(value, new_value);
        break;
    case G2SB_CTX2_G2UBA_A_OFFSET:
        fill_g2sb_ctx2_g2uba_a_details(value, new_value);
        break;
    case G2SB_CTX2_G2VBA_A_OFFSET:
        fill_g2sb_ctx2_g2vba_a_details(value, new_value);
        break;
    case G2SB_CTX2_G2SBFORMAT_OFFSET:
        fill_g2sb_ctx2_g2sbformat_details(value, new_value);
        break;
    case G2SB_CTX2_G2CONTROLSB_OFFSET:
        fill_g2sb_ctx2_g2controlsb_details(value, new_value);
        break;
    case G2SB_CTX2_G2CONTROLSECOND_OFFSET:
        fill_g2sb_ctx2_g2controlsecond_details(value, new_value);
        break;
    case G2SB_CTX2_G2CONTROLMAIN_OFFSET:
        fill_g2sb_ctx2_g2controlmain_details(value, new_value);
        break;
    case G2SB_CTX2_G2ROPFADE_OFFSET:
        fill_g2sb_ctx2_g2ropfade_details(value, new_value);
        break;
    case G2SB_CTX2_G2ALPHABLEND_OFFSET:
        fill_g2sb_ctx2_g2alphablend_details(value, new_value);
        break;
    case G2SB_CTX2_G2CLIPLEFTTOP_OFFSET:
        fill_g2sb_ctx2_g2cliplefttop_details(value, new_value);
        break;
    case G2SB_CTX2_G2CLIPRIGHTBOT_OFFSET:
        fill_g2sb_ctx2_g2cliprightbot_details(value, new_value);
        break;
    case G2SB_CTX2_G2PATPACK_OFFSET:
        fill_g2sb_ctx2_g2patpack_details(value, new_value);
        break;
    case G2SB_CTX2_G2PATPACK_SIZE_OFFSET:
        fill_g2sb_ctx2_g2patpack_size_details(value, new_value);
        break;
    case G2SB_CTX2_G2PATBA_OFFSET:
        fill_g2sb_ctx2_g2patba_details(value, new_value);
        break;
    case G2SB_CTX2_G2PATOS_OFFSET:
        fill_g2sb_ctx2_g2patos_details(value, new_value);
        break;
    case G2SB_CTX2_G2PATBGC_OFFSET:
        fill_g2sb_ctx2_g2patbgc_details(value, new_value);
        break;
    case G2SB_CTX2_G2PATFGC_OFFSET:
        fill_g2sb_ctx2_g2patfgc_details(value, new_value);
        break;
    case G2SB_CTX2_G2PATKEY_OFFSET:
        fill_g2sb_ctx2_g2patkey_details(value, new_value);
        break;
    case G2SB_CTX2_G2DSTBA_OFFSET:
        fill_g2sb_ctx2_g2dstba_details(value, new_value);
        break;
    case G2SB_CTX2_G2DSTBA_B_OFFSET:
        fill_g2sb_ctx2_g2dstba_b_details(value, new_value);
        break;
    case G2SB_CTX2_G2DSTBA_C_OFFSET:
        fill_g2sb_ctx2_g2dstba_c_details(value, new_value);
        break;
    case G2SB_CTX2_G2DSTST_OFFSET:
        fill_g2sb_ctx2_g2dstst_details(value, new_value);
        break;
    case G2SB_CTX2_G2SRCPACK_OFFSET:
        fill_g2sb_ctx2_g2srcpack_details(value, new_value);
        break;
    case G2SB_CTX2_G2SRCPACK_SIZE_OFFSET:
        fill_g2sb_ctx2_g2srcpack_size_details(value, new_value);
        break;
    case G2SB_CTX2_G2SRCBA_OFFSET:
        fill_g2sb_ctx2_g2srcba_details(value, new_value);
        break;
    case G2SB_CTX2_G2SRCBA_B_OFFSET:
        fill_g2sb_ctx2_g2srcba_b_details(value, new_value);
        break;
    case G2SB_CTX2_G2SRCST_OFFSET:
        fill_g2sb_ctx2_g2srcst_details(value, new_value);
        break;
    case G2SB_CTX2_G2SRCBGC_OFFSET:
        fill_g2sb_ctx2_g2srcbgc_details(value, new_value);
        break;
    case G2SB_CTX2_G2SRCFGC_OFFSET:
        fill_g2sb_ctx2_g2srcfgc_details(value, new_value);
        break;
    case G2SB_CTX2_G2SRCKEY_OFFSET:
        fill_g2sb_ctx2_g2srckey_details(value, new_value);
        break;
    case G2SB_CTX2_G2SRCSIZE_OFFSET:
        fill_g2sb_ctx2_g2srcsize_details(value, new_value);
        break;
    case G2SB_CTX2_G2DSTSIZE_OFFSET:
        fill_g2sb_ctx2_g2dstsize_details(value, new_value);
        break;
    case G2SB_CTX2_G2SRCPS_OFFSET:
        fill_g2sb_ctx2_g2srcps_details(value, new_value);
        break;
    case G2SB_CTX2_G2DSTPS_OFFSET:
        fill_g2sb_ctx2_g2dstps_details(value, new_value);
        break;
    case G2SB_CTX2_G2CBDES_OFFSET:
        fill_g2sb_ctx2_g2cbdes_details(value, new_value);
        break;
    case G2SB_CTX2_G2CBSTRIDE_OFFSET:
        fill_g2sb_ctx2_g2cbstride_details(value, new_value);
        break;
    case G2SB_CTX2_G2LINESETTING_OFFSET:
        fill_g2sb_ctx2_g2linesetting_details(value, new_value);
        break;
    case G2SB_CTX2_G2LINEDELTAN_OFFSET:
        fill_g2sb_ctx2_g2linedeltan_details(value, new_value);
        break;
    case G2SB_CTX2_G2LINEDELTAM_OFFSET:
        fill_g2sb_ctx2_g2linedeltam_details(value, new_value);
        break;
    case G2SB_CTX2_G2LINEPOS_OFFSET:
        fill_g2sb_ctx2_g2linepos_details(value, new_value);
        break;
    case G2SB_CTX2_G2LINELEN_OFFSET:
        fill_g2sb_ctx2_g2linelen_details(value, new_value);
        break;
    case G2SB_CTX2_G2CSCFOURTH_OFFSET:
        fill_g2sb_ctx2_g2cscfourth_details(value, new_value);
        break;
    case G2SB_CTX2_G2SRCST_B_OFFSET:
        fill_g2sb_ctx2_g2srcst_b_details(value, new_value);
        break;
    case G2SB_CTX2_G2UVSTRIDE_OFFSET:
        fill_g2sb_ctx2_g2uvstride_details(value, new_value);
        break;
    case G2SB_CTX2_G2CBDES2_OFFSET:
        fill_g2sb_ctx2_g2cbdes2_details(value, new_value);
        break;
    case G2SB_CTX2_G2TILEMODE_OFFSET:
        fill_g2sb_ctx2_g2tilemode_details(value, new_value);
        break;
    case G2SB_CTX2_G2PATBASE_OFFSET:
        fill_g2sb_ctx2_g2patbase_details(value, new_value);
        break;
    case G2SB_CTX2_G2SRCBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx2_g2srcba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX2_G2DSTBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx2_g2dstba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX2_G2DSTBA_B_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx2_g2dstba_b_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX2_G2VBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx2_g2vba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX2_G2UBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx2_g2uba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX3_INCR_SYNCPT_OFFSET:
        fill_g2sb_ctx3_incr_syncpt_details(value, new_value);
        break;
    case G2SB_CTX3_INCR_SYNCPT_CNTRL_OFFSET:
        fill_g2sb_ctx3_incr_syncpt_cntrl_details(value, new_value);
        break;
    case G2SB_CTX3_INCR_SYNCPT_ERROR_OFFSET:
        fill_g2sb_ctx3_incr_syncpt_error_details(value, new_value);
        break;
    case G2SB_CTX3_G2CLASSCHANNEL_REGONLY_OFFSET:
        fill_g2sb_ctx3_g2classchannel_regonly_details(value, new_value);
        break;
    case G2SB_CTX3_G2TRIGGER_OFFSET:
        fill_g2sb_ctx3_g2trigger_details(value, new_value);
        break;
    case G2SB_CTX3_G2TRIGGER1_OFFSET:
        fill_g2sb_ctx3_g2trigger1_details(value, new_value);
        break;
    case G2SB_CTX3_G2TRIGGER2_OFFSET:
        fill_g2sb_ctx3_g2trigger2_details(value, new_value);
        break;
    case G2SB_CTX3_G2CMDSEL_OFFSET:
        fill_g2sb_ctx3_g2cmdsel_details(value, new_value);
        break;
    case G2SB_CTX3_G2RAISE_OFFSET:
        fill_g2sb_ctx3_g2raise_details(value, new_value);
        break;
    case G2SB_CTX3_G2HOSTSET_OFFSET:
        fill_g2sb_ctx3_g2hostset_details(value, new_value);
        break;
    case G2SB_CTX3_G2HOSTFIFO_OFFSET:
        fill_g2sb_ctx3_g2hostfifo_details(value, new_value);
        break;
    case G2SB_CTX3_G2VDDA_OFFSET:
        fill_g2sb_ctx3_g2vdda_details(value, new_value);
        break;
    case G2SB_CTX3_G2VDDAINI_OFFSET:
        fill_g2sb_ctx3_g2vddaini_details(value, new_value);
        break;
    case G2SB_CTX3_G2HDDA_OFFSET:
        fill_g2sb_ctx3_g2hdda_details(value, new_value);
        break;
    case G2SB_CTX3_G2HDDAINILS_OFFSET:
        fill_g2sb_ctx3_g2hddainils_details(value, new_value);
        break;
    case G2SB_CTX3_G2CSCFIRST_OFFSET:
        fill_g2sb_ctx3_g2cscfirst_details(value, new_value);
        break;
    case G2SB_CTX3_G2CSCSECOND_OFFSET:
        fill_g2sb_ctx3_g2cscsecond_details(value, new_value);
        break;
    case G2SB_CTX3_G2CSCTHIRD_OFFSET:
        fill_g2sb_ctx3_g2cscthird_details(value, new_value);
        break;
    case G2SB_CTX3_G2CMKEYL_OFFSET:
        fill_g2sb_ctx3_g2cmkeyl_details(value, new_value);
        break;
    case G2SB_CTX3_G2CMKEYU_OFFSET:
        fill_g2sb_ctx3_g2cmkeyu_details(value, new_value);
        break;
    case G2SB_CTX3_G2UBA_A_OFFSET:
        fill_g2sb_ctx3_g2uba_a_details(value, new_value);
        break;
    case G2SB_CTX3_G2VBA_A_OFFSET:
        fill_g2sb_ctx3_g2vba_a_details(value, new_value);
        break;
    case G2SB_CTX3_G2SBFORMAT_OFFSET:
        fill_g2sb_ctx3_g2sbformat_details(value, new_value);
        break;
    case G2SB_CTX3_G2CONTROLSB_OFFSET:
        fill_g2sb_ctx3_g2controlsb_details(value, new_value);
        break;
    case G2SB_CTX3_G2CONTROLSECOND_OFFSET:
        fill_g2sb_ctx3_g2controlsecond_details(value, new_value);
        break;
    case G2SB_CTX3_G2CONTROLMAIN_OFFSET:
        fill_g2sb_ctx3_g2controlmain_details(value, new_value);
        break;
    case G2SB_CTX3_G2ROPFADE_OFFSET:
        fill_g2sb_ctx3_g2ropfade_details(value, new_value);
        break;
    case G2SB_CTX3_G2ALPHABLEND_OFFSET:
        fill_g2sb_ctx3_g2alphablend_details(value, new_value);
        break;
    case G2SB_CTX3_G2CLIPLEFTTOP_OFFSET:
        fill_g2sb_ctx3_g2cliplefttop_details(value, new_value);
        break;
    case G2SB_CTX3_G2CLIPRIGHTBOT_OFFSET:
        fill_g2sb_ctx3_g2cliprightbot_details(value, new_value);
        break;
    case G2SB_CTX3_G2PATPACK_OFFSET:
        fill_g2sb_ctx3_g2patpack_details(value, new_value);
        break;
    case G2SB_CTX3_G2PATPACK_SIZE_OFFSET:
        fill_g2sb_ctx3_g2patpack_size_details(value, new_value);
        break;
    case G2SB_CTX3_G2PATBA_OFFSET:
        fill_g2sb_ctx3_g2patba_details(value, new_value);
        break;
    case G2SB_CTX3_G2PATOS_OFFSET:
        fill_g2sb_ctx3_g2patos_details(value, new_value);
        break;
    case G2SB_CTX3_G2PATBGC_OFFSET:
        fill_g2sb_ctx3_g2patbgc_details(value, new_value);
        break;
    case G2SB_CTX3_G2PATFGC_OFFSET:
        fill_g2sb_ctx3_g2patfgc_details(value, new_value);
        break;
    case G2SB_CTX3_G2PATKEY_OFFSET:
        fill_g2sb_ctx3_g2patkey_details(value, new_value);
        break;
    case G2SB_CTX3_G2DSTBA_OFFSET:
        fill_g2sb_ctx3_g2dstba_details(value, new_value);
        break;
    case G2SB_CTX3_G2DSTBA_B_OFFSET:
        fill_g2sb_ctx3_g2dstba_b_details(value, new_value);
        break;
    case G2SB_CTX3_G2DSTBA_C_OFFSET:
        fill_g2sb_ctx3_g2dstba_c_details(value, new_value);
        break;
    case G2SB_CTX3_G2DSTST_OFFSET:
        fill_g2sb_ctx3_g2dstst_details(value, new_value);
        break;
    case G2SB_CTX3_G2SRCPACK_OFFSET:
        fill_g2sb_ctx3_g2srcpack_details(value, new_value);
        break;
    case G2SB_CTX3_G2SRCPACK_SIZE_OFFSET:
        fill_g2sb_ctx3_g2srcpack_size_details(value, new_value);
        break;
    case G2SB_CTX3_G2SRCBA_OFFSET:
        fill_g2sb_ctx3_g2srcba_details(value, new_value);
        break;
    case G2SB_CTX3_G2SRCBA_B_OFFSET:
        fill_g2sb_ctx3_g2srcba_b_details(value, new_value);
        break;
    case G2SB_CTX3_G2SRCST_OFFSET:
        fill_g2sb_ctx3_g2srcst_details(value, new_value);
        break;
    case G2SB_CTX3_G2SRCBGC_OFFSET:
        fill_g2sb_ctx3_g2srcbgc_details(value, new_value);
        break;
    case G2SB_CTX3_G2SRCFGC_OFFSET:
        fill_g2sb_ctx3_g2srcfgc_details(value, new_value);
        break;
    case G2SB_CTX3_G2SRCKEY_OFFSET:
        fill_g2sb_ctx3_g2srckey_details(value, new_value);
        break;
    case G2SB_CTX3_G2SRCSIZE_OFFSET:
        fill_g2sb_ctx3_g2srcsize_details(value, new_value);
        break;
    case G2SB_CTX3_G2DSTSIZE_OFFSET:
        fill_g2sb_ctx3_g2dstsize_details(value, new_value);
        break;
    case G2SB_CTX3_G2SRCPS_OFFSET:
        fill_g2sb_ctx3_g2srcps_details(value, new_value);
        break;
    case G2SB_CTX3_G2DSTPS_OFFSET:
        fill_g2sb_ctx3_g2dstps_details(value, new_value);
        break;
    case G2SB_CTX3_G2CBDES_OFFSET:
        fill_g2sb_ctx3_g2cbdes_details(value, new_value);
        break;
    case G2SB_CTX3_G2CBSTRIDE_OFFSET:
        fill_g2sb_ctx3_g2cbstride_details(value, new_value);
        break;
    case G2SB_CTX3_G2LINESETTING_OFFSET:
        fill_g2sb_ctx3_g2linesetting_details(value, new_value);
        break;
    case G2SB_CTX3_G2LINEDELTAN_OFFSET:
        fill_g2sb_ctx3_g2linedeltan_details(value, new_value);
        break;
    case G2SB_CTX3_G2LINEDELTAM_OFFSET:
        fill_g2sb_ctx3_g2linedeltam_details(value, new_value);
        break;
    case G2SB_CTX3_G2LINEPOS_OFFSET:
        fill_g2sb_ctx3_g2linepos_details(value, new_value);
        break;
    case G2SB_CTX3_G2LINELEN_OFFSET:
        fill_g2sb_ctx3_g2linelen_details(value, new_value);
        break;
    case G2SB_CTX3_G2CSCFOURTH_OFFSET:
        fill_g2sb_ctx3_g2cscfourth_details(value, new_value);
        break;
    case G2SB_CTX3_G2SRCST_B_OFFSET:
        fill_g2sb_ctx3_g2srcst_b_details(value, new_value);
        break;
    case G2SB_CTX3_G2UVSTRIDE_OFFSET:
        fill_g2sb_ctx3_g2uvstride_details(value, new_value);
        break;
    case G2SB_CTX3_G2CBDES2_OFFSET:
        fill_g2sb_ctx3_g2cbdes2_details(value, new_value);
        break;
    case G2SB_CTX3_G2TILEMODE_OFFSET:
        fill_g2sb_ctx3_g2tilemode_details(value, new_value);
        break;
    case G2SB_CTX3_G2PATBASE_OFFSET:
        fill_g2sb_ctx3_g2patbase_details(value, new_value);
        break;
    case G2SB_CTX3_G2SRCBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx3_g2srcba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX3_G2DSTBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx3_g2dstba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX3_G2DSTBA_B_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx3_g2dstba_b_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX3_G2VBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx3_g2vba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX3_G2UBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx3_g2uba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX4_INCR_SYNCPT_OFFSET:
        fill_g2sb_ctx4_incr_syncpt_details(value, new_value);
        break;
    case G2SB_CTX4_INCR_SYNCPT_CNTRL_OFFSET:
        fill_g2sb_ctx4_incr_syncpt_cntrl_details(value, new_value);
        break;
    case G2SB_CTX4_INCR_SYNCPT_ERROR_OFFSET:
        fill_g2sb_ctx4_incr_syncpt_error_details(value, new_value);
        break;
    case G2SB_CTX4_G2CLASSCHANNEL_REGONLY_OFFSET:
        fill_g2sb_ctx4_g2classchannel_regonly_details(value, new_value);
        break;
    case G2SB_CTX4_G2TRIGGER_OFFSET:
        fill_g2sb_ctx4_g2trigger_details(value, new_value);
        break;
    case G2SB_CTX4_G2TRIGGER1_OFFSET:
        fill_g2sb_ctx4_g2trigger1_details(value, new_value);
        break;
    case G2SB_CTX4_G2TRIGGER2_OFFSET:
        fill_g2sb_ctx4_g2trigger2_details(value, new_value);
        break;
    case G2SB_CTX4_G2CMDSEL_OFFSET:
        fill_g2sb_ctx4_g2cmdsel_details(value, new_value);
        break;
    case G2SB_CTX4_G2RAISE_OFFSET:
        fill_g2sb_ctx4_g2raise_details(value, new_value);
        break;
    case G2SB_CTX4_G2HOSTSET_OFFSET:
        fill_g2sb_ctx4_g2hostset_details(value, new_value);
        break;
    case G2SB_CTX4_G2HOSTFIFO_OFFSET:
        fill_g2sb_ctx4_g2hostfifo_details(value, new_value);
        break;
    case G2SB_CTX4_G2VDDA_OFFSET:
        fill_g2sb_ctx4_g2vdda_details(value, new_value);
        break;
    case G2SB_CTX4_G2VDDAINI_OFFSET:
        fill_g2sb_ctx4_g2vddaini_details(value, new_value);
        break;
    case G2SB_CTX4_G2HDDA_OFFSET:
        fill_g2sb_ctx4_g2hdda_details(value, new_value);
        break;
    case G2SB_CTX4_G2HDDAINILS_OFFSET:
        fill_g2sb_ctx4_g2hddainils_details(value, new_value);
        break;
    case G2SB_CTX4_G2CSCFIRST_OFFSET:
        fill_g2sb_ctx4_g2cscfirst_details(value, new_value);
        break;
    case G2SB_CTX4_G2CSCSECOND_OFFSET:
        fill_g2sb_ctx4_g2cscsecond_details(value, new_value);
        break;
    case G2SB_CTX4_G2CSCTHIRD_OFFSET:
        fill_g2sb_ctx4_g2cscthird_details(value, new_value);
        break;
    case G2SB_CTX4_G2CMKEYL_OFFSET:
        fill_g2sb_ctx4_g2cmkeyl_details(value, new_value);
        break;
    case G2SB_CTX4_G2CMKEYU_OFFSET:
        fill_g2sb_ctx4_g2cmkeyu_details(value, new_value);
        break;
    case G2SB_CTX4_G2UBA_A_OFFSET:
        fill_g2sb_ctx4_g2uba_a_details(value, new_value);
        break;
    case G2SB_CTX4_G2VBA_A_OFFSET:
        fill_g2sb_ctx4_g2vba_a_details(value, new_value);
        break;
    case G2SB_CTX4_G2SBFORMAT_OFFSET:
        fill_g2sb_ctx4_g2sbformat_details(value, new_value);
        break;
    case G2SB_CTX4_G2CONTROLSB_OFFSET:
        fill_g2sb_ctx4_g2controlsb_details(value, new_value);
        break;
    case G2SB_CTX4_G2CONTROLSECOND_OFFSET:
        fill_g2sb_ctx4_g2controlsecond_details(value, new_value);
        break;
    case G2SB_CTX4_G2CONTROLMAIN_OFFSET:
        fill_g2sb_ctx4_g2controlmain_details(value, new_value);
        break;
    case G2SB_CTX4_G2ROPFADE_OFFSET:
        fill_g2sb_ctx4_g2ropfade_details(value, new_value);
        break;
    case G2SB_CTX4_G2ALPHABLEND_OFFSET:
        fill_g2sb_ctx4_g2alphablend_details(value, new_value);
        break;
    case G2SB_CTX4_G2CLIPLEFTTOP_OFFSET:
        fill_g2sb_ctx4_g2cliplefttop_details(value, new_value);
        break;
    case G2SB_CTX4_G2CLIPRIGHTBOT_OFFSET:
        fill_g2sb_ctx4_g2cliprightbot_details(value, new_value);
        break;
    case G2SB_CTX4_G2PATPACK_OFFSET:
        fill_g2sb_ctx4_g2patpack_details(value, new_value);
        break;
    case G2SB_CTX4_G2PATPACK_SIZE_OFFSET:
        fill_g2sb_ctx4_g2patpack_size_details(value, new_value);
        break;
    case G2SB_CTX4_G2PATBA_OFFSET:
        fill_g2sb_ctx4_g2patba_details(value, new_value);
        break;
    case G2SB_CTX4_G2PATOS_OFFSET:
        fill_g2sb_ctx4_g2patos_details(value, new_value);
        break;
    case G2SB_CTX4_G2PATBGC_OFFSET:
        fill_g2sb_ctx4_g2patbgc_details(value, new_value);
        break;
    case G2SB_CTX4_G2PATFGC_OFFSET:
        fill_g2sb_ctx4_g2patfgc_details(value, new_value);
        break;
    case G2SB_CTX4_G2PATKEY_OFFSET:
        fill_g2sb_ctx4_g2patkey_details(value, new_value);
        break;
    case G2SB_CTX4_G2DSTBA_OFFSET:
        fill_g2sb_ctx4_g2dstba_details(value, new_value);
        break;
    case G2SB_CTX4_G2DSTBA_B_OFFSET:
        fill_g2sb_ctx4_g2dstba_b_details(value, new_value);
        break;
    case G2SB_CTX4_G2DSTBA_C_OFFSET:
        fill_g2sb_ctx4_g2dstba_c_details(value, new_value);
        break;
    case G2SB_CTX4_G2DSTST_OFFSET:
        fill_g2sb_ctx4_g2dstst_details(value, new_value);
        break;
    case G2SB_CTX4_G2SRCPACK_OFFSET:
        fill_g2sb_ctx4_g2srcpack_details(value, new_value);
        break;
    case G2SB_CTX4_G2SRCPACK_SIZE_OFFSET:
        fill_g2sb_ctx4_g2srcpack_size_details(value, new_value);
        break;
    case G2SB_CTX4_G2SRCBA_OFFSET:
        fill_g2sb_ctx4_g2srcba_details(value, new_value);
        break;
    case G2SB_CTX4_G2SRCBA_B_OFFSET:
        fill_g2sb_ctx4_g2srcba_b_details(value, new_value);
        break;
    case G2SB_CTX4_G2SRCST_OFFSET:
        fill_g2sb_ctx4_g2srcst_details(value, new_value);
        break;
    case G2SB_CTX4_G2SRCBGC_OFFSET:
        fill_g2sb_ctx4_g2srcbgc_details(value, new_value);
        break;
    case G2SB_CTX4_G2SRCFGC_OFFSET:
        fill_g2sb_ctx4_g2srcfgc_details(value, new_value);
        break;
    case G2SB_CTX4_G2SRCKEY_OFFSET:
        fill_g2sb_ctx4_g2srckey_details(value, new_value);
        break;
    case G2SB_CTX4_G2SRCSIZE_OFFSET:
        fill_g2sb_ctx4_g2srcsize_details(value, new_value);
        break;
    case G2SB_CTX4_G2DSTSIZE_OFFSET:
        fill_g2sb_ctx4_g2dstsize_details(value, new_value);
        break;
    case G2SB_CTX4_G2SRCPS_OFFSET:
        fill_g2sb_ctx4_g2srcps_details(value, new_value);
        break;
    case G2SB_CTX4_G2DSTPS_OFFSET:
        fill_g2sb_ctx4_g2dstps_details(value, new_value);
        break;
    case G2SB_CTX4_G2CBDES_OFFSET:
        fill_g2sb_ctx4_g2cbdes_details(value, new_value);
        break;
    case G2SB_CTX4_G2CBSTRIDE_OFFSET:
        fill_g2sb_ctx4_g2cbstride_details(value, new_value);
        break;
    case G2SB_CTX4_G2LINESETTING_OFFSET:
        fill_g2sb_ctx4_g2linesetting_details(value, new_value);
        break;
    case G2SB_CTX4_G2LINEDELTAN_OFFSET:
        fill_g2sb_ctx4_g2linedeltan_details(value, new_value);
        break;
    case G2SB_CTX4_G2LINEDELTAM_OFFSET:
        fill_g2sb_ctx4_g2linedeltam_details(value, new_value);
        break;
    case G2SB_CTX4_G2LINEPOS_OFFSET:
        fill_g2sb_ctx4_g2linepos_details(value, new_value);
        break;
    case G2SB_CTX4_G2LINELEN_OFFSET:
        fill_g2sb_ctx4_g2linelen_details(value, new_value);
        break;
    case G2SB_CTX4_G2CSCFOURTH_OFFSET:
        fill_g2sb_ctx4_g2cscfourth_details(value, new_value);
        break;
    case G2SB_CTX4_G2SRCST_B_OFFSET:
        fill_g2sb_ctx4_g2srcst_b_details(value, new_value);
        break;
    case G2SB_CTX4_G2UVSTRIDE_OFFSET:
        fill_g2sb_ctx4_g2uvstride_details(value, new_value);
        break;
    case G2SB_CTX4_G2CBDES2_OFFSET:
        fill_g2sb_ctx4_g2cbdes2_details(value, new_value);
        break;
    case G2SB_CTX4_G2TILEMODE_OFFSET:
        fill_g2sb_ctx4_g2tilemode_details(value, new_value);
        break;
    case G2SB_CTX4_G2PATBASE_OFFSET:
        fill_g2sb_ctx4_g2patbase_details(value, new_value);
        break;
    case G2SB_CTX4_G2SRCBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx4_g2srcba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX4_G2DSTBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx4_g2dstba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX4_G2DSTBA_B_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx4_g2dstba_b_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX4_G2VBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx4_g2vba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX4_G2UBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx4_g2uba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX5_INCR_SYNCPT_OFFSET:
        fill_g2sb_ctx5_incr_syncpt_details(value, new_value);
        break;
    case G2SB_CTX5_INCR_SYNCPT_CNTRL_OFFSET:
        fill_g2sb_ctx5_incr_syncpt_cntrl_details(value, new_value);
        break;
    case G2SB_CTX5_INCR_SYNCPT_ERROR_OFFSET:
        fill_g2sb_ctx5_incr_syncpt_error_details(value, new_value);
        break;
    case G2SB_CTX5_G2CLASSCHANNEL_REGONLY_OFFSET:
        fill_g2sb_ctx5_g2classchannel_regonly_details(value, new_value);
        break;
    case G2SB_CTX5_G2TRIGGER_OFFSET:
        fill_g2sb_ctx5_g2trigger_details(value, new_value);
        break;
    case G2SB_CTX5_G2TRIGGER1_OFFSET:
        fill_g2sb_ctx5_g2trigger1_details(value, new_value);
        break;
    case G2SB_CTX5_G2TRIGGER2_OFFSET:
        fill_g2sb_ctx5_g2trigger2_details(value, new_value);
        break;
    case G2SB_CTX5_G2CMDSEL_OFFSET:
        fill_g2sb_ctx5_g2cmdsel_details(value, new_value);
        break;
    case G2SB_CTX5_G2RAISE_OFFSET:
        fill_g2sb_ctx5_g2raise_details(value, new_value);
        break;
    case G2SB_CTX5_G2HOSTSET_OFFSET:
        fill_g2sb_ctx5_g2hostset_details(value, new_value);
        break;
    case G2SB_CTX5_G2HOSTFIFO_OFFSET:
        fill_g2sb_ctx5_g2hostfifo_details(value, new_value);
        break;
    case G2SB_CTX5_G2VDDA_OFFSET:
        fill_g2sb_ctx5_g2vdda_details(value, new_value);
        break;
    case G2SB_CTX5_G2VDDAINI_OFFSET:
        fill_g2sb_ctx5_g2vddaini_details(value, new_value);
        break;
    case G2SB_CTX5_G2HDDA_OFFSET:
        fill_g2sb_ctx5_g2hdda_details(value, new_value);
        break;
    case G2SB_CTX5_G2HDDAINILS_OFFSET:
        fill_g2sb_ctx5_g2hddainils_details(value, new_value);
        break;
    case G2SB_CTX5_G2CSCFIRST_OFFSET:
        fill_g2sb_ctx5_g2cscfirst_details(value, new_value);
        break;
    case G2SB_CTX5_G2CSCSECOND_OFFSET:
        fill_g2sb_ctx5_g2cscsecond_details(value, new_value);
        break;
    case G2SB_CTX5_G2CSCTHIRD_OFFSET:
        fill_g2sb_ctx5_g2cscthird_details(value, new_value);
        break;
    case G2SB_CTX5_G2CMKEYL_OFFSET:
        fill_g2sb_ctx5_g2cmkeyl_details(value, new_value);
        break;
    case G2SB_CTX5_G2CMKEYU_OFFSET:
        fill_g2sb_ctx5_g2cmkeyu_details(value, new_value);
        break;
    case G2SB_CTX5_G2UBA_A_OFFSET:
        fill_g2sb_ctx5_g2uba_a_details(value, new_value);
        break;
    case G2SB_CTX5_G2VBA_A_OFFSET:
        fill_g2sb_ctx5_g2vba_a_details(value, new_value);
        break;
    case G2SB_CTX5_G2SBFORMAT_OFFSET:
        fill_g2sb_ctx5_g2sbformat_details(value, new_value);
        break;
    case G2SB_CTX5_G2CONTROLSB_OFFSET:
        fill_g2sb_ctx5_g2controlsb_details(value, new_value);
        break;
    case G2SB_CTX5_G2CONTROLSECOND_OFFSET:
        fill_g2sb_ctx5_g2controlsecond_details(value, new_value);
        break;
    case G2SB_CTX5_G2CONTROLMAIN_OFFSET:
        fill_g2sb_ctx5_g2controlmain_details(value, new_value);
        break;
    case G2SB_CTX5_G2ROPFADE_OFFSET:
        fill_g2sb_ctx5_g2ropfade_details(value, new_value);
        break;
    case G2SB_CTX5_G2ALPHABLEND_OFFSET:
        fill_g2sb_ctx5_g2alphablend_details(value, new_value);
        break;
    case G2SB_CTX5_G2CLIPLEFTTOP_OFFSET:
        fill_g2sb_ctx5_g2cliplefttop_details(value, new_value);
        break;
    case G2SB_CTX5_G2CLIPRIGHTBOT_OFFSET:
        fill_g2sb_ctx5_g2cliprightbot_details(value, new_value);
        break;
    case G2SB_CTX5_G2PATPACK_OFFSET:
        fill_g2sb_ctx5_g2patpack_details(value, new_value);
        break;
    case G2SB_CTX5_G2PATPACK_SIZE_OFFSET:
        fill_g2sb_ctx5_g2patpack_size_details(value, new_value);
        break;
    case G2SB_CTX5_G2PATBA_OFFSET:
        fill_g2sb_ctx5_g2patba_details(value, new_value);
        break;
    case G2SB_CTX5_G2PATOS_OFFSET:
        fill_g2sb_ctx5_g2patos_details(value, new_value);
        break;
    case G2SB_CTX5_G2PATBGC_OFFSET:
        fill_g2sb_ctx5_g2patbgc_details(value, new_value);
        break;
    case G2SB_CTX5_G2PATFGC_OFFSET:
        fill_g2sb_ctx5_g2patfgc_details(value, new_value);
        break;
    case G2SB_CTX5_G2PATKEY_OFFSET:
        fill_g2sb_ctx5_g2patkey_details(value, new_value);
        break;
    case G2SB_CTX5_G2DSTBA_OFFSET:
        fill_g2sb_ctx5_g2dstba_details(value, new_value);
        break;
    case G2SB_CTX5_G2DSTBA_B_OFFSET:
        fill_g2sb_ctx5_g2dstba_b_details(value, new_value);
        break;
    case G2SB_CTX5_G2DSTBA_C_OFFSET:
        fill_g2sb_ctx5_g2dstba_c_details(value, new_value);
        break;
    case G2SB_CTX5_G2DSTST_OFFSET:
        fill_g2sb_ctx5_g2dstst_details(value, new_value);
        break;
    case G2SB_CTX5_G2SRCPACK_OFFSET:
        fill_g2sb_ctx5_g2srcpack_details(value, new_value);
        break;
    case G2SB_CTX5_G2SRCPACK_SIZE_OFFSET:
        fill_g2sb_ctx5_g2srcpack_size_details(value, new_value);
        break;
    case G2SB_CTX5_G2SRCBA_OFFSET:
        fill_g2sb_ctx5_g2srcba_details(value, new_value);
        break;
    case G2SB_CTX5_G2SRCBA_B_OFFSET:
        fill_g2sb_ctx5_g2srcba_b_details(value, new_value);
        break;
    case G2SB_CTX5_G2SRCST_OFFSET:
        fill_g2sb_ctx5_g2srcst_details(value, new_value);
        break;
    case G2SB_CTX5_G2SRCBGC_OFFSET:
        fill_g2sb_ctx5_g2srcbgc_details(value, new_value);
        break;
    case G2SB_CTX5_G2SRCFGC_OFFSET:
        fill_g2sb_ctx5_g2srcfgc_details(value, new_value);
        break;
    case G2SB_CTX5_G2SRCKEY_OFFSET:
        fill_g2sb_ctx5_g2srckey_details(value, new_value);
        break;
    case G2SB_CTX5_G2SRCSIZE_OFFSET:
        fill_g2sb_ctx5_g2srcsize_details(value, new_value);
        break;
    case G2SB_CTX5_G2DSTSIZE_OFFSET:
        fill_g2sb_ctx5_g2dstsize_details(value, new_value);
        break;
    case G2SB_CTX5_G2SRCPS_OFFSET:
        fill_g2sb_ctx5_g2srcps_details(value, new_value);
        break;
    case G2SB_CTX5_G2DSTPS_OFFSET:
        fill_g2sb_ctx5_g2dstps_details(value, new_value);
        break;
    case G2SB_CTX5_G2CBDES_OFFSET:
        fill_g2sb_ctx5_g2cbdes_details(value, new_value);
        break;
    case G2SB_CTX5_G2CBSTRIDE_OFFSET:
        fill_g2sb_ctx5_g2cbstride_details(value, new_value);
        break;
    case G2SB_CTX5_G2LINESETTING_OFFSET:
        fill_g2sb_ctx5_g2linesetting_details(value, new_value);
        break;
    case G2SB_CTX5_G2LINEDELTAN_OFFSET:
        fill_g2sb_ctx5_g2linedeltan_details(value, new_value);
        break;
    case G2SB_CTX5_G2LINEDELTAM_OFFSET:
        fill_g2sb_ctx5_g2linedeltam_details(value, new_value);
        break;
    case G2SB_CTX5_G2LINEPOS_OFFSET:
        fill_g2sb_ctx5_g2linepos_details(value, new_value);
        break;
    case G2SB_CTX5_G2LINELEN_OFFSET:
        fill_g2sb_ctx5_g2linelen_details(value, new_value);
        break;
    case G2SB_CTX5_G2CSCFOURTH_OFFSET:
        fill_g2sb_ctx5_g2cscfourth_details(value, new_value);
        break;
    case G2SB_CTX5_G2SRCST_B_OFFSET:
        fill_g2sb_ctx5_g2srcst_b_details(value, new_value);
        break;
    case G2SB_CTX5_G2UVSTRIDE_OFFSET:
        fill_g2sb_ctx5_g2uvstride_details(value, new_value);
        break;
    case G2SB_CTX5_G2CBDES2_OFFSET:
        fill_g2sb_ctx5_g2cbdes2_details(value, new_value);
        break;
    case G2SB_CTX5_G2TILEMODE_OFFSET:
        fill_g2sb_ctx5_g2tilemode_details(value, new_value);
        break;
    case G2SB_CTX5_G2PATBASE_OFFSET:
        fill_g2sb_ctx5_g2patbase_details(value, new_value);
        break;
    case G2SB_CTX5_G2SRCBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx5_g2srcba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX5_G2DSTBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx5_g2dstba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX5_G2DSTBA_B_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx5_g2dstba_b_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX5_G2VBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx5_g2vba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX5_G2UBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx5_g2uba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX6_INCR_SYNCPT_OFFSET:
        fill_g2sb_ctx6_incr_syncpt_details(value, new_value);
        break;
    case G2SB_CTX6_INCR_SYNCPT_CNTRL_OFFSET:
        fill_g2sb_ctx6_incr_syncpt_cntrl_details(value, new_value);
        break;
    case G2SB_CTX6_INCR_SYNCPT_ERROR_OFFSET:
        fill_g2sb_ctx6_incr_syncpt_error_details(value, new_value);
        break;
    case G2SB_CTX6_G2CLASSCHANNEL_REGONLY_OFFSET:
        fill_g2sb_ctx6_g2classchannel_regonly_details(value, new_value);
        break;
    case G2SB_CTX6_G2TRIGGER_OFFSET:
        fill_g2sb_ctx6_g2trigger_details(value, new_value);
        break;
    case G2SB_CTX6_G2TRIGGER1_OFFSET:
        fill_g2sb_ctx6_g2trigger1_details(value, new_value);
        break;
    case G2SB_CTX6_G2TRIGGER2_OFFSET:
        fill_g2sb_ctx6_g2trigger2_details(value, new_value);
        break;
    case G2SB_CTX6_G2CMDSEL_OFFSET:
        fill_g2sb_ctx6_g2cmdsel_details(value, new_value);
        break;
    case G2SB_CTX6_G2RAISE_OFFSET:
        fill_g2sb_ctx6_g2raise_details(value, new_value);
        break;
    case G2SB_CTX6_G2HOSTSET_OFFSET:
        fill_g2sb_ctx6_g2hostset_details(value, new_value);
        break;
    case G2SB_CTX6_G2HOSTFIFO_OFFSET:
        fill_g2sb_ctx6_g2hostfifo_details(value, new_value);
        break;
    case G2SB_CTX6_G2VDDA_OFFSET:
        fill_g2sb_ctx6_g2vdda_details(value, new_value);
        break;
    case G2SB_CTX6_G2VDDAINI_OFFSET:
        fill_g2sb_ctx6_g2vddaini_details(value, new_value);
        break;
    case G2SB_CTX6_G2HDDA_OFFSET:
        fill_g2sb_ctx6_g2hdda_details(value, new_value);
        break;
    case G2SB_CTX6_G2HDDAINILS_OFFSET:
        fill_g2sb_ctx6_g2hddainils_details(value, new_value);
        break;
    case G2SB_CTX6_G2CSCFIRST_OFFSET:
        fill_g2sb_ctx6_g2cscfirst_details(value, new_value);
        break;
    case G2SB_CTX6_G2CSCSECOND_OFFSET:
        fill_g2sb_ctx6_g2cscsecond_details(value, new_value);
        break;
    case G2SB_CTX6_G2CSCTHIRD_OFFSET:
        fill_g2sb_ctx6_g2cscthird_details(value, new_value);
        break;
    case G2SB_CTX6_G2CMKEYL_OFFSET:
        fill_g2sb_ctx6_g2cmkeyl_details(value, new_value);
        break;
    case G2SB_CTX6_G2CMKEYU_OFFSET:
        fill_g2sb_ctx6_g2cmkeyu_details(value, new_value);
        break;
    case G2SB_CTX6_G2UBA_A_OFFSET:
        fill_g2sb_ctx6_g2uba_a_details(value, new_value);
        break;
    case G2SB_CTX6_G2VBA_A_OFFSET:
        fill_g2sb_ctx6_g2vba_a_details(value, new_value);
        break;
    case G2SB_CTX6_G2SBFORMAT_OFFSET:
        fill_g2sb_ctx6_g2sbformat_details(value, new_value);
        break;
    case G2SB_CTX6_G2CONTROLSB_OFFSET:
        fill_g2sb_ctx6_g2controlsb_details(value, new_value);
        break;
    case G2SB_CTX6_G2CONTROLSECOND_OFFSET:
        fill_g2sb_ctx6_g2controlsecond_details(value, new_value);
        break;
    case G2SB_CTX6_G2CONTROLMAIN_OFFSET:
        fill_g2sb_ctx6_g2controlmain_details(value, new_value);
        break;
    case G2SB_CTX6_G2ROPFADE_OFFSET:
        fill_g2sb_ctx6_g2ropfade_details(value, new_value);
        break;
    case G2SB_CTX6_G2ALPHABLEND_OFFSET:
        fill_g2sb_ctx6_g2alphablend_details(value, new_value);
        break;
    case G2SB_CTX6_G2CLIPLEFTTOP_OFFSET:
        fill_g2sb_ctx6_g2cliplefttop_details(value, new_value);
        break;
    case G2SB_CTX6_G2CLIPRIGHTBOT_OFFSET:
        fill_g2sb_ctx6_g2cliprightbot_details(value, new_value);
        break;
    case G2SB_CTX6_G2PATPACK_OFFSET:
        fill_g2sb_ctx6_g2patpack_details(value, new_value);
        break;
    case G2SB_CTX6_G2PATPACK_SIZE_OFFSET:
        fill_g2sb_ctx6_g2patpack_size_details(value, new_value);
        break;
    case G2SB_CTX6_G2PATBA_OFFSET:
        fill_g2sb_ctx6_g2patba_details(value, new_value);
        break;
    case G2SB_CTX6_G2PATOS_OFFSET:
        fill_g2sb_ctx6_g2patos_details(value, new_value);
        break;
    case G2SB_CTX6_G2PATBGC_OFFSET:
        fill_g2sb_ctx6_g2patbgc_details(value, new_value);
        break;
    case G2SB_CTX6_G2PATFGC_OFFSET:
        fill_g2sb_ctx6_g2patfgc_details(value, new_value);
        break;
    case G2SB_CTX6_G2PATKEY_OFFSET:
        fill_g2sb_ctx6_g2patkey_details(value, new_value);
        break;
    case G2SB_CTX6_G2DSTBA_OFFSET:
        fill_g2sb_ctx6_g2dstba_details(value, new_value);
        break;
    case G2SB_CTX6_G2DSTBA_B_OFFSET:
        fill_g2sb_ctx6_g2dstba_b_details(value, new_value);
        break;
    case G2SB_CTX6_G2DSTBA_C_OFFSET:
        fill_g2sb_ctx6_g2dstba_c_details(value, new_value);
        break;
    case G2SB_CTX6_G2DSTST_OFFSET:
        fill_g2sb_ctx6_g2dstst_details(value, new_value);
        break;
    case G2SB_CTX6_G2SRCPACK_OFFSET:
        fill_g2sb_ctx6_g2srcpack_details(value, new_value);
        break;
    case G2SB_CTX6_G2SRCPACK_SIZE_OFFSET:
        fill_g2sb_ctx6_g2srcpack_size_details(value, new_value);
        break;
    case G2SB_CTX6_G2SRCBA_OFFSET:
        fill_g2sb_ctx6_g2srcba_details(value, new_value);
        break;
    case G2SB_CTX6_G2SRCBA_B_OFFSET:
        fill_g2sb_ctx6_g2srcba_b_details(value, new_value);
        break;
    case G2SB_CTX6_G2SRCST_OFFSET:
        fill_g2sb_ctx6_g2srcst_details(value, new_value);
        break;
    case G2SB_CTX6_G2SRCBGC_OFFSET:
        fill_g2sb_ctx6_g2srcbgc_details(value, new_value);
        break;
    case G2SB_CTX6_G2SRCFGC_OFFSET:
        fill_g2sb_ctx6_g2srcfgc_details(value, new_value);
        break;
    case G2SB_CTX6_G2SRCKEY_OFFSET:
        fill_g2sb_ctx6_g2srckey_details(value, new_value);
        break;
    case G2SB_CTX6_G2SRCSIZE_OFFSET:
        fill_g2sb_ctx6_g2srcsize_details(value, new_value);
        break;
    case G2SB_CTX6_G2DSTSIZE_OFFSET:
        fill_g2sb_ctx6_g2dstsize_details(value, new_value);
        break;
    case G2SB_CTX6_G2SRCPS_OFFSET:
        fill_g2sb_ctx6_g2srcps_details(value, new_value);
        break;
    case G2SB_CTX6_G2DSTPS_OFFSET:
        fill_g2sb_ctx6_g2dstps_details(value, new_value);
        break;
    case G2SB_CTX6_G2CBDES_OFFSET:
        fill_g2sb_ctx6_g2cbdes_details(value, new_value);
        break;
    case G2SB_CTX6_G2CBSTRIDE_OFFSET:
        fill_g2sb_ctx6_g2cbstride_details(value, new_value);
        break;
    case G2SB_CTX6_G2LINESETTING_OFFSET:
        fill_g2sb_ctx6_g2linesetting_details(value, new_value);
        break;
    case G2SB_CTX6_G2LINEDELTAN_OFFSET:
        fill_g2sb_ctx6_g2linedeltan_details(value, new_value);
        break;
    case G2SB_CTX6_G2LINEDELTAM_OFFSET:
        fill_g2sb_ctx6_g2linedeltam_details(value, new_value);
        break;
    case G2SB_CTX6_G2LINEPOS_OFFSET:
        fill_g2sb_ctx6_g2linepos_details(value, new_value);
        break;
    case G2SB_CTX6_G2LINELEN_OFFSET:
        fill_g2sb_ctx6_g2linelen_details(value, new_value);
        break;
    case G2SB_CTX6_G2CSCFOURTH_OFFSET:
        fill_g2sb_ctx6_g2cscfourth_details(value, new_value);
        break;
    case G2SB_CTX6_G2SRCST_B_OFFSET:
        fill_g2sb_ctx6_g2srcst_b_details(value, new_value);
        break;
    case G2SB_CTX6_G2UVSTRIDE_OFFSET:
        fill_g2sb_ctx6_g2uvstride_details(value, new_value);
        break;
    case G2SB_CTX6_G2CBDES2_OFFSET:
        fill_g2sb_ctx6_g2cbdes2_details(value, new_value);
        break;
    case G2SB_CTX6_G2TILEMODE_OFFSET:
        fill_g2sb_ctx6_g2tilemode_details(value, new_value);
        break;
    case G2SB_CTX6_G2PATBASE_OFFSET:
        fill_g2sb_ctx6_g2patbase_details(value, new_value);
        break;
    case G2SB_CTX6_G2SRCBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx6_g2srcba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX6_G2DSTBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx6_g2dstba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX6_G2DSTBA_B_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx6_g2dstba_b_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX6_G2VBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx6_g2vba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX6_G2UBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx6_g2uba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX7_INCR_SYNCPT_OFFSET:
        fill_g2sb_ctx7_incr_syncpt_details(value, new_value);
        break;
    case G2SB_CTX7_INCR_SYNCPT_CNTRL_OFFSET:
        fill_g2sb_ctx7_incr_syncpt_cntrl_details(value, new_value);
        break;
    case G2SB_CTX7_INCR_SYNCPT_ERROR_OFFSET:
        fill_g2sb_ctx7_incr_syncpt_error_details(value, new_value);
        break;
    case G2SB_CTX7_G2CLASSCHANNEL_REGONLY_OFFSET:
        fill_g2sb_ctx7_g2classchannel_regonly_details(value, new_value);
        break;
    case G2SB_CTX7_G2TRIGGER_OFFSET:
        fill_g2sb_ctx7_g2trigger_details(value, new_value);
        break;
    case G2SB_CTX7_G2TRIGGER1_OFFSET:
        fill_g2sb_ctx7_g2trigger1_details(value, new_value);
        break;
    case G2SB_CTX7_G2TRIGGER2_OFFSET:
        fill_g2sb_ctx7_g2trigger2_details(value, new_value);
        break;
    case G2SB_CTX7_G2CMDSEL_OFFSET:
        fill_g2sb_ctx7_g2cmdsel_details(value, new_value);
        break;
    case G2SB_CTX7_G2RAISE_OFFSET:
        fill_g2sb_ctx7_g2raise_details(value, new_value);
        break;
    case G2SB_CTX7_G2HOSTSET_OFFSET:
        fill_g2sb_ctx7_g2hostset_details(value, new_value);
        break;
    case G2SB_CTX7_G2HOSTFIFO_OFFSET:
        fill_g2sb_ctx7_g2hostfifo_details(value, new_value);
        break;
    case G2SB_CTX7_G2VDDA_OFFSET:
        fill_g2sb_ctx7_g2vdda_details(value, new_value);
        break;
    case G2SB_CTX7_G2VDDAINI_OFFSET:
        fill_g2sb_ctx7_g2vddaini_details(value, new_value);
        break;
    case G2SB_CTX7_G2HDDA_OFFSET:
        fill_g2sb_ctx7_g2hdda_details(value, new_value);
        break;
    case G2SB_CTX7_G2HDDAINILS_OFFSET:
        fill_g2sb_ctx7_g2hddainils_details(value, new_value);
        break;
    case G2SB_CTX7_G2CSCFIRST_OFFSET:
        fill_g2sb_ctx7_g2cscfirst_details(value, new_value);
        break;
    case G2SB_CTX7_G2CSCSECOND_OFFSET:
        fill_g2sb_ctx7_g2cscsecond_details(value, new_value);
        break;
    case G2SB_CTX7_G2CSCTHIRD_OFFSET:
        fill_g2sb_ctx7_g2cscthird_details(value, new_value);
        break;
    case G2SB_CTX7_G2CMKEYL_OFFSET:
        fill_g2sb_ctx7_g2cmkeyl_details(value, new_value);
        break;
    case G2SB_CTX7_G2CMKEYU_OFFSET:
        fill_g2sb_ctx7_g2cmkeyu_details(value, new_value);
        break;
    case G2SB_CTX7_G2UBA_A_OFFSET:
        fill_g2sb_ctx7_g2uba_a_details(value, new_value);
        break;
    case G2SB_CTX7_G2VBA_A_OFFSET:
        fill_g2sb_ctx7_g2vba_a_details(value, new_value);
        break;
    case G2SB_CTX7_G2SBFORMAT_OFFSET:
        fill_g2sb_ctx7_g2sbformat_details(value, new_value);
        break;
    case G2SB_CTX7_G2CONTROLSB_OFFSET:
        fill_g2sb_ctx7_g2controlsb_details(value, new_value);
        break;
    case G2SB_CTX7_G2CONTROLSECOND_OFFSET:
        fill_g2sb_ctx7_g2controlsecond_details(value, new_value);
        break;
    case G2SB_CTX7_G2CONTROLMAIN_OFFSET:
        fill_g2sb_ctx7_g2controlmain_details(value, new_value);
        break;
    case G2SB_CTX7_G2ROPFADE_OFFSET:
        fill_g2sb_ctx7_g2ropfade_details(value, new_value);
        break;
    case G2SB_CTX7_G2ALPHABLEND_OFFSET:
        fill_g2sb_ctx7_g2alphablend_details(value, new_value);
        break;
    case G2SB_CTX7_G2CLIPLEFTTOP_OFFSET:
        fill_g2sb_ctx7_g2cliplefttop_details(value, new_value);
        break;
    case G2SB_CTX7_G2CLIPRIGHTBOT_OFFSET:
        fill_g2sb_ctx7_g2cliprightbot_details(value, new_value);
        break;
    case G2SB_CTX7_G2PATPACK_OFFSET:
        fill_g2sb_ctx7_g2patpack_details(value, new_value);
        break;
    case G2SB_CTX7_G2PATPACK_SIZE_OFFSET:
        fill_g2sb_ctx7_g2patpack_size_details(value, new_value);
        break;
    case G2SB_CTX7_G2PATBA_OFFSET:
        fill_g2sb_ctx7_g2patba_details(value, new_value);
        break;
    case G2SB_CTX7_G2PATOS_OFFSET:
        fill_g2sb_ctx7_g2patos_details(value, new_value);
        break;
    case G2SB_CTX7_G2PATBGC_OFFSET:
        fill_g2sb_ctx7_g2patbgc_details(value, new_value);
        break;
    case G2SB_CTX7_G2PATFGC_OFFSET:
        fill_g2sb_ctx7_g2patfgc_details(value, new_value);
        break;
    case G2SB_CTX7_G2PATKEY_OFFSET:
        fill_g2sb_ctx7_g2patkey_details(value, new_value);
        break;
    case G2SB_CTX7_G2DSTBA_OFFSET:
        fill_g2sb_ctx7_g2dstba_details(value, new_value);
        break;
    case G2SB_CTX7_G2DSTBA_B_OFFSET:
        fill_g2sb_ctx7_g2dstba_b_details(value, new_value);
        break;
    case G2SB_CTX7_G2DSTBA_C_OFFSET:
        fill_g2sb_ctx7_g2dstba_c_details(value, new_value);
        break;
    case G2SB_CTX7_G2DSTST_OFFSET:
        fill_g2sb_ctx7_g2dstst_details(value, new_value);
        break;
    case G2SB_CTX7_G2SRCPACK_OFFSET:
        fill_g2sb_ctx7_g2srcpack_details(value, new_value);
        break;
    case G2SB_CTX7_G2SRCPACK_SIZE_OFFSET:
        fill_g2sb_ctx7_g2srcpack_size_details(value, new_value);
        break;
    case G2SB_CTX7_G2SRCBA_OFFSET:
        fill_g2sb_ctx7_g2srcba_details(value, new_value);
        break;
    case G2SB_CTX7_G2SRCBA_B_OFFSET:
        fill_g2sb_ctx7_g2srcba_b_details(value, new_value);
        break;
    case G2SB_CTX7_G2SRCST_OFFSET:
        fill_g2sb_ctx7_g2srcst_details(value, new_value);
        break;
    case G2SB_CTX7_G2SRCBGC_OFFSET:
        fill_g2sb_ctx7_g2srcbgc_details(value, new_value);
        break;
    case G2SB_CTX7_G2SRCFGC_OFFSET:
        fill_g2sb_ctx7_g2srcfgc_details(value, new_value);
        break;
    case G2SB_CTX7_G2SRCKEY_OFFSET:
        fill_g2sb_ctx7_g2srckey_details(value, new_value);
        break;
    case G2SB_CTX7_G2SRCSIZE_OFFSET:
        fill_g2sb_ctx7_g2srcsize_details(value, new_value);
        break;
    case G2SB_CTX7_G2DSTSIZE_OFFSET:
        fill_g2sb_ctx7_g2dstsize_details(value, new_value);
        break;
    case G2SB_CTX7_G2SRCPS_OFFSET:
        fill_g2sb_ctx7_g2srcps_details(value, new_value);
        break;
    case G2SB_CTX7_G2DSTPS_OFFSET:
        fill_g2sb_ctx7_g2dstps_details(value, new_value);
        break;
    case G2SB_CTX7_G2CBDES_OFFSET:
        fill_g2sb_ctx7_g2cbdes_details(value, new_value);
        break;
    case G2SB_CTX7_G2CBSTRIDE_OFFSET:
        fill_g2sb_ctx7_g2cbstride_details(value, new_value);
        break;
    case G2SB_CTX7_G2LINESETTING_OFFSET:
        fill_g2sb_ctx7_g2linesetting_details(value, new_value);
        break;
    case G2SB_CTX7_G2LINEDELTAN_OFFSET:
        fill_g2sb_ctx7_g2linedeltan_details(value, new_value);
        break;
    case G2SB_CTX7_G2LINEDELTAM_OFFSET:
        fill_g2sb_ctx7_g2linedeltam_details(value, new_value);
        break;
    case G2SB_CTX7_G2LINEPOS_OFFSET:
        fill_g2sb_ctx7_g2linepos_details(value, new_value);
        break;
    case G2SB_CTX7_G2LINELEN_OFFSET:
        fill_g2sb_ctx7_g2linelen_details(value, new_value);
        break;
    case G2SB_CTX7_G2CSCFOURTH_OFFSET:
        fill_g2sb_ctx7_g2cscfourth_details(value, new_value);
        break;
    case G2SB_CTX7_G2SRCST_B_OFFSET:
        fill_g2sb_ctx7_g2srcst_b_details(value, new_value);
        break;
    case G2SB_CTX7_G2UVSTRIDE_OFFSET:
        fill_g2sb_ctx7_g2uvstride_details(value, new_value);
        break;
    case G2SB_CTX7_G2CBDES2_OFFSET:
        fill_g2sb_ctx7_g2cbdes2_details(value, new_value);
        break;
    case G2SB_CTX7_G2TILEMODE_OFFSET:
        fill_g2sb_ctx7_g2tilemode_details(value, new_value);
        break;
    case G2SB_CTX7_G2PATBASE_OFFSET:
        fill_g2sb_ctx7_g2patbase_details(value, new_value);
        break;
    case G2SB_CTX7_G2SRCBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx7_g2srcba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX7_G2DSTBA_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx7_g2dstba_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX7_G2DSTBA_B_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx7_g2dstba_b_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX7_G2VBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx7_g2vba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_CTX7_G2UBA_A_SB_SURFBASE_OFFSET:
        fill_g2sb_ctx7_g2uba_a_sb_surfbase_details(value, new_value);
        break;
    case G2SB_SWITCH_G2INTERRUPT_OFFSET:
        fill_g2sb_switch_g2interrupt_details(value, new_value);
        break;
    case G2SB_SWITCH_G2INTENABLE_OFFSET:
        fill_g2sb_switch_g2intenable_details(value, new_value);
        break;
    case G2SB_SWITCH_G2CURRENTCONTEXT_OFFSET:
        fill_g2sb_switch_g2currentcontext_details(value, new_value);
        break;
    case G2SB_SWITCH_G2NXTCXTSWITCH_OFFSET:
        fill_g2sb_switch_g2nxtcxtswitch_details(value, new_value);
        break;
    case G2SB_SWITCH_G2GLOBALCONTROL_OFFSET:
        fill_g2sb_switch_g2globalcontrol_details(value, new_value);
        break;
    case G2SB_SWITCH_G2GLOBALCONTROLB_OFFSET:
        fill_g2sb_switch_g2globalcontrolb_details(value, new_value);
        break;
    case G2SB_SWITCH_G2WORKINGSTAT_OFFSET:
        fill_g2sb_switch_g2workingstat_details(value, new_value);
        break;
    case G2SB_SWITCH_G2BUFTHRESHOLD_OFFSET:
        fill_g2sb_switch_g2bufthreshold_details(value, new_value);
        break;
    case G2SB_SWITCH_CLKEN_OVERIDE_OFFSET:
        fill_g2sb_switch_clken_overide_details(value, new_value);
        break;
    case G2SB_SWITCH_G2_MCCIF_FIFOCTRL_OFFSET:
        fill_g2sb_switch_g2_mccif_fifoctrl_details(value, new_value);
        break;
    case G2SB_SWITCH_TIMEOUT_WCOAL_G2_OFFSET:
        fill_g2sb_switch_timeout_wcoal_g2_details(value, new_value);
        break;

    default:
        m_bit_details_model.bits.clear();
        break;
    }
}
